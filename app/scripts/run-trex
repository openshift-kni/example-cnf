#!/usr/bin/env python3

# https://github.com/secdev/scapy/blob/master/scapy/layers/l2.py#L164

import os
import sys
sys.path.append(os.path.abspath("/opt/pyfiles/"))

from trex.stl.api import *

import subprocess
import signal
import time
import json
import queue
from threading import Thread
from datetime import datetime

# Internal python files - /opt/pyfiles/
from logger import CustomLogger, log
import trexmac
import trexevent
import trexstats

clog = CustomLogger("debug")


class STLS1(object):
    def __init__ (self, ports, size, rate, duration=-1, verbose="debug"):
        self.client = STLClient(verbose_level=verbose, logger=clog)
        self.fsize = 64
        self.pg_id = 0
        self.pkt_type = "ether"
        self.num_streams = 1
        self.force_exit = False
        self.ports = ports
        self.port_a = ports[0]
        self.port_b = ports[1]
        self.size =size
        self.rate = rate
        self.duration = duration
        self.queue = queue.Queue(maxsize=0)
        signal.signal(signal.SIGINT, self.signal_handler)
        self.stats_obj = trexstats.TRexAppStats(ports)

    def create_stream (self, dest_mac=None):
        size = self.fsize - 4; # HW will add 4 bytes ethernet CRC

        ethr = Ether(dst=dest_mac) / IP(src = "16.0.0.1", dst = "48.0.0.1") / UDP(dport = 12, sport = 1025)
        vlan = Ether() / Dot1Q(vlan=11) / IP(src = "16.0.0.1", dst = "48.0.0.1") / UDP(dport = 12, sport = 1025)
        qinq = Ether(type=0x88A8) / Dot1Q(vlan=19) / Dot1Q(vlan=11) / IP(src = "16.0.0.1", dst = "48.0.0.1") / UDP(dport = 12, sport = 1025)

        pkt_types = {
            "ether": ethr,
            "vlan": vlan,
            "qinq": qinq
        }

        if self.pkt_type not in pkt_types.keys():
            log.info ("Wrong pkt_type given. Allowed values are " + format(pkt_types.keys()))
            return []

        pad = max(0, size - len(self.pkt_type)) * 'x'
        pkt = STLPktBuilder(pkt = pkt_types[self.pkt_type]/pad)

        streams = []
        for pg_id_add in range(0, self.num_streams):
            streams.append(STLStream(packet = pkt, mode = STLTXCont(pps=1), flow_stats = STLFlowStats(pg_id = self.pg_id + pg_id_add)))
        return streams

    def start_watch(self):
        process = Thread(target=trexmac.watch_cr, args=[self.queue])
        process.start()

    def update(self, obj):
        meta = obj['metadata']
        spec = obj['spec']
        log.info("Name(%s) Namespace(%s)" % (meta['name'], meta['namespace']))
        macs = self.get_macs(spec)
        if len(macs) < len(self.ports):
            log.info("ERROR: macs len(%s) is less then ports len (%s)" % (len(macs), len(self.ports)))
            return

        log.info("reset ports")
        self.client.reset(ports=self.ports)
        log.info("create stream with new mac address")
        for idx in range(0, len(self.ports)):
            self.add_streams(self.ports[idx], macs[idx])
        log.info("staring ports")
        self.client.start(ports=self.ports, mult=self.rate, duration=self.duration, core_mask=STLClient.CORE_MASK_PIN)
        data = {}
        now = datetime.now()
        data['microtime'] = now.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        data['time'] = now.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        data['msg'] = ("Packet stream is updated with mac: %s" % ','.join(macs))
        data['reason'] = 'StreamUpdated'
        trexevent.create_event(data)

    def add_streams(self, port, dest_mac):
        if dest_mac:
            log.info("create stream for port %s with dest mac %s" % (port, dest_mac))
        new_stream = self.create_stream(dest_mac)
        self.client.add_streams(new_stream, [port])

    def init_streams(self):
        macs = trexmac.get_testpmdmac_cr_values()
        if macs:
            log.info("destination macs available")
            for idx in range(0, len(self.ports)):
                self.add_streams(self.ports[idx], macs[0])
        else:
            log.info("destination macs not available")
            for idx in range(0, len(self.ports)):
                self.add_streams(self.ports[idx], None)

    def simple_burst(self):
        passed = True
        try:
            # connect to server
            self.client.connect()

            # prepare our ports
            self.client.reset(ports = self.ports)

            self.init_streams()

            # clear the stats before injecting
            self.client.clear_stats()

            # here we multiply the traffic lineaer to whatever given in rate
            log.info("Running {:} on ports {:}, {:} for 10 seconds...".format(self.rate, self.port_a, self.port_b))
            self.client.start(ports = self.ports,
                mult = self.rate,
                duration = self.duration,
                core_mask = STLClient.CORE_MASK_PIN
            )
            self.start_watch()

            if self.duration == -1:
                while True:
                    self.stats_obj.stats(self.client.get_stats(), ports = self.ports)
                    try:
                        obj = self.queue.get_nowait()
                        self.update(obj)
                    except queue.Empty:
                        pass
                    if self.force_exit:
                        break
                    time.sleep(1)
            else:
                # block until done
                self.client.wait_on_traffic(ports=self.ports)

            # read the stats after the test
            stats = self.client.get_stats()

            log.info(json.dumps(stats[self.port_a], indent = 4, separators=(',', ': '), sort_keys = True))
            log.info(json.dumps(stats[self.port_b], indent = 4, separators=(',', ': '), sort_keys = True))

            lost_a = stats[self.port_a]["opackets"] - stats[self.port_b]["ipackets"]
            lost_b = stats[self.port_b]["opackets"] - stats[self.port_a]["ipackets"]

            log.info("\npackets lost from {0} --> {1}:   {2} pkts".format(self.port_a, self.port_b, lost_a))
            log.info("packets lost from {0} --> {1}:   {2} pkts".format(self.port_b, self.port_a, lost_b))

            if self.client.get_warnings():
                log.info("\n\n*** test had warnings ****\n\n")
                for w in self.client.get_warnings():
                    log.info(w)

            if (lost_a == 0) and (lost_b == 0) and not self.client.get_warnings():
                passed = True
            else:
                passed = False

        except STLError as e:
            passed = False
            log.info(e)

        finally:
            self.force_exit = True
            self.client.disconnect()

        if passed:
            print("\nTest has passed :-)\n")
        else:
            print("\nTest has failed :-(\n")

    def signal_handler(self, sig, frame):
        log.info('You pressed Ctrl+C!')
        time.sleep(6)
        self.force_exit = True
        clog.force_exit = True
        sys.exit(0)


def main():
    # run the tests
    packet_size = os.getenv("PACKET_SIZE") or os.getenv("packet_size") or 64
    packet_rate = os.getenv("PACKET_RATE") or os.getenv("packet_rate") or "10pps"
    duration = os.getenv("DURATION") or os.getenv("duration") or -1
    if duration != -1:
        duration = int(duration)
    log.info("Starting burst...")
    log.info("Packet Size - %s" % packet_size)
    log.info("Packet Rate - %s" % packet_rate)
    if duration == -1:
        log.info("Packets will be generated forever...")
    try:
        obj = STLS1(ports = [0, 1], size=packet_size, rate=packet_rate, duration=duration)
        obj.simple_burst()
    except Exception as e:
        log.exception("failed to start burst: %s" % e)

if __name__ == "__main__":
    main()
