#!/usr/bin/env python3

# https://github.com/secdev/scapy/blob/master/scapy/layers/l2.py#L164

from trex.stl.api import *
from trex.common.trex_logger import Logger

import time
import json
from datetime import datetime
import sys
import logging
import re


log = logging.getLogger('run-trex')
log.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(message)s')

fh = logging.FileHandler('/var/log/run-trex.log')
fh.setLevel(logging.INFO)
fh.setFormatter(formatter)

fhd = logging.FileHandler('/var/log/trex.log')
fhd.setLevel(logging.DEBUG)
fhd.setFormatter(formatter)

st = logging.StreamHandler()
st.setLevel(logging.INFO)
st.setFormatter(formatter)

log.addHandler(fh)
log.addHandler(fhd)
log.addHandler(st)

force_exit = False

class CustomLogger(Logger):
    def __init__ (self, verbose = "error"):
        super(CustomLogger, self).__init__(verbose)
        self.msg = ''

    def _write (self, msg, newline):
        if not force_exit:
            ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
            if isinstance(msg, (str, bytes)):
                msg = ansi_escape.sub('', msg)
                self.msg += msg
            if newline:
                log.debug(self.msg)
                self.msg = ''

    def _flush (self):
        pass

clog = CustomLogger("debug")


class STLS1(object):

    def __init__ (self, ports):
        self.fsize = 64
        self.pg_id = 0
        self.pkt_type = "ether"
        self.num_streams = 1
        self.ipack = [0] * len(ports)
        self.opack = [0] * len(ports)
        self.miss = []

    def create_stream (self):
        size = self.fsize - 4; # HW will add 4 bytes ethernet CRC

        ethr = Ether() / IP(src = "16.0.0.1", dst = "48.0.0.1") / UDP(dport = 12, sport = 1025)
        vlan = Ether() / Dot1Q(vlan=11) / IP(src = "16.0.0.1", dst = "48.0.0.1") / UDP(dport = 12, sport = 1025)
        qinq = Ether(type=0x88A8) / Dot1Q(vlan=19) / Dot1Q(vlan=11) / IP(src = "16.0.0.1", dst = "48.0.0.1") / UDP(dport = 12, sport = 1025)

        pkt_types = {
            "ether": ethr,
            "vlan": vlan,
            "qinq": qinq
        }

        if self.pkt_type not in pkt_types.keys():
            log.info ("Wrong pkt_type given. Allowed values are " + format(pkt_types.keys()))
            return []

        pad = max(0, size - len(self.pkt_type)) * 'x'
        pkt = STLPktBuilder(pkt = pkt_types[self.pkt_type]/pad)

        streams = []
        for pg_id_add in range(0, self.num_streams):
            streams.append(STLStream(packet = pkt, mode = STLTXCont(pps=1), flow_stats = STLFlowStats(pg_id = self.pg_id + pg_id_add)))

        return streams

    def stats(self, stat, ports):
        for i in ports:
            ipack = stat[i]['ipackets'] - self.ipack[i]
            opack = stat[i]['opackets'] - self.opack[i]
            self.ipack[i] = stat[i]['ipackets']
            self.opack[i] = stat[i]['opackets']
        if ipack >= opack:
            log.info("MATCH: out(%s) > in(%s)" % (opack, ipack))
            if self.miss and not self.miss[-1].get('end'):
                self.miss[-1]['end'] = datetime.now()
                log.info("Loss recovery: %s" % (self.miss[-1]['end'] - self.miss[-1]['start']))
        else:
            log.info("MISS:  out(%s) > in(%s)" % (opack, ipack))
            if self.miss and not self.miss[-1].get('end'):
                self.miss.append({'start': datetime.now()})

# create client
c = STLClient(verbose_level="debug", logger=clog)

def simple_burst (port_a, port_b, pkt_size, rate, duration=-1):
    global force_exit
    passed = True

    try:
        obj = STLS1(ports = [port_a, port_b])
        s1 = obj.create_stream()

        # connect to server
        c.connect()

        # prepare our ports
        c.reset(ports = [port_a, port_b])

        # add both streams to ports
        c.add_streams(s1, ports = [port_a])
        c.add_streams(s1, ports = [port_b])

        # clear the stats before injecting
        c.clear_stats()

        # here we multiply the traffic lineaer to whatever given in rate
        log.info("Running {:} on ports {:}, {:} for 10 seconds...".format(rate, port_a, port_b))
        c.start(ports = [port_a, port_b],
            mult = rate,
            duration = duration,
            core_mask = STLClient.CORE_MASK_PIN
        )

        if duration == -1:
            # Infinite
            while True:
                obj.stats(c.get_stats(), ports = [port_a, port_b])
                if force_exit:
                    break
                time.sleep(5)
        else:
            # block until done
            c.wait_on_traffic(ports = [port_a, port_b])

        # read the stats after the test
        stats = c.get_stats()

        log.info(json.dumps(stats[port_a], indent = 4, separators=(',', ': '), sort_keys = True))
        log.info(json.dumps(stats[port_b], indent = 4, separators=(',', ': '), sort_keys = True))

        lost_a = stats[port_a]["opackets"] - stats[port_b]["ipackets"]
        lost_b = stats[port_b]["opackets"] - stats[port_a]["ipackets"]

        log.info("\npackets lost from {0} --> {1}:   {2} pkts".format(port_a, port_b, lost_a))
        log.info("packets lost from {0} --> {1}:   {2} pkts".format(port_b, port_a, lost_b))

        if c.get_warnings():
            log.info("\n\n*** test had warnings ****\n\n")
            for w in c.get_warnings():
                log.info(w)

        if (lost_a == 0) and (lost_b == 0) and not c.get_warnings():
            passed = True
        else:
            passed = False

    except STLError as e:
        passed = False
        log.info(e)

    finally:
        force_exit = True
        c.disconnect()

    if passed:
        print("\nTest has passed :-)\n")
    else:
        print("\nTest has failed :-(\n")

# run the tests
packet_size = os.getenv("PACKET_SIZE") or 64
packet_rate = os.getenv("PACKET_RATE") or "10pps"
duration = os.getenv("DURATION") or -1
if duration != -1:
    duration = int(duration)
log.info("Starting burst...")
log.info("Packet Size - %s" % packet_size)
log.info("Packet Rate - %s" % packet_rate)
if duration == -1:
    log.info("Packets will be generated forever...")

import signal
import sys

def signal_handler(sig, frame):
    log.info('You pressed Ctrl+C!')
    time.sleep(6)
    global force_exit
    force_exit = True
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)


try:
    simple_burst(0, 1, packet_size, packet_rate, duration)
except Exception as e:
    log.exception("failed to start burst: %s" % e)

