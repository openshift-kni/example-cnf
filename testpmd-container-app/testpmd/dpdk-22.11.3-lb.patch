diff -urN dpdk/app/test-pmd/5tswap.c testpmd-as-load-balancer/v19.11/test-pmd/5tswap.c
--- dpdk/app/test-pmd/5tswap.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/5tswap.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,206 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright 2014-2020 Mellanox Technologies, Ltd
- */
-
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <inttypes.h>
-
-#include <sys/queue.h>
-#include <sys/stat.h>
-
-#include <rte_common.h>
-#include <rte_ether.h>
-#include <rte_ethdev.h>
-#include <rte_ip.h>
-#include <rte_flow.h>
-
-#include "macswap_common.h"
-#include "testpmd.h"
-
-
-static inline void
-swap_mac(struct rte_ether_hdr *eth_hdr)
-{
-	struct rte_ether_addr addr;
-
-	/* Swap dest and src mac addresses. */
-	rte_ether_addr_copy(&eth_hdr->dst_addr, &addr);
-	rte_ether_addr_copy(&eth_hdr->src_addr, &eth_hdr->dst_addr);
-	rte_ether_addr_copy(&addr, &eth_hdr->src_addr);
-}
-
-static inline void
-swap_ipv4(struct rte_ipv4_hdr *ipv4_hdr)
-{
-	rte_be32_t addr;
-
-	/* Swap dest and src ipv4 addresses. */
-	addr = ipv4_hdr->src_addr;
-	ipv4_hdr->src_addr = ipv4_hdr->dst_addr;
-	ipv4_hdr->dst_addr = addr;
-}
-
-static inline void
-swap_ipv6(struct rte_ipv6_hdr *ipv6_hdr)
-{
-	uint8_t addr[16];
-
-	/* Swap dest and src ipv6 addresses. */
-	memcpy(&addr, &ipv6_hdr->src_addr, 16);
-	memcpy(&ipv6_hdr->src_addr, &ipv6_hdr->dst_addr, 16);
-	memcpy(&ipv6_hdr->dst_addr, &addr, 16);
-}
-
-static inline void
-swap_tcp(struct rte_tcp_hdr *tcp_hdr)
-{
-	rte_be16_t port;
-
-	/* Swap dest and src tcp port. */
-	port = tcp_hdr->src_port;
-	tcp_hdr->src_port = tcp_hdr->dst_port;
-	tcp_hdr->dst_port = port;
-}
-
-static inline void
-swap_udp(struct rte_udp_hdr *udp_hdr)
-{
-	rte_be16_t port;
-
-	/* Swap dest and src udp port */
-	port = udp_hdr->src_port;
-	udp_hdr->src_port = udp_hdr->dst_port;
-	udp_hdr->dst_port = port;
-}
-
-/*
- * 5 tuple swap forwarding mode: Swap the source and the destination of layers
- * 2,3,4. Swaps source and destination for MAC, IPv4/IPv6, UDP/TCP.
- * Parses each layer and swaps it. When the next layer doesn't match it stops.
- */
-static void
-pkt_burst_5tuple_swap(struct fwd_stream *fs)
-{
-	struct rte_mbuf  *pkts_burst[MAX_PKT_BURST];
-	struct rte_port  *txp;
-	struct rte_mbuf *mb;
-	uint16_t next_proto;
-	uint64_t ol_flags;
-	uint16_t proto;
-	uint16_t nb_rx;
-	uint16_t nb_tx;
-	uint32_t retry;
-
-	int i;
-	union {
-		struct rte_ether_hdr *eth;
-		struct rte_vlan_hdr *vlan;
-		struct rte_ipv4_hdr *ipv4;
-		struct rte_ipv6_hdr *ipv6;
-		struct rte_tcp_hdr *tcp;
-		struct rte_udp_hdr *udp;
-		uint8_t *byte;
-	} h;
-
-	uint64_t start_tsc = 0;
-
-	get_start_cycles(&start_tsc);
-
-	/*
-	 * Receive a burst of packets and forward them.
-	 */
-	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue, pkts_burst,
-				 nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
-	if (unlikely(nb_rx == 0))
-		return;
-
-	fs->rx_packets += nb_rx;
-	txp = &ports[fs->tx_port];
-	ol_flags = ol_flags_init(txp->dev_conf.txmode.offloads);
-	vlan_qinq_set(pkts_burst, nb_rx, ol_flags,
-			txp->tx_vlan_id, txp->tx_vlan_id_outer);
-	for (i = 0; i < nb_rx; i++) {
-		if (likely(i < nb_rx - 1))
-			rte_prefetch0(rte_pktmbuf_mtod(pkts_burst[i+1],
-					void *));
-		mb = pkts_burst[i];
-		h.eth = rte_pktmbuf_mtod(mb, struct rte_ether_hdr *);
-		proto = h.eth->ether_type;
-		swap_mac(h.eth);
-		mb->l2_len = sizeof(struct rte_ether_hdr);
-		h.eth++;
-		while (proto == RTE_BE16(RTE_ETHER_TYPE_VLAN) ||
-		       proto == RTE_BE16(RTE_ETHER_TYPE_QINQ)) {
-			proto = h.vlan->eth_proto;
-			h.vlan++;
-			mb->l2_len += sizeof(struct rte_vlan_hdr);
-		}
-		if (proto == RTE_BE16(RTE_ETHER_TYPE_IPV4)) {
-			swap_ipv4(h.ipv4);
-			next_proto = h.ipv4->next_proto_id;
-			mb->l3_len = rte_ipv4_hdr_len(h.ipv4);
-			h.byte += mb->l3_len;
-		} else if (proto == RTE_BE16(RTE_ETHER_TYPE_IPV6)) {
-			swap_ipv6(h.ipv6);
-			next_proto = h.ipv6->proto;
-			h.ipv6++;
-			mb->l3_len = sizeof(struct rte_ipv6_hdr);
-		} else {
-			mbuf_field_set(mb, ol_flags);
-			continue;
-		}
-		if (next_proto == IPPROTO_UDP) {
-			swap_udp(h.udp);
-			mb->l4_len = sizeof(struct rte_udp_hdr);
-		} else if (next_proto == IPPROTO_TCP) {
-			swap_tcp(h.tcp);
-			mb->l4_len = (h.tcp->data_off & 0xf0) >> 2;
-		}
-		mbuf_field_set(mb, ol_flags);
-	}
-	nb_tx = rte_eth_tx_burst(fs->tx_port, fs->tx_queue, pkts_burst, nb_rx);
-	/*
-	 * Retry if necessary
-	 */
-	if (unlikely(nb_tx < nb_rx) && fs->retry_enabled) {
-		retry = 0;
-		while (nb_tx < nb_rx && retry++ < burst_tx_retry_num) {
-			rte_delay_us(burst_tx_delay_time);
-			nb_tx += rte_eth_tx_burst(fs->tx_port, fs->tx_queue,
-					&pkts_burst[nb_tx], nb_rx - nb_tx);
-		}
-	}
-	fs->tx_packets += nb_tx;
-	inc_tx_burst_stats(fs, nb_tx);
-	if (unlikely(nb_tx < nb_rx)) {
-		fs->fwd_dropped += (nb_rx - nb_tx);
-		do {
-			rte_pktmbuf_free(pkts_burst[nb_tx]);
-		} while (++nb_tx < nb_rx);
-	}
-	get_end_cycles(fs, start_tsc);
-}
-
-static void
-stream_init_5tuple_swap(struct fwd_stream *fs)
-{
-	bool rx_stopped, tx_stopped;
-
-	rx_stopped = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	tx_stopped = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	fs->disabled = rx_stopped || tx_stopped;
-}
-
-struct fwd_engine five_tuple_swap_fwd_engine = {
-	.fwd_mode_name  = "5tswap",
-	.port_fwd_begin = NULL,
-	.port_fwd_end   = NULL,
-	.stream_init    = stream_init_5tuple_swap,
-	.packet_fwd     = pkt_burst_5tuple_swap,
-};
diff -urN dpdk/app/test-pmd/bpf_cmd.c testpmd-as-load-balancer/v19.11/test-pmd/bpf_cmd.c
--- dpdk/app/test-pmd/bpf_cmd.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/bpf_cmd.c	2023-12-15 15:26:37.089199123 +0100
@@ -2,9 +2,7 @@
  * Copyright(c) 2018 Intel Corporation
  */
 
-#include <ctype.h>
 #include <stdio.h>
-
 #include <rte_mbuf.h>
 #include <rte_ethdev.h>
 #include <rte_flow.h>
@@ -22,7 +20,7 @@
 		.name = RTE_STR(stdout),
 		.type = RTE_BPF_XTYPE_VAR,
 		.var = {
-			.val = (void *)(uintptr_t)&stdout,
+			.val = &stdout,
 			.desc = {
 				.type = RTE_BPF_ARG_PTR,
 				.size = sizeof(stdout),
@@ -57,7 +55,7 @@
 struct cmd_bpf_ld_result {
 	cmdline_fixed_string_t bpf;
 	cmdline_fixed_string_t dir;
-	uint16_t port;
+	uint8_t port;
 	uint16_t queue;
 	cmdline_fixed_string_t op;
 	cmdline_fixed_string_t flags;
@@ -71,7 +69,7 @@
 
 	*flags = RTE_BPF_ETH_F_NONE;
 	arg->type = RTE_BPF_ARG_PTR;
-	arg->size = mbuf_data_size[0];
+	arg->size = mbuf_data_size;
 
 	for (i = 0; str[i] != 0; i++) {
 		v = toupper(str[i]);
@@ -80,17 +78,17 @@
 		else if (v == 'M') {
 			arg->type = RTE_BPF_ARG_PTR_MBUF;
 			arg->size = sizeof(struct rte_mbuf);
-			arg->buf_size = mbuf_data_size[0];
+			arg->buf_size = mbuf_data_size;
 		} else if (v == '-')
 			continue;
 		else
-			fprintf(stderr, "unknown flag: \'%c\'", v);
+			printf("unknown flag: \'%c\'", v);
 	}
 }
 
 static void cmd_operate_bpf_ld_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	int32_t rc;
 	uint32_t flags;
@@ -116,23 +114,23 @@
 			fname, sname, flags);
 		printf("%d:%s\n", rc, strerror(-rc));
 	} else
-		fprintf(stderr, "invalid value: %s\n", res->dir);
+		printf("invalid value: %s\n", res->dir);
 }
 
-static cmdline_parse_token_string_t cmd_load_bpf_start =
+cmdline_parse_token_string_t cmd_load_bpf_start =
 	TOKEN_STRING_INITIALIZER(struct cmd_bpf_ld_result,
 			bpf, "bpf-load");
-static cmdline_parse_token_string_t cmd_load_bpf_dir =
+cmdline_parse_token_string_t cmd_load_bpf_dir =
 	TOKEN_STRING_INITIALIZER(struct cmd_bpf_ld_result,
 			dir, "rx#tx");
-static cmdline_parse_token_num_t cmd_load_bpf_port =
-	TOKEN_NUM_INITIALIZER(struct cmd_bpf_ld_result, port, RTE_UINT8);
-static cmdline_parse_token_num_t cmd_load_bpf_queue =
-	TOKEN_NUM_INITIALIZER(struct cmd_bpf_ld_result, queue, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_load_bpf_flags =
+cmdline_parse_token_num_t cmd_load_bpf_port =
+	TOKEN_NUM_INITIALIZER(struct cmd_bpf_ld_result, port, UINT8);
+cmdline_parse_token_num_t cmd_load_bpf_queue =
+	TOKEN_NUM_INITIALIZER(struct cmd_bpf_ld_result, queue, UINT16);
+cmdline_parse_token_string_t cmd_load_bpf_flags =
 	TOKEN_STRING_INITIALIZER(struct cmd_bpf_ld_result,
 			flags, NULL);
-static cmdline_parse_token_string_t cmd_load_bpf_prm =
+cmdline_parse_token_string_t cmd_load_bpf_prm =
 	TOKEN_STRING_INITIALIZER(struct cmd_bpf_ld_result,
 			prm, NULL);
 
@@ -155,13 +153,13 @@
 struct cmd_bpf_unld_result {
 	cmdline_fixed_string_t bpf;
 	cmdline_fixed_string_t dir;
-	uint16_t port;
+	uint8_t port;
 	uint16_t queue;
 };
 
 static void cmd_operate_bpf_unld_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_bpf_unld_result *res;
 
@@ -172,19 +170,19 @@
 	else if (strcmp(res->dir, "tx") == 0)
 		rte_bpf_eth_tx_unload(res->port, res->queue);
 	else
-		fprintf(stderr, "invalid value: %s\n", res->dir);
+		printf("invalid value: %s\n", res->dir);
 }
 
-static cmdline_parse_token_string_t cmd_unload_bpf_start =
+cmdline_parse_token_string_t cmd_unload_bpf_start =
 	TOKEN_STRING_INITIALIZER(struct cmd_bpf_unld_result,
 			bpf, "bpf-unload");
-static cmdline_parse_token_string_t cmd_unload_bpf_dir =
+cmdline_parse_token_string_t cmd_unload_bpf_dir =
 	TOKEN_STRING_INITIALIZER(struct cmd_bpf_unld_result,
 			dir, "rx#tx");
-static cmdline_parse_token_num_t cmd_unload_bpf_port =
-	TOKEN_NUM_INITIALIZER(struct cmd_bpf_unld_result, port, RTE_UINT8);
-static cmdline_parse_token_num_t cmd_unload_bpf_queue =
-	TOKEN_NUM_INITIALIZER(struct cmd_bpf_unld_result, queue, RTE_UINT16);
+cmdline_parse_token_num_t cmd_unload_bpf_port =
+	TOKEN_NUM_INITIALIZER(struct cmd_bpf_unld_result, port, UINT8);
+cmdline_parse_token_num_t cmd_unload_bpf_queue =
+	TOKEN_NUM_INITIALIZER(struct cmd_bpf_unld_result, queue, UINT16);
 
 cmdline_parse_inst_t cmd_operate_bpf_unld_parse = {
 	.f = cmd_operate_bpf_unld_parsed,
diff -urN dpdk/app/test-pmd/bpf_cmd.h testpmd-as-load-balancer/v19.11/test-pmd/bpf_cmd.h
--- dpdk/app/test-pmd/bpf_cmd.h	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/bpf_cmd.h	2023-12-15 15:26:37.089199123 +0100
@@ -5,12 +5,12 @@
 #ifndef _BPF_CMD_H_
 #define _BPF_CMD_H_
 
-#ifdef RTE_LIB_BPF
+#ifdef RTE_LIBRTE_BPF
 
  /* BPF CLI */
 extern cmdline_parse_inst_t cmd_operate_bpf_ld_parse;
 extern cmdline_parse_inst_t cmd_operate_bpf_unld_parse;
 
-#endif /* RTE_LIB_BPF */
+#endif /* RTE_LIBRTE_BPF */
 
 #endif /* _BPF_CMD_H_ */
diff -urN dpdk/app/test-pmd/cmd_flex_item.c testpmd-as-load-balancer/v19.11/test-pmd/cmd_flex_item.c
--- dpdk/app/test-pmd/cmd_flex_item.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/cmd_flex_item.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,553 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright (c) 2021 NVIDIA Corporation & Affiliates
- */
-
-#include <stddef.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <string.h>
-
-#include <rte_common.h>
-#include <rte_ethdev.h>
-#include <cmdline_parse.h>
-#include <cmdline_parse_string.h>
-#include <cmdline_parse_num.h>
-#include <rte_flow.h>
-
-#include "testpmd.h"
-
-struct flex_item *flex_items[RTE_MAX_ETHPORTS][FLEX_MAX_PARSERS_NUM];
-struct flex_pattern flex_patterns[FLEX_MAX_PATTERNS_NUM];
-
-#ifdef RTE_HAS_JANSSON
-
-static struct flex_item *
-flex_parser_fetch(uint16_t port_id, uint16_t flex_id)
-{
-	if (port_id >= RTE_MAX_ETHPORTS) {
-		printf("Invalid port_id: %u\n", port_id);
-		return FLEX_PARSER_ERR;
-	}
-	if (flex_id >= FLEX_MAX_PARSERS_NUM) {
-		printf("Invalid flex item flex_id: %u\n", flex_id);
-		return FLEX_PARSER_ERR;
-	}
-	return flex_items[port_id][flex_id];
-}
-
-static __rte_always_inline bool
-match_strkey(const char *key, const char *pattern)
-{
-	return strncmp(key, pattern, strlen(key)) == 0;
-}
-
-static int
-flex_tunnel_parse(json_t *jtun, enum rte_flow_item_flex_tunnel_mode *tunnel)
-{
-	int tun = -1;
-
-	if (json_is_integer(jtun))
-		tun = (int)json_integer_value(jtun);
-	else if (json_is_real(jtun))
-		tun = (int)json_real_value(jtun);
-	else if (json_is_string(jtun)) {
-		const char *mode = json_string_value(jtun);
-
-		if (match_strkey(mode, "FLEX_TUNNEL_MODE_SINGLE"))
-			tun = FLEX_TUNNEL_MODE_SINGLE;
-		else if (match_strkey(mode, "FLEX_TUNNEL_MODE_OUTER"))
-			tun = FLEX_TUNNEL_MODE_OUTER;
-		else if (match_strkey(mode, "FLEX_TUNNEL_MODE_INNER"))
-			tun = FLEX_TUNNEL_MODE_INNER;
-		else if (match_strkey(mode, "FLEX_TUNNEL_MODE_MULTI"))
-			tun = FLEX_TUNNEL_MODE_MULTI;
-		else if (match_strkey(mode, "FLEX_TUNNEL_MODE_TUNNEL"))
-			tun = FLEX_TUNNEL_MODE_TUNNEL;
-		else
-			return -EINVAL;
-	} else
-		return -EINVAL;
-	*tunnel = (enum rte_flow_item_flex_tunnel_mode)tun;
-	return 0;
-}
-
-static int
-flex_field_parse(json_t *jfld, struct rte_flow_item_flex_field *fld)
-{
-	const char *key;
-	json_t *je;
-
-#define FLEX_FIELD_GET(fm, t) \
-do {                  \
-	if (!strncmp(key, # fm, strlen(# fm))) { \
-		if (json_is_real(je))   \
-			fld->fm = (t) json_real_value(je); \
-		else if (json_is_integer(je))   \
-			fld->fm = (t) json_integer_value(je); \
-		else   \
-			return -EINVAL; \
-	}         \
-} while (0)
-
-	json_object_foreach(jfld, key, je) {
-		FLEX_FIELD_GET(field_size, uint32_t);
-		FLEX_FIELD_GET(field_base, int32_t);
-		FLEX_FIELD_GET(offset_base, uint32_t);
-		FLEX_FIELD_GET(offset_mask, uint32_t);
-		FLEX_FIELD_GET(offset_shift, int32_t);
-		FLEX_FIELD_GET(field_id, uint16_t);
-		if (match_strkey(key, "field_mode")) {
-			const char *mode;
-			if (!json_is_string(je))
-				return -EINVAL;
-			mode = json_string_value(je);
-			if (match_strkey(mode, "FIELD_MODE_DUMMY"))
-				fld->field_mode = FIELD_MODE_DUMMY;
-			else if (match_strkey(mode, "FIELD_MODE_FIXED"))
-				fld->field_mode = FIELD_MODE_FIXED;
-			else if (match_strkey(mode, "FIELD_MODE_OFFSET"))
-				fld->field_mode = FIELD_MODE_OFFSET;
-			else if (match_strkey(mode, "FIELD_MODE_BITMASK"))
-				fld->field_mode = FIELD_MODE_BITMASK;
-			else
-				return -EINVAL;
-		}
-	}
-	return 0;
-}
-
-enum flex_link_type {
-	FLEX_LINK_IN = 0,
-	FLEX_LINK_OUT = 1
-};
-
-static int
-flex_link_item_parse(const char *src, struct rte_flow_item *item)
-{
-#define  FLEX_PARSE_DATA_SIZE 1024
-
-	int ret;
-	uint8_t *ptr, data[FLEX_PARSE_DATA_SIZE] = {0,};
-	char flow_rule[256];
-	struct rte_flow_attr *attr;
-	struct rte_flow_item *pattern;
-	struct rte_flow_action *actions;
-
-	sprintf(flow_rule,
-		"flow create 0 pattern %s / end actions drop / end", src);
-	src = flow_rule;
-	ret = flow_parse(src, (void *)data, sizeof(data),
-			 &attr, &pattern, &actions);
-	if (ret)
-		return ret;
-	item->type = pattern->type;
-	if (pattern->spec) {
-		ptr = (void *)(uintptr_t)item->spec;
-		memcpy(ptr, pattern->spec, FLEX_MAX_FLOW_PATTERN_LENGTH);
-	} else {
-		item->spec = NULL;
-	}
-	if (pattern->mask) {
-		ptr = (void *)(uintptr_t)item->mask;
-		memcpy(ptr, pattern->mask, FLEX_MAX_FLOW_PATTERN_LENGTH);
-	} else {
-		item->mask = NULL;
-	}
-	if (pattern->last) {
-		ptr = (void *)(uintptr_t)item->last;
-		memcpy(ptr, pattern->last, FLEX_MAX_FLOW_PATTERN_LENGTH);
-	} else {
-		item->last = NULL;
-	}
-	return 0;
-}
-
-static int
-flex_link_parse(json_t *jobj, struct rte_flow_item_flex_link *link,
-		enum flex_link_type link_type)
-{
-	const char *key;
-	json_t *je;
-	int ret;
-	json_object_foreach(jobj, key, je) {
-		if (match_strkey(key, "item")) {
-			if (!json_is_string(je))
-				return -EINVAL;
-			ret = flex_link_item_parse(json_string_value(je),
-						   &link->item);
-			if (ret)
-				return -EINVAL;
-			if (link_type == FLEX_LINK_IN) {
-				if (!link->item.spec || !link->item.mask)
-					return -EINVAL;
-				if (link->item.last)
-					return -EINVAL;
-			}
-		}
-		if (match_strkey(key, "next")) {
-			if (json_is_integer(je))
-				link->next = (typeof(link->next))
-					     json_integer_value(je);
-			else if (json_is_real(je))
-				link->next = (typeof(link->next))
-					     json_real_value(je);
-			else
-				return -EINVAL;
-		}
-	}
-	return 0;
-}
-
-static int flex_item_config(json_t *jroot,
-			    struct rte_flow_item_flex_conf *flex_conf)
-{
-	const char *key;
-	json_t *jobj = NULL;
-	int ret = 0;
-
-	json_object_foreach(jroot, key, jobj) {
-		if (match_strkey(key, "tunnel")) {
-			ret = flex_tunnel_parse(jobj, &flex_conf->tunnel);
-			if (ret) {
-				printf("Can't parse tunnel value\n");
-				goto out;
-			}
-		} else if (match_strkey(key, "next_header")) {
-			ret = flex_field_parse(jobj, &flex_conf->next_header);
-			if (ret) {
-				printf("Can't parse next_header field\n");
-				goto out;
-			}
-		} else if (match_strkey(key, "next_protocol")) {
-			ret = flex_field_parse(jobj,
-					       &flex_conf->next_protocol);
-			if (ret) {
-				printf("Can't parse next_protocol field\n");
-				goto out;
-			}
-		} else if (match_strkey(key, "sample_data")) {
-			json_t *ji;
-			uint32_t i, size = json_array_size(jobj);
-			for (i = 0; i < size; i++) {
-				ji = json_array_get(jobj, i);
-				ret = flex_field_parse
-					(ji, flex_conf->sample_data + i);
-				if (ret) {
-					printf("Can't parse sample_data field(s)\n");
-					goto out;
-				}
-			}
-			flex_conf->nb_samples = size;
-		} else if (match_strkey(key, "input_link")) {
-			json_t *ji;
-			uint32_t i, size = json_array_size(jobj);
-			for (i = 0; i < size; i++) {
-				ji = json_array_get(jobj, i);
-				ret = flex_link_parse(ji,
-						      flex_conf->input_link + i,
-						      FLEX_LINK_IN);
-				if (ret) {
-					printf("Can't parse input_link(s)\n");
-					goto out;
-				}
-			}
-			flex_conf->nb_inputs = size;
-		} else if (match_strkey(key, "output_link")) {
-			json_t *ji;
-			uint32_t i, size = json_array_size(jobj);
-			for (i = 0; i < size; i++) {
-				ji = json_array_get(jobj, i);
-				ret = flex_link_parse
-					(ji, flex_conf->output_link + i,
-					 FLEX_LINK_OUT);
-				if (ret) {
-					printf("Can't parse output_link(s)\n");
-					goto out;
-				}
-			}
-			flex_conf->nb_outputs = size;
-		}
-	}
-out:
-	return ret;
-}
-
-static struct flex_item *
-flex_item_init(void)
-{
-	size_t base_size, samples_size, links_size, spec_size;
-	struct rte_flow_item_flex_conf *conf;
-	struct flex_item *fp;
-	uint8_t (*pattern)[FLEX_MAX_FLOW_PATTERN_LENGTH];
-	int i;
-
-	base_size = RTE_ALIGN(sizeof(*conf), sizeof(uintptr_t));
-	samples_size = RTE_ALIGN(FLEX_ITEM_MAX_SAMPLES_NUM *
-				 sizeof(conf->sample_data[0]),
-				 sizeof(uintptr_t));
-	links_size = RTE_ALIGN(FLEX_ITEM_MAX_LINKS_NUM *
-			       sizeof(conf->input_link[0]),
-			       sizeof(uintptr_t));
-	/* spec & mask for all input links */
-	spec_size = 2 * FLEX_MAX_FLOW_PATTERN_LENGTH * FLEX_ITEM_MAX_LINKS_NUM;
-	fp = calloc(1, base_size + samples_size + 2 * links_size + spec_size);
-	if (fp == NULL) {
-		printf("Can't allocate memory for flex item\n");
-		return NULL;
-	}
-	conf = &fp->flex_conf;
-	conf->sample_data = (typeof(conf->sample_data))
-			    ((uint8_t *)fp + base_size);
-	conf->input_link = (typeof(conf->input_link))
-			   ((uint8_t *)conf->sample_data + samples_size);
-	conf->output_link = (typeof(conf->output_link))
-			    ((uint8_t *)conf->input_link + links_size);
-	pattern = (typeof(pattern))((uint8_t *)conf->output_link + links_size);
-	for (i = 0; i < FLEX_ITEM_MAX_LINKS_NUM; i++) {
-		struct rte_flow_item_flex_link *in = conf->input_link + i;
-		in->item.spec = pattern++;
-		in->item.mask = pattern++;
-	}
-	return fp;
-}
-
-static int
-flex_item_build_config(struct flex_item *fp, const char *filename)
-{
-	int ret;
-	json_error_t json_error;
-	json_t *jroot = json_load_file(filename, 0, &json_error);
-
-	if (!jroot) {
-		printf("Bad JSON file \"%s\": %s\n", filename, json_error.text);
-		return -1;
-	}
-	ret = flex_item_config(jroot, &fp->flex_conf);
-	json_decref(jroot);
-	return ret;
-}
-
-void
-flex_item_create(portid_t port_id, uint16_t flex_id, const char *filename)
-{
-	struct rte_flow_error flow_error;
-	struct flex_item *fp = flex_parser_fetch(port_id, flex_id);
-	int ret;
-
-	if (fp == FLEX_PARSER_ERR) {
-		printf("Bad parameters: port_id=%u flex_id=%u\n",
-		       port_id, flex_id);
-		return;
-	}
-	if (fp) {
-		printf("port-%u: flex item #%u is already in use\n",
-		       port_id, flex_id);
-		return;
-	}
-	fp = flex_item_init();
-	if (!fp) {
-		printf("Could not allocate flex item\n");
-		goto out;
-	}
-	ret = flex_item_build_config(fp, filename);
-	if (ret)
-		goto out;
-	fp->flex_handle = rte_flow_flex_item_create(port_id,
-						    &fp->flex_conf,
-						    &flow_error);
-	if (fp->flex_handle) {
-		flex_items[port_id][flex_id] = fp;
-		printf("port-%u: created flex item #%u\n", port_id, flex_id);
-		fp = NULL;
-	} else {
-		printf("port-%u: flex item #%u creation failed: %s\n",
-		       port_id, flex_id,
-		       flow_error.message ? flow_error.message : "");
-	}
-out:
-	free(fp);
-}
-
-void
-flex_item_destroy(portid_t port_id, uint16_t flex_id)
-{
-	int ret;
-	struct rte_flow_error error;
-	struct flex_item *fp = flex_parser_fetch(port_id, flex_id);
-	if (fp == FLEX_PARSER_ERR) {
-		printf("Bad parameters: port_id=%u flex_id=%u\n",
-		       port_id, flex_id);
-		return;
-	}
-	if (!fp)
-		return;
-	ret = rte_flow_flex_item_release(port_id, fp->flex_handle, &error);
-	if (!ret) {
-		free(fp);
-		flex_items[port_id][flex_id] = NULL;
-		printf("port-%u: released flex item #%u\n",
-		       port_id, flex_id);
-
-	} else {
-		printf("port-%u: cannot release flex item #%u: %s\n",
-		       port_id, flex_id, error.message);
-	}
-}
-
-#else /* RTE_HAS_JANSSON */
-void flex_item_create(__rte_unused portid_t port_id,
-		      __rte_unused uint16_t flex_id,
-		      __rte_unused const char *filename)
-{
-	printf("cannot create flex item - no JSON library configured\n");
-}
-
-void
-flex_item_destroy(__rte_unused portid_t port_id, __rte_unused uint16_t flex_id)
-{
-
-}
-
-#endif /* RTE_HAS_JANSSON */
-
-void
-port_flex_item_flush(portid_t port_id)
-{
-	uint16_t i;
-
-	for (i = 0; i < FLEX_MAX_PARSERS_NUM; i++) {
-		if (flex_items[port_id][i] != NULL) {
-			flex_item_destroy(port_id, i);
-			flex_items[port_id][i] = NULL;
-		}
-	}
-}
-
-struct flex_pattern_set {
-	cmdline_fixed_string_t set, flex_pattern;
-	cmdline_fixed_string_t is_spec, mask;
-	cmdline_fixed_string_t spec_data, mask_data;
-	uint16_t id;
-};
-
-static cmdline_parse_token_string_t flex_pattern_set_token =
-	TOKEN_STRING_INITIALIZER(struct flex_pattern_set, set, "set");
-static cmdline_parse_token_string_t flex_pattern_token =
-	TOKEN_STRING_INITIALIZER(struct flex_pattern_set,
-flex_pattern, "flex_pattern");
-static cmdline_parse_token_string_t flex_pattern_is_token =
-	TOKEN_STRING_INITIALIZER(struct flex_pattern_set,
-is_spec, "is");
-static cmdline_parse_token_string_t flex_pattern_spec_token =
-	TOKEN_STRING_INITIALIZER(struct flex_pattern_set,
-is_spec, "spec");
-static cmdline_parse_token_string_t flex_pattern_mask_token =
-	TOKEN_STRING_INITIALIZER(struct flex_pattern_set, mask, "mask");
-static cmdline_parse_token_string_t flex_pattern_spec_data_token =
-	TOKEN_STRING_INITIALIZER(struct flex_pattern_set, spec_data, NULL);
-static cmdline_parse_token_string_t flex_pattern_mask_data_token =
-	TOKEN_STRING_INITIALIZER(struct flex_pattern_set, mask_data, NULL);
-static cmdline_parse_token_num_t flex_pattern_id_token =
-	TOKEN_NUM_INITIALIZER(struct flex_pattern_set, id, RTE_UINT16);
-
-/*
- * flex pattern data - spec or mask is a string representation of byte array
- * in hexadecimal format. Each byte in data string must have 2 characters:
- * 0x15 - "15"
- * 0x1  - "01"
- * Bytes in data array are in network order.
- */
-static uint32_t
-flex_pattern_data(const char *str, uint8_t *data)
-{
-	uint32_t i, len = strlen(str);
-	char b[3], *endptr;
-
-	if (len & 01)
-		return 0;
-	len /= 2;
-	if (len >= FLEX_MAX_FLOW_PATTERN_LENGTH)
-		return 0;
-	for (i = 0, b[2] = '\0'; i < len; i++) {
-		b[0] = str[2 * i];
-		b[1] = str[2 * i + 1];
-		data[i] = strtoul(b, &endptr, 16);
-		if (endptr != &b[2])
-			return 0;
-	}
-	return len;
-}
-
-static void
-flex_pattern_parsed_fn(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
-{
-	struct flex_pattern_set *res = parsed_result;
-	struct flex_pattern *fp;
-	bool full_spec;
-
-	if (res->id >= FLEX_MAX_PATTERNS_NUM) {
-		printf("Bad flex pattern id\n");
-		return;
-	}
-	fp = flex_patterns + res->id;
-	memset(fp->spec_pattern, 0, sizeof(fp->spec_pattern));
-	memset(fp->mask_pattern, 0, sizeof(fp->mask_pattern));
-	fp->spec.length = flex_pattern_data(res->spec_data, fp->spec_pattern);
-	if (!fp->spec.length) {
-		printf("Bad flex pattern spec\n");
-		return;
-	}
-	full_spec = strncmp(res->is_spec, "spec", strlen("spec")) == 0;
-	if (full_spec) {
-		fp->mask.length = flex_pattern_data(res->mask_data,
-						    fp->mask_pattern);
-		if (!fp->mask.length) {
-			printf("Bad flex pattern mask\n");
-			return;
-		}
-	} else {
-		memset(fp->mask_pattern, 0xFF, fp->spec.length);
-		fp->mask.length = fp->spec.length;
-	}
-	if (fp->mask.length != fp->spec.length) {
-		printf("Spec length do not match mask length\n");
-		return;
-	}
-	fp->spec.pattern = fp->spec_pattern;
-	fp->mask.pattern = fp->mask_pattern;
-	printf("created pattern #%u\n", res->id);
-}
-
-cmdline_parse_inst_t cmd_set_flex_is_pattern = {
-	.f = flex_pattern_parsed_fn,
-	.data = NULL,
-	.help_str = "set flex_pattern <id> is <spec_data>",
-	.tokens = {
-		(void *)&flex_pattern_set_token,
-		(void *)&flex_pattern_token,
-		(void *)&flex_pattern_id_token,
-		(void *)&flex_pattern_is_token,
-		(void *)&flex_pattern_spec_data_token,
-		NULL,
-	}
-};
-
-cmdline_parse_inst_t cmd_set_flex_spec_pattern = {
-	.f = flex_pattern_parsed_fn,
-	.data = NULL,
-	.help_str = "set flex_pattern <id> spec <spec_data> mask <mask_data>",
-	.tokens = {
-		(void *)&flex_pattern_set_token,
-		(void *)&flex_pattern_token,
-		(void *)&flex_pattern_id_token,
-		(void *)&flex_pattern_spec_token,
-		(void *)&flex_pattern_spec_data_token,
-		(void *)&flex_pattern_mask_token,
-		(void *)&flex_pattern_mask_data_token,
-		NULL,
-	}
-};
diff -urN dpdk/app/test-pmd/cmdline.c testpmd-as-load-balancer/v19.11/test-pmd/cmdline.c
--- dpdk/app/test-pmd/cmdline.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/cmdline.c	2023-12-15 15:26:37.089199123 +0100
@@ -3,15 +3,17 @@
  * Copyright(c) 2014 6WIND S.A.
  */
 
-#include <ctype.h>
 #include <stdarg.h>
 #include <errno.h>
 #include <stdio.h>
 #include <stdint.h>
-#include <stdlib.h>
 #include <string.h>
+#include <termios.h>
 #include <unistd.h>
 #include <inttypes.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
 #include <sys/queue.h>
 
 #include <rte_common.h>
@@ -26,19 +28,18 @@
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_ring.h>
 #include <rte_mempool.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_string_fns.h>
 #include <rte_devargs.h>
 #include <rte_flow.h>
-#ifdef RTE_LIB_GRO
 #include <rte_gro.h>
-#endif
-#include <rte_mbuf_dyn.h>
 
 #include <cmdline_rdline.h>
 #include <cmdline_parse.h>
@@ -48,16 +49,20 @@
 #include <cmdline_parse_etheraddr.h>
 #include <cmdline_socket.h>
 #include <cmdline.h>
-#if defined RTE_BUS_DPAA && defined RTE_NET_DPAA
+#ifdef RTE_LIBRTE_PMD_BOND
+#include <rte_eth_bond.h>
+#include <rte_eth_bond_8023ad.h>
+#endif
+#if defined RTE_LIBRTE_DPAA_BUS && defined RTE_LIBRTE_DPAA_PMD
 #include <rte_pmd_dpaa.h>
 #endif
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 #include <rte_pmd_ixgbe.h>
 #endif
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 #include <rte_pmd_i40e.h>
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 #include <rte_pmd_bnxt.h>
 #endif
 #include "testpmd.h"
@@ -66,18 +71,17 @@
 #include "bpf_cmd.h"
 
 static struct cmdline *testpmd_cl;
-static cmdline_parse_ctx_t *main_ctx;
-static TAILQ_HEAD(, testpmd_driver_commands) driver_commands_head =
-	TAILQ_HEAD_INITIALIZER(driver_commands_head);
+
+static void cmd_reconfig_device_queue(portid_t id, uint8_t dev, uint8_t queue);
 
 /* *** Help command with introduction. *** */
 struct cmd_help_brief_result {
 	cmdline_fixed_string_t help;
 };
 
-static void cmd_help_brief_parsed(__rte_unused void *parsed_result,
+static void cmd_help_brief_parsed(__attribute__((unused)) void *parsed_result,
                                   struct cmdline *cl,
-                                  __rte_unused void *data)
+                                  __attribute__((unused)) void *data)
 {
 	cmdline_printf(
 		cl,
@@ -88,19 +92,19 @@
 		"information.\n"
 		"    help config                     : Configuration information.\n"
 		"    help ports                      : Configuring ports.\n"
+		"    help registers                  : Reading and setting port registers.\n"
 		"    help filters                    : Filters configuration help.\n"
-		"    help traffic_management         : Traffic Management commands.\n"
-		"    help devices                    : Device related commands.\n"
-		"    help drivers                    : Driver specific commands.\n"
+		"    help traffic_management         : Traffic Management commmands.\n"
+		"    help devices                    : Device related cmds.\n"
 		"    help all                        : All of the above sections.\n\n"
 	);
 
 }
 
-static cmdline_parse_token_string_t cmd_help_brief_help =
+cmdline_parse_token_string_t cmd_help_brief_help =
 	TOKEN_STRING_INITIALIZER(struct cmd_help_brief_result, help, "help");
 
-static cmdline_parse_inst_t cmd_help_brief = {
+cmdline_parse_inst_t cmd_help_brief = {
 	.f = cmd_help_brief_parsed,
 	.data = NULL,
 	.help_str = "help: Show help",
@@ -118,7 +122,7 @@
 
 static void cmd_help_long_parsed(void *parsed_result,
                                  struct cmdline *cl,
-                                 __rte_unused void *data)
+                                 __attribute__((unused)) void *data)
 {
 	int show_all = 0;
 	struct cmd_help_long_result *res = parsed_result;
@@ -158,15 +162,9 @@
 			"Display:\n"
 			"--------\n\n"
 
-			"show port (info|stats|summary|xstats|fdir|dcb_tc) (port_id|all)\n"
+			"show port (info|stats|summary|xstats|fdir|stat_qmap|dcb_tc|cap) (port_id|all)\n"
 			"    Display information for port_id, or all.\n\n"
 
-			"show port info (port_id) representor\n"
-			"    Show supported representors for a specific port\n\n"
-
-			"show port port_id (module_eeprom|eeprom)\n"
-			"    Display the module EEPROM or EEPROM information for port_id.\n\n"
-
 			"show port X rss reta (size) (mask0,mask1,...)\n"
 			"    Display the rss redirection table entry indicated"
 			" by masks on port X. size is used to indicate the"
@@ -175,13 +173,13 @@
 			"show port (port_id) rss-hash [key]\n"
 			"    Display the RSS hash functions and RSS hash key of port\n\n"
 
-			"clear port (info|stats|xstats|fdir) (port_id|all)\n"
+			"clear port (info|stats|xstats|fdir|stat_qmap) (port_id|all)\n"
 			"    Clear information for port_id, or all.\n\n"
 
 			"show (rxq|txq) info (port_id) (queue_id)\n"
 			"    Display information for configured RX/TX queue.\n\n"
 
-			"show config (rxtx|cores|fwd|rxoffs|rxpkts|rxhdrs|txpkts)\n"
+			"show config (rxtx|cores|fwd|txpkts)\n"
 			"    Display the given configuration.\n\n"
 
 			"read rxd (port_id) (queue_id) (rxd_id)\n"
@@ -190,12 +188,21 @@
 			"read txd (port_id) (queue_id) (txd_id)\n"
 			"    Display a TX descriptor of a port TX queue.\n\n"
 
+			"ddp get list (port_id)\n"
+			"    Get ddp profile info list\n\n"
+
+			"ddp get info (profile_path)\n"
+			"    Get ddp profile information.\n\n"
+
 			"show vf stats (port_id) (vf_id)\n"
 			"    Display a VF's statistics.\n\n"
 
 			"clear vf stats (port_id) (vf_id)\n"
 			"    Reset a VF's statistics.\n\n"
 
+			"show port (port_id) pctype mapping\n"
+			"    Get flow ptype to pctype mapping on a port\n\n"
+
 			"show port meter stats (port_id) (meter_id) (clear)\n"
 			"    Get meter stats on a port\n\n"
 
@@ -234,25 +241,6 @@
 
 			"show port (port_id) rxq|txq (queue_id) desc (desc_id) status"
 			"       Show status of rx|tx descriptor.\n\n"
-
-			"show port (port_id) rxq (queue_id) desc used count\n"
-			"    Show current number of filled receive"
-			" packet descriptors.\n\n"
-
-			"show port (port_id) macs|mcast_macs"
-			"       Display list of mac addresses added to port.\n\n"
-
-			"show port (port_id) flow transfer proxy\n"
-			"	Display proxy port to manage transfer flows\n\n"
-
-			"show port (port_id) fec capabilities"
-			"	Show fec capabilities of a port.\n\n"
-
-			"show port (port_id) fec_mode"
-			"	Show fec mode of a port.\n\n"
-
-			"show port (port_id) flow_ctrl"
-			"	Show flow control info of a port.\n\n"
 		);
 	}
 
@@ -293,29 +281,6 @@
 			"    Set the transmit delay time and number of retries,"
 			" effective when retry is enabled.\n\n"
 
-			"set rxoffs (x[,y]*)\n"
-			"    Set the offset of each packet segment on"
-			" receiving if split feature is engaged."
-			" Affects only the queues configured with split"
-			" offloads.\n\n"
-
-			"set rxpkts (x[,y]*)\n"
-			"    Set the length of each segment to scatter"
-			" packets on receiving if split feature is engaged."
-			" Affects only the queues configured with split"
-			" offloads.\n\n"
-
-			"set rxhdrs (eth[,ipv4])*\n"
-			"    Set the protocol hdr of each segment to scatter"
-			" packets on receiving if split feature is engaged."
-			" Affects only the queues configured with split"
-			" offloads.\n"
-			"    Supported values: eth|ipv4|ipv6|ipv4-tcp|ipv6-tcp|"
-			"ipv4-udp|ipv6-udp|ipv4-sctp|ipv6-sctp|"
-			"grenat|inner-eth|inner-ipv4|inner-ipv6|inner-ipv4-tcp|"
-			"inner-ipv6-tcp|inner-ipv4-udp|inner-ipv6-udp|"
-			"inner-ipv4-sctp|inner-ipv6-sctp\n\n"
-
 			"set txpkts (x[,y]*)\n"
 			"    Set the length of each segment of TXONLY"
 			" and optionally CSUM packets.\n\n"
@@ -325,10 +290,6 @@
 			" Right now only applicable for CSUM and TXONLY"
 			" modes\n\n"
 
-			"set txtimes (x, y)\n"
-			"    Set the scheduling on timestamps"
-			" timings for the TXONLY mode\n\n"
-
 			"set corelist (x[,y]*)\n"
 			"    Set the list of forwarding cores.\n\n"
 
@@ -344,9 +305,27 @@
 			"set all queues drop (port_id) (on|off)\n"
 			"    Set drop enable bit for all queues.\n\n"
 
+			"set vf split drop (port_id) (vf_id) (on|off)\n"
+			"    Set split drop enable bit for a VF from the PF.\n\n"
+
 			"set vf mac antispoof (port_id) (vf_id) (on|off).\n"
 			"    Set MAC antispoof for a VF from the PF.\n\n"
 
+			"set macsec offload (port_id) on encrypt (on|off) replay-protect (on|off)\n"
+			"    Enable MACsec offload.\n\n"
+
+			"set macsec offload (port_id) off\n"
+			"    Disable MACsec offload.\n\n"
+
+			"set macsec sc (tx|rx) (port_id) (mac) (pi)\n"
+			"    Configure MACsec secure connection (SC).\n\n"
+
+			"set macsec sa (tx|rx) (port_id) (idx) (an) (pn) (key)\n"
+			"    Configure MACsec secure association (SA).\n\n"
+
+			"set vf broadcast (port_id) (vf_id) (on|off)\n"
+			"    Set VF broadcast for a VF from the PF.\n\n"
+
 			"vlan set stripq (on|off) (port_id,queue_id)\n"
 			"    Set the VLAN strip for a queue on a port.\n\n"
 
@@ -359,6 +338,24 @@
 			"set vf vlan antispoof (port_id) (vf_id) (on|off)\n"
 			"    Set VLAN antispoof for a VF from the PF.\n\n"
 
+			"set vf vlan tag (port_id) (vf_id) (on|off)\n"
+			"    Set VLAN tag for a VF from the PF.\n\n"
+
+			"set vf tx max-bandwidth (port_id) (vf_id) (bandwidth)\n"
+			"    Set a VF's max bandwidth(Mbps).\n\n"
+
+			"set vf tc tx min-bandwidth (port_id) (vf_id) (bw1, bw2, ...)\n"
+			"    Set all TCs' min bandwidth(%%) on a VF.\n\n"
+
+			"set vf tc tx max-bandwidth (port_id) (vf_id) (tc_no) (bandwidth)\n"
+			"    Set a TC's max bandwidth(Mbps) on a VF.\n\n"
+
+			"set tx strict-link-priority (port_id) (tc_bitmap)\n"
+			"    Set some TCs' strict link priority mode on a physical port.\n\n"
+
+			"set tc tx min-bandwidth (port_id) (bw1, bw2, ...)\n"
+			"    Set all TCs' min bandwidth(%%) for all PF and VFs.\n\n"
+
 			"vlan set (strip|filter|qinq_strip|extend) (on|off) (port_id)\n"
 			"    Set the VLAN strip or filter or qinq strip or extend\n\n"
 
@@ -382,6 +379,16 @@
 			"    Remove a vlan_id, to the set of VLAN identifiers"
 			"filtered for VF(s) from port_id.\n\n"
 
+			"tunnel_filter add (port_id) (outer_mac) (inner_mac) (ip_addr) "
+			"(inner_vlan) (vxlan|nvgre|ipingre|vxlan-gpe) (imac-ivlan|imac-ivlan-tenid|"
+			"imac-tenid|imac|omac-imac-tenid|oip|iip) (tenant_id) (queue_id)\n"
+			"   add a tunnel filter of a port.\n\n"
+
+			"tunnel_filter rm (port_id) (outer_mac) (inner_mac) (ip_addr) "
+			"(inner_vlan) (vxlan|nvgre|ipingre|vxlan-gpe) (imac-ivlan|imac-ivlan-tenid|"
+			"imac-tenid|imac|omac-imac-tenid|oip|iip) (tenant_id) (queue_id)\n"
+			"   remove a tunnel filter of a port.\n\n"
+
 			"rx_vxlan_port add (udp_port) (port_id)\n"
 			"    Add an UDP port for VXLAN packet filter on a port\n\n"
 
@@ -427,7 +434,6 @@
 			"tso show (portid)"
 			"    Display the status of TCP Segmentation Offload.\n\n"
 
-#ifdef RTE_LIB_GRO
 			"set port (port_id) gro on|off\n"
 			"    Enable or disable Generic Receive Offload in"
 			" csum forwarding engine.\n\n"
@@ -438,9 +444,7 @@
 			"set gro flush (cycles)\n"
 			"    Set the cycle to flush GROed packets from"
 			" reassembly tables.\n\n"
-#endif
 
-#ifdef RTE_LIB_GSO
 			"set port (port_id) gso (on|off)"
 			"    Enable or disable Generic Segmentation Offload in"
 			" csum forwarding engine.\n\n"
@@ -451,7 +455,6 @@
 
 			"show port (port_id) gso\n"
 			"    Show GSO configuration.\n\n"
-#endif
 
 			"set fwd (%s)\n"
 			"    Set packet forwarding mode.\n\n"
@@ -484,6 +487,12 @@
 			"set allmulti (port_id|all) (on|off)\n"
 			"    Set the allmulti mode on port_id, or all.\n\n"
 
+			"set vf promisc (port_id) (vf_id) (on|off)\n"
+			"    Set unicast promiscuous mode for a VF from the PF.\n\n"
+
+			"set vf allmulti (port_id) (vf_id) (on|off)\n"
+			"    Set multicast promiscuous mode for a VF from the PF.\n\n"
+
 			"set flow_ctrl rx (on|off) tx (on|off) (high_water)"
 			" (low_water) (pause_time) (send_xon) mac_ctrl_frame_fwd"
 			" (on|off) autoneg (on|off) (port_id)\n"
@@ -502,14 +511,6 @@
 			"    Set the priority flow control parameter on a"
 			" port.\n\n"
 
-			"set pfc_queue_ctrl (port_id) rx (on|off) (tx_qid)"
-			" (tx_tc) tx (on|off) (rx_qid) (rx_tc) (pause_time)\n"
-			"    Set the queue priority flow control parameter on a"
-			" given Rx and Tx queues of a port.\n\n"
-
-			"set port (port_id) rxq (queue_id) avail_thresh (0..99)>\n "
-			"    set available descriptors threshold for Rx queue\n\n"
-
 			"set stat_qmap (tx|rx) (port_id) (queue_id) (qmapping)\n"
 			"    Set statistics mapping (qmapping 0..15) for RX/TX"
 			" queue on port.\n"
@@ -520,14 +521,13 @@
 			"    Set the option to hide the zero values"
 			" for xstats display.\n"
 
-			"set record-core-cycles on|off\n"
-			"    Set the option to enable measurement of CPU cycles.\n"
-
-			"set record-burst-stats on|off\n"
-			"    Set the option to enable display of RX and TX bursts.\n"
-
 			"set port (port_id) vf (vf_id) rx|tx on|off\n"
-			"    Enable/Disable a VF receive/transmit from a port\n\n"
+			"    Enable/Disable a VF receive/tranmit from a port\n\n"
+
+			"set port (port_id) vf (vf_id) (mac_addr)"
+			" (exact-mac#exact-mac-vlan#hashmac|hashmac-vlan) on|off\n"
+			"   Add/Remove unicast or multicast MAC addr filter"
+			" for a VF.\n\n"
 
 			"set port (port_id) vf (vf_id) rxmode (AUPE|ROPE|BAM"
 			"|MPE) (on|off)\n"
@@ -544,36 +544,167 @@
 			"queue_mask (queue_mask_value)\n"
 			"    Set rate limit for queues in VF of a port\n\n"
 
+			"set port (port_id) mirror-rule (rule_id)"
+			" (pool-mirror-up|pool-mirror-down|vlan-mirror)"
+			" (poolmask|vlanid[,vlanid]*) dst-pool (pool_id) (on|off)\n"
+			"   Set pool or vlan type mirror rule on a port.\n"
+			"   e.g., 'set port 0 mirror-rule 0 vlan-mirror 0,1"
+			" dst-pool 0 on' enable mirror traffic with vlan 0,1"
+			" to pool 0.\n\n"
+
+			"set port (port_id) mirror-rule (rule_id)"
+			" (uplink-mirror|downlink-mirror) dst-pool"
+			" (pool_id) (on|off)\n"
+			"   Set uplink or downlink type mirror rule on a port.\n"
+			"   e.g., 'set port 0 mirror-rule 0 uplink-mirror dst-pool"
+			" 0 on' enable mirror income traffic to pool 0.\n\n"
+
+			"reset port (port_id) mirror-rule (rule_id)\n"
+			"   Reset a mirror rule.\n\n"
+
 			"set flush_rx (on|off)\n"
 			"   Flush (default) or don't flush RX streams before"
 			" forwarding. Mainly used with PCAP drivers.\n\n"
 
+			"set bypass mode (normal|bypass|isolate) (port_id)\n"
+			"   Set the bypass mode for the lowest port on bypass enabled"
+			" NIC.\n\n"
+
+			"set bypass event (timeout|os_on|os_off|power_on|power_off) "
+			"mode (normal|bypass|isolate) (port_id)\n"
+			"   Set the event required to initiate specified bypass mode for"
+			" the lowest port on a bypass enabled NIC where:\n"
+			"       timeout   = enable bypass after watchdog timeout.\n"
+			"       os_on     = enable bypass when OS/board is powered on.\n"
+			"       os_off    = enable bypass when OS/board is powered off.\n"
+			"       power_on  = enable bypass when power supply is turned on.\n"
+			"       power_off = enable bypass when power supply is turned off."
+			"\n\n"
+
+			"set bypass timeout (0|1.5|2|3|4|8|16|32)\n"
+			"   Set the bypass watchdog timeout to 'n' seconds"
+			" where 0 = instant.\n\n"
+
+			"show bypass config (port_id)\n"
+			"   Show the bypass configuration for a bypass enabled NIC"
+			" using the lowest port on the NIC.\n\n"
+
+#ifdef RTE_LIBRTE_PMD_BOND
+			"create bonded device (mode) (socket)\n"
+			"	Create a new bonded device with specific bonding mode and socket.\n\n"
+
+			"add bonding slave (slave_id) (port_id)\n"
+			"	Add a slave device to a bonded device.\n\n"
+
+			"remove bonding slave (slave_id) (port_id)\n"
+			"	Remove a slave device from a bonded device.\n\n"
+
+			"set bonding mode (value) (port_id)\n"
+			"	Set the bonding mode on a bonded device.\n\n"
+
+			"set bonding primary (slave_id) (port_id)\n"
+			"	Set the primary slave for a bonded device.\n\n"
+
+			"show bonding config (port_id)\n"
+			"	Show the bonding config for port_id.\n\n"
+
+			"set bonding mac_addr (port_id) (address)\n"
+			"	Set the MAC address of a bonded device.\n\n"
+
+			"set bonding mode IEEE802.3AD aggregator policy (port_id) (agg_name)"
+			"	Set Aggregation mode for IEEE802.3AD (mode 4)"
+
+			"set bonding xmit_balance_policy (port_id) (l2|l23|l34)\n"
+			"	Set the transmit balance policy for bonded device running in balance mode.\n\n"
+
+			"set bonding mon_period (port_id) (value)\n"
+			"	Set the bonding link status monitoring polling period in ms.\n\n"
+
+			"set bonding lacp dedicated_queues <port_id> (enable|disable)\n"
+			"	Enable/disable dedicated queues for LACP control traffic.\n\n"
+
+#endif
 			"set link-up port (port_id)\n"
 			"	Set link up for a port.\n\n"
 
 			"set link-down port (port_id)\n"
 			"	Set link down for a port.\n\n"
 
+			"E-tag set insertion on port-tag-id (value)"
+			" port (port_id) vf (vf_id)\n"
+			"    Enable E-tag insertion for a VF on a port\n\n"
+
+			"E-tag set insertion off port (port_id) vf (vf_id)\n"
+			"    Disable E-tag insertion for a VF on a port\n\n"
+
+			"E-tag set stripping (on|off) port (port_id)\n"
+			"    Enable/disable E-tag stripping on a port\n\n"
+
+			"E-tag set forwarding (on|off) port (port_id)\n"
+			"    Enable/disable E-tag based forwarding"
+			" on a port\n\n"
+
+			"E-tag set filter add e-tag-id (value) dst-pool"
+			" (pool_id) port (port_id)\n"
+			"    Add an E-tag forwarding filter on a port\n\n"
+
+			"E-tag set filter del e-tag-id (value) port (port_id)\n"
+			"    Delete an E-tag forwarding filter on a port\n\n"
+
+			"ddp add (port_id) (profile_path[,backup_profile_path])\n"
+			"    Load a profile package on a port\n\n"
+
+			"ddp del (port_id) (backup_profile_path)\n"
+			"    Delete a profile package from a port\n\n"
+
+			"ptype mapping get (port_id) (valid_only)\n"
+			"    Get ptype mapping on a port\n\n"
+
+			"ptype mapping replace (port_id) (target) (mask) (pky_type)\n"
+			"    Replace target with the pkt_type in ptype mapping\n\n"
+
+			"ptype mapping reset (port_id)\n"
+			"    Reset ptype mapping on a port\n\n"
+
+			"ptype mapping update (port_id) (hw_ptype) (sw_ptype)\n"
+			"    Update a ptype mapping item on a port\n\n"
+
 			"set port (port_id) ptype_mask (ptype_mask)\n"
 			"    set packet types classification for a specific port\n\n"
 
+			"set port (port_id) queue-region region_id (value) "
+			"queue_start_index (value) queue_num (value)\n"
+			"    Set a queue region on a port\n\n"
+
+			"set port (port_id) queue-region region_id (value) "
+			"flowtype (value)\n"
+			"    Set a flowtype region index on a port\n\n"
+
+			"set port (port_id) queue-region UP (value) region_id (value)\n"
+			"    Set the mapping of User Priority to "
+			"queue region on a port\n\n"
+
+			"set port (port_id) queue-region flush (on|off)\n"
+			"    flush all queue region related configuration\n\n"
+
 			"show port meter cap (port_id)\n"
 			"    Show port meter capability information\n\n"
 
-			"add port meter profile srtcm_rfc2697 (port_id) (profile_id) (cir) (cbs) (ebs) (packet_mode)\n"
+			"add port meter profile srtcm_rfc2697 (port_id) (profile_id) (cir) (cbs) (ebs)\n"
 			"    meter profile add - srtcm rfc 2697\n\n"
 
-			"add port meter profile trtcm_rfc2698 (port_id) (profile_id) (cir) (pir) (cbs) (pbs) (packet_mode)\n"
+			"add port meter profile trtcm_rfc2698 (port_id) (profile_id) (cir) (pir) (cbs) (pbs)\n"
 			"    meter profile add - trtcm rfc 2698\n\n"
 
-			"add port meter profile trtcm_rfc4115 (port_id) (profile_id) (cir) (eir) (cbs) (ebs) (packet_mode)\n"
+			"add port meter profile trtcm_rfc4115 (port_id) (profile_id) (cir) (eir) (cbs) (ebs)\n"
 			"    meter profile add - trtcm rfc 4115\n\n"
 
 			"del port meter profile (port_id) (profile_id)\n"
 			"    meter profile delete\n\n"
 
-			"create port meter (port_id) (mtr_id) (profile_id) (policy_id) (meter_enable)\n"
-			"(stats_mask) (shared) (use_pre_meter_color) [(dscp_tbl_entry0) (dscp_tbl_entry1)...\n"
+			"create port meter (port_id) (mtr_id) (profile_id) (meter_enable)\n"
+			"(g_action) (y_action) (r_action) (stats_mask) (shared)\n"
+			"(use_pre_meter_color) [(dscp_tbl_entry0) (dscp_tbl_entry1)...\n"
 			"(dscp_tbl_entry63)]\n"
 			"    meter create\n\n"
 
@@ -586,13 +717,6 @@
 			"del port meter (port_id) (mtr_id)\n"
 			"    meter delete\n\n"
 
-			"add port meter policy (port_id) (policy_id) g_actions (actions)\n"
-			"y_actions (actions) r_actions (actions)\n"
-			"    meter policy add\n\n"
-
-			"del port meter policy (port_id) (policy_id)\n"
-			"    meter policy delete\n\n"
-
 			"set port meter profile (port_id) (mtr_id) (profile_id)\n"
 			"    meter update meter profile\n\n"
 
@@ -607,8 +731,8 @@
 			"set port meter stats mask (port_id) (mtr_id) (stats_mask)\n"
 			"    meter update stats\n\n"
 
-			"set port (port_id) fec_mode auto|off|rs|baser\n"
-			"    set fec mode for a specific port\n\n"
+			"show port (port_id) queue-region\n"
+			"    show all queue region related configuration info\n\n"
 
 			, list_pkt_forwarding_modes()
 		);
@@ -641,7 +765,7 @@
 			"    Detach physical or virtual dev by port_id\n\n"
 
 			"port config (port_id|all)"
-			" speed (10|100|1000|10000|25000|40000|50000|100000|200000|auto)"
+			" speed (10|100|1000|10000|25000|40000|50000|100000|auto)"
 			" duplex (half|full|auto)\n"
 			"    Set speed and duplex for all ports or port_id\n\n"
 
@@ -661,14 +785,8 @@
 			"    Enable or disable packet drop on all RX queues of all ports when no "
 			"receive buffers available.\n\n"
 
-			"port config all rss (all|default|level-default|level-outer|level-inner|"
-			"ip|tcp|udp|sctp|tunnel|vlan|none|"
-			"ipv4|ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|ipv4-other|"
-			"ipv6|ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|ipv6-other|ipv6-ex|ipv6-tcp-ex|ipv6-udp-ex|"
-			"l2-payload|port|vxlan|geneve|nvgre|gtpu|eth|s-vlan|c-vlan|"
-			"esp|ah|l2tpv3|pfcp|pppoe|ecpri|mpls|ipv4-chksum|l4-chksum|"
-			"l2tpv2|l3-pre96|l3-pre64|l3-pre56|l3-pre48|l3-pre40|l3-pre32|"
-			"l2-dst-only|l2-src-only|l4-dst-only|l4-src-only|l3-dst-only|l3-src-only|<rsstype_id>)\n"
+			"port config all rss (all|default|ip|tcp|udp|sctp|"
+			"ether|port|vxlan|geneve|nvgre|vxlan-gpe|none|<flowtype_id>)\n"
 			"    Set the RSS mode.\n\n"
 
 			"port config port-id rss reta (hash,queue)[,(hash,queue)]\n"
@@ -708,22 +826,46 @@
 			"port (port_id) (rxq|txq) (queue_id) setup\n"
 			"    Setup a rx/tx queue of port X.\n\n"
 
-			"port config (port_id) udp_tunnel_port add|rm vxlan|geneve|ecpri (udp_port)\n\n"
+			"port config (port_id|all) l2-tunnel E-tag ether-type"
+			" (value)\n"
+			"    Set the value of E-tag ether-type.\n\n"
+
+			"port config (port_id|all) l2-tunnel E-tag"
+			" (enable|disable)\n"
+			"    Enable/disable the E-tag support.\n\n"
+
+			"port config (port_id) pctype mapping reset\n"
+			"    Reset flow type to pctype mapping on a port\n\n"
+
+			"port config (port_id) pctype mapping update"
+			" (pctype_id_0[,pctype_id_1]*) (flow_type_id)\n"
+			"    Update a flow type to pctype mapping item on a port\n\n"
+
+			"port config (port_id) pctype (pctype_id) hash_inset|"
+			"fdir_inset|fdir_flx_inset get|set|clear field\n"
+			" (field_idx)\n"
+			"    Configure RSS|FDIR|FDIR_FLX input set for some pctype\n\n"
+
+			"port config (port_id) pctype (pctype_id) hash_inset|"
+			"fdir_inset|fdir_flx_inset clear all"
+			"    Clear RSS|FDIR|FDIR_FLX input set completely for some pctype\n\n"
+
+			"port config (port_id) udp_tunnel_port add|rm vxlan|geneve (udp_port)\n\n"
 			"    Add/remove UDP tunnel port for tunneling offload\n\n"
 
 			"port config <port_id> rx_offload vlan_strip|"
 			"ipv4_cksum|udp_cksum|tcp_cksum|tcp_lro|qinq_strip|"
-			"outer_ipv4_cksum|macsec_strip|"
-			"vlan_filter|vlan_extend|scatter|"
-			"buffer_split|timestamp|security|keep_crc on|off\n"
+			"outer_ipv4_cksum|macsec_strip|header_split|"
+			"vlan_filter|vlan_extend|jumbo_frame|"
+			"scatter|timestamp|security|keep_crc on|off\n"
 			"     Enable or disable a per port Rx offloading"
 			" on all Rx queues of a port\n\n"
 
 			"port (port_id) rxq (queue_id) rx_offload vlan_strip|"
 			"ipv4_cksum|udp_cksum|tcp_cksum|tcp_lro|qinq_strip|"
-			"outer_ipv4_cksum|macsec_strip|"
-			"vlan_filter|vlan_extend|scatter|"
-			"buffer_split|timestamp|security|keep_crc on|off\n"
+			"outer_ipv4_cksum|macsec_strip|header_split|"
+			"vlan_filter|vlan_extend|jumbo_frame|"
+			"scatter|timestamp|security|keep_crc on|off\n"
 			"    Enable or disable a per queue Rx offloading"
 			" only on a specific Rx queue\n\n"
 
@@ -756,17 +898,37 @@
 			"port config (port_id) tx_metadata (value)\n"
 			"    Set Tx metadata value per port. Testpmd will add this value"
 			" to any Tx packet sent from this port\n\n"
+		);
+	}
 
-			"port config (port_id) dynf (name) set|clear\n"
-			"    Register a dynf and Set/clear this flag on Tx. "
-			"Testpmd will set this value to any Tx packet "
-			"sent from this port\n\n"
+	if (show_all || !strcmp(res->section, "registers")) {
 
-			"port cleanup (port_id) txq (queue_id) (free_cnt)\n"
-			"    Cleanup txq mbufs for a specific Tx queue\n\n"
+		cmdline_printf(
+			cl,
+			"\n"
+			"Registers:\n"
+			"----------\n\n"
+
+			"read reg (port_id) (address)\n"
+			"    Display value of a port register.\n\n"
+
+			"read regfield (port_id) (address) (bit_x) (bit_y)\n"
+			"    Display a port register bit field.\n\n"
+
+			"read regbit (port_id) (address) (bit_x)\n"
+			"    Display a single port register bit.\n\n"
+
+			"write reg (port_id) (address) (value)\n"
+			"    Set value of a port register.\n\n"
+
+			"write regfield (port_id) (address) (bit_x) (bit_y)"
+			" (value)\n"
+			"    Set bit field of a port register.\n\n"
+
+			"write regbit (port_id) (address) (bit_x) (value)\n"
+			"    Set single bit value of a port register.\n\n"
 		);
 	}
-
 	if (show_all || !strcmp(res->section, "filters")) {
 
 		cmdline_printf(
@@ -775,6 +937,154 @@
 			"filters:\n"
 			"--------\n\n"
 
+			"ethertype_filter (port_id) (add|del)"
+			" (mac_addr|mac_ignr) (mac_address) ethertype"
+			" (ether_type) (drop|fwd) queue (queue_id)\n"
+			"    Add/Del an ethertype filter.\n\n"
+
+			"2tuple_filter (port_id) (add|del)"
+			" dst_port (dst_port_value) protocol (protocol_value)"
+			" mask (mask_value) tcp_flags (tcp_flags_value)"
+			" priority (prio_value) queue (queue_id)\n"
+			"    Add/Del a 2tuple filter.\n\n"
+
+			"5tuple_filter (port_id) (add|del)"
+			" dst_ip (dst_address) src_ip (src_address)"
+			" dst_port (dst_port_value) src_port (src_port_value)"
+			" protocol (protocol_value)"
+			" mask (mask_value) tcp_flags (tcp_flags_value)"
+			" priority (prio_value) queue (queue_id)\n"
+			"    Add/Del a 5tuple filter.\n\n"
+
+			"syn_filter (port_id) (add|del) priority (high|low) queue (queue_id)"
+			"    Add/Del syn filter.\n\n"
+
+			"flex_filter (port_id) (add|del) len (len_value)"
+			" bytes (bytes_value) mask (mask_value)"
+			" priority (prio_value) queue (queue_id)\n"
+			"    Add/Del a flex filter.\n\n"
+
+			"flow_director_filter (port_id) mode IP (add|del|update)"
+			" flow (ipv4-other|ipv4-frag|ipv6-other|ipv6-frag)"
+			" src (src_ip_address) dst (dst_ip_address)"
+			" tos (tos_value) proto (proto_value) ttl (ttl_value)"
+			" vlan (vlan_value) flexbytes (flexbytes_value)"
+			" (drop|fwd) pf|vf(vf_id) queue (queue_id)"
+			" fd_id (fd_id_value)\n"
+			"    Add/Del an IP type flow director filter.\n\n"
+
+			"flow_director_filter (port_id) mode IP (add|del|update)"
+			" flow (ipv4-tcp|ipv4-udp|ipv6-tcp|ipv6-udp)"
+			" src (src_ip_address) (src_port)"
+			" dst (dst_ip_address) (dst_port)"
+			" tos (tos_value) ttl (ttl_value)"
+			" vlan (vlan_value) flexbytes (flexbytes_value)"
+			" (drop|fwd) pf|vf(vf_id) queue (queue_id)"
+			" fd_id (fd_id_value)\n"
+			"    Add/Del an UDP/TCP type flow director filter.\n\n"
+
+			"flow_director_filter (port_id) mode IP (add|del|update)"
+			" flow (ipv4-sctp|ipv6-sctp)"
+			" src (src_ip_address) (src_port)"
+			" dst (dst_ip_address) (dst_port)"
+			" tag (verification_tag) "
+			" tos (tos_value) ttl (ttl_value)"
+			" vlan (vlan_value)"
+			" flexbytes (flexbytes_value) (drop|fwd)"
+			" pf|vf(vf_id) queue (queue_id) fd_id (fd_id_value)\n"
+			"    Add/Del a SCTP type flow director filter.\n\n"
+
+			"flow_director_filter (port_id) mode IP (add|del|update)"
+			" flow l2_payload ether (ethertype)"
+			" flexbytes (flexbytes_value) (drop|fwd)"
+			" pf|vf(vf_id) queue (queue_id) fd_id (fd_id_value)\n"
+			"    Add/Del a l2 payload type flow director filter.\n\n"
+
+			"flow_director_filter (port_id) mode MAC-VLAN (add|del|update)"
+			" mac (mac_address) vlan (vlan_value)"
+			" flexbytes (flexbytes_value) (drop|fwd)"
+			" queue (queue_id) fd_id (fd_id_value)\n"
+			"    Add/Del a MAC-VLAN flow director filter.\n\n"
+
+			"flow_director_filter (port_id) mode Tunnel (add|del|update)"
+			" mac (mac_address) vlan (vlan_value)"
+			" tunnel (NVGRE|VxLAN) tunnel-id (tunnel_id_value)"
+			" flexbytes (flexbytes_value) (drop|fwd)"
+			" queue (queue_id) fd_id (fd_id_value)\n"
+			"    Add/Del a Tunnel flow director filter.\n\n"
+
+			"flow_director_filter (port_id) mode raw (add|del|update)"
+			" flow (flow_id) (drop|fwd) queue (queue_id)"
+			" fd_id (fd_id_value) packet (packet file name)\n"
+			"    Add/Del a raw type flow director filter.\n\n"
+
+			"flush_flow_director (port_id)\n"
+			"    Flush all flow director entries of a device.\n\n"
+
+			"flow_director_mask (port_id) mode IP vlan (vlan_value)"
+			" src_mask (ipv4_src) (ipv6_src) (src_port)"
+			" dst_mask (ipv4_dst) (ipv6_dst) (dst_port)\n"
+			"    Set flow director IP mask.\n\n"
+
+			"flow_director_mask (port_id) mode MAC-VLAN"
+			" vlan (vlan_value)\n"
+			"    Set flow director MAC-VLAN mask.\n\n"
+
+			"flow_director_mask (port_id) mode Tunnel"
+			" vlan (vlan_value) mac (mac_value)"
+			" tunnel-type (tunnel_type_value)"
+			" tunnel-id (tunnel_id_value)\n"
+			"    Set flow director Tunnel mask.\n\n"
+
+			"flow_director_flex_mask (port_id)"
+			" flow (none|ipv4-other|ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|"
+			"ipv6-other|ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|l2_payload|all)"
+			" (mask)\n"
+			"    Configure mask of flex payload.\n\n"
+
+			"flow_director_flex_payload (port_id)"
+			" (raw|l2|l3|l4) (config)\n"
+			"    Configure flex payload selection.\n\n"
+
+			"get_sym_hash_ena_per_port (port_id)\n"
+			"    get symmetric hash enable configuration per port.\n\n"
+
+			"set_sym_hash_ena_per_port (port_id) (enable|disable)\n"
+			"    set symmetric hash enable configuration per port"
+			" to enable or disable.\n\n"
+
+			"get_hash_global_config (port_id)\n"
+			"    Get the global configurations of hash filters.\n\n"
+
+			"set_hash_global_config (port_id) (toeplitz|simple_xor|symmetric_toeplitz|default)"
+			" (ipv4|ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|ipv4-other|ipv6|"
+			"ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|ipv6-other|l2_payload)"
+			" (enable|disable)\n"
+			"    Set the global configurations of hash filters.\n\n"
+
+			"set_hash_input_set (port_id) (ipv4|ipv4-frag|"
+			"ipv4-tcp|ipv4-udp|ipv4-sctp|ipv4-other|ipv6|"
+			"ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|ipv6-other|"
+			"l2_payload|<flowtype_id>) (ovlan|ivlan|src-ipv4|dst-ipv4|"
+			"src-ipv6|dst-ipv6|ipv4-tos|ipv4-proto|ipv6-tc|"
+			"ipv6-next-header|udp-src-port|udp-dst-port|"
+			"tcp-src-port|tcp-dst-port|sctp-src-port|"
+			"sctp-dst-port|sctp-veri-tag|udp-key|gre-key|fld-1st|"
+			"fld-2nd|fld-3rd|fld-4th|fld-5th|fld-6th|fld-7th|"
+			"fld-8th|none) (select|add)\n"
+			"    Set the input set for hash.\n\n"
+
+			"set_fdir_input_set (port_id) "
+			"(ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|ipv4-other|"
+			"ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|ipv6-other|"
+			"l2_payload) (ivlan|ethertype|src-ipv4|dst-ipv4|src-ipv6|"
+			"dst-ipv6|ipv4-tos|ipv4-proto|ipv4-ttl|ipv6-tc|"
+			"ipv6-next-header|ipv6-hop-limits|udp-src-port|"
+			"udp-dst-port|tcp-src-port|tcp-dst-port|"
+			"sctp-src-port|sctp-dst-port|sctp-veri-tag|none)"
+			" (select|add)\n"
+			"    Set the input set for FDir.\n\n"
+
 			"flow validate {port_id}"
 			" [group {group_id}] [priority {level}]"
 			" [ingress] [egress]"
@@ -806,28 +1116,6 @@
 			"    Restrict ingress traffic to the defined"
 			" flow rules\n\n"
 
-			"flow aged {port_id} [destroy]\n"
-			"    List and destroy aged flows"
-			" flow rules\n\n"
-
-			"flow indirect_action {port_id} create"
-			" [action_id {indirect_action_id}]"
-			" [ingress] [egress]"
-			" action {action} / end\n"
-			"    Create indirect action.\n\n"
-
-			"flow indirect_action {port_id} update"
-			" {indirect_action_id} action {action} / end\n"
-			"    Update indirect action.\n\n"
-
-			"flow indirect_action {port_id} destroy"
-			" action_id {indirect_action_id} [...]\n"
-			"    Destroy specific indirect actions.\n\n"
-
-			"flow indirect_action {port_id} query"
-			" {indirect_action_id}\n"
-			"    Query an existing indirect action.\n\n"
-
 			"set vxlan ip-version (ipv4|ipv6) vni (vni) udp-src"
 			" (udp-src) udp-dst (udp-dst) ip-src (ip-src) ip-dst"
 			" (ip-dst) eth-src (eth-src) eth-dst (eth-dst)\n"
@@ -885,9 +1173,14 @@
 			"show port tm node stats (port_id) (node_id) (clear)\n"
 			"       Display the port TM node stats.\n\n"
 
+#if defined RTE_LIBRTE_PMD_SOFTNIC && defined RTE_LIBRTE_SCHED
+			"set port tm hierarchy default (port_id)\n"
+			"       Set default traffic Management hierarchy on a port\n\n"
+#endif
+
 			"add port tm node shaper profile (port_id) (shaper_profile_id)"
 			" (cmit_tb_rate) (cmit_tb_size) (peak_tb_rate) (peak_tb_size)"
-			" (packet_length_adjust) (packet_mode)\n"
+			" (packet_length_adjust)\n"
 			"       Add port tm node private shaper profile.\n\n"
 
 			"del port tm node shaper profile (port_id) (shaper_profile_id)\n"
@@ -919,12 +1212,6 @@
 			" [(shared_shaper_id_0) (shared_shaper_id_1)...]\n"
 			"       Add port tm nonleaf node.\n\n"
 
-			"add port tm nonleaf node pktmode (port_id) (node_id) (parent_node_id)"
-			" (priority) (weight) (level_id) (shaper_profile_id)"
-			" (n_sp_priorities) (stats_mask) (n_shared_shapers)"
-			" [(shared_shaper_id_0) (shared_shaper_id_1)...]\n"
-			"       Add port tm nonleaf node with pkt mode enabled.\n\n"
-
 			"add port tm leaf node (port_id) (node_id) (parent_node_id)"
 			" (priority) (weight) (level_id) (shaper_profile_id)"
 			" (cman_mode) (wred_profile_id) (stats_mask) (n_shared_shapers)"
@@ -976,36 +1263,21 @@
 		);
 	}
 
-	if (show_all || !strcmp(res->section, "drivers")) {
-		struct testpmd_driver_commands *c;
-		unsigned int i;
-
-		cmdline_printf(
-			cl,
-			"\n"
-			"Driver specific:\n"
-			"----------------\n"
-		);
-		TAILQ_FOREACH(c, &driver_commands_head, next) {
-			for (i = 0; c->commands[i].ctx != NULL; i++)
-				cmdline_printf(cl, "%s\n", c->commands[i].help);
-		}
-	}
 }
 
-static cmdline_parse_token_string_t cmd_help_long_help =
+cmdline_parse_token_string_t cmd_help_long_help =
 	TOKEN_STRING_INITIALIZER(struct cmd_help_long_result, help, "help");
 
-static cmdline_parse_token_string_t cmd_help_long_section =
+cmdline_parse_token_string_t cmd_help_long_section =
 	TOKEN_STRING_INITIALIZER(struct cmd_help_long_result, section,
-		"all#control#display#config#ports#"
-		"filters#traffic_management#devices#drivers");
+			"all#control#display#config#"
+			"ports#registers#filters#traffic_management#devices");
 
-static cmdline_parse_inst_t cmd_help_long = {
+cmdline_parse_inst_t cmd_help_long = {
 	.f = cmd_help_long_parsed,
 	.data = NULL,
-	.help_str = "help all|control|display|config|ports|"
-		"filters|traffic_management|devices|drivers: "
+	.help_str = "help all|control|display|config|ports|register|"
+		"filters|traffic_management|devices: "
 		"Show help",
 	.tokens = {
 		(void *)&cmd_help_long_help,
@@ -1023,8 +1295,8 @@
 };
 
 static void cmd_operate_port_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_operate_port_result *res = parsed_result;
 
@@ -1037,22 +1309,22 @@
 	else if (!strcmp(res->name, "reset"))
 		reset_port(RTE_PORT_ALL);
 	else
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 }
 
-static cmdline_parse_token_string_t cmd_operate_port_all_cmd =
+cmdline_parse_token_string_t cmd_operate_port_all_cmd =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_port_result, keyword,
 								"port");
-static cmdline_parse_token_string_t cmd_operate_port_all_port =
+cmdline_parse_token_string_t cmd_operate_port_all_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_port_result, name,
 						"start#stop#close#reset");
-static cmdline_parse_token_string_t cmd_operate_port_all_all =
+cmdline_parse_token_string_t cmd_operate_port_all_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_port_result, value, "all");
 
-static cmdline_parse_inst_t cmd_operate_port = {
+cmdline_parse_inst_t cmd_operate_port = {
 	.f = cmd_operate_port_parsed,
 	.data = NULL,
-	.help_str = "port start|stop|close|reset all: Start/Stop/Close/Reset all ports",
+	.help_str = "port start|stop|close all: Start/Stop/Close/Reset all ports",
 	.tokens = {
 		(void *)&cmd_operate_port_all_cmd,
 		(void *)&cmd_operate_port_all_port,
@@ -1069,8 +1341,8 @@
 };
 
 static void cmd_operate_specific_port_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_operate_specific_port_result *res = parsed_result;
 
@@ -1083,23 +1355,23 @@
 	else if (!strcmp(res->name, "reset"))
 		reset_port(res->value);
 	else
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 }
 
-static cmdline_parse_token_string_t cmd_operate_specific_port_cmd =
+cmdline_parse_token_string_t cmd_operate_specific_port_cmd =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_specific_port_result,
 							keyword, "port");
-static cmdline_parse_token_string_t cmd_operate_specific_port_port =
+cmdline_parse_token_string_t cmd_operate_specific_port_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_specific_port_result,
 						name, "start#stop#close#reset");
-static cmdline_parse_token_num_t cmd_operate_specific_port_id =
+cmdline_parse_token_num_t cmd_operate_specific_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_operate_specific_port_result,
-							value, RTE_UINT8);
+							value, UINT8);
 
-static cmdline_parse_inst_t cmd_operate_specific_port = {
+cmdline_parse_inst_t cmd_operate_specific_port = {
 	.f = cmd_operate_specific_port_parsed,
 	.data = NULL,
-	.help_str = "port start|stop|close|reset <port_id>: Start/Stop/Close/Reset port_id",
+	.help_str = "port start|stop|close <port_id>: Start/Stop/Close/Reset port_id",
 	.tokens = {
 		(void *)&cmd_operate_specific_port_cmd,
 		(void *)&cmd_operate_specific_port_port,
@@ -1118,8 +1390,8 @@
 };
 
 static void cmd_set_port_setup_on_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_set_port_setup_on_result *res = parsed_result;
 
@@ -1128,26 +1400,26 @@
 	else if (strcmp(res->mode, "iterator") == 0)
 		setup_on_probe_event = false;
 	else
-		fprintf(stderr, "Unknown mode\n");
+		printf("Unknown mode\n");
 }
 
-static cmdline_parse_token_string_t cmd_set_port_setup_on_set =
+cmdline_parse_token_string_t cmd_set_port_setup_on_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_port_setup_on_result,
 			set, "set");
-static cmdline_parse_token_string_t cmd_set_port_setup_on_port =
+cmdline_parse_token_string_t cmd_set_port_setup_on_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_port_setup_on_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_set_port_setup_on_setup =
+cmdline_parse_token_string_t cmd_set_port_setup_on_setup =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_port_setup_on_result,
 			setup, "setup");
-static cmdline_parse_token_string_t cmd_set_port_setup_on_on =
+cmdline_parse_token_string_t cmd_set_port_setup_on_on =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_port_setup_on_result,
 			on, "on");
-static cmdline_parse_token_string_t cmd_set_port_setup_on_mode =
+cmdline_parse_token_string_t cmd_set_port_setup_on_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_port_setup_on_result,
 			mode, "iterator#event");
 
-static cmdline_parse_inst_t cmd_set_port_setup_on = {
+cmdline_parse_inst_t cmd_set_port_setup_on = {
 	.f = cmd_set_port_setup_on_parsed,
 	.data = NULL,
 	.help_str = "set port setup on iterator|event",
@@ -1165,32 +1437,32 @@
 struct cmd_operate_attach_port_result {
 	cmdline_fixed_string_t port;
 	cmdline_fixed_string_t keyword;
-	cmdline_multi_string_t identifier;
+	cmdline_fixed_string_t identifier;
 };
 
 static void cmd_operate_attach_port_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_operate_attach_port_result *res = parsed_result;
 
 	if (!strcmp(res->keyword, "attach"))
 		attach_port(res->identifier);
 	else
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 }
 
-static cmdline_parse_token_string_t cmd_operate_attach_port_port =
+cmdline_parse_token_string_t cmd_operate_attach_port_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_attach_port_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_operate_attach_port_keyword =
+cmdline_parse_token_string_t cmd_operate_attach_port_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_attach_port_result,
 			keyword, "attach");
-static cmdline_parse_token_string_t cmd_operate_attach_port_identifier =
+cmdline_parse_token_string_t cmd_operate_attach_port_identifier =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_attach_port_result,
-			identifier, TOKEN_STRING_MULTI);
+			identifier, NULL);
 
-static cmdline_parse_inst_t cmd_operate_attach_port = {
+cmdline_parse_inst_t cmd_operate_attach_port = {
 	.f = cmd_operate_attach_port_parsed,
 	.data = NULL,
 	.help_str = "port attach <identifier>: "
@@ -1211,30 +1483,28 @@
 };
 
 static void cmd_operate_detach_port_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_operate_detach_port_result *res = parsed_result;
 
-	if (!strcmp(res->keyword, "detach")) {
-		RTE_ETH_VALID_PORTID_OR_RET(res->port_id);
+	if (!strcmp(res->keyword, "detach"))
 		detach_port_device(res->port_id);
-	} else {
-		fprintf(stderr, "Unknown parameter\n");
-	}
+	else
+		printf("Unknown parameter\n");
 }
 
-static cmdline_parse_token_string_t cmd_operate_detach_port_port =
+cmdline_parse_token_string_t cmd_operate_detach_port_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_detach_port_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_operate_detach_port_keyword =
+cmdline_parse_token_string_t cmd_operate_detach_port_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_detach_port_result,
 			keyword, "detach");
-static cmdline_parse_token_num_t cmd_operate_detach_port_port_id =
+cmdline_parse_token_num_t cmd_operate_detach_port_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_operate_detach_port_result,
-			port_id, RTE_UINT16);
+			port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_operate_detach_port = {
+cmdline_parse_inst_t cmd_operate_detach_port = {
 	.f = cmd_operate_detach_port_parsed,
 	.data = NULL,
 	.help_str = "port detach <port_id>",
@@ -1254,28 +1524,28 @@
 };
 
 static void cmd_operate_detach_device_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_operate_detach_device_result *res = parsed_result;
 
 	if (!strcmp(res->keyword, "detach"))
-		detach_devargs(res->identifier);
+		detach_device(res->identifier);
 	else
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 }
 
-static cmdline_parse_token_string_t cmd_operate_detach_device_device =
+cmdline_parse_token_string_t cmd_operate_detach_device_device =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_detach_device_result,
 			device, "device");
-static cmdline_parse_token_string_t cmd_operate_detach_device_keyword =
+cmdline_parse_token_string_t cmd_operate_detach_device_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_detach_device_result,
 			keyword, "detach");
-static cmdline_parse_token_string_t cmd_operate_detach_device_identifier =
+cmdline_parse_token_string_t cmd_operate_detach_device_identifier =
 	TOKEN_STRING_INITIALIZER(struct cmd_operate_detach_device_result,
 			identifier, NULL);
 
-static cmdline_parse_inst_t cmd_operate_detach_device = {
+cmdline_parse_inst_t cmd_operate_detach_device = {
 	.f = cmd_operate_detach_device_parsed,
 	.data = NULL,
 	.help_str = "device detach <identifier>:"
@@ -1305,66 +1575,61 @@
 	int duplex;
 
 	if (!strcmp(duplexstr, "half")) {
-		duplex = RTE_ETH_LINK_HALF_DUPLEX;
+		duplex = ETH_LINK_HALF_DUPLEX;
 	} else if (!strcmp(duplexstr, "full")) {
-		duplex = RTE_ETH_LINK_FULL_DUPLEX;
+		duplex = ETH_LINK_FULL_DUPLEX;
 	} else if (!strcmp(duplexstr, "auto")) {
-		duplex = RTE_ETH_LINK_FULL_DUPLEX;
+		duplex = ETH_LINK_FULL_DUPLEX;
 	} else {
-		fprintf(stderr, "Unknown duplex parameter\n");
+		printf("Unknown duplex parameter\n");
 		return -1;
 	}
 
 	if (!strcmp(speedstr, "10")) {
-		*speed = (duplex == RTE_ETH_LINK_HALF_DUPLEX) ?
-				RTE_ETH_LINK_SPEED_10M_HD : RTE_ETH_LINK_SPEED_10M;
+		*speed = (duplex == ETH_LINK_HALF_DUPLEX) ?
+				ETH_LINK_SPEED_10M_HD : ETH_LINK_SPEED_10M;
 	} else if (!strcmp(speedstr, "100")) {
-		*speed = (duplex == RTE_ETH_LINK_HALF_DUPLEX) ?
-				RTE_ETH_LINK_SPEED_100M_HD : RTE_ETH_LINK_SPEED_100M;
+		*speed = (duplex == ETH_LINK_HALF_DUPLEX) ?
+				ETH_LINK_SPEED_100M_HD : ETH_LINK_SPEED_100M;
 	} else {
-		if (duplex != RTE_ETH_LINK_FULL_DUPLEX) {
-			fprintf(stderr, "Invalid speed/duplex parameters\n");
+		if (duplex != ETH_LINK_FULL_DUPLEX) {
+			printf("Invalid speed/duplex parameters\n");
 			return -1;
 		}
 		if (!strcmp(speedstr, "1000")) {
-			*speed = RTE_ETH_LINK_SPEED_1G;
+			*speed = ETH_LINK_SPEED_1G;
 		} else if (!strcmp(speedstr, "10000")) {
-			*speed = RTE_ETH_LINK_SPEED_10G;
+			*speed = ETH_LINK_SPEED_10G;
 		} else if (!strcmp(speedstr, "25000")) {
-			*speed = RTE_ETH_LINK_SPEED_25G;
+			*speed = ETH_LINK_SPEED_25G;
 		} else if (!strcmp(speedstr, "40000")) {
-			*speed = RTE_ETH_LINK_SPEED_40G;
+			*speed = ETH_LINK_SPEED_40G;
 		} else if (!strcmp(speedstr, "50000")) {
-			*speed = RTE_ETH_LINK_SPEED_50G;
+			*speed = ETH_LINK_SPEED_50G;
 		} else if (!strcmp(speedstr, "100000")) {
-			*speed = RTE_ETH_LINK_SPEED_100G;
-		} else if (!strcmp(speedstr, "200000")) {
-			*speed = RTE_ETH_LINK_SPEED_200G;
+			*speed = ETH_LINK_SPEED_100G;
 		} else if (!strcmp(speedstr, "auto")) {
-			*speed = RTE_ETH_LINK_SPEED_AUTONEG;
+			*speed = ETH_LINK_SPEED_AUTONEG;
 		} else {
-			fprintf(stderr, "Unknown speed parameter\n");
+			printf("Unknown speed parameter\n");
 			return -1;
 		}
 	}
 
-	if (*speed != RTE_ETH_LINK_SPEED_AUTONEG)
-		*speed |= RTE_ETH_LINK_SPEED_FIXED;
-
 	return 0;
 }
 
 static void
 cmd_config_speed_all_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_config_speed_all *res = parsed_result;
 	uint32_t link_speed;
 	portid_t pid;
 
 	if (!all_ports_stopped()) {
-		fprintf(stderr, "Please stop all ports first\n");
+		printf("Please stop all ports first\n");
 		return;
 	}
 
@@ -1379,29 +1644,29 @@
 	cmd_reconfig_device_queue(RTE_PORT_ALL, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_speed_all_port =
+cmdline_parse_token_string_t cmd_config_speed_all_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_all, port, "port");
-static cmdline_parse_token_string_t cmd_config_speed_all_keyword =
+cmdline_parse_token_string_t cmd_config_speed_all_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_all, keyword,
 							"config");
-static cmdline_parse_token_string_t cmd_config_speed_all_all =
+cmdline_parse_token_string_t cmd_config_speed_all_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_all, all, "all");
-static cmdline_parse_token_string_t cmd_config_speed_all_item1 =
+cmdline_parse_token_string_t cmd_config_speed_all_item1 =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_all, item1, "speed");
-static cmdline_parse_token_string_t cmd_config_speed_all_value1 =
+cmdline_parse_token_string_t cmd_config_speed_all_value1 =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_all, value1,
-				"10#100#1000#10000#25000#40000#50000#100000#200000#auto");
-static cmdline_parse_token_string_t cmd_config_speed_all_item2 =
+				"10#100#1000#10000#25000#40000#50000#100000#auto");
+cmdline_parse_token_string_t cmd_config_speed_all_item2 =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_all, item2, "duplex");
-static cmdline_parse_token_string_t cmd_config_speed_all_value2 =
+cmdline_parse_token_string_t cmd_config_speed_all_value2 =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_all, value2,
 						"half#full#auto");
 
-static cmdline_parse_inst_t cmd_config_speed_all = {
+cmdline_parse_inst_t cmd_config_speed_all = {
 	.f = cmd_config_speed_all_parsed,
 	.data = NULL,
 	.help_str = "port config all speed "
-		"10|100|1000|10000|25000|40000|50000|100000|200000|auto duplex "
+		"10|100|1000|10000|25000|40000|50000|100000|auto duplex "
 							"half|full|auto",
 	.tokens = {
 		(void *)&cmd_config_speed_all_port,
@@ -1428,19 +1693,19 @@
 
 static void
 cmd_config_speed_specific_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_speed_specific *res = parsed_result;
 	uint32_t link_speed;
 
-	if (port_id_is_invalid(res->id, ENABLED_WARN))
+	if (!all_ports_stopped()) {
+		printf("Please stop all ports first\n");
 		return;
+	}
 
-	if (!port_is_stopped(res->id)) {
-		fprintf(stderr, "Please stop port %d first\n", res->id);
+	if (port_id_is_invalid(res->id, ENABLED_WARN))
 		return;
-	}
 
 	if (parse_and_check_speed_duplex(res->value1, res->value2,
 			&link_speed) < 0)
@@ -1452,32 +1717,32 @@
 }
 
 
-static cmdline_parse_token_string_t cmd_config_speed_specific_port =
+cmdline_parse_token_string_t cmd_config_speed_specific_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_specific, port,
 								"port");
-static cmdline_parse_token_string_t cmd_config_speed_specific_keyword =
+cmdline_parse_token_string_t cmd_config_speed_specific_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_specific, keyword,
 								"config");
-static cmdline_parse_token_num_t cmd_config_speed_specific_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_speed_specific, id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_speed_specific_item1 =
+cmdline_parse_token_num_t cmd_config_speed_specific_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_speed_specific, id, UINT16);
+cmdline_parse_token_string_t cmd_config_speed_specific_item1 =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_specific, item1,
 								"speed");
-static cmdline_parse_token_string_t cmd_config_speed_specific_value1 =
+cmdline_parse_token_string_t cmd_config_speed_specific_value1 =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_specific, value1,
-				"10#100#1000#10000#25000#40000#50000#100000#200000#auto");
-static cmdline_parse_token_string_t cmd_config_speed_specific_item2 =
+				"10#100#1000#10000#25000#40000#50000#100000#auto");
+cmdline_parse_token_string_t cmd_config_speed_specific_item2 =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_specific, item2,
 								"duplex");
-static cmdline_parse_token_string_t cmd_config_speed_specific_value2 =
+cmdline_parse_token_string_t cmd_config_speed_specific_value2 =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_speed_specific, value2,
 							"half#full#auto");
 
-static cmdline_parse_inst_t cmd_config_speed_specific = {
+cmdline_parse_inst_t cmd_config_speed_specific = {
 	.f = cmd_config_speed_specific_parsed,
 	.data = NULL,
 	.help_str = "port config <port_id> speed "
-		"10|100|1000|10000|25000|40000|50000|100000|200000|auto duplex "
+		"10|100|1000|10000|25000|40000|50000|100000|auto duplex "
 							"half|full|auto",
 	.tokens = {
 		(void *)&cmd_config_speed_specific_port,
@@ -1502,14 +1767,14 @@
 
 static void
 cmd_config_loopback_all_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_config_loopback_all *res = parsed_result;
 	portid_t pid;
 
 	if (!all_ports_stopped()) {
-		fprintf(stderr, "Please stop all ports first\n");
+		printf("Please stop all ports first\n");
 		return;
 	}
 
@@ -1520,20 +1785,20 @@
 	cmd_reconfig_device_queue(RTE_PORT_ALL, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_loopback_all_port =
+cmdline_parse_token_string_t cmd_config_loopback_all_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_loopback_all, port, "port");
-static cmdline_parse_token_string_t cmd_config_loopback_all_keyword =
+cmdline_parse_token_string_t cmd_config_loopback_all_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_loopback_all, keyword,
 							"config");
-static cmdline_parse_token_string_t cmd_config_loopback_all_all =
+cmdline_parse_token_string_t cmd_config_loopback_all_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_loopback_all, all, "all");
-static cmdline_parse_token_string_t cmd_config_loopback_all_item =
+cmdline_parse_token_string_t cmd_config_loopback_all_item =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_loopback_all, item,
 							"loopback");
-static cmdline_parse_token_num_t cmd_config_loopback_all_mode =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_loopback_all, mode, RTE_UINT32);
+cmdline_parse_token_num_t cmd_config_loopback_all_mode =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_loopback_all, mode, UINT32);
 
-static cmdline_parse_inst_t cmd_config_loopback_all = {
+cmdline_parse_inst_t cmd_config_loopback_all = {
 	.f = cmd_config_loopback_all_parsed,
 	.data = NULL,
 	.help_str = "port config all loopback <mode>",
@@ -1558,8 +1823,8 @@
 
 static void
 cmd_config_loopback_specific_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_loopback_specific *res = parsed_result;
 
@@ -1567,7 +1832,7 @@
 		return;
 
 	if (!port_is_stopped(res->port_id)) {
-		fprintf(stderr, "Please stop port %u first\n", res->port_id);
+		printf("Please stop port %u first\n", res->port_id);
 		return;
 	}
 
@@ -1577,23 +1842,23 @@
 }
 
 
-static cmdline_parse_token_string_t cmd_config_loopback_specific_port =
+cmdline_parse_token_string_t cmd_config_loopback_specific_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_loopback_specific, port,
 								"port");
-static cmdline_parse_token_string_t cmd_config_loopback_specific_keyword =
+cmdline_parse_token_string_t cmd_config_loopback_specific_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_loopback_specific, keyword,
 								"config");
-static cmdline_parse_token_num_t cmd_config_loopback_specific_id =
+cmdline_parse_token_num_t cmd_config_loopback_specific_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_loopback_specific, port_id,
-								RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_loopback_specific_item =
+								UINT16);
+cmdline_parse_token_string_t cmd_config_loopback_specific_item =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_loopback_specific, item,
 								"loopback");
-static cmdline_parse_token_num_t cmd_config_loopback_specific_mode =
+cmdline_parse_token_num_t cmd_config_loopback_specific_mode =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_loopback_specific, mode,
-			      RTE_UINT32);
+			      UINT32);
 
-static cmdline_parse_inst_t cmd_config_loopback_specific = {
+cmdline_parse_inst_t cmd_config_loopback_specific = {
 	.f = cmd_config_loopback_specific_parsed,
 	.data = NULL,
 	.help_str = "port config <port_id> loopback <mode>",
@@ -1618,18 +1883,18 @@
 
 static void
 cmd_config_rx_tx_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_config_rx_tx *res = parsed_result;
 
 	if (!all_ports_stopped()) {
-		fprintf(stderr, "Please stop all ports first\n");
+		printf("Please stop all ports first\n");
 		return;
 	}
 	if (!strcmp(res->name, "rxq")) {
 		if (!res->value && !nb_txq) {
-			fprintf(stderr, "Warning: Either rx or tx queues should be non zero\n");
+			printf("Warning: Either rx or tx queues should be non zero\n");
 			return;
 		}
 		if (check_nb_rxq(res->value) != 0)
@@ -1638,7 +1903,7 @@
 	}
 	else if (!strcmp(res->name, "txq")) {
 		if (!res->value && !nb_rxq) {
-			fprintf(stderr, "Warning: Either rx or tx queues should be non zero\n");
+			printf("Warning: Either rx or tx queues should be non zero\n");
 			return;
 		}
 		if (check_nb_txq(res->value) != 0)
@@ -1646,16 +1911,21 @@
 		nb_txq = res->value;
 	}
 	else if (!strcmp(res->name, "rxd")) {
-		if (check_nb_rxd(res->value) != 0)
+		if (res->value <= 0 || res->value > RTE_TEST_RX_DESC_MAX) {
+			printf("rxd %d invalid - must be > 0 && <= %d\n",
+					res->value, RTE_TEST_RX_DESC_MAX);
 			return;
+		}
 		nb_rxd = res->value;
 	} else if (!strcmp(res->name, "txd")) {
-		if (check_nb_txd(res->value) != 0)
+		if (res->value <= 0 || res->value > RTE_TEST_TX_DESC_MAX) {
+			printf("txd %d invalid - must be > 0 && <= %d\n",
+					res->value, RTE_TEST_TX_DESC_MAX);
 			return;
-
+		}
 		nb_txd = res->value;
 	} else {
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 		return;
 	}
 
@@ -1666,19 +1936,19 @@
 	cmd_reconfig_device_queue(RTE_PORT_ALL, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_rx_tx_port =
+cmdline_parse_token_string_t cmd_config_rx_tx_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rx_tx, port, "port");
-static cmdline_parse_token_string_t cmd_config_rx_tx_keyword =
+cmdline_parse_token_string_t cmd_config_rx_tx_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rx_tx, keyword, "config");
-static cmdline_parse_token_string_t cmd_config_rx_tx_all =
+cmdline_parse_token_string_t cmd_config_rx_tx_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rx_tx, all, "all");
-static cmdline_parse_token_string_t cmd_config_rx_tx_name =
+cmdline_parse_token_string_t cmd_config_rx_tx_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rx_tx, name,
 						"rxq#txq#rxd#txd");
-static cmdline_parse_token_num_t cmd_config_rx_tx_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_rx_tx, value, RTE_UINT16);
+cmdline_parse_token_num_t cmd_config_rx_tx_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_rx_tx, value, UINT16);
 
-static cmdline_parse_inst_t cmd_config_rx_tx = {
+cmdline_parse_inst_t cmd_config_rx_tx = {
 	.f = cmd_config_rx_tx_parsed,
 	.data = NULL,
 	.help_str = "port config all rxq|txq|rxd|txd <value>",
@@ -1703,42 +1973,40 @@
 
 static void
 cmd_config_max_pkt_len_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_max_pkt_len_result *res = parsed_result;
-	portid_t port_id;
-	int ret;
-
-	if (strcmp(res->name, "max-pkt-len") != 0) {
-		printf("Unknown parameter\n");
-		return;
-	}
+	portid_t pid;
 
 	if (!all_ports_stopped()) {
-		fprintf(stderr, "Please stop all ports first\n");
+		printf("Please stop all ports first\n");
 		return;
 	}
 
-	RTE_ETH_FOREACH_DEV(port_id) {
-		struct rte_port *port = &ports[port_id];
+	RTE_ETH_FOREACH_DEV(pid) {
+		struct rte_port *port = &ports[pid];
+		uint64_t rx_offloads = port->dev_conf.rxmode.offloads;
 
-		if (res->value < RTE_ETHER_MIN_LEN) {
-			fprintf(stderr,
-				"max-pkt-len can not be less than %d\n",
-				RTE_ETHER_MIN_LEN);
-			return;
-		}
+		if (!strcmp(res->name, "max-pkt-len")) {
+			if (res->value < RTE_ETHER_MIN_LEN) {
+				printf("max-pkt-len can not be less than %d\n",
+						RTE_ETHER_MIN_LEN);
+				return;
+			}
+			if (res->value == port->dev_conf.rxmode.max_rx_pkt_len)
+				return;
 
-		ret = eth_dev_info_get_print_err(port_id, &port->dev_info);
-		if (ret != 0) {
-			fprintf(stderr,
-				"rte_eth_dev_info_get() failed for port %u\n",
-				port_id);
+			port->dev_conf.rxmode.max_rx_pkt_len = res->value;
+			if (res->value > RTE_ETHER_MAX_LEN)
+				rx_offloads |= DEV_RX_OFFLOAD_JUMBO_FRAME;
+			else
+				rx_offloads &= ~DEV_RX_OFFLOAD_JUMBO_FRAME;
+			port->dev_conf.rxmode.offloads = rx_offloads;
+		} else {
+			printf("Unknown parameter\n");
 			return;
 		}
-
-		update_mtu_from_frame_size(port_id, res->value);
 	}
 
 	init_port_config();
@@ -1746,23 +2014,23 @@
 	cmd_reconfig_device_queue(RTE_PORT_ALL, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_max_pkt_len_port =
+cmdline_parse_token_string_t cmd_config_max_pkt_len_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_max_pkt_len_result, port,
 								"port");
-static cmdline_parse_token_string_t cmd_config_max_pkt_len_keyword =
+cmdline_parse_token_string_t cmd_config_max_pkt_len_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_max_pkt_len_result, keyword,
 								"config");
-static cmdline_parse_token_string_t cmd_config_max_pkt_len_all =
+cmdline_parse_token_string_t cmd_config_max_pkt_len_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_max_pkt_len_result, all,
 								"all");
-static cmdline_parse_token_string_t cmd_config_max_pkt_len_name =
+cmdline_parse_token_string_t cmd_config_max_pkt_len_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_max_pkt_len_result, name,
 								"max-pkt-len");
-static cmdline_parse_token_num_t cmd_config_max_pkt_len_value =
+cmdline_parse_token_num_t cmd_config_max_pkt_len_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_max_pkt_len_result, value,
-								RTE_UINT32);
+								UINT32);
 
-static cmdline_parse_inst_t cmd_config_max_pkt_len = {
+cmdline_parse_inst_t cmd_config_max_pkt_len = {
 	.f = cmd_config_max_pkt_len_parsed,
 	.data = NULL,
 	.help_str = "port config all max-pkt-len <value>",
@@ -1787,14 +2055,14 @@
 
 static void
 cmd_config_max_lro_pkt_size_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_max_lro_pkt_size_result *res = parsed_result;
 	portid_t pid;
 
 	if (!all_ports_stopped()) {
-		fprintf(stderr, "Please stop all ports first\n");
+		printf("Please stop all ports first\n");
 		return;
 	}
 
@@ -1808,7 +2076,7 @@
 
 			port->dev_conf.rxmode.max_lro_pkt_size = res->value;
 		} else {
-			fprintf(stderr, "Unknown parameter\n");
+			printf("Unknown parameter\n");
 			return;
 		}
 	}
@@ -1818,23 +2086,23 @@
 	cmd_reconfig_device_queue(RTE_PORT_ALL, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_max_lro_pkt_size_port =
+cmdline_parse_token_string_t cmd_config_max_lro_pkt_size_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_max_lro_pkt_size_result,
 				 port, "port");
-static cmdline_parse_token_string_t cmd_config_max_lro_pkt_size_keyword =
+cmdline_parse_token_string_t cmd_config_max_lro_pkt_size_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_max_lro_pkt_size_result,
 				 keyword, "config");
-static cmdline_parse_token_string_t cmd_config_max_lro_pkt_size_all =
+cmdline_parse_token_string_t cmd_config_max_lro_pkt_size_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_max_lro_pkt_size_result,
 				 all, "all");
-static cmdline_parse_token_string_t cmd_config_max_lro_pkt_size_name =
+cmdline_parse_token_string_t cmd_config_max_lro_pkt_size_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_max_lro_pkt_size_result,
 				 name, "max-lro-pkt-size");
-static cmdline_parse_token_num_t cmd_config_max_lro_pkt_size_value =
+cmdline_parse_token_num_t cmd_config_max_lro_pkt_size_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_max_lro_pkt_size_result,
-			      value, RTE_UINT32);
+			      value, UINT32);
 
-static cmdline_parse_inst_t cmd_config_max_lro_pkt_size = {
+cmdline_parse_inst_t cmd_config_max_lro_pkt_size = {
 	.f = cmd_config_max_lro_pkt_size_parsed,
 	.data = NULL,
 	.help_str = "port config all max-lro-pkt-size <value>",
@@ -1859,31 +2127,33 @@
 
 static void
 cmd_config_mtu_parsed(void *parsed_result,
-		      __rte_unused struct cmdline *cl,
-		      __rte_unused void *data)
+		      __attribute__((unused)) struct cmdline *cl,
+		      __attribute__((unused)) void *data)
 {
 	struct cmd_config_mtu_result *res = parsed_result;
 
+	if (res->value < RTE_ETHER_MIN_LEN) {
+		printf("mtu cannot be less than %d\n", RTE_ETHER_MIN_LEN);
+		return;
+	}
 	port_mtu_set(res->port_id, res->value);
 }
 
-static cmdline_parse_token_string_t cmd_config_mtu_port =
+cmdline_parse_token_string_t cmd_config_mtu_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_mtu_result, port,
 				 "port");
-static cmdline_parse_token_string_t cmd_config_mtu_keyword =
+cmdline_parse_token_string_t cmd_config_mtu_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_mtu_result, keyword,
 				 "config");
-static cmdline_parse_token_string_t cmd_config_mtu_mtu =
+cmdline_parse_token_string_t cmd_config_mtu_mtu =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_mtu_result, keyword,
 				 "mtu");
-static cmdline_parse_token_num_t cmd_config_mtu_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_mtu_result, port_id,
-				 RTE_UINT16);
-static cmdline_parse_token_num_t cmd_config_mtu_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_mtu_result, value,
-				 RTE_UINT16);
+cmdline_parse_token_num_t cmd_config_mtu_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_mtu_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_config_mtu_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_mtu_result, value, UINT16);
 
-static cmdline_parse_inst_t cmd_config_mtu = {
+cmdline_parse_inst_t cmd_config_mtu = {
 	.f = cmd_config_mtu_parsed,
 	.data = NULL,
 	.help_str = "port config mtu <port_id> <value>",
@@ -1908,13 +2178,13 @@
 
 static void
 cmd_config_rx_mode_flag_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_rx_mode_flag *res = parsed_result;
 
 	if (!all_ports_stopped()) {
-		fprintf(stderr, "Please stop all ports first\n");
+		printf("Please stop all ports first\n");
 		return;
 	}
 
@@ -1924,11 +2194,11 @@
 		else if (!strcmp(res->value, "off"))
 			rx_drop_en = 0;
 		else {
-			fprintf(stderr, "Unknown parameter\n");
+			printf("Unknown parameter\n");
 			return;
 		}
 	} else {
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 		return;
 	}
 
@@ -1937,21 +2207,21 @@
 	cmd_reconfig_device_queue(RTE_PORT_ALL, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_rx_mode_flag_port =
+cmdline_parse_token_string_t cmd_config_rx_mode_flag_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rx_mode_flag, port, "port");
-static cmdline_parse_token_string_t cmd_config_rx_mode_flag_keyword =
+cmdline_parse_token_string_t cmd_config_rx_mode_flag_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rx_mode_flag, keyword,
 								"config");
-static cmdline_parse_token_string_t cmd_config_rx_mode_flag_all =
+cmdline_parse_token_string_t cmd_config_rx_mode_flag_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rx_mode_flag, all, "all");
-static cmdline_parse_token_string_t cmd_config_rx_mode_flag_name =
+cmdline_parse_token_string_t cmd_config_rx_mode_flag_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rx_mode_flag, name,
 					"drop-en");
-static cmdline_parse_token_string_t cmd_config_rx_mode_flag_value =
+cmdline_parse_token_string_t cmd_config_rx_mode_flag_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rx_mode_flag, value,
 							"on#off");
 
-static cmdline_parse_inst_t cmd_config_rx_mode_flag = {
+cmdline_parse_inst_t cmd_config_rx_mode_flag = {
 	.f = cmd_config_rx_mode_flag_parsed,
 	.data = NULL,
 	.help_str = "port config all drop-en on|off",
@@ -1976,8 +2246,8 @@
 
 static void
 cmd_config_rss_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_config_rss *res = parsed_result;
 	struct rte_eth_rss_conf rss_conf = { .rss_key_len = 0, };
@@ -1988,33 +2258,46 @@
 	uint16_t i;
 	int ret;
 
-	if (!strcmp(res->value, "level-default")) {
-		rss_hf &= (~RTE_ETH_RSS_LEVEL_MASK);
-		rss_conf.rss_hf = (rss_hf | RTE_ETH_RSS_LEVEL_PMD_DEFAULT);
-	} else if (!strcmp(res->value, "level-outer")) {
-		rss_hf &= (~RTE_ETH_RSS_LEVEL_MASK);
-		rss_conf.rss_hf = (rss_hf | RTE_ETH_RSS_LEVEL_OUTERMOST);
-	} else if (!strcmp(res->value, "level-inner")) {
-		rss_hf &= (~RTE_ETH_RSS_LEVEL_MASK);
-		rss_conf.rss_hf = (rss_hf | RTE_ETH_RSS_LEVEL_INNERMOST);
-	} else if (!strcmp(res->value, "default")) {
-		use_default = 1;
-	} else if (isdigit(res->value[0])) {
-		int value = atoi(res->value);
-		if (value > 0 && value < 64)
-			rss_conf.rss_hf = 1ULL << (uint8_t)value;
-		else {
-			fprintf(stderr, "flowtype_id should be greater than 0 and less than 64.\n");
-			return;
-		}
-	} else if (!strcmp(res->value, "none")) {
+	if (!strcmp(res->value, "all"))
+		rss_conf.rss_hf = ETH_RSS_IP | ETH_RSS_TCP |
+				ETH_RSS_UDP | ETH_RSS_SCTP |
+					ETH_RSS_L2_PAYLOAD;
+	else if (!strcmp(res->value, "ip"))
+		rss_conf.rss_hf = ETH_RSS_IP;
+	else if (!strcmp(res->value, "udp"))
+		rss_conf.rss_hf = ETH_RSS_UDP;
+	else if (!strcmp(res->value, "tcp"))
+		rss_conf.rss_hf = ETH_RSS_TCP;
+	else if (!strcmp(res->value, "sctp"))
+		rss_conf.rss_hf = ETH_RSS_SCTP;
+	else if (!strcmp(res->value, "ether"))
+		rss_conf.rss_hf = ETH_RSS_L2_PAYLOAD;
+	else if (!strcmp(res->value, "port"))
+		rss_conf.rss_hf = ETH_RSS_PORT;
+	else if (!strcmp(res->value, "vxlan"))
+		rss_conf.rss_hf = ETH_RSS_VXLAN;
+	else if (!strcmp(res->value, "geneve"))
+		rss_conf.rss_hf = ETH_RSS_GENEVE;
+	else if (!strcmp(res->value, "nvgre"))
+		rss_conf.rss_hf = ETH_RSS_NVGRE;
+	else if (!strcmp(res->value, "l3-src-only"))
+		rss_conf.rss_hf = ETH_RSS_L3_SRC_ONLY;
+	else if (!strcmp(res->value, "l3-dst-only"))
+		rss_conf.rss_hf = ETH_RSS_L3_DST_ONLY;
+	else if (!strcmp(res->value, "l4-src-only"))
+		rss_conf.rss_hf = ETH_RSS_L4_SRC_ONLY;
+	else if (!strcmp(res->value, "l4-dst-only"))
+		rss_conf.rss_hf = ETH_RSS_L4_DST_ONLY;
+	else if (!strcmp(res->value, "none"))
 		rss_conf.rss_hf = 0;
-	} else {
-		rss_conf.rss_hf = str_to_rsstypes(res->value);
-		if (rss_conf.rss_hf == 0) {
-			fprintf(stderr, "Unknown parameter\n");
-			return;
-		}
+	else if (!strcmp(res->value, "default"))
+		use_default = 1;
+	else if (isdigit(res->value[0]) && atoi(res->value) > 0 &&
+						atoi(res->value) < 64)
+		rss_conf.rss_hf = 1ULL << atoi(res->value);
+	else {
+		printf("Unknown parameter\n");
+		return;
 	}
 	rss_conf.rss_key = NULL;
 	/* Update global configuration for RSS types. */
@@ -2039,40 +2322,31 @@
 		diag = rte_eth_dev_rss_hash_update(i, &local_rss_conf);
 		if (diag < 0) {
 			all_updated = 0;
-			fprintf(stderr,
-				"Configuration of RSS hash at ethernet port %d failed with error (%d): %s.\n",
+			printf("Configuration of RSS hash at ethernet port %d "
+				"failed with error (%d): %s.\n",
 				i, -diag, strerror(-diag));
 		}
 	}
-	if (all_updated && !use_default) {
+	if (all_updated && !use_default)
 		rss_hf = rss_conf.rss_hf;
-		printf("rss_hf %#"PRIx64"\n", rss_hf);
-	}
 }
 
-static cmdline_parse_token_string_t cmd_config_rss_port =
+cmdline_parse_token_string_t cmd_config_rss_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss, port, "port");
-static cmdline_parse_token_string_t cmd_config_rss_keyword =
+cmdline_parse_token_string_t cmd_config_rss_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss, keyword, "config");
-static cmdline_parse_token_string_t cmd_config_rss_all =
+cmdline_parse_token_string_t cmd_config_rss_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss, all, "all");
-static cmdline_parse_token_string_t cmd_config_rss_name =
+cmdline_parse_token_string_t cmd_config_rss_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss, name, "rss");
-static cmdline_parse_token_string_t cmd_config_rss_value =
+cmdline_parse_token_string_t cmd_config_rss_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss, value, NULL);
 
-static cmdline_parse_inst_t cmd_config_rss = {
+cmdline_parse_inst_t cmd_config_rss = {
 	.f = cmd_config_rss_parsed,
 	.data = NULL,
 	.help_str = "port config all rss "
-		"all|default|level-default|level-outer|level-inner|"
-		"ip|tcp|udp|sctp|tunnel|vlan|none|"
-		"ipv4|ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|ipv4-other|"
-		"ipv6|ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|ipv6-other|ipv6-ex|ipv6-tcp-ex|ipv6-udp-ex|"
-		"l2-payload|port|vxlan|geneve|nvgre|gtpu|eth|s-vlan|c-vlan|"
-		"esp|ah|l2tpv3|pfcp|pppoe|ecpri|mpls|ipv4-chksum|l4-chksum|"
-		"l2tpv2|l3-pre96|l3-pre64|l3-pre56|l3-pre48|l3-pre40|l3-pre32|"
-		"l2-dst-only|l2-src-only|l4-dst-only|l4-src-only|l3-dst-only|l3-src-only|<rsstype_id>",
+		"all|default|ip|tcp|udp|sctp|ether|port|vxlan|geneve|nvgre|vxlan-gpe|none|<flowtype_id>",
 	.tokens = {
 		(void *)&cmd_config_rss_port,
 		(void *)&cmd_config_rss_keyword,
@@ -2113,16 +2387,15 @@
 
 	hexa_v = hexa_digit_to_value(key[idx]);
 	if (hexa_v == 0xFF)
-		fprintf(stderr,
-			"invalid key: character %c at position %d is not a valid hexa digit\n",
-			key[idx], idx);
+		printf("invalid key: character %c at position %d is not a "
+		       "valid hexa digit\n", key[idx], idx);
 	return hexa_v;
 }
 
 static void
 cmd_config_rss_hash_key_parsed(void *parsed_result,
-			       __rte_unused struct cmdline *cl,
-			       __rte_unused void *data)
+			       __attribute__((unused)) struct cmdline *cl,
+			       __attribute__((unused)) void *data)
 {
 	struct cmd_config_rss_hash_key *res = parsed_result;
 	uint8_t hash_key[RSS_HASH_KEY_LENGTH];
@@ -2142,16 +2415,15 @@
 			dev_info.hash_key_size <= sizeof(hash_key))
 		hash_key_size = dev_info.hash_key_size;
 	else {
-		fprintf(stderr,
-			"dev_info did not provide a valid hash key size\n");
+		printf("dev_info did not provide a valid hash key size\n");
 		return;
 	}
 	/* Check the length of the RSS hash key */
 	key_len = strlen(res->key);
 	if (key_len != (hash_key_size * 2)) {
-		fprintf(stderr,
-			"key length: %d invalid - key must be a string of %d hexa-decimal numbers\n",
-			(int)key_len, hash_key_size * 2);
+		printf("key length: %d invalid - key must be a string of %d"
+			   " hexa-decimal numbers\n",
+			   (int) key_len, hash_key_size * 2);
 		return;
 	}
 	/* Translate RSS hash key into binary representation */
@@ -2168,39 +2440,34 @@
 			hash_key_size);
 }
 
-static cmdline_parse_token_string_t cmd_config_rss_hash_key_port =
+cmdline_parse_token_string_t cmd_config_rss_hash_key_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss_hash_key, port, "port");
-static cmdline_parse_token_string_t cmd_config_rss_hash_key_config =
+cmdline_parse_token_string_t cmd_config_rss_hash_key_config =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss_hash_key, config,
 				 "config");
-static cmdline_parse_token_num_t cmd_config_rss_hash_key_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_rss_hash_key, port_id,
-				 RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_rss_hash_key_rss_hash_key =
+cmdline_parse_token_num_t cmd_config_rss_hash_key_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_rss_hash_key, port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_rss_hash_key_rss_hash_key =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss_hash_key,
 				 rss_hash_key, "rss-hash-key");
-static cmdline_parse_token_string_t cmd_config_rss_hash_key_rss_type =
+cmdline_parse_token_string_t cmd_config_rss_hash_key_rss_type =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss_hash_key, rss_type,
 				 "ipv4#ipv4-frag#ipv4-tcp#ipv4-udp#ipv4-sctp#"
 				 "ipv4-other#ipv6#ipv6-frag#ipv6-tcp#ipv6-udp#"
 				 "ipv6-sctp#ipv6-other#l2-payload#ipv6-ex#"
 				 "ipv6-tcp-ex#ipv6-udp-ex#"
-				 "l3-src-only#l3-dst-only#l4-src-only#l4-dst-only#"
-				 "l2-src-only#l2-dst-only#s-vlan#c-vlan#"
-				 "l2tpv3#esp#ah#pfcp#pppoe#gtpu#ecpri#mpls#l2tpv2");
-static cmdline_parse_token_string_t cmd_config_rss_hash_key_value =
+				 "l3-src-only#l3-dst-only#l4-src-only#l4-dst-only");
+cmdline_parse_token_string_t cmd_config_rss_hash_key_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss_hash_key, key, NULL);
 
-static cmdline_parse_inst_t cmd_config_rss_hash_key = {
+cmdline_parse_inst_t cmd_config_rss_hash_key = {
 	.f = cmd_config_rss_hash_key_parsed,
 	.data = NULL,
 	.help_str = "port config <port_id> rss-hash-key "
 		"ipv4|ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|ipv4-other|"
 		"ipv6|ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|ipv6-other|"
 		"l2-payload|ipv6-ex|ipv6-tcp-ex|ipv6-udp-ex|"
-		"l3-src-only|l3-dst-only|l4-src-only|l4-dst-only|"
-		"l2-src-only|l2-dst-only|s-vlan|c-vlan|"
-		"l2tpv3|esp|ah|pfcp|pppoe|gtpu|ecpri|mpls|l2tpv2 "
+		"l3-src-only|l3-dst-only|l4-src-only|l4-dst-only "
 		"<string of hex digits (variable length, NIC dependent)>",
 	.tokens = {
 		(void *)&cmd_config_rss_hash_key_port,
@@ -2213,90 +2480,6 @@
 	},
 };
 
-/* *** cleanup txq mbufs *** */
-struct cmd_cleanup_txq_mbufs_result {
-	cmdline_fixed_string_t port;
-	cmdline_fixed_string_t keyword;
-	cmdline_fixed_string_t name;
-	uint16_t port_id;
-	uint16_t queue_id;
-	uint32_t free_cnt;
-};
-
-static void
-cmd_cleanup_txq_mbufs_parsed(void *parsed_result,
-			     __rte_unused struct cmdline *cl,
-			     __rte_unused void *data)
-{
-	struct cmd_cleanup_txq_mbufs_result *res = parsed_result;
-	uint16_t port_id = res->port_id;
-	uint16_t queue_id = res->queue_id;
-	uint32_t free_cnt = res->free_cnt;
-	struct rte_eth_txq_info qinfo;
-	int ret;
-
-	if (test_done == 0) {
-		fprintf(stderr, "Please stop forwarding first\n");
-		return;
-	}
-
-	if (rte_eth_tx_queue_info_get(port_id, queue_id, &qinfo)) {
-		fprintf(stderr, "Failed to get port %u Tx queue %u info\n",
-			port_id, queue_id);
-		return;
-	}
-
-	if (qinfo.queue_state != RTE_ETH_QUEUE_STATE_STARTED) {
-		fprintf(stderr, "Tx queue %u not started\n", queue_id);
-		return;
-	}
-
-	ret = rte_eth_tx_done_cleanup(port_id, queue_id, free_cnt);
-	if (ret < 0) {
-		fprintf(stderr,
-			"Failed to cleanup mbuf for port %u Tx queue %u error desc: %s(%d)\n",
-			port_id, queue_id, strerror(-ret), ret);
-		return;
-	}
-
-	printf("Cleanup port %u Tx queue %u mbuf nums: %u\n",
-	       port_id, queue_id, ret);
-}
-
-static cmdline_parse_token_string_t cmd_cleanup_txq_mbufs_port =
-	TOKEN_STRING_INITIALIZER(struct cmd_cleanup_txq_mbufs_result, port,
-				 "port");
-static cmdline_parse_token_string_t cmd_cleanup_txq_mbufs_cleanup =
-	TOKEN_STRING_INITIALIZER(struct cmd_cleanup_txq_mbufs_result, keyword,
-				 "cleanup");
-static cmdline_parse_token_num_t cmd_cleanup_txq_mbufs_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_cleanup_txq_mbufs_result, port_id,
-			      RTE_UINT16);
-static cmdline_parse_token_string_t cmd_cleanup_txq_mbufs_txq =
-	TOKEN_STRING_INITIALIZER(struct cmd_cleanup_txq_mbufs_result, name,
-				 "txq");
-static cmdline_parse_token_num_t cmd_cleanup_txq_mbufs_queue_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_cleanup_txq_mbufs_result, queue_id,
-			      RTE_UINT16);
-static cmdline_parse_token_num_t cmd_cleanup_txq_mbufs_free_cnt =
-	TOKEN_NUM_INITIALIZER(struct cmd_cleanup_txq_mbufs_result, free_cnt,
-			      RTE_UINT32);
-
-static cmdline_parse_inst_t cmd_cleanup_txq_mbufs = {
-	.f = cmd_cleanup_txq_mbufs_parsed,
-	.data = NULL,
-	.help_str = "port cleanup <port_id> txq <queue_id> <free_cnt>",
-	.tokens = {
-		(void *)&cmd_cleanup_txq_mbufs_port,
-		(void *)&cmd_cleanup_txq_mbufs_cleanup,
-		(void *)&cmd_cleanup_txq_mbufs_port_id,
-		(void *)&cmd_cleanup_txq_mbufs_txq,
-		(void *)&cmd_cleanup_txq_mbufs_queue_id,
-		(void *)&cmd_cleanup_txq_mbufs_free_cnt,
-		NULL,
-	},
-};
-
 /* *** configure port rxq/txq ring size *** */
 struct cmd_config_rxtx_ring_size {
 	cmdline_fixed_string_t port;
@@ -2310,8 +2493,8 @@
 
 static void
 cmd_config_rxtx_ring_size_parsed(void *parsed_result,
-				 __rte_unused struct cmdline *cl,
-				 __rte_unused void *data)
+				 __attribute__((unused)) struct cmdline *cl,
+				 __attribute__((unused)) void *data)
 {
 	struct cmd_config_rxtx_ring_size *res = parsed_result;
 	struct rte_port *port;
@@ -2321,7 +2504,7 @@
 		return;
 
 	if (res->portid == (portid_t)RTE_PORT_ALL) {
-		fprintf(stderr, "Invalid port id\n");
+		printf("Invalid port id\n");
 		return;
 	}
 
@@ -2332,7 +2515,7 @@
 	else if (!strcmp(res->rxtxq, "txq"))
 		isrx = 0;
 	else {
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 		return;
 	}
 
@@ -2342,9 +2525,8 @@
 		return;
 
 	if (isrx && res->size != 0 && res->size <= rx_free_thresh) {
-		fprintf(stderr,
-			"Invalid rx ring_size, must > rx_free_thresh: %d\n",
-			rx_free_thresh);
+		printf("Invalid rx ring_size, must > rx_free_thresh: %d\n",
+		       rx_free_thresh);
 		return;
 	}
 
@@ -2356,29 +2538,29 @@
 	cmd_reconfig_device_queue(res->portid, 0, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_rxtx_ring_size_port =
+cmdline_parse_token_string_t cmd_config_rxtx_ring_size_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rxtx_ring_size,
 				 port, "port");
-static cmdline_parse_token_string_t cmd_config_rxtx_ring_size_config =
+cmdline_parse_token_string_t cmd_config_rxtx_ring_size_config =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rxtx_ring_size,
 				 config, "config");
-static cmdline_parse_token_num_t cmd_config_rxtx_ring_size_portid =
+cmdline_parse_token_num_t cmd_config_rxtx_ring_size_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_rxtx_ring_size,
-				 portid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_rxtx_ring_size_rxtxq =
+				 portid, UINT16);
+cmdline_parse_token_string_t cmd_config_rxtx_ring_size_rxtxq =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rxtx_ring_size,
 				 rxtxq, "rxq#txq");
-static cmdline_parse_token_num_t cmd_config_rxtx_ring_size_qid =
+cmdline_parse_token_num_t cmd_config_rxtx_ring_size_qid =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_rxtx_ring_size,
-			      qid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_rxtx_ring_size_rsize =
+			      qid, UINT16);
+cmdline_parse_token_string_t cmd_config_rxtx_ring_size_rsize =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rxtx_ring_size,
 				 rsize, "ring_size");
-static cmdline_parse_token_num_t cmd_config_rxtx_ring_size_size =
+cmdline_parse_token_num_t cmd_config_rxtx_ring_size_size =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_rxtx_ring_size,
-			      size, RTE_UINT16);
+			      size, UINT16);
 
-static cmdline_parse_inst_t cmd_config_rxtx_ring_size = {
+cmdline_parse_inst_t cmd_config_rxtx_ring_size = {
 	.f = cmd_config_rxtx_ring_size_parsed,
 	.data = NULL,
 	.help_str = "port config <port_id> rxq|txq <queue_id> ring_size <value>",
@@ -2405,18 +2587,16 @@
 
 static void
 cmd_config_rxtx_queue_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_config_rxtx_queue *res = parsed_result;
-	struct rte_port *port;
 	uint8_t isrx;
 	uint8_t isstart;
-	uint8_t *state;
 	int ret = 0;
 
 	if (test_done == 0) {
-		fprintf(stderr, "Please stop forwarding first\n");
+		printf("Please stop forwarding first\n");
 		return;
 	}
 
@@ -2424,7 +2604,7 @@
 		return;
 
 	if (port_is_started(res->portid) != 1) {
-		fprintf(stderr, "Please start port %u first\n", res->portid);
+		printf("Please start port %u first\n", res->portid);
 		return;
 	}
 
@@ -2433,7 +2613,7 @@
 	else if (!strcmp(res->rxtxq, "txq"))
 		isrx = 0;
 	else {
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 		return;
 	}
 
@@ -2447,7 +2627,7 @@
 	else if (!strcmp(res->opname, "stop"))
 		isstart = 0;
 	else {
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 		return;
 	}
 
@@ -2460,30 +2640,23 @@
 	else
 		ret = rte_eth_dev_tx_queue_stop(res->portid, res->qid);
 
-	if (ret == -ENOTSUP) {
-		fprintf(stderr, "Function not supported in PMD\n");
-		return;
-	}
-
-	port = &ports[res->portid];
-	state = isrx ? &port->rxq[res->qid].state : &port->txq[res->qid].state;
-	*state = isstart ? RTE_ETH_QUEUE_STATE_STARTED :
-			   RTE_ETH_QUEUE_STATE_STOPPED;
+	if (ret == -ENOTSUP)
+		printf("Function not supported in PMD driver\n");
 }
 
-static cmdline_parse_token_string_t cmd_config_rxtx_queue_port =
+cmdline_parse_token_string_t cmd_config_rxtx_queue_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rxtx_queue, port, "port");
-static cmdline_parse_token_num_t cmd_config_rxtx_queue_portid =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_rxtx_queue, portid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_rxtx_queue_rxtxq =
+cmdline_parse_token_num_t cmd_config_rxtx_queue_portid =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_rxtx_queue, portid, UINT16);
+cmdline_parse_token_string_t cmd_config_rxtx_queue_rxtxq =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rxtx_queue, rxtxq, "rxq#txq");
-static cmdline_parse_token_num_t cmd_config_rxtx_queue_qid =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_rxtx_queue, qid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_rxtx_queue_opname =
+cmdline_parse_token_num_t cmd_config_rxtx_queue_qid =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_rxtx_queue, qid, UINT16);
+cmdline_parse_token_string_t cmd_config_rxtx_queue_opname =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rxtx_queue, opname,
 						"start#stop");
 
-static cmdline_parse_inst_t cmd_config_rxtx_queue = {
+cmdline_parse_inst_t cmd_config_rxtx_queue = {
 	.f = cmd_config_rxtx_queue_parsed,
 	.data = NULL,
 	.help_str = "port <port_id> rxq|txq <queue_id> start|stop",
@@ -2509,8 +2682,8 @@
 
 static void
 cmd_config_deferred_start_rxtx_queue_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_config_deferred_start_rxtx_queue *res = parsed_result;
 	struct rte_port *port;
@@ -2522,7 +2695,7 @@
 		return;
 
 	if (port_is_started(res->port_id) != 0) {
-		fprintf(stderr, "Please stop port %u first\n", res->port_id);
+		printf("Please stop port %u first\n", res->port_id);
 		return;
 	}
 
@@ -2537,11 +2710,11 @@
 
 	ison = !strcmp(res->state, "on");
 
-	if (isrx && port->rxq[res->qid].conf.rx_deferred_start != ison) {
-		port->rxq[res->qid].conf.rx_deferred_start = ison;
+	if (isrx && port->rx_conf[res->qid].rx_deferred_start != ison) {
+		port->rx_conf[res->qid].rx_deferred_start = ison;
 		needreconfig = 1;
-	} else if (!isrx && port->txq[res->qid].conf.tx_deferred_start != ison) {
-		port->txq[res->qid].conf.tx_deferred_start = ison;
+	} else if (!isrx && port->tx_conf[res->qid].tx_deferred_start != ison) {
+		port->tx_conf[res->qid].tx_deferred_start = ison;
 		needreconfig = 1;
 	}
 
@@ -2549,26 +2722,26 @@
 		cmd_reconfig_device_queue(res->port_id, 0, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_deferred_start_rxtx_queue_port =
+cmdline_parse_token_string_t cmd_config_deferred_start_rxtx_queue_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_deferred_start_rxtx_queue,
 						port, "port");
-static cmdline_parse_token_num_t cmd_config_deferred_start_rxtx_queue_port_id =
+cmdline_parse_token_num_t cmd_config_deferred_start_rxtx_queue_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_deferred_start_rxtx_queue,
-						port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_deferred_start_rxtx_queue_rxtxq =
+						port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_deferred_start_rxtx_queue_rxtxq =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_deferred_start_rxtx_queue,
 						rxtxq, "rxq#txq");
-static cmdline_parse_token_num_t cmd_config_deferred_start_rxtx_queue_qid =
+cmdline_parse_token_num_t cmd_config_deferred_start_rxtx_queue_qid =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_deferred_start_rxtx_queue,
-						qid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_deferred_start_rxtx_queue_opname =
+						qid, UINT16);
+cmdline_parse_token_string_t cmd_config_deferred_start_rxtx_queue_opname =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_deferred_start_rxtx_queue,
 						opname, "deferred_start");
-static cmdline_parse_token_string_t cmd_config_deferred_start_rxtx_queue_state =
+cmdline_parse_token_string_t cmd_config_deferred_start_rxtx_queue_state =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_deferred_start_rxtx_queue,
 						state, "on#off");
 
-static cmdline_parse_inst_t cmd_config_deferred_start_rxtx_queue = {
+cmdline_parse_inst_t cmd_config_deferred_start_rxtx_queue = {
 	.f = cmd_config_deferred_start_rxtx_queue_parsed,
 	.data = NULL,
 	.help_str = "port <port_id> rxq|txq <queue_id> deferred_start on|off",
@@ -2593,22 +2766,22 @@
 };
 
 /* Common CLI fields for queue setup */
-static cmdline_parse_token_string_t cmd_setup_rxtx_queue_port =
+cmdline_parse_token_string_t cmd_setup_rxtx_queue_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_setup_rxtx_queue, port, "port");
-static cmdline_parse_token_num_t cmd_setup_rxtx_queue_portid =
-	TOKEN_NUM_INITIALIZER(struct cmd_setup_rxtx_queue, portid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_setup_rxtx_queue_rxtxq =
+cmdline_parse_token_num_t cmd_setup_rxtx_queue_portid =
+	TOKEN_NUM_INITIALIZER(struct cmd_setup_rxtx_queue, portid, UINT16);
+cmdline_parse_token_string_t cmd_setup_rxtx_queue_rxtxq =
 	TOKEN_STRING_INITIALIZER(struct cmd_setup_rxtx_queue, rxtxq, "rxq#txq");
-static cmdline_parse_token_num_t cmd_setup_rxtx_queue_qid =
-	TOKEN_NUM_INITIALIZER(struct cmd_setup_rxtx_queue, qid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_setup_rxtx_queue_setup =
+cmdline_parse_token_num_t cmd_setup_rxtx_queue_qid =
+	TOKEN_NUM_INITIALIZER(struct cmd_setup_rxtx_queue, qid, UINT16);
+cmdline_parse_token_string_t cmd_setup_rxtx_queue_setup =
 	TOKEN_STRING_INITIALIZER(struct cmd_setup_rxtx_queue, setup, "setup");
 
 static void
 cmd_setup_rxtx_queue_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_setup_rxtx_queue *res = parsed_result;
 	struct rte_port *port;
@@ -2621,7 +2794,7 @@
 		return;
 
 	if (res->portid == (portid_t)RTE_PORT_ALL) {
-		fprintf(stderr, "Invalid port id\n");
+		printf("Invalid port id\n");
 		return;
 	}
 
@@ -2630,15 +2803,15 @@
 	else if (!strcmp(res->rxtxq, "txq"))
 		isrx = 0;
 	else {
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 		return;
 	}
 
 	if (isrx && rx_queue_id_is_invalid(res->qid)) {
-		fprintf(stderr, "Invalid rx queue\n");
+		printf("Invalid rx queue\n");
 		return;
 	} else if (!isrx && tx_queue_id_is_invalid(res->qid)) {
-		fprintf(stderr, "Invalid tx queue\n");
+		printf("Invalid tx queue\n");
 		return;
 	}
 
@@ -2648,42 +2821,38 @@
 		if (!numa_support || socket_id == NUMA_NO_CONFIG)
 			socket_id = port->socket_id;
 
-		mp = mbuf_pool_find(socket_id, 0);
+		mp = mbuf_pool_find(socket_id);
 		if (mp == NULL) {
-			fprintf(stderr,
-				"Failed to setup RX queue: No mempool allocation on the socket %d\n",
+			printf("Failed to setup RX queue: "
+				"No mempool allocation"
+				" on the socket %d\n",
 				rxring_numa[res->portid]);
 			return;
 		}
-		ret = rx_queue_setup(res->portid,
-				     res->qid,
-				     port->nb_rx_desc[res->qid],
-				     socket_id,
-				     &port->rxq[res->qid].conf,
-				     mp);
+		ret = rte_eth_rx_queue_setup(res->portid,
+					     res->qid,
+					     port->nb_rx_desc[res->qid],
+					     socket_id,
+					     &port->rx_conf[res->qid],
+					     mp);
 		if (ret)
-			fprintf(stderr, "Failed to setup RX queue\n");
+			printf("Failed to setup RX queue\n");
 	} else {
 		socket_id = txring_numa[res->portid];
 		if (!numa_support || socket_id == NUMA_NO_CONFIG)
 			socket_id = port->socket_id;
 
-		if (port->nb_tx_desc[res->qid] < tx_pkt_nb_segs) {
-			fprintf(stderr,
-				"Failed to setup TX queue: not enough descriptors\n");
-			return;
-		}
 		ret = rte_eth_tx_queue_setup(res->portid,
 					     res->qid,
 					     port->nb_tx_desc[res->qid],
 					     socket_id,
-					     &port->txq[res->qid].conf);
+					     &port->tx_conf[res->qid]);
 		if (ret)
-			fprintf(stderr, "Failed to setup TX queue\n");
+			printf("Failed to setup TX queue\n");
 	}
 }
 
-static cmdline_parse_inst_t cmd_setup_rxtx_queue = {
+cmdline_parse_inst_t cmd_setup_rxtx_queue = {
 	.f = cmd_setup_rxtx_queue_parsed,
 	.data = NULL,
 	.help_str = "port <port_id> rxq|txq <queue_idx> setup",
@@ -2752,13 +2921,12 @@
 		nb_queue = (uint16_t)int_fld[FLD_QUEUE];
 
 		if (hash_index >= nb_entries) {
-			fprintf(stderr, "Invalid RETA hash index=%d\n",
-				hash_index);
+			printf("Invalid RETA hash index=%d\n", hash_index);
 			return -1;
 		}
 
-		idx = hash_index / RTE_ETH_RETA_GROUP_SIZE;
-		shift = hash_index % RTE_ETH_RETA_GROUP_SIZE;
+		idx = hash_index / RTE_RETA_GROUP_SIZE;
+		shift = hash_index % RTE_RETA_GROUP_SIZE;
 		reta_conf[idx].mask |= (1ULL << shift);
 		reta_conf[idx].reta[shift] = nb_queue;
 	}
@@ -2768,8 +2936,8 @@
 
 static void
 cmd_set_rss_reta_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	int ret;
 	struct rte_eth_dev_info dev_info;
@@ -2781,16 +2949,15 @@
 		return;
 
 	if (dev_info.reta_size == 0) {
-		fprintf(stderr,
-			"Redirection table size is 0 which is invalid for RSS\n");
+		printf("Redirection table size is 0 which is "
+					"invalid for RSS\n");
 		return;
 	} else
 		printf("The reta size of port %d is %u\n",
 			res->port_id, dev_info.reta_size);
-	if (dev_info.reta_size > RTE_ETH_RSS_RETA_SIZE_512) {
-		fprintf(stderr,
-			"Currently do not support more than %u entries of redirection table\n",
-			RTE_ETH_RSS_RETA_SIZE_512);
+	if (dev_info.reta_size > ETH_RSS_RETA_SIZE_512) {
+		printf("Currently do not support more than %u entries of "
+			"redirection table\n", ETH_RSS_RETA_SIZE_512);
 		return;
 	}
 
@@ -2798,33 +2965,32 @@
 	if (!strcmp(res->list_name, "reta")) {
 		if (parse_reta_config(res->list_of_items, reta_conf,
 						dev_info.reta_size)) {
-			fprintf(stderr,
-				"Invalid RSS Redirection Table config entered\n");
+			printf("Invalid RSS Redirection Table "
+					"config entered\n");
 			return;
 		}
 		ret = rte_eth_dev_rss_reta_update(res->port_id,
 				reta_conf, dev_info.reta_size);
 		if (ret != 0)
-			fprintf(stderr,
-				"Bad redirection table parameter, return code = %d\n",
-				ret);
+			printf("Bad redirection table parameter, "
+					"return code = %d \n", ret);
 	}
 }
 
-static cmdline_parse_token_string_t cmd_config_rss_reta_port =
+cmdline_parse_token_string_t cmd_config_rss_reta_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss_reta, port, "port");
-static cmdline_parse_token_string_t cmd_config_rss_reta_keyword =
+cmdline_parse_token_string_t cmd_config_rss_reta_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss_reta, keyword, "config");
-static cmdline_parse_token_num_t cmd_config_rss_reta_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_rss_reta, port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_rss_reta_name =
+cmdline_parse_token_num_t cmd_config_rss_reta_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_rss_reta, port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_rss_reta_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss_reta, name, "rss");
-static cmdline_parse_token_string_t cmd_config_rss_reta_list_name =
+cmdline_parse_token_string_t cmd_config_rss_reta_list_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_rss_reta, list_name, "reta");
-static cmdline_parse_token_string_t cmd_config_rss_reta_list_of_items =
+cmdline_parse_token_string_t cmd_config_rss_reta_list_of_items =
         TOKEN_STRING_INITIALIZER(struct cmd_config_rss_reta, list_of_items,
                                  NULL);
-static cmdline_parse_inst_t cmd_config_rss_reta = {
+cmdline_parse_inst_t cmd_config_rss_reta = {
 	.f = cmd_set_rss_reta_parsed,
 	.data = NULL,
 	.help_str = "port config <port_id> rss reta <hash,queue[,hash,queue]*>",
@@ -2861,8 +3027,8 @@
 	char *end;
 	char *str_fld[8];
 	uint16_t i;
-	uint16_t num = (nb_entries + RTE_ETH_RETA_GROUP_SIZE - 1) /
-			RTE_ETH_RETA_GROUP_SIZE;
+	uint16_t num = (nb_entries + RTE_RETA_GROUP_SIZE - 1) /
+			RTE_RETA_GROUP_SIZE;
 	int ret;
 
 	p = strchr(p0, '(');
@@ -2874,28 +3040,26 @@
 		return -1;
 	size = p0 - p;
 	if (size >= sizeof(s)) {
-		fprintf(stderr,
-			"The string size exceeds the internal buffer size\n");
+		printf("The string size exceeds the internal buffer size\n");
 		return -1;
 	}
 	snprintf(s, sizeof(s), "%.*s", size, p);
 	ret = rte_strsplit(s, sizeof(s), str_fld, num, ',');
 	if (ret <= 0 || ret != num) {
-		fprintf(stderr,
-			"The bits of masks do not match the number of reta entries: %u\n",
-			num);
+		printf("The bits of masks do not match the number of "
+					"reta entries: %u\n", num);
 		return -1;
 	}
 	for (i = 0; i < ret; i++)
-		conf[i].mask = (uint64_t)strtoull(str_fld[i], &end, 0);
+		conf[i].mask = (uint64_t)strtoul(str_fld[i], &end, 0);
 
 	return 0;
 }
 
 static void
 cmd_showport_reta_parsed(void *parsed_result,
-			 __rte_unused struct cmdline *cl,
-			 __rte_unused void *data)
+			 __attribute__((unused)) struct cmdline *cl,
+			 __attribute__((unused)) void *data)
 {
 	struct cmd_showport_reta *res = parsed_result;
 	struct rte_eth_rss_reta_entry64 reta_conf[8];
@@ -2907,9 +3071,9 @@
 	if (ret != 0)
 		return;
 
-	max_reta_size = RTE_MIN(dev_info.reta_size, RTE_ETH_RSS_RETA_SIZE_512);
+	max_reta_size = RTE_MIN(dev_info.reta_size, ETH_RSS_RETA_SIZE_512);
 	if (res->size == 0 || res->size > max_reta_size) {
-		fprintf(stderr, "Invalid redirection table size: %u (1-%u)\n",
+		printf("Invalid redirection table size: %u (1-%u)\n",
 			res->size, max_reta_size);
 		return;
 	}
@@ -2917,30 +3081,30 @@
 	memset(reta_conf, 0, sizeof(reta_conf));
 	if (showport_parse_reta_config(reta_conf, res->size,
 				res->list_of_items) < 0) {
-		fprintf(stderr, "Invalid string: %s for reta masks\n",
-			res->list_of_items);
+		printf("Invalid string: %s for reta masks\n",
+					res->list_of_items);
 		return;
 	}
 	port_rss_reta_info(res->port_id, reta_conf, res->size);
 }
 
-static cmdline_parse_token_string_t cmd_showport_reta_show =
+cmdline_parse_token_string_t cmd_showport_reta_show =
 	TOKEN_STRING_INITIALIZER(struct  cmd_showport_reta, show, "show");
-static cmdline_parse_token_string_t cmd_showport_reta_port =
+cmdline_parse_token_string_t cmd_showport_reta_port =
 	TOKEN_STRING_INITIALIZER(struct  cmd_showport_reta, port, "port");
-static cmdline_parse_token_num_t cmd_showport_reta_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_showport_reta, port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_showport_reta_rss =
+cmdline_parse_token_num_t cmd_showport_reta_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_showport_reta, port_id, UINT16);
+cmdline_parse_token_string_t cmd_showport_reta_rss =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_reta, rss, "rss");
-static cmdline_parse_token_string_t cmd_showport_reta_reta =
+cmdline_parse_token_string_t cmd_showport_reta_reta =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_reta, reta, "reta");
-static cmdline_parse_token_num_t cmd_showport_reta_size =
-	TOKEN_NUM_INITIALIZER(struct cmd_showport_reta, size, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_showport_reta_list_of_items =
+cmdline_parse_token_num_t cmd_showport_reta_size =
+	TOKEN_NUM_INITIALIZER(struct cmd_showport_reta, size, UINT16);
+cmdline_parse_token_string_t cmd_showport_reta_list_of_items =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_reta,
 					list_of_items, NULL);
 
-static cmdline_parse_inst_t cmd_showport_reta = {
+cmdline_parse_inst_t cmd_showport_reta = {
 	.f = cmd_showport_reta_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> rss reta <size> <mask0[,mask1]*>",
@@ -2967,7 +3131,7 @@
 };
 
 static void cmd_showport_rss_hash_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
+				__attribute__((unused)) struct cmdline *cl,
 				void *show_rss_key)
 {
 	struct cmd_showport_rss_hash *res = parsed_result;
@@ -2975,20 +3139,19 @@
 	port_rss_hash_conf_show(res->port_id, show_rss_key != NULL);
 }
 
-static cmdline_parse_token_string_t cmd_showport_rss_hash_show =
+cmdline_parse_token_string_t cmd_showport_rss_hash_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_rss_hash, show, "show");
-static cmdline_parse_token_string_t cmd_showport_rss_hash_port =
+cmdline_parse_token_string_t cmd_showport_rss_hash_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_rss_hash, port, "port");
-static cmdline_parse_token_num_t cmd_showport_rss_hash_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_showport_rss_hash, port_id,
-				 RTE_UINT16);
-static cmdline_parse_token_string_t cmd_showport_rss_hash_rss_hash =
+cmdline_parse_token_num_t cmd_showport_rss_hash_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_showport_rss_hash, port_id, UINT16);
+cmdline_parse_token_string_t cmd_showport_rss_hash_rss_hash =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_rss_hash, rss_hash,
 				 "rss-hash");
-static cmdline_parse_token_string_t cmd_showport_rss_hash_rss_key =
+cmdline_parse_token_string_t cmd_showport_rss_hash_rss_key =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_rss_hash, key, "key");
 
-static cmdline_parse_inst_t cmd_showport_rss_hash = {
+cmdline_parse_inst_t cmd_showport_rss_hash = {
 	.f = cmd_showport_rss_hash_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> rss-hash",
@@ -3001,7 +3164,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_showport_rss_hash_key = {
+cmdline_parse_inst_t cmd_showport_rss_hash_key = {
 	.f = cmd_showport_rss_hash_parsed,
 	.data = (void *)1,
 	.help_str = "show port <port_id> rss-hash key",
@@ -3030,11 +3193,10 @@
 
 static void
 cmd_config_dcb_parsed(void *parsed_result,
-                        __rte_unused struct cmdline *cl,
-                        __rte_unused void *data)
+                        __attribute__((unused)) struct cmdline *cl,
+                        __attribute__((unused)) void *data)
 {
 	struct cmd_config_dcb *res = parsed_result;
-	struct rte_eth_dcb_info dcb_info;
 	portid_t port_id = res->port_id;
 	struct rte_port *port;
 	uint8_t pfc_en;
@@ -3043,29 +3205,20 @@
 	port = &ports[port_id];
 	/** Check if the port is not started **/
 	if (port->port_status != RTE_PORT_STOPPED) {
-		fprintf(stderr, "Please stop port %d first\n", port_id);
+		printf("Please stop port %d first\n", port_id);
 		return;
 	}
 
-	if ((res->num_tcs != RTE_ETH_4_TCS) && (res->num_tcs != RTE_ETH_8_TCS)) {
-		fprintf(stderr,
-			"The invalid number of traffic class, only 4 or 8 allowed.\n");
+	if ((res->num_tcs != ETH_4_TCS) && (res->num_tcs != ETH_8_TCS)) {
+		printf("The invalid number of traffic class,"
+			" only 4 or 8 allowed.\n");
 		return;
 	}
 
 	if (nb_fwd_lcores < res->num_tcs) {
-		fprintf(stderr,
-			"nb_cores shouldn't be less than number of TCs.\n");
+		printf("nb_cores shouldn't be less than number of TCs.\n");
 		return;
 	}
-
-	/* Check whether the port supports the report of DCB info. */
-	ret = rte_eth_dev_get_dcb_info(port_id, &dcb_info);
-	if (ret == -ENOTSUP) {
-		fprintf(stderr, "rte_eth_dev_get_dcb_info not supported.\n");
-		return;
-	}
-
 	if (!strncmp(res->pfc_en, "on", 2))
 		pfc_en = 1;
 	else
@@ -3080,36 +3233,36 @@
 		ret = init_port_dcb_config(port_id, DCB_ENABLED,
 				(enum rte_eth_nb_tcs)res->num_tcs,
 				pfc_en);
+
+
 	if (ret != 0) {
-		fprintf(stderr, "Cannot initialize network ports.\n");
+		printf("Cannot initialize network ports.\n");
 		return;
 	}
 
-	fwd_config_setup();
-
 	cmd_reconfig_device_queue(port_id, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_dcb_port =
+cmdline_parse_token_string_t cmd_config_dcb_port =
         TOKEN_STRING_INITIALIZER(struct cmd_config_dcb, port, "port");
-static cmdline_parse_token_string_t cmd_config_dcb_config =
+cmdline_parse_token_string_t cmd_config_dcb_config =
         TOKEN_STRING_INITIALIZER(struct cmd_config_dcb, config, "config");
-static cmdline_parse_token_num_t cmd_config_dcb_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_dcb, port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_dcb_dcb =
+cmdline_parse_token_num_t cmd_config_dcb_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_dcb, port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_dcb_dcb =
         TOKEN_STRING_INITIALIZER(struct cmd_config_dcb, dcb, "dcb");
-static cmdline_parse_token_string_t cmd_config_dcb_vt =
+cmdline_parse_token_string_t cmd_config_dcb_vt =
         TOKEN_STRING_INITIALIZER(struct cmd_config_dcb, vt, "vt");
-static cmdline_parse_token_string_t cmd_config_dcb_vt_en =
+cmdline_parse_token_string_t cmd_config_dcb_vt_en =
         TOKEN_STRING_INITIALIZER(struct cmd_config_dcb, vt_en, "on#off");
-static cmdline_parse_token_num_t cmd_config_dcb_num_tcs =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_dcb, num_tcs, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_config_dcb_pfc =
+cmdline_parse_token_num_t cmd_config_dcb_num_tcs =
+        TOKEN_NUM_INITIALIZER(struct cmd_config_dcb, num_tcs, UINT8);
+cmdline_parse_token_string_t cmd_config_dcb_pfc=
         TOKEN_STRING_INITIALIZER(struct cmd_config_dcb, pfc, "pfc");
-static cmdline_parse_token_string_t cmd_config_dcb_pfc_en =
+cmdline_parse_token_string_t cmd_config_dcb_pfc_en =
         TOKEN_STRING_INITIALIZER(struct cmd_config_dcb, pfc_en, "on#off");
 
-static cmdline_parse_inst_t cmd_config_dcb = {
+cmdline_parse_inst_t cmd_config_dcb = {
 	.f = cmd_config_dcb_parsed,
 	.data = NULL,
 	.help_str = "port config <port-id> dcb vt on|off <num_tcs> pfc on|off",
@@ -3138,8 +3291,8 @@
 
 static void
 cmd_config_burst_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_config_burst *res = parsed_result;
 	struct rte_eth_dev_info dev_info;
@@ -3147,7 +3300,7 @@
 	int ret;
 
 	if (!all_ports_stopped()) {
-		fprintf(stderr, "Please stop all ports first\n");
+		printf("Please stop all ports first\n");
 		return;
 	}
 
@@ -3179,13 +3332,12 @@
 				rec_nb_pkts);
 			nb_pkt_per_burst = rec_nb_pkts;
 		} else if (res->value > MAX_PKT_BURST) {
-			fprintf(stderr, "burst must be >= 1 && <= %d\n",
-				MAX_PKT_BURST);
+			printf("burst must be >= 1 && <= %d\n", MAX_PKT_BURST);
 			return;
 		} else
 			nb_pkt_per_burst = res->value;
 	} else {
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 		return;
 	}
 
@@ -3194,18 +3346,18 @@
 	cmd_reconfig_device_queue(RTE_PORT_ALL, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_burst_port =
+cmdline_parse_token_string_t cmd_config_burst_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_burst, port, "port");
-static cmdline_parse_token_string_t cmd_config_burst_keyword =
+cmdline_parse_token_string_t cmd_config_burst_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_burst, keyword, "config");
-static cmdline_parse_token_string_t cmd_config_burst_all =
+cmdline_parse_token_string_t cmd_config_burst_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_burst, all, "all");
-static cmdline_parse_token_string_t cmd_config_burst_name =
+cmdline_parse_token_string_t cmd_config_burst_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_burst, name, "burst");
-static cmdline_parse_token_num_t cmd_config_burst_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_burst, value, RTE_UINT16);
+cmdline_parse_token_num_t cmd_config_burst_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_burst, value, UINT16);
 
-static cmdline_parse_inst_t cmd_config_burst = {
+cmdline_parse_inst_t cmd_config_burst = {
 	.f = cmd_config_burst_parsed,
 	.data = NULL,
 	.help_str = "port config all burst <value>",
@@ -3230,13 +3382,13 @@
 
 static void
 cmd_config_thresh_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_config_thresh *res = parsed_result;
 
 	if (!all_ports_stopped()) {
-		fprintf(stderr, "Please stop all ports first\n");
+		printf("Please stop all ports first\n");
 		return;
 	}
 
@@ -3253,7 +3405,7 @@
 	else if(!strcmp(res->name, "rxwt"))
 		rx_wthresh = res->value;
 	else {
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 		return;
 	}
 
@@ -3262,19 +3414,19 @@
 	cmd_reconfig_device_queue(RTE_PORT_ALL, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_thresh_port =
+cmdline_parse_token_string_t cmd_config_thresh_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_thresh, port, "port");
-static cmdline_parse_token_string_t cmd_config_thresh_keyword =
+cmdline_parse_token_string_t cmd_config_thresh_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_thresh, keyword, "config");
-static cmdline_parse_token_string_t cmd_config_thresh_all =
+cmdline_parse_token_string_t cmd_config_thresh_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_thresh, all, "all");
-static cmdline_parse_token_string_t cmd_config_thresh_name =
+cmdline_parse_token_string_t cmd_config_thresh_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_thresh, name,
 				"txpt#txht#txwt#rxpt#rxht#rxwt");
-static cmdline_parse_token_num_t cmd_config_thresh_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_thresh, value, RTE_UINT8);
+cmdline_parse_token_num_t cmd_config_thresh_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_thresh, value, UINT8);
 
-static cmdline_parse_inst_t cmd_config_thresh = {
+cmdline_parse_inst_t cmd_config_thresh = {
 	.f = cmd_config_thresh_parsed,
 	.data = NULL,
 	.help_str = "port config all txpt|txht|txwt|rxpt|rxht|rxwt <value>",
@@ -3299,13 +3451,13 @@
 
 static void
 cmd_config_threshold_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_config_threshold *res = parsed_result;
 
 	if (!all_ports_stopped()) {
-		fprintf(stderr, "Please stop all ports first\n");
+		printf("Please stop all ports first\n");
 		return;
 	}
 
@@ -3316,7 +3468,7 @@
 	else if (!strcmp(res->name, "rxfreet"))
 		rx_free_thresh = res->value;
 	else {
-		fprintf(stderr, "Unknown parameter\n");
+		printf("Unknown parameter\n");
 		return;
 	}
 
@@ -3325,20 +3477,20 @@
 	cmd_reconfig_device_queue(RTE_PORT_ALL, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_config_threshold_port =
+cmdline_parse_token_string_t cmd_config_threshold_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_threshold, port, "port");
-static cmdline_parse_token_string_t cmd_config_threshold_keyword =
+cmdline_parse_token_string_t cmd_config_threshold_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_threshold, keyword,
 								"config");
-static cmdline_parse_token_string_t cmd_config_threshold_all =
+cmdline_parse_token_string_t cmd_config_threshold_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_threshold, all, "all");
-static cmdline_parse_token_string_t cmd_config_threshold_name =
+cmdline_parse_token_string_t cmd_config_threshold_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_threshold, name,
 						"txfreet#txrst#rxfreet");
-static cmdline_parse_token_num_t cmd_config_threshold_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_threshold, value, RTE_UINT16);
+cmdline_parse_token_num_t cmd_config_threshold_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_config_threshold, value, UINT16);
 
-static cmdline_parse_inst_t cmd_config_threshold = {
+cmdline_parse_inst_t cmd_config_threshold = {
 	.f = cmd_config_threshold_parsed,
 	.data = NULL,
 	.help_str = "port config all txfreet|txrst|rxfreet <value>",
@@ -3357,17 +3509,17 @@
 	cmdline_fixed_string_t stop;
 };
 
-static void cmd_stop_parsed(__rte_unused void *parsed_result,
-			    __rte_unused struct cmdline *cl,
-			    __rte_unused void *data)
+static void cmd_stop_parsed(__attribute__((unused)) void *parsed_result,
+			    __attribute__((unused)) struct cmdline *cl,
+			    __attribute__((unused)) void *data)
 {
 	stop_packet_forwarding();
 }
 
-static cmdline_parse_token_string_t cmd_stop_stop =
+cmdline_parse_token_string_t cmd_stop_stop =
 	TOKEN_STRING_INITIALIZER(struct cmd_stop_result, stop, "stop");
 
-static cmdline_parse_inst_t cmd_stop = {
+cmdline_parse_inst_t cmd_stop = {
 	.f = cmd_stop_parsed,
 	.data = NULL,
 	.help_str = "stop: Stop packet forwarding",
@@ -3377,94 +3529,10 @@
 	},
 };
 
-static unsigned int
-get_ptype(char *value)
-{
-	uint32_t protocol;
-
-	if (!strcmp(value, "eth"))
-		protocol = RTE_PTYPE_L2_ETHER;
-	else if (!strcmp(value, "ipv4"))
-		protocol = RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4_EXT_UNKNOWN;
-	else if (!strcmp(value, "ipv6"))
-		protocol = RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV6_EXT_UNKNOWN;
-	else if (!strcmp(value, "ipv4-tcp"))
-		protocol = RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_L4_TCP;
-	else if (!strcmp(value, "ipv4-udp"))
-		protocol = RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_L4_UDP;
-	else if (!strcmp(value, "ipv4-sctp"))
-		protocol = RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_L4_SCTP;
-	else if (!strcmp(value, "ipv6-tcp"))
-		protocol = RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_L4_TCP;
-	else if (!strcmp(value, "ipv6-udp"))
-		protocol = RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_L4_UDP;
-	else if (!strcmp(value, "ipv6-sctp"))
-		protocol = RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_L4_SCTP;
-	else if (!strcmp(value, "grenat"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT;
-	else if (!strcmp(value, "inner-eth"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER;
-	else if (!strcmp(value, "inner-ipv4"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-				RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN;
-	else if (!strcmp(value, "inner-ipv6"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-				RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN;
-	else if (!strcmp(value, "inner-ipv4-tcp"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-				RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_TCP;
-	else if (!strcmp(value, "inner-ipv4-udp"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-				RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_UDP;
-	else if (!strcmp(value, "inner-ipv4-sctp"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-				RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_SCTP;
-	else if (!strcmp(value, "inner-ipv6-tcp"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-				RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_TCP;
-	else if (!strcmp(value, "inner-ipv6-udp"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-				RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_UDP;
-	else if (!strcmp(value, "inner-ipv6-sctp"))
-		protocol = RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-				RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_SCTP;
-	else {
-		fprintf(stderr, "Unsupported protocol: %s\n", value);
-		protocol = RTE_PTYPE_UNKNOWN;
-	}
-
-	return protocol;
-}
-
-/* *** SET RXHDRSLIST *** */
-
-unsigned int
-parse_hdrs_list(const char *str, const char *item_name, unsigned int max_items,
-				unsigned int *parsed_items)
-{
-	unsigned int nb_item;
-	char *cur;
-	char *tmp;
-
-	nb_item = 0;
-	char *str2 = strdup(str);
-	cur = strtok_r(str2, ",", &tmp);
-	while (cur != NULL) {
-		parsed_items[nb_item] = get_ptype(cur);
-		cur = strtok_r(NULL, ",", &tmp);
-		nb_item++;
-	}
-	if (nb_item > max_items)
-		fprintf(stderr, "Number of %s = %u > %u (maximum items)\n",
-			item_name, nb_item + 1, max_items);
-	free(str2);
-	return nb_item;
-}
-
 /* *** SET CORELIST and PORTLIST CONFIGURATION *** */
 
 unsigned int
-parse_item_list(const char *str, const char *item_name, unsigned int max_items,
+parse_item_list(char* str, const char* item_name, unsigned int max_items,
 		unsigned int *parsed_items, int check_unique_values)
 {
 	unsigned int nb_item;
@@ -3488,11 +3556,11 @@
 			continue;
 		}
 		if (c != ',') {
-			fprintf(stderr, "character %c is not a decimal digit\n", c);
+			printf("character %c is not a decimal digit\n", c);
 			return 0;
 		}
 		if (! value_ok) {
-			fprintf(stderr, "No valid value before comma\n");
+			printf("No valid value before comma\n");
 			return 0;
 		}
 		if (nb_item < max_items) {
@@ -3503,8 +3571,8 @@
 		nb_item++;
 	}
 	if (nb_item >= max_items) {
-		fprintf(stderr, "Number of %s = %u > %u (maximum items)\n",
-			item_name, nb_item + 1, max_items);
+		printf("Number of %s = %u > %u (maximum items)\n",
+		       item_name, nb_item + 1, max_items);
 		return 0;
 	}
 	parsed_items[nb_item++] = value;
@@ -3512,15 +3580,14 @@
 		return nb_item;
 
 	/*
-	 * Then, check that all values in the list are different.
+	 * Then, check that all values in the list are differents.
 	 * No optimization here...
 	 */
 	for (i = 0; i < nb_item; i++) {
 		for (j = i + 1; j < nb_item; j++) {
 			if (parsed_items[j] == parsed_items[i]) {
-				fprintf(stderr,
-					"duplicated %s %u at index %u and %u\n",
-					item_name, parsed_items[i], i, j);
+				printf("duplicated %s %u at index %u and %u\n",
+				       item_name, parsed_items[i], i, j);
 				return 0;
 			}
 		}
@@ -3535,8 +3602,8 @@
 };
 
 static void cmd_set_list_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_set_list_result *res;
 	union {
@@ -3546,7 +3613,7 @@
 	unsigned int nb_item;
 
 	if (test_done == 0) {
-		fprintf(stderr, "Please stop forwarding first\n");
+		printf("Please stop forwarding first\n");
 		return;
 	}
 
@@ -3572,17 +3639,17 @@
 	}
 }
 
-static cmdline_parse_token_string_t cmd_set_list_keyword =
+cmdline_parse_token_string_t cmd_set_list_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_list_result, cmd_keyword,
 				 "set");
-static cmdline_parse_token_string_t cmd_set_list_name =
+cmdline_parse_token_string_t cmd_set_list_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_list_result, list_name,
 				 "corelist#portlist");
-static cmdline_parse_token_string_t cmd_set_list_of_items =
+cmdline_parse_token_string_t cmd_set_list_of_items =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_list_result, list_of_items,
 				 NULL);
 
-static cmdline_parse_inst_t cmd_set_fwd_list = {
+cmdline_parse_inst_t cmd_set_fwd_list = {
 	.f = cmd_set_list_parsed,
 	.data = NULL,
 	.help_str = "set corelist|portlist <list0[,list1]*>",
@@ -3603,13 +3670,13 @@
 };
 
 static void cmd_set_mask_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_setmask_result *res = parsed_result;
 
 	if (test_done == 0) {
-		fprintf(stderr, "Please stop forwarding first\n");
+		printf("Please stop forwarding first\n");
 		return;
 	}
 	if (!strcmp(res->mask, "coremask")) {
@@ -3621,15 +3688,15 @@
 	}
 }
 
-static cmdline_parse_token_string_t cmd_setmask_set =
+cmdline_parse_token_string_t cmd_setmask_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_setmask_result, set, "set");
-static cmdline_parse_token_string_t cmd_setmask_mask =
+cmdline_parse_token_string_t cmd_setmask_mask =
 	TOKEN_STRING_INITIALIZER(struct cmd_setmask_result, mask,
 				 "coremask#portmask");
-static cmdline_parse_token_num_t cmd_setmask_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_setmask_result, hexavalue, RTE_UINT64);
+cmdline_parse_token_num_t cmd_setmask_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_setmask_result, hexavalue, UINT64);
 
-static cmdline_parse_inst_t cmd_set_fwd_mask = {
+cmdline_parse_inst_t cmd_set_fwd_mask = {
 	.f = cmd_set_mask_parsed,
 	.data = NULL,
 	.help_str = "set coremask|portmask <hexadecimal value>",
@@ -3651,8 +3718,8 @@
 };
 
 static void cmd_set_parsed(void *parsed_result,
-			   __rte_unused struct cmdline *cl,
-			   __rte_unused void *data)
+			   __attribute__((unused)) struct cmdline *cl,
+			   __attribute__((unused)) void *data)
 {
 	struct cmd_set_result *res = parsed_result;
 	if (!strcmp(res->what, "nbport")) {
@@ -3667,15 +3734,15 @@
 		set_verbose_level(res->value);
 }
 
-static cmdline_parse_token_string_t cmd_set_set =
+cmdline_parse_token_string_t cmd_set_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_what =
+cmdline_parse_token_string_t cmd_set_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_result, what,
 				 "nbport#nbcore#burst#verbose");
-static cmdline_parse_token_num_t cmd_set_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_result, value, RTE_UINT16);
+cmdline_parse_token_num_t cmd_set_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_result, value, UINT16);
 
-static cmdline_parse_inst_t cmd_set_numbers = {
+cmdline_parse_inst_t cmd_set_numbers = {
 	.f = cmd_set_parsed,
 	.data = NULL,
 	.help_str = "set nbport|nbcore|burst|verbose <value>",
@@ -3698,8 +3765,8 @@
 
 static void
 cmd_set_log_parsed(void *parsed_result,
-		   __rte_unused struct cmdline *cl,
-		   __rte_unused void *data)
+		   __attribute__((unused)) struct cmdline *cl,
+		   __attribute__((unused)) void *data)
 {
 	struct cmd_set_log_result *res;
 	int ret;
@@ -3710,20 +3777,20 @@
 	else {
 		ret = rte_log_set_level_regexp(res->type, res->level);
 		if (ret < 0)
-			fprintf(stderr, "Unable to set log level\n");
+			printf("Unable to set log level\n");
 	}
 }
 
-static cmdline_parse_token_string_t cmd_set_log_set =
+cmdline_parse_token_string_t cmd_set_log_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_log_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_log_log =
+cmdline_parse_token_string_t cmd_set_log_log =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_log_result, log, "log");
-static cmdline_parse_token_string_t cmd_set_log_type =
+cmdline_parse_token_string_t cmd_set_log_type =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_log_result, type, NULL);
-static cmdline_parse_token_num_t cmd_set_log_level =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_log_result, level, RTE_UINT32);
+cmdline_parse_token_num_t cmd_set_log_level =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_log_result, level, UINT32);
 
-static cmdline_parse_inst_t cmd_set_log = {
+cmdline_parse_inst_t cmd_set_log = {
 	.f = cmd_set_log_parsed,
 	.data = NULL,
 	.help_str = "set log global|<type> <level>",
@@ -3736,146 +3803,6 @@
 	},
 };
 
-/* *** SET SEGMENT OFFSETS OF RX PACKETS SPLIT *** */
-
-struct cmd_set_rxoffs_result {
-	cmdline_fixed_string_t cmd_keyword;
-	cmdline_fixed_string_t rxoffs;
-	cmdline_fixed_string_t seg_offsets;
-};
-
-static void
-cmd_set_rxoffs_parsed(void *parsed_result,
-		      __rte_unused struct cmdline *cl,
-		      __rte_unused void *data)
-{
-	struct cmd_set_rxoffs_result *res;
-	unsigned int seg_offsets[MAX_SEGS_BUFFER_SPLIT];
-	unsigned int nb_segs;
-
-	res = parsed_result;
-	nb_segs = parse_item_list(res->seg_offsets, "segment offsets",
-				  MAX_SEGS_BUFFER_SPLIT, seg_offsets, 0);
-	if (nb_segs > 0)
-		set_rx_pkt_offsets(seg_offsets, nb_segs);
-	cmd_reconfig_device_queue(RTE_PORT_ALL, 0, 1);
-}
-
-static cmdline_parse_token_string_t cmd_set_rxoffs_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxoffs_result,
-				 cmd_keyword, "set");
-static cmdline_parse_token_string_t cmd_set_rxoffs_name =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxoffs_result,
-				 rxoffs, "rxoffs");
-static cmdline_parse_token_string_t cmd_set_rxoffs_offsets =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxoffs_result,
-				 seg_offsets, NULL);
-
-static cmdline_parse_inst_t cmd_set_rxoffs = {
-	.f = cmd_set_rxoffs_parsed,
-	.data = NULL,
-	.help_str = "set rxoffs <len0[,len1]*>",
-	.tokens = {
-		(void *)&cmd_set_rxoffs_keyword,
-		(void *)&cmd_set_rxoffs_name,
-		(void *)&cmd_set_rxoffs_offsets,
-		NULL,
-	},
-};
-
-/* *** SET SEGMENT LENGTHS OF RX PACKETS SPLIT *** */
-
-struct cmd_set_rxpkts_result {
-	cmdline_fixed_string_t cmd_keyword;
-	cmdline_fixed_string_t rxpkts;
-	cmdline_fixed_string_t seg_lengths;
-};
-
-static void
-cmd_set_rxpkts_parsed(void *parsed_result,
-		      __rte_unused struct cmdline *cl,
-		      __rte_unused void *data)
-{
-	struct cmd_set_rxpkts_result *res;
-	unsigned int seg_lengths[MAX_SEGS_BUFFER_SPLIT];
-	unsigned int nb_segs;
-
-	res = parsed_result;
-	nb_segs = parse_item_list(res->seg_lengths, "segment lengths",
-				  MAX_SEGS_BUFFER_SPLIT, seg_lengths, 0);
-	if (nb_segs > 0)
-		set_rx_pkt_segments(seg_lengths, nb_segs);
-	cmd_reconfig_device_queue(RTE_PORT_ALL, 0, 1);
-}
-
-static cmdline_parse_token_string_t cmd_set_rxpkts_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxpkts_result,
-				 cmd_keyword, "set");
-static cmdline_parse_token_string_t cmd_set_rxpkts_name =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxpkts_result,
-				 rxpkts, "rxpkts");
-static cmdline_parse_token_string_t cmd_set_rxpkts_lengths =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxpkts_result,
-				 seg_lengths, NULL);
-
-static cmdline_parse_inst_t cmd_set_rxpkts = {
-	.f = cmd_set_rxpkts_parsed,
-	.data = NULL,
-	.help_str = "set rxpkts <len0[,len1]*>",
-	.tokens = {
-		(void *)&cmd_set_rxpkts_keyword,
-		(void *)&cmd_set_rxpkts_name,
-		(void *)&cmd_set_rxpkts_lengths,
-		NULL,
-	},
-};
-
-/* *** SET SEGMENT HEADERS OF RX PACKETS SPLIT *** */
-struct cmd_set_rxhdrs_result {
-	cmdline_fixed_string_t set;
-	cmdline_fixed_string_t rxhdrs;
-	cmdline_fixed_string_t values;
-};
-
-static void
-cmd_set_rxhdrs_parsed(void *parsed_result,
-		      __rte_unused struct cmdline *cl,
-		      __rte_unused void *data)
-{
-	struct cmd_set_rxhdrs_result *res;
-	unsigned int seg_hdrs[MAX_SEGS_BUFFER_SPLIT];
-	unsigned int nb_segs;
-
-	res = parsed_result;
-	nb_segs = parse_hdrs_list(res->values, "segment hdrs",
-				  MAX_SEGS_BUFFER_SPLIT, seg_hdrs);
-	if (nb_segs > 0)
-		set_rx_pkt_hdrs(seg_hdrs, nb_segs);
-	cmd_reconfig_device_queue(RTE_PORT_ALL, 0, 1);
-}
-
-static cmdline_parse_token_string_t cmd_set_rxhdrs_set =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxhdrs_result,
-				set, "set");
-static cmdline_parse_token_string_t cmd_set_rxhdrs_rxhdrs =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxhdrs_result,
-				rxhdrs, "rxhdrs");
-static cmdline_parse_token_string_t cmd_set_rxhdrs_values =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxhdrs_result,
-				values, NULL);
-
-static cmdline_parse_inst_t cmd_set_rxhdrs = {
-	.f = cmd_set_rxhdrs_parsed,
-	.data = NULL,
-	.help_str = "set rxhdrs <eth[,ipv4]*>",
-	.tokens = {
-		(void *)&cmd_set_rxhdrs_set,
-		(void *)&cmd_set_rxhdrs_rxhdrs,
-		(void *)&cmd_set_rxhdrs_values,
-		NULL,
-	},
-};
-
 /* *** SET SEGMENT LENGTHS OF TXONLY PACKETS *** */
 
 struct cmd_set_txpkts_result {
@@ -3886,8 +3813,8 @@
 
 static void
 cmd_set_txpkts_parsed(void *parsed_result,
-		      __rte_unused struct cmdline *cl,
-		      __rte_unused void *data)
+		      __attribute__((unused)) struct cmdline *cl,
+		      __attribute__((unused)) void *data)
 {
 	struct cmd_set_txpkts_result *res;
 	unsigned seg_lengths[RTE_MAX_SEGS_PER_PKT];
@@ -3900,17 +3827,17 @@
 		set_tx_pkt_segments(seg_lengths, nb_segs);
 }
 
-static cmdline_parse_token_string_t cmd_set_txpkts_keyword =
+cmdline_parse_token_string_t cmd_set_txpkts_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_txpkts_result,
 				 cmd_keyword, "set");
-static cmdline_parse_token_string_t cmd_set_txpkts_name =
+cmdline_parse_token_string_t cmd_set_txpkts_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_txpkts_result,
 				 txpkts, "txpkts");
-static cmdline_parse_token_string_t cmd_set_txpkts_lengths =
+cmdline_parse_token_string_t cmd_set_txpkts_lengths =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_txpkts_result,
 				 seg_lengths, NULL);
 
-static cmdline_parse_inst_t cmd_set_txpkts = {
+cmdline_parse_inst_t cmd_set_txpkts = {
 	.f = cmd_set_txpkts_parsed,
 	.data = NULL,
 	.help_str = "set txpkts <len0[,len1]*>",
@@ -3932,8 +3859,8 @@
 
 static void
 cmd_set_txsplit_parsed(void *parsed_result,
-		      __rte_unused struct cmdline *cl,
-		      __rte_unused void *data)
+		      __attribute__((unused)) struct cmdline *cl,
+		      __attribute__((unused)) void *data)
 {
 	struct cmd_set_txsplit_result *res;
 
@@ -3941,17 +3868,17 @@
 	set_tx_pkt_split(res->mode);
 }
 
-static cmdline_parse_token_string_t cmd_set_txsplit_keyword =
+cmdline_parse_token_string_t cmd_set_txsplit_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_txsplit_result,
 				 cmd_keyword, "set");
-static cmdline_parse_token_string_t cmd_set_txsplit_name =
+cmdline_parse_token_string_t cmd_set_txsplit_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_txsplit_result,
 				 txsplit, "txsplit");
-static cmdline_parse_token_string_t cmd_set_txsplit_mode =
+cmdline_parse_token_string_t cmd_set_txsplit_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_txsplit_result,
 				 mode, NULL);
 
-static cmdline_parse_inst_t cmd_set_txsplit = {
+cmdline_parse_inst_t cmd_set_txsplit = {
 	.f = cmd_set_txsplit_parsed,
 	.data = NULL,
 	.help_str = "set txsplit on|off|rand",
@@ -3963,52 +3890,6 @@
 	},
 };
 
-/* *** SET TIMES FOR TXONLY PACKETS SCHEDULING ON TIMESTAMPS *** */
-
-struct cmd_set_txtimes_result {
-	cmdline_fixed_string_t cmd_keyword;
-	cmdline_fixed_string_t txtimes;
-	cmdline_fixed_string_t tx_times;
-};
-
-static void
-cmd_set_txtimes_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
-{
-	struct cmd_set_txtimes_result *res;
-	unsigned int tx_times[2] = {0, 0};
-	unsigned int n_times;
-
-	res = parsed_result;
-	n_times = parse_item_list(res->tx_times, "tx times",
-				  2, tx_times, 0);
-	if (n_times == 2)
-		set_tx_pkt_times(tx_times);
-}
-
-static cmdline_parse_token_string_t cmd_set_txtimes_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_txtimes_result,
-				 cmd_keyword, "set");
-static cmdline_parse_token_string_t cmd_set_txtimes_name =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_txtimes_result,
-				 txtimes, "txtimes");
-static cmdline_parse_token_string_t cmd_set_txtimes_value =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_txtimes_result,
-				 tx_times, NULL);
-
-static cmdline_parse_inst_t cmd_set_txtimes = {
-	.f = cmd_set_txtimes_parsed,
-	.data = NULL,
-	.help_str = "set txtimes <inter_burst>,<intra_burst>",
-	.tokens = {
-		(void *)&cmd_set_txtimes_keyword,
-		(void *)&cmd_set_txtimes_name,
-		(void *)&cmd_set_txtimes_value,
-		NULL,
-	},
-};
-
 /* *** ADD/REMOVE ALL VLAN IDENTIFIERS TO/FROM A PORT VLAN RX FILTER *** */
 struct cmd_rx_vlan_filter_all_result {
 	cmdline_fixed_string_t rx_vlan;
@@ -4019,8 +3900,8 @@
 
 static void
 cmd_rx_vlan_filter_all_parsed(void *parsed_result,
-			      __rte_unused struct cmdline *cl,
-			      __rte_unused void *data)
+			      __attribute__((unused)) struct cmdline *cl,
+			      __attribute__((unused)) void *data)
 {
 	struct cmd_rx_vlan_filter_all_result *res = parsed_result;
 
@@ -4030,20 +3911,20 @@
 		rx_vlan_all_filter_set(res->port_id, 0);
 }
 
-static cmdline_parse_token_string_t cmd_rx_vlan_filter_all_rx_vlan =
+cmdline_parse_token_string_t cmd_rx_vlan_filter_all_rx_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_rx_vlan_filter_all_result,
 				 rx_vlan, "rx_vlan");
-static cmdline_parse_token_string_t cmd_rx_vlan_filter_all_what =
+cmdline_parse_token_string_t cmd_rx_vlan_filter_all_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_rx_vlan_filter_all_result,
 				 what, "add#rm");
-static cmdline_parse_token_string_t cmd_rx_vlan_filter_all_all =
+cmdline_parse_token_string_t cmd_rx_vlan_filter_all_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_rx_vlan_filter_all_result,
 				 all, "all");
-static cmdline_parse_token_num_t cmd_rx_vlan_filter_all_portid =
+cmdline_parse_token_num_t cmd_rx_vlan_filter_all_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_rx_vlan_filter_all_result,
-			      port_id, RTE_UINT16);
+			      port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_rx_vlan_filter_all = {
+cmdline_parse_inst_t cmd_rx_vlan_filter_all = {
 	.f = cmd_rx_vlan_filter_all_parsed,
 	.data = NULL,
 	.help_str = "rx_vlan add|rm all <port_id>: "
@@ -4070,8 +3951,8 @@
 
 static void
 cmd_vlan_offload_parsed(void *parsed_result,
-			  __rte_unused struct cmdline *cl,
-			  __rte_unused void *data)
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
 {
 	int on;
 	struct cmd_vlan_offload_result *res = parsed_result;
@@ -4109,7 +3990,7 @@
 
 		/* No queue_id, return */
 		if(i + 1 >= len) {
-			fprintf(stderr, "must specify (port,queue_id)\n");
+			printf("must specify (port,queue_id)\n");
 			return;
 		}
 		tmp = strtoul(str + i + 1, NULL, 0);
@@ -4130,23 +4011,23 @@
 	return;
 }
 
-static cmdline_parse_token_string_t cmd_vlan_offload_vlan =
+cmdline_parse_token_string_t cmd_vlan_offload_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_vlan_offload_result,
 				 vlan, "vlan");
-static cmdline_parse_token_string_t cmd_vlan_offload_set =
+cmdline_parse_token_string_t cmd_vlan_offload_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_vlan_offload_result,
 				 set, "set");
-static cmdline_parse_token_string_t cmd_vlan_offload_what =
+cmdline_parse_token_string_t cmd_vlan_offload_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_vlan_offload_result,
 				what, "strip#filter#qinq_strip#extend#stripq");
-static cmdline_parse_token_string_t cmd_vlan_offload_on =
+cmdline_parse_token_string_t cmd_vlan_offload_on =
 	TOKEN_STRING_INITIALIZER(struct cmd_vlan_offload_result,
 			      on, "on#off");
-static cmdline_parse_token_string_t cmd_vlan_offload_portid =
+cmdline_parse_token_string_t cmd_vlan_offload_portid =
 	TOKEN_STRING_INITIALIZER(struct cmd_vlan_offload_result,
 			      port_id, NULL);
 
-static cmdline_parse_inst_t cmd_vlan_offload = {
+cmdline_parse_inst_t cmd_vlan_offload = {
 	.f = cmd_vlan_offload_parsed,
 	.data = NULL,
 	.help_str = "vlan set strip|filter|qinq_strip|extend|stripq on|off "
@@ -4174,43 +4055,43 @@
 
 static void
 cmd_vlan_tpid_parsed(void *parsed_result,
-			  __rte_unused struct cmdline *cl,
-			  __rte_unused void *data)
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
 {
 	struct cmd_vlan_tpid_result *res = parsed_result;
 	enum rte_vlan_type vlan_type;
 
 	if (!strcmp(res->vlan_type, "inner"))
-		vlan_type = RTE_ETH_VLAN_TYPE_INNER;
+		vlan_type = ETH_VLAN_TYPE_INNER;
 	else if (!strcmp(res->vlan_type, "outer"))
-		vlan_type = RTE_ETH_VLAN_TYPE_OUTER;
+		vlan_type = ETH_VLAN_TYPE_OUTER;
 	else {
-		fprintf(stderr, "Unknown vlan type\n");
+		printf("Unknown vlan type\n");
 		return;
 	}
 	vlan_tpid_set(res->port_id, vlan_type, res->tp_id);
 }
 
-static cmdline_parse_token_string_t cmd_vlan_tpid_vlan =
+cmdline_parse_token_string_t cmd_vlan_tpid_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_vlan_tpid_result,
 				 vlan, "vlan");
-static cmdline_parse_token_string_t cmd_vlan_tpid_set =
+cmdline_parse_token_string_t cmd_vlan_tpid_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_vlan_tpid_result,
 				 set, "set");
-static cmdline_parse_token_string_t cmd_vlan_type =
+cmdline_parse_token_string_t cmd_vlan_type =
 	TOKEN_STRING_INITIALIZER(struct cmd_vlan_tpid_result,
 				 vlan_type, "inner#outer");
-static cmdline_parse_token_string_t cmd_vlan_tpid_what =
+cmdline_parse_token_string_t cmd_vlan_tpid_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_vlan_tpid_result,
 				 what, "tpid");
-static cmdline_parse_token_num_t cmd_vlan_tpid_tpid =
+cmdline_parse_token_num_t cmd_vlan_tpid_tpid =
 	TOKEN_NUM_INITIALIZER(struct cmd_vlan_tpid_result,
-			      tp_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_vlan_tpid_portid =
+			      tp_id, UINT16);
+cmdline_parse_token_num_t cmd_vlan_tpid_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_vlan_tpid_result,
-			      port_id, RTE_UINT16);
+			      port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_vlan_tpid = {
+cmdline_parse_inst_t cmd_vlan_tpid = {
 	.f = cmd_vlan_tpid_parsed,
 	.data = NULL,
 	.help_str = "vlan set inner|outer tpid <tp_id> <port_id>: "
@@ -4236,8 +4117,8 @@
 
 static void
 cmd_rx_vlan_filter_parsed(void *parsed_result,
-			  __rte_unused struct cmdline *cl,
-			  __rte_unused void *data)
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
 {
 	struct cmd_rx_vlan_filter_result *res = parsed_result;
 
@@ -4247,20 +4128,20 @@
 		rx_vft_set(res->port_id, res->vlan_id, 0);
 }
 
-static cmdline_parse_token_string_t cmd_rx_vlan_filter_rx_vlan =
+cmdline_parse_token_string_t cmd_rx_vlan_filter_rx_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_rx_vlan_filter_result,
 				 rx_vlan, "rx_vlan");
-static cmdline_parse_token_string_t cmd_rx_vlan_filter_what =
+cmdline_parse_token_string_t cmd_rx_vlan_filter_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_rx_vlan_filter_result,
 				 what, "add#rm");
-static cmdline_parse_token_num_t cmd_rx_vlan_filter_vlanid =
+cmdline_parse_token_num_t cmd_rx_vlan_filter_vlanid =
 	TOKEN_NUM_INITIALIZER(struct cmd_rx_vlan_filter_result,
-			      vlan_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_rx_vlan_filter_portid =
+			      vlan_id, UINT16);
+cmdline_parse_token_num_t cmd_rx_vlan_filter_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_rx_vlan_filter_result,
-			      port_id, RTE_UINT16);
+			      port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_rx_vlan_filter = {
+cmdline_parse_inst_t cmd_rx_vlan_filter = {
 	.f = cmd_rx_vlan_filter_parsed,
 	.data = NULL,
 	.help_str = "rx_vlan add|rm <vlan_id> <port_id>: "
@@ -4285,16 +4166,13 @@
 
 static void
 cmd_tx_vlan_set_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	struct cmd_tx_vlan_set_result *res = parsed_result;
 
-	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
-		return;
-
 	if (!port_is_stopped(res->port_id)) {
-		fprintf(stderr, "Please stop port %d first\n", res->port_id);
+		printf("Please stop port %d first\n", res->port_id);
 		return;
 	}
 
@@ -4303,20 +4181,20 @@
 	cmd_reconfig_device_queue(res->port_id, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_tx_vlan_set_tx_vlan =
+cmdline_parse_token_string_t cmd_tx_vlan_set_tx_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_set_result,
 				 tx_vlan, "tx_vlan");
-static cmdline_parse_token_string_t cmd_tx_vlan_set_set =
+cmdline_parse_token_string_t cmd_tx_vlan_set_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_set_result,
 				 set, "set");
-static cmdline_parse_token_num_t cmd_tx_vlan_set_portid =
+cmdline_parse_token_num_t cmd_tx_vlan_set_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_tx_vlan_set_result,
-			      port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_tx_vlan_set_vlanid =
+			      port_id, UINT16);
+cmdline_parse_token_num_t cmd_tx_vlan_set_vlanid =
 	TOKEN_NUM_INITIALIZER(struct cmd_tx_vlan_set_result,
-			      vlan_id, RTE_UINT16);
+			      vlan_id, UINT16);
 
-static cmdline_parse_inst_t cmd_tx_vlan_set = {
+cmdline_parse_inst_t cmd_tx_vlan_set = {
 	.f = cmd_tx_vlan_set_parsed,
 	.data = NULL,
 	.help_str = "tx_vlan set <port_id> <vlan_id>: "
@@ -4342,16 +4220,13 @@
 
 static void
 cmd_tx_vlan_set_qinq_parsed(void *parsed_result,
-			    __rte_unused struct cmdline *cl,
-			    __rte_unused void *data)
+			    __attribute__((unused)) struct cmdline *cl,
+			    __attribute__((unused)) void *data)
 {
 	struct cmd_tx_vlan_set_qinq_result *res = parsed_result;
 
-	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
-		return;
-
 	if (!port_is_stopped(res->port_id)) {
-		fprintf(stderr, "Please stop port %d first\n", res->port_id);
+		printf("Please stop port %d first\n", res->port_id);
 		return;
 	}
 
@@ -4360,23 +4235,23 @@
 	cmd_reconfig_device_queue(res->port_id, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_tx_vlan_set_qinq_tx_vlan =
+cmdline_parse_token_string_t cmd_tx_vlan_set_qinq_tx_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_set_qinq_result,
 		tx_vlan, "tx_vlan");
-static cmdline_parse_token_string_t cmd_tx_vlan_set_qinq_set =
+cmdline_parse_token_string_t cmd_tx_vlan_set_qinq_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_set_qinq_result,
 		set, "set");
-static cmdline_parse_token_num_t cmd_tx_vlan_set_qinq_portid =
+cmdline_parse_token_num_t cmd_tx_vlan_set_qinq_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_tx_vlan_set_qinq_result,
-		port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_tx_vlan_set_qinq_vlanid =
+		port_id, UINT16);
+cmdline_parse_token_num_t cmd_tx_vlan_set_qinq_vlanid =
 	TOKEN_NUM_INITIALIZER(struct cmd_tx_vlan_set_qinq_result,
-		vlan_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_tx_vlan_set_qinq_vlanid_outer =
+		vlan_id, UINT16);
+cmdline_parse_token_num_t cmd_tx_vlan_set_qinq_vlanid_outer =
 	TOKEN_NUM_INITIALIZER(struct cmd_tx_vlan_set_qinq_result,
-		vlan_id_outer, RTE_UINT16);
+		vlan_id_outer, UINT16);
 
-static cmdline_parse_inst_t cmd_tx_vlan_set_qinq = {
+cmdline_parse_inst_t cmd_tx_vlan_set_qinq = {
 	.f = cmd_tx_vlan_set_qinq_parsed,
 	.data = NULL,
 	.help_str = "tx_vlan set <port_id> <vlan_id> <outer_vlan_id>: "
@@ -4404,8 +4279,8 @@
 
 static void
 cmd_tx_vlan_set_pvid_parsed(void *parsed_result,
-			    __rte_unused struct cmdline *cl,
-			    __rte_unused void *data)
+			    __attribute__((unused)) struct cmdline *cl,
+			    __attribute__((unused)) void *data)
 {
 	struct cmd_tx_vlan_set_pvid_result *res = parsed_result;
 
@@ -4415,26 +4290,26 @@
 		tx_vlan_pvid_set(res->port_id, res->vlan_id, 0);
 }
 
-static cmdline_parse_token_string_t cmd_tx_vlan_set_pvid_tx_vlan =
+cmdline_parse_token_string_t cmd_tx_vlan_set_pvid_tx_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_set_pvid_result,
 				 tx_vlan, "tx_vlan");
-static cmdline_parse_token_string_t cmd_tx_vlan_set_pvid_set =
+cmdline_parse_token_string_t cmd_tx_vlan_set_pvid_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_set_pvid_result,
 				 set, "set");
-static cmdline_parse_token_string_t cmd_tx_vlan_set_pvid_pvid =
+cmdline_parse_token_string_t cmd_tx_vlan_set_pvid_pvid =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_set_pvid_result,
 				 pvid, "pvid");
-static cmdline_parse_token_num_t cmd_tx_vlan_set_pvid_port_id =
+cmdline_parse_token_num_t cmd_tx_vlan_set_pvid_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_tx_vlan_set_pvid_result,
-			     port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_tx_vlan_set_pvid_vlan_id =
+			     port_id, UINT16);
+cmdline_parse_token_num_t cmd_tx_vlan_set_pvid_vlan_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_tx_vlan_set_pvid_result,
-			      vlan_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_tx_vlan_set_pvid_mode =
+			      vlan_id, UINT16);
+cmdline_parse_token_string_t cmd_tx_vlan_set_pvid_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_set_pvid_result,
 				 mode, "on#off");
 
-static cmdline_parse_inst_t cmd_tx_vlan_set_pvid = {
+cmdline_parse_inst_t cmd_tx_vlan_set_pvid = {
 	.f = cmd_tx_vlan_set_pvid_parsed,
 	.data = NULL,
 	.help_str = "tx_vlan set pvid <port_id> <vlan_id> on|off",
@@ -4458,16 +4333,13 @@
 
 static void
 cmd_tx_vlan_reset_parsed(void *parsed_result,
-			 __rte_unused struct cmdline *cl,
-			 __rte_unused void *data)
+			 __attribute__((unused)) struct cmdline *cl,
+			 __attribute__((unused)) void *data)
 {
 	struct cmd_tx_vlan_reset_result *res = parsed_result;
 
-	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
-		return;
-
 	if (!port_is_stopped(res->port_id)) {
-		fprintf(stderr, "Please stop port %d first\n", res->port_id);
+		printf("Please stop port %d first\n", res->port_id);
 		return;
 	}
 
@@ -4476,17 +4348,17 @@
 	cmd_reconfig_device_queue(res->port_id, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_tx_vlan_reset_tx_vlan =
+cmdline_parse_token_string_t cmd_tx_vlan_reset_tx_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_reset_result,
 				 tx_vlan, "tx_vlan");
-static cmdline_parse_token_string_t cmd_tx_vlan_reset_reset =
+cmdline_parse_token_string_t cmd_tx_vlan_reset_reset =
 	TOKEN_STRING_INITIALIZER(struct cmd_tx_vlan_reset_result,
 				 reset, "reset");
-static cmdline_parse_token_num_t cmd_tx_vlan_reset_portid =
+cmdline_parse_token_num_t cmd_tx_vlan_reset_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_tx_vlan_reset_result,
-			      port_id, RTE_UINT16);
+			      port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_tx_vlan_reset = {
+cmdline_parse_inst_t cmd_tx_vlan_reset = {
 	.f = cmd_tx_vlan_reset_parsed,
 	.data = NULL,
 	.help_str = "tx_vlan reset <port_id>: Disable hardware insertion of a "
@@ -4520,59 +4392,53 @@
 	printf("Parse tunnel is %s\n",
 		(ports[port_id].parse_tunnel) ? "on" : "off");
 	printf("IP checksum offload is %s\n",
-		(tx_offloads & RTE_ETH_TX_OFFLOAD_IPV4_CKSUM) ? "hw" : "sw");
+		(tx_offloads & DEV_TX_OFFLOAD_IPV4_CKSUM) ? "hw" : "sw");
 	printf("UDP checksum offload is %s\n",
-		(tx_offloads & RTE_ETH_TX_OFFLOAD_UDP_CKSUM) ? "hw" : "sw");
+		(tx_offloads & DEV_TX_OFFLOAD_UDP_CKSUM) ? "hw" : "sw");
 	printf("TCP checksum offload is %s\n",
-		(tx_offloads & RTE_ETH_TX_OFFLOAD_TCP_CKSUM) ? "hw" : "sw");
+		(tx_offloads & DEV_TX_OFFLOAD_TCP_CKSUM) ? "hw" : "sw");
 	printf("SCTP checksum offload is %s\n",
-		(tx_offloads & RTE_ETH_TX_OFFLOAD_SCTP_CKSUM) ? "hw" : "sw");
+		(tx_offloads & DEV_TX_OFFLOAD_SCTP_CKSUM) ? "hw" : "sw");
 	printf("Outer-Ip checksum offload is %s\n",
-		(tx_offloads & RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM) ? "hw" : "sw");
+		(tx_offloads & DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM) ? "hw" : "sw");
 	printf("Outer-Udp checksum offload is %s\n",
-		(tx_offloads & RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM) ? "hw" : "sw");
+		(tx_offloads & DEV_TX_OFFLOAD_OUTER_UDP_CKSUM) ? "hw" : "sw");
 
 	/* display warnings if configuration is not supported by the NIC */
 	ret = eth_dev_info_get_print_err(port_id, &dev_info);
 	if (ret != 0)
 		return;
 
-	if ((tx_offloads & RTE_ETH_TX_OFFLOAD_IPV4_CKSUM) &&
-		(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_IPV4_CKSUM) == 0) {
-		fprintf(stderr,
-			"Warning: hardware IP checksum enabled but not supported by port %d\n",
-			port_id);
-	}
-	if ((tx_offloads & RTE_ETH_TX_OFFLOAD_UDP_CKSUM) &&
-		(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_UDP_CKSUM) == 0) {
-		fprintf(stderr,
-			"Warning: hardware UDP checksum enabled but not supported by port %d\n",
-			port_id);
-	}
-	if ((tx_offloads & RTE_ETH_TX_OFFLOAD_TCP_CKSUM) &&
-		(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_TCP_CKSUM) == 0) {
-		fprintf(stderr,
-			"Warning: hardware TCP checksum enabled but not supported by port %d\n",
-			port_id);
-	}
-	if ((tx_offloads & RTE_ETH_TX_OFFLOAD_SCTP_CKSUM) &&
-		(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_SCTP_CKSUM) == 0) {
-		fprintf(stderr,
-			"Warning: hardware SCTP checksum enabled but not supported by port %d\n",
-			port_id);
-	}
-	if ((tx_offloads & RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM) &&
-		(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM) == 0) {
-		fprintf(stderr,
-			"Warning: hardware outer IP checksum enabled but not supported by port %d\n",
-			port_id);
+	if ((tx_offloads & DEV_TX_OFFLOAD_IPV4_CKSUM) &&
+		(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_IPV4_CKSUM) == 0) {
+		printf("Warning: hardware IP checksum enabled but not "
+			"supported by port %d\n", port_id);
+	}
+	if ((tx_offloads & DEV_TX_OFFLOAD_UDP_CKSUM) &&
+		(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_UDP_CKSUM) == 0) {
+		printf("Warning: hardware UDP checksum enabled but not "
+			"supported by port %d\n", port_id);
+	}
+	if ((tx_offloads & DEV_TX_OFFLOAD_TCP_CKSUM) &&
+		(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_TCP_CKSUM) == 0) {
+		printf("Warning: hardware TCP checksum enabled but not "
+			"supported by port %d\n", port_id);
+	}
+	if ((tx_offloads & DEV_TX_OFFLOAD_SCTP_CKSUM) &&
+		(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_SCTP_CKSUM) == 0) {
+		printf("Warning: hardware SCTP checksum enabled but not "
+			"supported by port %d\n", port_id);
+	}
+	if ((tx_offloads & DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM) &&
+		(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM) == 0) {
+		printf("Warning: hardware outer IP checksum enabled but not "
+			"supported by port %d\n", port_id);
 	}
-	if ((tx_offloads & RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM) &&
-		(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM)
+	if ((tx_offloads & DEV_TX_OFFLOAD_OUTER_UDP_CKSUM) &&
+		(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_OUTER_UDP_CKSUM)
 			== 0) {
-		fprintf(stderr,
-			"Warning: hardware outer UDP checksum enabled but not supported by port %d\n",
-			port_id);
+		printf("Warning: hardware outer UDP checksum enabled but not "
+			"supported by port %d\n", port_id);
 	}
 }
 
@@ -4582,15 +4448,15 @@
 	int k;
 
 	/* Apply queue tx offloads configuration */
-	for (k = 0; k < port->dev_info.max_tx_queues; k++)
-		port->txq[k].conf.offloads =
+	for (k = 0; k < port->dev_info.max_rx_queues; k++)
+		port->tx_conf[k].offloads =
 			port->dev_conf.txmode.offloads;
 }
 
 static void
 cmd_csum_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	struct cmd_csum_result *res = parsed_result;
 	int hw = 0;
@@ -4599,11 +4465,11 @@
 	int ret;
 
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN)) {
-		fprintf(stderr, "invalid port %d\n", res->port_id);
+		printf("invalid port %d\n", res->port_id);
 		return;
 	}
 	if (!port_is_stopped(res->port_id)) {
-		fprintf(stderr, "Please stop port %d first\n", res->port_id);
+		printf("Please stop port %d first\n", res->port_id);
 		return;
 	}
 
@@ -4618,59 +4484,53 @@
 
 		if (!strcmp(res->proto, "ip")) {
 			if (hw == 0 || (dev_info.tx_offload_capa &
-						RTE_ETH_TX_OFFLOAD_IPV4_CKSUM)) {
-				csum_offloads |= RTE_ETH_TX_OFFLOAD_IPV4_CKSUM;
+						DEV_TX_OFFLOAD_IPV4_CKSUM)) {
+				csum_offloads |= DEV_TX_OFFLOAD_IPV4_CKSUM;
 			} else {
-				fprintf(stderr,
-					"IP checksum offload is not supported by port %u\n",
-					res->port_id);
+				printf("IP checksum offload is not supported "
+				       "by port %u\n", res->port_id);
 			}
 		} else if (!strcmp(res->proto, "udp")) {
 			if (hw == 0 || (dev_info.tx_offload_capa &
-						RTE_ETH_TX_OFFLOAD_UDP_CKSUM)) {
-				csum_offloads |= RTE_ETH_TX_OFFLOAD_UDP_CKSUM;
+						DEV_TX_OFFLOAD_UDP_CKSUM)) {
+				csum_offloads |= DEV_TX_OFFLOAD_UDP_CKSUM;
 			} else {
-				fprintf(stderr,
-					"UDP checksum offload is not supported by port %u\n",
-					res->port_id);
+				printf("UDP checksum offload is not supported "
+				       "by port %u\n", res->port_id);
 			}
 		} else if (!strcmp(res->proto, "tcp")) {
 			if (hw == 0 || (dev_info.tx_offload_capa &
-						RTE_ETH_TX_OFFLOAD_TCP_CKSUM)) {
-				csum_offloads |= RTE_ETH_TX_OFFLOAD_TCP_CKSUM;
+						DEV_TX_OFFLOAD_TCP_CKSUM)) {
+				csum_offloads |= DEV_TX_OFFLOAD_TCP_CKSUM;
 			} else {
-				fprintf(stderr,
-					"TCP checksum offload is not supported by port %u\n",
-					res->port_id);
+				printf("TCP checksum offload is not supported "
+				       "by port %u\n", res->port_id);
 			}
 		} else if (!strcmp(res->proto, "sctp")) {
 			if (hw == 0 || (dev_info.tx_offload_capa &
-						RTE_ETH_TX_OFFLOAD_SCTP_CKSUM)) {
-				csum_offloads |= RTE_ETH_TX_OFFLOAD_SCTP_CKSUM;
+						DEV_TX_OFFLOAD_SCTP_CKSUM)) {
+				csum_offloads |= DEV_TX_OFFLOAD_SCTP_CKSUM;
 			} else {
-				fprintf(stderr,
-					"SCTP checksum offload is not supported by port %u\n",
-					res->port_id);
+				printf("SCTP checksum offload is not supported "
+				       "by port %u\n", res->port_id);
 			}
 		} else if (!strcmp(res->proto, "outer-ip")) {
 			if (hw == 0 || (dev_info.tx_offload_capa &
-					RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM)) {
+					DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM)) {
 				csum_offloads |=
-						RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM;
+						DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM;
 			} else {
-				fprintf(stderr,
-					"Outer IP checksum offload is not supported by port %u\n",
-					res->port_id);
+				printf("Outer IP checksum offload is not "
+				       "supported by port %u\n", res->port_id);
 			}
 		} else if (!strcmp(res->proto, "outer-udp")) {
 			if (hw == 0 || (dev_info.tx_offload_capa &
-					RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM)) {
+					DEV_TX_OFFLOAD_OUTER_UDP_CKSUM)) {
 				csum_offloads |=
-						RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM;
+						DEV_TX_OFFLOAD_OUTER_UDP_CKSUM;
 			} else {
-				fprintf(stderr,
-					"Outer UDP checksum offload is not supported by port %u\n",
-					res->port_id);
+				printf("Outer UDP checksum offload is not "
+				       "supported by port %u\n", res->port_id);
 			}
 		}
 
@@ -4688,23 +4548,23 @@
 	cmd_reconfig_device_queue(res->port_id, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_csum_csum =
+cmdline_parse_token_string_t cmd_csum_csum =
 	TOKEN_STRING_INITIALIZER(struct cmd_csum_result,
 				csum, "csum");
-static cmdline_parse_token_string_t cmd_csum_mode =
+cmdline_parse_token_string_t cmd_csum_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_csum_result,
 				mode, "set");
-static cmdline_parse_token_string_t cmd_csum_proto =
+cmdline_parse_token_string_t cmd_csum_proto =
 	TOKEN_STRING_INITIALIZER(struct cmd_csum_result,
 				proto, "ip#tcp#udp#sctp#outer-ip#outer-udp");
-static cmdline_parse_token_string_t cmd_csum_hwsw =
+cmdline_parse_token_string_t cmd_csum_hwsw =
 	TOKEN_STRING_INITIALIZER(struct cmd_csum_result,
 				hwsw, "hw#sw");
-static cmdline_parse_token_num_t cmd_csum_portid =
+cmdline_parse_token_num_t cmd_csum_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_csum_result,
-				port_id, RTE_UINT16);
+				port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_csum_set = {
+cmdline_parse_inst_t cmd_csum_set = {
 	.f = cmd_csum_parsed,
 	.data = NULL,
 	.help_str = "csum set ip|tcp|udp|sctp|outer-ip|outer-udp hw|sw <port_id>: "
@@ -4720,11 +4580,11 @@
 	},
 };
 
-static cmdline_parse_token_string_t cmd_csum_mode_show =
+cmdline_parse_token_string_t cmd_csum_mode_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_csum_result,
 				mode, "show");
 
-static cmdline_parse_inst_t cmd_csum_show = {
+cmdline_parse_inst_t cmd_csum_show = {
 	.f = cmd_csum_parsed,
 	.data = NULL,
 	.help_str = "csum show <port_id>: Show checksum offload configuration",
@@ -4746,8 +4606,8 @@
 
 static void
 cmd_csum_tunnel_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	struct cmd_csum_tunnel_result *res = parsed_result;
 
@@ -4762,20 +4622,20 @@
 	csum_show(res->port_id);
 }
 
-static cmdline_parse_token_string_t cmd_csum_tunnel_csum =
+cmdline_parse_token_string_t cmd_csum_tunnel_csum =
 	TOKEN_STRING_INITIALIZER(struct cmd_csum_tunnel_result,
 				csum, "csum");
-static cmdline_parse_token_string_t cmd_csum_tunnel_parse =
+cmdline_parse_token_string_t cmd_csum_tunnel_parse =
 	TOKEN_STRING_INITIALIZER(struct cmd_csum_tunnel_result,
 				parse, "parse-tunnel");
-static cmdline_parse_token_string_t cmd_csum_tunnel_onoff =
+cmdline_parse_token_string_t cmd_csum_tunnel_onoff =
 	TOKEN_STRING_INITIALIZER(struct cmd_csum_tunnel_result,
 				onoff, "on#off");
-static cmdline_parse_token_num_t cmd_csum_tunnel_portid =
+cmdline_parse_token_num_t cmd_csum_tunnel_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_csum_tunnel_result,
-				port_id, RTE_UINT16);
+				port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_csum_tunnel = {
+cmdline_parse_inst_t cmd_csum_tunnel = {
 	.f = cmd_csum_tunnel_parsed,
 	.data = NULL,
 	.help_str = "csum parse-tunnel on|off <port_id>: "
@@ -4789,55 +4649,6 @@
 	},
 };
 
-struct cmd_csum_mac_swap_result {
-	cmdline_fixed_string_t csum;
-	cmdline_fixed_string_t parse;
-	cmdline_fixed_string_t onoff;
-	portid_t port_id;
-};
-
-static void
-cmd_csum_mac_swap_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
-{
-	struct cmd_csum_mac_swap_result *res = parsed_result;
-
-	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
-		return;
-	if (strcmp(res->onoff, "on") == 0)
-		ports[res->port_id].fwd_mac_swap = 1;
-	else
-		ports[res->port_id].fwd_mac_swap = 0;
-}
-
-static cmdline_parse_token_string_t cmd_csum_mac_swap_csum =
-	TOKEN_STRING_INITIALIZER(struct cmd_csum_mac_swap_result,
-				 csum, "csum");
-static cmdline_parse_token_string_t cmd_csum_mac_swap_parse =
-	TOKEN_STRING_INITIALIZER(struct cmd_csum_mac_swap_result,
-				 parse, "mac-swap");
-static cmdline_parse_token_string_t cmd_csum_mac_swap_onoff =
-	TOKEN_STRING_INITIALIZER(struct cmd_csum_mac_swap_result,
-				 onoff, "on#off");
-static cmdline_parse_token_num_t cmd_csum_mac_swap_portid =
-	TOKEN_NUM_INITIALIZER(struct cmd_csum_mac_swap_result,
-			      port_id, RTE_UINT16);
-
-static cmdline_parse_inst_t cmd_csum_mac_swap = {
-	.f = cmd_csum_mac_swap_parsed,
-	.data = NULL,
-	.help_str = "csum mac-swap on|off <port_id>: "
-		    "Enable/Disable forward mac address swap",
-	.tokens = {
-		(void *)&cmd_csum_mac_swap_csum,
-		(void *)&cmd_csum_mac_swap_parse,
-		(void *)&cmd_csum_mac_swap_onoff,
-		(void *)&cmd_csum_mac_swap_portid,
-		NULL,
-	},
-};
-
 /* *** ENABLE HARDWARE SEGMENTATION IN TX NON-TUNNELED PACKETS *** */
 struct cmd_tso_set_result {
 	cmdline_fixed_string_t tso;
@@ -4848,8 +4659,8 @@
 
 static void
 cmd_tso_set_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	struct cmd_tso_set_result *res = parsed_result;
 	struct rte_eth_dev_info dev_info;
@@ -4858,7 +4669,7 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 	if (!port_is_stopped(res->port_id)) {
-		fprintf(stderr, "Please stop port %d first\n", res->port_id);
+		printf("Please stop port %d first\n", res->port_id);
 		return;
 	}
 
@@ -4870,19 +4681,19 @@
 		return;
 
 	if ((ports[res->port_id].tso_segsz != 0) &&
-		(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_TCP_TSO) == 0) {
-		fprintf(stderr, "Error: TSO is not supported by port %d\n",
-			res->port_id);
+		(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_TCP_TSO) == 0) {
+		printf("Error: TSO is not supported by port %d\n",
+		       res->port_id);
 		return;
 	}
 
 	if (ports[res->port_id].tso_segsz == 0) {
 		ports[res->port_id].dev_conf.txmode.offloads &=
-						~RTE_ETH_TX_OFFLOAD_TCP_TSO;
+						~DEV_TX_OFFLOAD_TCP_TSO;
 		printf("TSO for non-tunneled packets is disabled\n");
 	} else {
 		ports[res->port_id].dev_conf.txmode.offloads |=
-						RTE_ETH_TX_OFFLOAD_TCP_TSO;
+						DEV_TX_OFFLOAD_TCP_TSO;
 		printf("TSO segment size for non-tunneled packets is %d\n",
 			ports[res->port_id].tso_segsz);
 	}
@@ -4894,29 +4705,28 @@
 		return;
 
 	if ((ports[res->port_id].tso_segsz != 0) &&
-		(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_TCP_TSO) == 0) {
-		fprintf(stderr,
-			"Warning: TSO enabled but not supported by port %d\n",
-			res->port_id);
+		(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_TCP_TSO) == 0) {
+		printf("Warning: TSO enabled but not "
+			"supported by port %d\n", res->port_id);
 	}
 
 	cmd_reconfig_device_queue(res->port_id, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_tso_set_tso =
+cmdline_parse_token_string_t cmd_tso_set_tso =
 	TOKEN_STRING_INITIALIZER(struct cmd_tso_set_result,
 				tso, "tso");
-static cmdline_parse_token_string_t cmd_tso_set_mode =
+cmdline_parse_token_string_t cmd_tso_set_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_tso_set_result,
 				mode, "set");
-static cmdline_parse_token_num_t cmd_tso_set_tso_segsz =
+cmdline_parse_token_num_t cmd_tso_set_tso_segsz =
 	TOKEN_NUM_INITIALIZER(struct cmd_tso_set_result,
-				tso_segsz, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_tso_set_portid =
+				tso_segsz, UINT16);
+cmdline_parse_token_num_t cmd_tso_set_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_tso_set_result,
-				port_id, RTE_UINT16);
+				port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_tso_set = {
+cmdline_parse_inst_t cmd_tso_set = {
 	.f = cmd_tso_set_parsed,
 	.data = NULL,
 	.help_str = "tso set <tso_segsz> <port_id>: "
@@ -4931,12 +4741,12 @@
 	},
 };
 
-static cmdline_parse_token_string_t cmd_tso_show_mode =
+cmdline_parse_token_string_t cmd_tso_show_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_tso_set_result,
 				mode, "show");
 
 
-static cmdline_parse_inst_t cmd_tso_show = {
+cmdline_parse_inst_t cmd_tso_show = {
 	.f = cmd_tso_set_parsed,
 	.data = NULL,
 	.help_str = "tso show <port_id>: "
@@ -4965,37 +4775,31 @@
 	if (eth_dev_info_get_print_err(port_id, &dev_info) != 0)
 		return dev_info;
 
-	if (!(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_VXLAN_TNL_TSO))
-		fprintf(stderr,
-			"Warning: VXLAN TUNNEL TSO not supported therefore not enabled for port %d\n",
-			port_id);
-	if (!(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_GRE_TNL_TSO))
-		fprintf(stderr,
-			"Warning: GRE TUNNEL TSO not supported therefore not enabled for port %d\n",
-			port_id);
-	if (!(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_IPIP_TNL_TSO))
-		fprintf(stderr,
-			"Warning: IPIP TUNNEL TSO not supported therefore not enabled for port %d\n",
-			port_id);
-	if (!(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_GENEVE_TNL_TSO))
-		fprintf(stderr,
-			"Warning: GENEVE TUNNEL TSO not supported therefore not enabled for port %d\n",
-			port_id);
-	if (!(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_IP_TNL_TSO))
-		fprintf(stderr,
-			"Warning: IP TUNNEL TSO not supported therefore not enabled for port %d\n",
-			port_id);
-	if (!(dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_UDP_TNL_TSO))
-		fprintf(stderr,
-			"Warning: UDP TUNNEL TSO not supported therefore not enabled for port %d\n",
-			port_id);
+	if (!(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_VXLAN_TNL_TSO))
+		printf("Warning: VXLAN TUNNEL TSO not supported therefore "
+		       "not enabled for port %d\n", port_id);
+	if (!(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_GRE_TNL_TSO))
+		printf("Warning: GRE TUNNEL TSO	not supported therefore "
+		       "not enabled for port %d\n", port_id);
+	if (!(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_IPIP_TNL_TSO))
+		printf("Warning: IPIP TUNNEL TSO not supported therefore "
+		       "not enabled for port %d\n", port_id);
+	if (!(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_GENEVE_TNL_TSO))
+		printf("Warning: GENEVE TUNNEL TSO not supported therefore "
+		       "not enabled for port %d\n", port_id);
+	if (!(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_IP_TNL_TSO))
+		printf("Warning: IP TUNNEL TSO not supported therefore "
+		       "not enabled for port %d\n", port_id);
+	if (!(dev_info.tx_offload_capa & DEV_TX_OFFLOAD_UDP_TNL_TSO))
+		printf("Warning: UDP TUNNEL TSO not supported therefore "
+		       "not enabled for port %d\n", port_id);
 	return dev_info;
 }
 
 static void
 cmd_tunnel_tso_set_parsed(void *parsed_result,
-			  __rte_unused struct cmdline *cl,
-			  __rte_unused void *data)
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
 {
 	struct cmd_tunnel_tso_set_result *res = parsed_result;
 	struct rte_eth_dev_info dev_info;
@@ -5003,7 +4807,7 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 	if (!port_is_stopped(res->port_id)) {
-		fprintf(stderr, "Please stop port %d first\n", res->port_id);
+		printf("Please stop port %d first\n", res->port_id);
 		return;
 	}
 
@@ -5013,20 +4817,20 @@
 	dev_info = check_tunnel_tso_nic_support(res->port_id);
 	if (ports[res->port_id].tunnel_tso_segsz == 0) {
 		ports[res->port_id].dev_conf.txmode.offloads &=
-			~(RTE_ETH_TX_OFFLOAD_VXLAN_TNL_TSO |
-			  RTE_ETH_TX_OFFLOAD_GRE_TNL_TSO |
-			  RTE_ETH_TX_OFFLOAD_IPIP_TNL_TSO |
-			  RTE_ETH_TX_OFFLOAD_GENEVE_TNL_TSO |
-			  RTE_ETH_TX_OFFLOAD_IP_TNL_TSO |
-			  RTE_ETH_TX_OFFLOAD_UDP_TNL_TSO);
+			~(DEV_TX_OFFLOAD_VXLAN_TNL_TSO |
+			  DEV_TX_OFFLOAD_GRE_TNL_TSO |
+			  DEV_TX_OFFLOAD_IPIP_TNL_TSO |
+			  DEV_TX_OFFLOAD_GENEVE_TNL_TSO |
+			  DEV_TX_OFFLOAD_IP_TNL_TSO |
+			  DEV_TX_OFFLOAD_UDP_TNL_TSO);
 		printf("TSO for tunneled packets is disabled\n");
 	} else {
-		uint64_t tso_offloads = (RTE_ETH_TX_OFFLOAD_VXLAN_TNL_TSO |
-					 RTE_ETH_TX_OFFLOAD_GRE_TNL_TSO |
-					 RTE_ETH_TX_OFFLOAD_IPIP_TNL_TSO |
-					 RTE_ETH_TX_OFFLOAD_GENEVE_TNL_TSO |
-					 RTE_ETH_TX_OFFLOAD_IP_TNL_TSO |
-					 RTE_ETH_TX_OFFLOAD_UDP_TNL_TSO);
+		uint64_t tso_offloads = (DEV_TX_OFFLOAD_VXLAN_TNL_TSO |
+					 DEV_TX_OFFLOAD_GRE_TNL_TSO |
+					 DEV_TX_OFFLOAD_IPIP_TNL_TSO |
+					 DEV_TX_OFFLOAD_GENEVE_TNL_TSO |
+					 DEV_TX_OFFLOAD_IP_TNL_TSO |
+					 DEV_TX_OFFLOAD_UDP_TNL_TSO);
 
 		ports[res->port_id].dev_conf.txmode.offloads |=
 			(tso_offloads & dev_info.tx_offload_capa);
@@ -5046,32 +4850,32 @@
 		 */
 
 		if (!ports[res->port_id].parse_tunnel)
-			fprintf(stderr,
-				"Warning: csum parse_tunnel must be set so that tunneled packets are recognized\n");
+			printf("Warning: csum parse_tunnel must be set "
+				"so that tunneled packets are recognized\n");
 		if (!(ports[res->port_id].dev_conf.txmode.offloads &
-		      RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM))
-			fprintf(stderr,
-				"Warning: csum set outer-ip must be set to hw if outer L3 is IPv4; not necessary for IPv6\n");
+		      DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM))
+			printf("Warning: csum set outer-ip must be set to hw "
+				"if outer L3 is IPv4; not necessary for IPv6\n");
 	}
 
 	cmd_config_queue_tx_offloads(&ports[res->port_id]);
 	cmd_reconfig_device_queue(res->port_id, 1, 1);
 }
 
-static cmdline_parse_token_string_t cmd_tunnel_tso_set_tso =
+cmdline_parse_token_string_t cmd_tunnel_tso_set_tso =
 	TOKEN_STRING_INITIALIZER(struct cmd_tunnel_tso_set_result,
 				tso, "tunnel_tso");
-static cmdline_parse_token_string_t cmd_tunnel_tso_set_mode =
+cmdline_parse_token_string_t cmd_tunnel_tso_set_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_tunnel_tso_set_result,
 				mode, "set");
-static cmdline_parse_token_num_t cmd_tunnel_tso_set_tso_segsz =
+cmdline_parse_token_num_t cmd_tunnel_tso_set_tso_segsz =
 	TOKEN_NUM_INITIALIZER(struct cmd_tunnel_tso_set_result,
-				tso_segsz, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_tunnel_tso_set_portid =
+				tso_segsz, UINT16);
+cmdline_parse_token_num_t cmd_tunnel_tso_set_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_tunnel_tso_set_result,
-				port_id, RTE_UINT16);
+				port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_tunnel_tso_set = {
+cmdline_parse_inst_t cmd_tunnel_tso_set = {
 	.f = cmd_tunnel_tso_set_parsed,
 	.data = NULL,
 	.help_str = "tunnel_tso set <tso_segsz> <port_id>: "
@@ -5086,12 +4890,12 @@
 	},
 };
 
-static cmdline_parse_token_string_t cmd_tunnel_tso_show_mode =
+cmdline_parse_token_string_t cmd_tunnel_tso_show_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_tunnel_tso_set_result,
 				mode, "show");
 
 
-static cmdline_parse_inst_t cmd_tunnel_tso_show = {
+cmdline_parse_inst_t cmd_tunnel_tso_show = {
 	.f = cmd_tunnel_tso_set_parsed,
 	.data = NULL,
 	.help_str = "tunnel_tso show <port_id> "
@@ -5104,7 +4908,6 @@
 	},
 };
 
-#ifdef RTE_LIB_GRO
 /* *** SET GRO FOR A PORT *** */
 struct cmd_gro_enable_result {
 	cmdline_fixed_string_t cmd_set;
@@ -5116,8 +4919,8 @@
 
 static void
 cmd_gro_enable_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_gro_enable_result *res;
 
@@ -5126,23 +4929,23 @@
 		setup_gro(res->cmd_onoff, res->cmd_pid);
 }
 
-static cmdline_parse_token_string_t cmd_gro_enable_set =
+cmdline_parse_token_string_t cmd_gro_enable_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_enable_result,
 			cmd_set, "set");
-static cmdline_parse_token_string_t cmd_gro_enable_port =
+cmdline_parse_token_string_t cmd_gro_enable_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_enable_result,
 			cmd_keyword, "port");
-static cmdline_parse_token_num_t cmd_gro_enable_pid =
+cmdline_parse_token_num_t cmd_gro_enable_pid =
 	TOKEN_NUM_INITIALIZER(struct cmd_gro_enable_result,
-			cmd_pid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_gro_enable_keyword =
+			cmd_pid, UINT16);
+cmdline_parse_token_string_t cmd_gro_enable_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_enable_result,
 			cmd_keyword, "gro");
-static cmdline_parse_token_string_t cmd_gro_enable_onoff =
+cmdline_parse_token_string_t cmd_gro_enable_onoff =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_enable_result,
 			cmd_onoff, "on#off");
 
-static cmdline_parse_inst_t cmd_gro_enable = {
+cmdline_parse_inst_t cmd_gro_enable = {
 	.f = cmd_gro_enable_parsed,
 	.data = NULL,
 	.help_str = "set port <port_id> gro on|off",
@@ -5166,8 +4969,8 @@
 
 static void
 cmd_gro_show_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_gro_show_result *res;
 
@@ -5176,20 +4979,20 @@
 		show_gro(res->cmd_pid);
 }
 
-static cmdline_parse_token_string_t cmd_gro_show_show =
+cmdline_parse_token_string_t cmd_gro_show_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_show_result,
 			cmd_show, "show");
-static cmdline_parse_token_string_t cmd_gro_show_port =
+cmdline_parse_token_string_t cmd_gro_show_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_show_result,
 			cmd_port, "port");
-static cmdline_parse_token_num_t cmd_gro_show_pid =
+cmdline_parse_token_num_t cmd_gro_show_pid =
 	TOKEN_NUM_INITIALIZER(struct cmd_gro_show_result,
-			cmd_pid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_gro_show_keyword =
+			cmd_pid, UINT16);
+cmdline_parse_token_string_t cmd_gro_show_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_show_result,
 			cmd_keyword, "gro");
 
-static cmdline_parse_inst_t cmd_gro_show = {
+cmdline_parse_inst_t cmd_gro_show = {
 	.f = cmd_gro_show_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> gro",
@@ -5212,8 +5015,8 @@
 
 static void
 cmd_gro_flush_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_gro_flush_result *res;
 
@@ -5223,20 +5026,20 @@
 		setup_gro_flush_cycles(res->cmd_cycles);
 }
 
-static cmdline_parse_token_string_t cmd_gro_flush_set =
+cmdline_parse_token_string_t cmd_gro_flush_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_flush_result,
 			cmd_set, "set");
-static cmdline_parse_token_string_t cmd_gro_flush_keyword =
+cmdline_parse_token_string_t cmd_gro_flush_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_flush_result,
 			cmd_keyword, "gro");
-static cmdline_parse_token_string_t cmd_gro_flush_flush =
+cmdline_parse_token_string_t cmd_gro_flush_flush =
 	TOKEN_STRING_INITIALIZER(struct cmd_gro_flush_result,
 			cmd_flush, "flush");
-static cmdline_parse_token_num_t cmd_gro_flush_cycles =
+cmdline_parse_token_num_t cmd_gro_flush_cycles =
 	TOKEN_NUM_INITIALIZER(struct cmd_gro_flush_result,
-			cmd_cycles, RTE_UINT8);
+			cmd_cycles, UINT8);
 
-static cmdline_parse_inst_t cmd_gro_flush = {
+cmdline_parse_inst_t cmd_gro_flush = {
 	.f = cmd_gro_flush_parsed,
 	.data = NULL,
 	.help_str = "set gro flush <cycles>",
@@ -5248,9 +5051,7 @@
 		NULL,
 	},
 };
-#endif /* RTE_LIB_GRO */
 
-#ifdef RTE_LIB_GSO
 /* *** ENABLE/DISABLE GSO *** */
 struct cmd_gso_enable_result {
 	cmdline_fixed_string_t cmd_set;
@@ -5262,8 +5063,8 @@
 
 static void
 cmd_gso_enable_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_gso_enable_result *res;
 
@@ -5272,23 +5073,23 @@
 		setup_gso(res->cmd_mode, res->cmd_pid);
 }
 
-static cmdline_parse_token_string_t cmd_gso_enable_set =
+cmdline_parse_token_string_t cmd_gso_enable_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_gso_enable_result,
 			cmd_set, "set");
-static cmdline_parse_token_string_t cmd_gso_enable_port =
+cmdline_parse_token_string_t cmd_gso_enable_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_gso_enable_result,
 			cmd_port, "port");
-static cmdline_parse_token_string_t cmd_gso_enable_keyword =
+cmdline_parse_token_string_t cmd_gso_enable_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_gso_enable_result,
 			cmd_keyword, "gso");
-static cmdline_parse_token_string_t cmd_gso_enable_mode =
+cmdline_parse_token_string_t cmd_gso_enable_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_gso_enable_result,
 			cmd_mode, "on#off");
-static cmdline_parse_token_num_t cmd_gso_enable_pid =
+cmdline_parse_token_num_t cmd_gso_enable_pid =
 	TOKEN_NUM_INITIALIZER(struct cmd_gso_enable_result,
-			cmd_pid, RTE_UINT16);
+			cmd_pid, UINT16);
 
-static cmdline_parse_inst_t cmd_gso_enable = {
+cmdline_parse_inst_t cmd_gso_enable = {
 	.f = cmd_gso_enable_parsed,
 	.data = NULL,
 	.help_str = "set port <port_id> gso on|off",
@@ -5312,42 +5113,42 @@
 
 static void
 cmd_gso_size_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	struct cmd_gso_size_result *res = parsed_result;
 
 	if (test_done == 0) {
-		fprintf(stderr,
-			"Before setting GSO segsz, please first stop forwarding\n");
+		printf("Before setting GSO segsz, please first"
+				" stop fowarding\n");
 		return;
 	}
 
 	if (!strcmp(res->cmd_keyword, "gso") &&
 			!strcmp(res->cmd_segsz, "segsz")) {
 		if (res->cmd_size < RTE_GSO_SEG_SIZE_MIN)
-			fprintf(stderr,
-				"gso_size should be larger than %zu. Please input a legal value\n",
-				RTE_GSO_SEG_SIZE_MIN);
+			printf("gso_size should be larger than %zu."
+					" Please input a legal value\n",
+					RTE_GSO_SEG_SIZE_MIN);
 		else
 			gso_max_segment_size = res->cmd_size;
 	}
 }
 
-static cmdline_parse_token_string_t cmd_gso_size_set =
+cmdline_parse_token_string_t cmd_gso_size_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_gso_size_result,
 				cmd_set, "set");
-static cmdline_parse_token_string_t cmd_gso_size_keyword =
+cmdline_parse_token_string_t cmd_gso_size_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_gso_size_result,
 				cmd_keyword, "gso");
-static cmdline_parse_token_string_t cmd_gso_size_segsz =
+cmdline_parse_token_string_t cmd_gso_size_segsz =
 	TOKEN_STRING_INITIALIZER(struct cmd_gso_size_result,
 				cmd_segsz, "segsz");
-static cmdline_parse_token_num_t cmd_gso_size_size =
+cmdline_parse_token_num_t cmd_gso_size_size =
 	TOKEN_NUM_INITIALIZER(struct cmd_gso_size_result,
-				cmd_size, RTE_UINT16);
+				cmd_size, UINT16);
 
-static cmdline_parse_inst_t cmd_gso_size = {
+cmdline_parse_inst_t cmd_gso_size = {
 	.f = cmd_gso_size_parsed,
 	.data = NULL,
 	.help_str = "set gso segsz <length>",
@@ -5370,13 +5171,13 @@
 
 static void
 cmd_gso_show_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	struct cmd_gso_show_result *res = parsed_result;
 
 	if (!rte_eth_dev_is_valid_port(res->cmd_pid)) {
-		fprintf(stderr, "invalid port id %u\n", res->cmd_pid);
+		printf("invalid port id %u\n", res->cmd_pid);
 		return;
 	}
 	if (!strcmp(res->cmd_keyword, "gso")) {
@@ -5392,20 +5193,20 @@
 	}
 }
 
-static cmdline_parse_token_string_t cmd_gso_show_show =
+cmdline_parse_token_string_t cmd_gso_show_show =
 TOKEN_STRING_INITIALIZER(struct cmd_gso_show_result,
 		cmd_show, "show");
-static cmdline_parse_token_string_t cmd_gso_show_port =
+cmdline_parse_token_string_t cmd_gso_show_port =
 TOKEN_STRING_INITIALIZER(struct cmd_gso_show_result,
 		cmd_port, "port");
-static cmdline_parse_token_string_t cmd_gso_show_keyword =
+cmdline_parse_token_string_t cmd_gso_show_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_gso_show_result,
 				cmd_keyword, "gso");
-static cmdline_parse_token_num_t cmd_gso_show_pid =
+cmdline_parse_token_num_t cmd_gso_show_pid =
 	TOKEN_NUM_INITIALIZER(struct cmd_gso_show_result,
-				cmd_pid, RTE_UINT16);
+				cmd_pid, UINT16);
 
-static cmdline_parse_inst_t cmd_gso_show = {
+cmdline_parse_inst_t cmd_gso_show = {
 	.f = cmd_gso_show_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> gso",
@@ -5417,7 +5218,6 @@
 		NULL,
 	},
 };
-#endif /* RTE_LIB_GSO */
 
 /* *** ENABLE/DISABLE FLUSH ON RX STREAMS *** */
 struct cmd_set_flush_rx {
@@ -5428,31 +5228,25 @@
 
 static void
 cmd_set_flush_rx_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_set_flush_rx *res = parsed_result;
-
-	if (num_procs > 1 && (strcmp(res->mode, "on") == 0)) {
-		printf("multi-process doesn't support to flush Rx queues.\n");
-		return;
-	}
-
 	no_flush_rx = (uint8_t)((strcmp(res->mode, "on") == 0) ? 0 : 1);
 }
 
-static cmdline_parse_token_string_t cmd_setflushrx_set =
+cmdline_parse_token_string_t cmd_setflushrx_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_flush_rx,
 			set, "set");
-static cmdline_parse_token_string_t cmd_setflushrx_flush_rx =
+cmdline_parse_token_string_t cmd_setflushrx_flush_rx =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_flush_rx,
 			flush_rx, "flush_rx");
-static cmdline_parse_token_string_t cmd_setflushrx_mode =
+cmdline_parse_token_string_t cmd_setflushrx_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_flush_rx,
 			mode, "on#off");
 
 
-static cmdline_parse_inst_t cmd_set_flush_rx = {
+cmdline_parse_inst_t cmd_set_flush_rx = {
 	.f = cmd_set_flush_rx_parsed,
 	.help_str = "set flush_rx on|off: Enable/Disable flush on rx streams",
 	.data = NULL,
@@ -5473,25 +5267,25 @@
 
 static void
 cmd_set_link_check_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_set_link_check *res = parsed_result;
 	no_link_check = (uint8_t)((strcmp(res->mode, "on") == 0) ? 0 : 1);
 }
 
-static cmdline_parse_token_string_t cmd_setlinkcheck_set =
+cmdline_parse_token_string_t cmd_setlinkcheck_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_link_check,
 			set, "set");
-static cmdline_parse_token_string_t cmd_setlinkcheck_link_check =
+cmdline_parse_token_string_t cmd_setlinkcheck_link_check =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_link_check,
 			link_check, "link_check");
-static cmdline_parse_token_string_t cmd_setlinkcheck_mode =
+cmdline_parse_token_string_t cmd_setlinkcheck_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_link_check,
 			mode, "on#off");
 
 
-static cmdline_parse_inst_t cmd_set_link_check = {
+cmdline_parse_inst_t cmd_set_link_check = {
 	.f = cmd_set_link_check_parsed,
 	.help_str = "set link_check on|off: Enable/Disable link status check "
 	            "when starting/stopping a port",
@@ -5504,6 +5298,1116 @@
 	},
 };
 
+/* *** SET NIC BYPASS MODE *** */
+struct cmd_set_bypass_mode_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bypass;
+	cmdline_fixed_string_t mode;
+	cmdline_fixed_string_t value;
+	portid_t port_id;
+};
+
+static void
+cmd_set_bypass_mode_parsed(void *parsed_result,
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_set_bypass_mode_result *res = parsed_result;
+	portid_t port_id = res->port_id;
+	int32_t rc = -EINVAL;
+
+#if defined RTE_LIBRTE_IXGBE_PMD && defined RTE_LIBRTE_IXGBE_BYPASS
+	uint32_t bypass_mode = RTE_PMD_IXGBE_BYPASS_MODE_NORMAL;
+
+	if (!strcmp(res->value, "bypass"))
+		bypass_mode = RTE_PMD_IXGBE_BYPASS_MODE_BYPASS;
+	else if (!strcmp(res->value, "isolate"))
+		bypass_mode = RTE_PMD_IXGBE_BYPASS_MODE_ISOLATE;
+	else
+		bypass_mode = RTE_PMD_IXGBE_BYPASS_MODE_NORMAL;
+
+	/* Set the bypass mode for the relevant port. */
+	rc = rte_pmd_ixgbe_bypass_state_set(port_id, &bypass_mode);
+#endif
+	if (rc != 0)
+		printf("\t Failed to set bypass mode for port = %d.\n", port_id);
+}
+
+cmdline_parse_token_string_t cmd_setbypass_mode_set =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_mode_result,
+			set, "set");
+cmdline_parse_token_string_t cmd_setbypass_mode_bypass =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_mode_result,
+			bypass, "bypass");
+cmdline_parse_token_string_t cmd_setbypass_mode_mode =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_mode_result,
+			mode, "mode");
+cmdline_parse_token_string_t cmd_setbypass_mode_value =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_mode_result,
+			value, "normal#bypass#isolate");
+cmdline_parse_token_num_t cmd_setbypass_mode_port =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_bypass_mode_result,
+				port_id, UINT16);
+
+cmdline_parse_inst_t cmd_set_bypass_mode = {
+	.f = cmd_set_bypass_mode_parsed,
+	.help_str = "set bypass mode normal|bypass|isolate <port_id>: "
+	            "Set the NIC bypass mode for port_id",
+	.data = NULL,
+	.tokens = {
+		(void *)&cmd_setbypass_mode_set,
+		(void *)&cmd_setbypass_mode_bypass,
+		(void *)&cmd_setbypass_mode_mode,
+		(void *)&cmd_setbypass_mode_value,
+		(void *)&cmd_setbypass_mode_port,
+		NULL,
+	},
+};
+
+/* *** SET NIC BYPASS EVENT *** */
+struct cmd_set_bypass_event_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bypass;
+	cmdline_fixed_string_t event;
+	cmdline_fixed_string_t event_value;
+	cmdline_fixed_string_t mode;
+	cmdline_fixed_string_t mode_value;
+	portid_t port_id;
+};
+
+static void
+cmd_set_bypass_event_parsed(void *parsed_result,
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	int32_t rc = -EINVAL;
+	struct cmd_set_bypass_event_result *res = parsed_result;
+	portid_t port_id = res->port_id;
+
+#if defined RTE_LIBRTE_IXGBE_PMD && defined RTE_LIBRTE_IXGBE_BYPASS
+	uint32_t bypass_event = RTE_PMD_IXGBE_BYPASS_EVENT_NONE;
+	uint32_t bypass_mode = RTE_PMD_IXGBE_BYPASS_MODE_NORMAL;
+
+	if (!strcmp(res->event_value, "timeout"))
+		bypass_event = RTE_PMD_IXGBE_BYPASS_EVENT_TIMEOUT;
+	else if (!strcmp(res->event_value, "os_on"))
+		bypass_event = RTE_PMD_IXGBE_BYPASS_EVENT_OS_ON;
+	else if (!strcmp(res->event_value, "os_off"))
+		bypass_event = RTE_PMD_IXGBE_BYPASS_EVENT_OS_OFF;
+	else if (!strcmp(res->event_value, "power_on"))
+		bypass_event = RTE_PMD_IXGBE_BYPASS_EVENT_POWER_ON;
+	else if (!strcmp(res->event_value, "power_off"))
+		bypass_event = RTE_PMD_IXGBE_BYPASS_EVENT_POWER_OFF;
+	else
+		bypass_event = RTE_PMD_IXGBE_BYPASS_EVENT_NONE;
+
+	if (!strcmp(res->mode_value, "bypass"))
+		bypass_mode = RTE_PMD_IXGBE_BYPASS_MODE_BYPASS;
+	else if (!strcmp(res->mode_value, "isolate"))
+		bypass_mode = RTE_PMD_IXGBE_BYPASS_MODE_ISOLATE;
+	else
+		bypass_mode = RTE_PMD_IXGBE_BYPASS_MODE_NORMAL;
+
+	/* Set the watchdog timeout. */
+	if (bypass_event == RTE_PMD_IXGBE_BYPASS_EVENT_TIMEOUT) {
+
+		rc = -EINVAL;
+		if (RTE_PMD_IXGBE_BYPASS_TMT_VALID(bypass_timeout)) {
+			rc = rte_pmd_ixgbe_bypass_wd_timeout_store(port_id,
+							   bypass_timeout);
+		}
+		if (rc != 0) {
+			printf("Failed to set timeout value %u "
+			"for port %d, errto code: %d.\n",
+			bypass_timeout, port_id, rc);
+		}
+	}
+
+	/* Set the bypass event to transition to bypass mode. */
+	rc = rte_pmd_ixgbe_bypass_event_store(port_id, bypass_event,
+					      bypass_mode);
+#endif
+
+	if (rc != 0)
+		printf("\t Failed to set bypass event for port = %d.\n",
+		       port_id);
+}
+
+cmdline_parse_token_string_t cmd_setbypass_event_set =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_event_result,
+			set, "set");
+cmdline_parse_token_string_t cmd_setbypass_event_bypass =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_event_result,
+			bypass, "bypass");
+cmdline_parse_token_string_t cmd_setbypass_event_event =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_event_result,
+			event, "event");
+cmdline_parse_token_string_t cmd_setbypass_event_event_value =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_event_result,
+			event_value, "none#timeout#os_off#os_on#power_on#power_off");
+cmdline_parse_token_string_t cmd_setbypass_event_mode =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_event_result,
+			mode, "mode");
+cmdline_parse_token_string_t cmd_setbypass_event_mode_value =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_event_result,
+			mode_value, "normal#bypass#isolate");
+cmdline_parse_token_num_t cmd_setbypass_event_port =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_bypass_event_result,
+				port_id, UINT16);
+
+cmdline_parse_inst_t cmd_set_bypass_event = {
+	.f = cmd_set_bypass_event_parsed,
+	.help_str = "set bypass event none|timeout|os_on|os_off|power_on|"
+		"power_off mode normal|bypass|isolate <port_id>: "
+		"Set the NIC bypass event mode for port_id",
+	.data = NULL,
+	.tokens = {
+		(void *)&cmd_setbypass_event_set,
+		(void *)&cmd_setbypass_event_bypass,
+		(void *)&cmd_setbypass_event_event,
+		(void *)&cmd_setbypass_event_event_value,
+		(void *)&cmd_setbypass_event_mode,
+		(void *)&cmd_setbypass_event_mode_value,
+		(void *)&cmd_setbypass_event_port,
+		NULL,
+	},
+};
+
+
+/* *** SET NIC BYPASS TIMEOUT *** */
+struct cmd_set_bypass_timeout_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bypass;
+	cmdline_fixed_string_t timeout;
+	cmdline_fixed_string_t value;
+};
+
+static void
+cmd_set_bypass_timeout_parsed(void *parsed_result,
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	__rte_unused struct cmd_set_bypass_timeout_result *res = parsed_result;
+
+#if defined RTE_LIBRTE_IXGBE_PMD && defined RTE_LIBRTE_IXGBE_BYPASS
+	if (!strcmp(res->value, "1.5"))
+		bypass_timeout = RTE_PMD_IXGBE_BYPASS_TMT_1_5_SEC;
+	else if (!strcmp(res->value, "2"))
+		bypass_timeout = RTE_PMD_IXGBE_BYPASS_TMT_2_SEC;
+	else if (!strcmp(res->value, "3"))
+		bypass_timeout = RTE_PMD_IXGBE_BYPASS_TMT_3_SEC;
+	else if (!strcmp(res->value, "4"))
+		bypass_timeout = RTE_PMD_IXGBE_BYPASS_TMT_4_SEC;
+	else if (!strcmp(res->value, "8"))
+		bypass_timeout = RTE_PMD_IXGBE_BYPASS_TMT_8_SEC;
+	else if (!strcmp(res->value, "16"))
+		bypass_timeout = RTE_PMD_IXGBE_BYPASS_TMT_16_SEC;
+	else if (!strcmp(res->value, "32"))
+		bypass_timeout = RTE_PMD_IXGBE_BYPASS_TMT_32_SEC;
+	else
+		bypass_timeout = RTE_PMD_IXGBE_BYPASS_TMT_OFF;
+#endif
+}
+
+cmdline_parse_token_string_t cmd_setbypass_timeout_set =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_timeout_result,
+			set, "set");
+cmdline_parse_token_string_t cmd_setbypass_timeout_bypass =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_timeout_result,
+			bypass, "bypass");
+cmdline_parse_token_string_t cmd_setbypass_timeout_timeout =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_timeout_result,
+			timeout, "timeout");
+cmdline_parse_token_string_t cmd_setbypass_timeout_value =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bypass_timeout_result,
+			value, "0#1.5#2#3#4#8#16#32");
+
+cmdline_parse_inst_t cmd_set_bypass_timeout = {
+	.f = cmd_set_bypass_timeout_parsed,
+	.help_str = "set bypass timeout 0|1.5|2|3|4|8|16|32: "
+		"Set the NIC bypass watchdog timeout in seconds",
+	.data = NULL,
+	.tokens = {
+		(void *)&cmd_setbypass_timeout_set,
+		(void *)&cmd_setbypass_timeout_bypass,
+		(void *)&cmd_setbypass_timeout_timeout,
+		(void *)&cmd_setbypass_timeout_value,
+		NULL,
+	},
+};
+
+/* *** SHOW NIC BYPASS MODE *** */
+struct cmd_show_bypass_config_result {
+	cmdline_fixed_string_t show;
+	cmdline_fixed_string_t bypass;
+	cmdline_fixed_string_t config;
+	portid_t port_id;
+};
+
+static void
+cmd_show_bypass_config_parsed(void *parsed_result,
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_show_bypass_config_result *res = parsed_result;
+	portid_t port_id = res->port_id;
+	int rc = -EINVAL;
+#if defined RTE_LIBRTE_IXGBE_PMD && defined RTE_LIBRTE_IXGBE_BYPASS
+	uint32_t event_mode;
+	uint32_t bypass_mode;
+	uint32_t timeout = bypass_timeout;
+	int i;
+
+	static const char * const timeouts[RTE_PMD_IXGBE_BYPASS_TMT_NUM] =
+		{"off", "1.5", "2", "3", "4", "8", "16", "32"};
+	static const char * const modes[RTE_PMD_IXGBE_BYPASS_MODE_NUM] =
+		{"UNKNOWN", "normal", "bypass", "isolate"};
+	static const char * const events[RTE_PMD_IXGBE_BYPASS_EVENT_NUM] = {
+		"NONE",
+		"OS/board on",
+		"power supply on",
+		"OS/board off",
+		"power supply off",
+		"timeout"};
+	int num_events = (sizeof events) / (sizeof events[0]);
+
+	/* Display the bypass mode.*/
+	if (rte_pmd_ixgbe_bypass_state_show(port_id, &bypass_mode) != 0) {
+		printf("\tFailed to get bypass mode for port = %d\n", port_id);
+		return;
+	}
+	else {
+		if (!RTE_PMD_IXGBE_BYPASS_MODE_VALID(bypass_mode))
+			bypass_mode = RTE_PMD_IXGBE_BYPASS_MODE_NONE;
+
+		printf("\tbypass mode    = %s\n",  modes[bypass_mode]);
+	}
+
+	/* Display the bypass timeout.*/
+	if (!RTE_PMD_IXGBE_BYPASS_TMT_VALID(timeout))
+		timeout = RTE_PMD_IXGBE_BYPASS_TMT_OFF;
+
+	printf("\tbypass timeout = %s\n", timeouts[timeout]);
+
+	/* Display the bypass events and associated modes. */
+	for (i = RTE_PMD_IXGBE_BYPASS_EVENT_START; i < num_events; i++) {
+
+		if (rte_pmd_ixgbe_bypass_event_show(port_id, i, &event_mode)) {
+			printf("\tFailed to get bypass mode for event = %s\n",
+				events[i]);
+		} else {
+			if (!RTE_PMD_IXGBE_BYPASS_MODE_VALID(event_mode))
+				event_mode = RTE_PMD_IXGBE_BYPASS_MODE_NONE;
+
+			printf("\tbypass event: %-16s = %s\n", events[i],
+				modes[event_mode]);
+		}
+	}
+#endif
+	if (rc != 0)
+		printf("\tFailed to get bypass configuration for port = %d\n",
+		       port_id);
+}
+
+cmdline_parse_token_string_t cmd_showbypass_config_show =
+	TOKEN_STRING_INITIALIZER(struct cmd_show_bypass_config_result,
+			show, "show");
+cmdline_parse_token_string_t cmd_showbypass_config_bypass =
+	TOKEN_STRING_INITIALIZER(struct cmd_show_bypass_config_result,
+			bypass, "bypass");
+cmdline_parse_token_string_t cmd_showbypass_config_config =
+	TOKEN_STRING_INITIALIZER(struct cmd_show_bypass_config_result,
+			config, "config");
+cmdline_parse_token_num_t cmd_showbypass_config_port =
+	TOKEN_NUM_INITIALIZER(struct cmd_show_bypass_config_result,
+				port_id, UINT16);
+
+cmdline_parse_inst_t cmd_show_bypass_config = {
+	.f = cmd_show_bypass_config_parsed,
+	.help_str = "show bypass config <port_id>: "
+	            "Show the NIC bypass config for port_id",
+	.data = NULL,
+	.tokens = {
+		(void *)&cmd_showbypass_config_show,
+		(void *)&cmd_showbypass_config_bypass,
+		(void *)&cmd_showbypass_config_config,
+		(void *)&cmd_showbypass_config_port,
+		NULL,
+	},
+};
+
+#ifdef RTE_LIBRTE_PMD_BOND
+/* *** SET BONDING MODE *** */
+struct cmd_set_bonding_mode_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t mode;
+	uint8_t value;
+	portid_t port_id;
+};
+
+static void cmd_set_bonding_mode_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_set_bonding_mode_result *res = parsed_result;
+	portid_t port_id = res->port_id;
+
+	/* Set the bonding mode for the relevant port. */
+	if (0 != rte_eth_bond_mode_set(port_id, res->value))
+		printf("\t Failed to set bonding mode for port = %d.\n", port_id);
+}
+
+cmdline_parse_token_string_t cmd_setbonding_mode_set =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_mode_result,
+		set, "set");
+cmdline_parse_token_string_t cmd_setbonding_mode_bonding =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_mode_result,
+		bonding, "bonding");
+cmdline_parse_token_string_t cmd_setbonding_mode_mode =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_mode_result,
+		mode, "mode");
+cmdline_parse_token_num_t cmd_setbonding_mode_value =
+TOKEN_NUM_INITIALIZER(struct cmd_set_bonding_mode_result,
+		value, UINT8);
+cmdline_parse_token_num_t cmd_setbonding_mode_port =
+TOKEN_NUM_INITIALIZER(struct cmd_set_bonding_mode_result,
+		port_id, UINT16);
+
+cmdline_parse_inst_t cmd_set_bonding_mode = {
+		.f = cmd_set_bonding_mode_parsed,
+		.help_str = "set bonding mode <mode_value> <port_id>: "
+			"Set the bonding mode for port_id",
+		.data = NULL,
+		.tokens = {
+				(void *) &cmd_setbonding_mode_set,
+				(void *) &cmd_setbonding_mode_bonding,
+				(void *) &cmd_setbonding_mode_mode,
+				(void *) &cmd_setbonding_mode_value,
+				(void *) &cmd_setbonding_mode_port,
+				NULL
+		}
+};
+
+/* *** SET BONDING SLOW_QUEUE SW/HW *** */
+struct cmd_set_bonding_lacp_dedicated_queues_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t lacp;
+	cmdline_fixed_string_t dedicated_queues;
+	portid_t port_id;
+	cmdline_fixed_string_t mode;
+};
+
+static void cmd_set_bonding_lacp_dedicated_queues_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_set_bonding_lacp_dedicated_queues_result *res = parsed_result;
+	portid_t port_id = res->port_id;
+	struct rte_port *port;
+
+	port = &ports[port_id];
+
+	/** Check if the port is not started **/
+	if (port->port_status != RTE_PORT_STOPPED) {
+		printf("Please stop port %d first\n", port_id);
+		return;
+	}
+
+	if (!strcmp(res->mode, "enable")) {
+		if (rte_eth_bond_8023ad_dedicated_queues_enable(port_id) == 0)
+			printf("Dedicate queues for LACP control packets"
+					" enabled\n");
+		else
+			printf("Enabling dedicate queues for LACP control "
+					"packets on port %d failed\n", port_id);
+	} else if (!strcmp(res->mode, "disable")) {
+		if (rte_eth_bond_8023ad_dedicated_queues_disable(port_id) == 0)
+			printf("Dedicated queues for LACP control packets "
+					"disabled\n");
+		else
+			printf("Disabling dedicated queues for LACP control "
+					"traffic on port %d failed\n", port_id);
+	}
+}
+
+cmdline_parse_token_string_t cmd_setbonding_lacp_dedicated_queues_set =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_lacp_dedicated_queues_result,
+		set, "set");
+cmdline_parse_token_string_t cmd_setbonding_lacp_dedicated_queues_bonding =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_lacp_dedicated_queues_result,
+		bonding, "bonding");
+cmdline_parse_token_string_t cmd_setbonding_lacp_dedicated_queues_lacp =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_lacp_dedicated_queues_result,
+		lacp, "lacp");
+cmdline_parse_token_string_t cmd_setbonding_lacp_dedicated_queues_dedicated_queues =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_lacp_dedicated_queues_result,
+		dedicated_queues, "dedicated_queues");
+cmdline_parse_token_num_t cmd_setbonding_lacp_dedicated_queues_port_id =
+TOKEN_NUM_INITIALIZER(struct cmd_set_bonding_lacp_dedicated_queues_result,
+		port_id, UINT16);
+cmdline_parse_token_string_t cmd_setbonding_lacp_dedicated_queues_mode =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_lacp_dedicated_queues_result,
+		mode, "enable#disable");
+
+cmdline_parse_inst_t cmd_set_lacp_dedicated_queues = {
+		.f = cmd_set_bonding_lacp_dedicated_queues_parsed,
+		.help_str = "set bonding lacp dedicated_queues <port_id> "
+			"enable|disable: "
+			"Enable/disable dedicated queues for LACP control traffic for port_id",
+		.data = NULL,
+		.tokens = {
+			(void *)&cmd_setbonding_lacp_dedicated_queues_set,
+			(void *)&cmd_setbonding_lacp_dedicated_queues_bonding,
+			(void *)&cmd_setbonding_lacp_dedicated_queues_lacp,
+			(void *)&cmd_setbonding_lacp_dedicated_queues_dedicated_queues,
+			(void *)&cmd_setbonding_lacp_dedicated_queues_port_id,
+			(void *)&cmd_setbonding_lacp_dedicated_queues_mode,
+			NULL
+		}
+};
+
+/* *** SET BALANCE XMIT POLICY *** */
+struct cmd_set_bonding_balance_xmit_policy_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t balance_xmit_policy;
+	portid_t port_id;
+	cmdline_fixed_string_t policy;
+};
+
+static void cmd_set_bonding_balance_xmit_policy_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_set_bonding_balance_xmit_policy_result *res = parsed_result;
+	portid_t port_id = res->port_id;
+	uint8_t policy;
+
+	if (!strcmp(res->policy, "l2")) {
+		policy = BALANCE_XMIT_POLICY_LAYER2;
+	} else if (!strcmp(res->policy, "l23")) {
+		policy = BALANCE_XMIT_POLICY_LAYER23;
+	} else if (!strcmp(res->policy, "l34")) {
+		policy = BALANCE_XMIT_POLICY_LAYER34;
+	} else {
+		printf("\t Invalid xmit policy selection");
+		return;
+	}
+
+	/* Set the bonding mode for the relevant port. */
+	if (0 != rte_eth_bond_xmit_policy_set(port_id, policy)) {
+		printf("\t Failed to set bonding balance xmit policy for port = %d.\n",
+				port_id);
+	}
+}
+
+cmdline_parse_token_string_t cmd_setbonding_balance_xmit_policy_set =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_balance_xmit_policy_result,
+		set, "set");
+cmdline_parse_token_string_t cmd_setbonding_balance_xmit_policy_bonding =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_balance_xmit_policy_result,
+		bonding, "bonding");
+cmdline_parse_token_string_t cmd_setbonding_balance_xmit_policy_balance_xmit_policy =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_balance_xmit_policy_result,
+		balance_xmit_policy, "balance_xmit_policy");
+cmdline_parse_token_num_t cmd_setbonding_balance_xmit_policy_port =
+TOKEN_NUM_INITIALIZER(struct cmd_set_bonding_balance_xmit_policy_result,
+		port_id, UINT16);
+cmdline_parse_token_string_t cmd_setbonding_balance_xmit_policy_policy =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_balance_xmit_policy_result,
+		policy, "l2#l23#l34");
+
+cmdline_parse_inst_t cmd_set_balance_xmit_policy = {
+		.f = cmd_set_bonding_balance_xmit_policy_parsed,
+		.help_str = "set bonding balance_xmit_policy <port_id> "
+			"l2|l23|l34: "
+			"Set the bonding balance_xmit_policy for port_id",
+		.data = NULL,
+		.tokens = {
+				(void *)&cmd_setbonding_balance_xmit_policy_set,
+				(void *)&cmd_setbonding_balance_xmit_policy_bonding,
+				(void *)&cmd_setbonding_balance_xmit_policy_balance_xmit_policy,
+				(void *)&cmd_setbonding_balance_xmit_policy_port,
+				(void *)&cmd_setbonding_balance_xmit_policy_policy,
+				NULL
+		}
+};
+
+/* *** SHOW NIC BONDING CONFIGURATION *** */
+struct cmd_show_bonding_config_result {
+	cmdline_fixed_string_t show;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t config;
+	portid_t port_id;
+};
+
+static void cmd_show_bonding_config_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_show_bonding_config_result *res = parsed_result;
+	int bonding_mode, agg_mode;
+	portid_t slaves[RTE_MAX_ETHPORTS];
+	int num_slaves, num_active_slaves;
+	int primary_id;
+	int i;
+	portid_t port_id = res->port_id;
+
+	/* Display the bonding mode.*/
+	bonding_mode = rte_eth_bond_mode_get(port_id);
+	if (bonding_mode < 0) {
+		printf("\tFailed to get bonding mode for port = %d\n", port_id);
+		return;
+	} else
+		printf("\tBonding mode: %d\n", bonding_mode);
+
+	if (bonding_mode == BONDING_MODE_BALANCE) {
+		int balance_xmit_policy;
+
+		balance_xmit_policy = rte_eth_bond_xmit_policy_get(port_id);
+		if (balance_xmit_policy < 0) {
+			printf("\tFailed to get balance xmit policy for port = %d\n",
+					port_id);
+			return;
+		} else {
+			printf("\tBalance Xmit Policy: ");
+
+			switch (balance_xmit_policy) {
+			case BALANCE_XMIT_POLICY_LAYER2:
+				printf("BALANCE_XMIT_POLICY_LAYER2");
+				break;
+			case BALANCE_XMIT_POLICY_LAYER23:
+				printf("BALANCE_XMIT_POLICY_LAYER23");
+				break;
+			case BALANCE_XMIT_POLICY_LAYER34:
+				printf("BALANCE_XMIT_POLICY_LAYER34");
+				break;
+			}
+			printf("\n");
+		}
+	}
+
+	if (bonding_mode == BONDING_MODE_8023AD) {
+		agg_mode = rte_eth_bond_8023ad_agg_selection_get(port_id);
+		printf("\tIEEE802.3AD Aggregator Mode: ");
+		switch (agg_mode) {
+		case AGG_BANDWIDTH:
+			printf("bandwidth");
+			break;
+		case AGG_STABLE:
+			printf("stable");
+			break;
+		case AGG_COUNT:
+			printf("count");
+			break;
+		}
+		printf("\n");
+	}
+
+	num_slaves = rte_eth_bond_slaves_get(port_id, slaves, RTE_MAX_ETHPORTS);
+
+	if (num_slaves < 0) {
+		printf("\tFailed to get slave list for port = %d\n", port_id);
+		return;
+	}
+	if (num_slaves > 0) {
+		printf("\tSlaves (%d): [", num_slaves);
+		for (i = 0; i < num_slaves - 1; i++)
+			printf("%d ", slaves[i]);
+
+		printf("%d]\n", slaves[num_slaves - 1]);
+	} else {
+		printf("\tSlaves: []\n");
+
+	}
+
+	num_active_slaves = rte_eth_bond_active_slaves_get(port_id, slaves,
+			RTE_MAX_ETHPORTS);
+
+	if (num_active_slaves < 0) {
+		printf("\tFailed to get active slave list for port = %d\n", port_id);
+		return;
+	}
+	if (num_active_slaves > 0) {
+		printf("\tActive Slaves (%d): [", num_active_slaves);
+		for (i = 0; i < num_active_slaves - 1; i++)
+			printf("%d ", slaves[i]);
+
+		printf("%d]\n", slaves[num_active_slaves - 1]);
+
+	} else {
+		printf("\tActive Slaves: []\n");
+
+	}
+
+	primary_id = rte_eth_bond_primary_get(port_id);
+	if (primary_id < 0) {
+		printf("\tFailed to get primary slave for port = %d\n", port_id);
+		return;
+	} else
+		printf("\tPrimary: [%d]\n", primary_id);
+
+}
+
+cmdline_parse_token_string_t cmd_showbonding_config_show =
+TOKEN_STRING_INITIALIZER(struct cmd_show_bonding_config_result,
+		show, "show");
+cmdline_parse_token_string_t cmd_showbonding_config_bonding =
+TOKEN_STRING_INITIALIZER(struct cmd_show_bonding_config_result,
+		bonding, "bonding");
+cmdline_parse_token_string_t cmd_showbonding_config_config =
+TOKEN_STRING_INITIALIZER(struct cmd_show_bonding_config_result,
+		config, "config");
+cmdline_parse_token_num_t cmd_showbonding_config_port =
+TOKEN_NUM_INITIALIZER(struct cmd_show_bonding_config_result,
+		port_id, UINT16);
+
+cmdline_parse_inst_t cmd_show_bonding_config = {
+		.f = cmd_show_bonding_config_parsed,
+		.help_str = "show bonding config <port_id>: "
+			"Show the bonding config for port_id",
+		.data = NULL,
+		.tokens = {
+				(void *)&cmd_showbonding_config_show,
+				(void *)&cmd_showbonding_config_bonding,
+				(void *)&cmd_showbonding_config_config,
+				(void *)&cmd_showbonding_config_port,
+				NULL
+		}
+};
+
+/* *** SET BONDING PRIMARY *** */
+struct cmd_set_bonding_primary_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t primary;
+	portid_t slave_id;
+	portid_t port_id;
+};
+
+static void cmd_set_bonding_primary_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_set_bonding_primary_result *res = parsed_result;
+	portid_t master_port_id = res->port_id;
+	portid_t slave_port_id = res->slave_id;
+
+	/* Set the primary slave for a bonded device. */
+	if (0 != rte_eth_bond_primary_set(master_port_id, slave_port_id)) {
+		printf("\t Failed to set primary slave for port = %d.\n",
+				master_port_id);
+		return;
+	}
+	init_port_config();
+}
+
+cmdline_parse_token_string_t cmd_setbonding_primary_set =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_primary_result,
+		set, "set");
+cmdline_parse_token_string_t cmd_setbonding_primary_bonding =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_primary_result,
+		bonding, "bonding");
+cmdline_parse_token_string_t cmd_setbonding_primary_primary =
+TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_primary_result,
+		primary, "primary");
+cmdline_parse_token_num_t cmd_setbonding_primary_slave =
+TOKEN_NUM_INITIALIZER(struct cmd_set_bonding_primary_result,
+		slave_id, UINT16);
+cmdline_parse_token_num_t cmd_setbonding_primary_port =
+TOKEN_NUM_INITIALIZER(struct cmd_set_bonding_primary_result,
+		port_id, UINT16);
+
+cmdline_parse_inst_t cmd_set_bonding_primary = {
+		.f = cmd_set_bonding_primary_parsed,
+		.help_str = "set bonding primary <slave_id> <port_id>: "
+			"Set the primary slave for port_id",
+		.data = NULL,
+		.tokens = {
+				(void *)&cmd_setbonding_primary_set,
+				(void *)&cmd_setbonding_primary_bonding,
+				(void *)&cmd_setbonding_primary_primary,
+				(void *)&cmd_setbonding_primary_slave,
+				(void *)&cmd_setbonding_primary_port,
+				NULL
+		}
+};
+
+/* *** ADD SLAVE *** */
+struct cmd_add_bonding_slave_result {
+	cmdline_fixed_string_t add;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t slave;
+	portid_t slave_id;
+	portid_t port_id;
+};
+
+static void cmd_add_bonding_slave_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_add_bonding_slave_result *res = parsed_result;
+	portid_t master_port_id = res->port_id;
+	portid_t slave_port_id = res->slave_id;
+
+	/* add the slave for a bonded device. */
+	if (0 != rte_eth_bond_slave_add(master_port_id, slave_port_id)) {
+		printf("\t Failed to add slave %d to master port = %d.\n",
+				slave_port_id, master_port_id);
+		return;
+	}
+	init_port_config();
+	set_port_slave_flag(slave_port_id);
+}
+
+cmdline_parse_token_string_t cmd_addbonding_slave_add =
+TOKEN_STRING_INITIALIZER(struct cmd_add_bonding_slave_result,
+		add, "add");
+cmdline_parse_token_string_t cmd_addbonding_slave_bonding =
+TOKEN_STRING_INITIALIZER(struct cmd_add_bonding_slave_result,
+		bonding, "bonding");
+cmdline_parse_token_string_t cmd_addbonding_slave_slave =
+TOKEN_STRING_INITIALIZER(struct cmd_add_bonding_slave_result,
+		slave, "slave");
+cmdline_parse_token_num_t cmd_addbonding_slave_slaveid =
+TOKEN_NUM_INITIALIZER(struct cmd_add_bonding_slave_result,
+		slave_id, UINT16);
+cmdline_parse_token_num_t cmd_addbonding_slave_port =
+TOKEN_NUM_INITIALIZER(struct cmd_add_bonding_slave_result,
+		port_id, UINT16);
+
+cmdline_parse_inst_t cmd_add_bonding_slave = {
+		.f = cmd_add_bonding_slave_parsed,
+		.help_str = "add bonding slave <slave_id> <port_id>: "
+			"Add a slave device to a bonded device",
+		.data = NULL,
+		.tokens = {
+				(void *)&cmd_addbonding_slave_add,
+				(void *)&cmd_addbonding_slave_bonding,
+				(void *)&cmd_addbonding_slave_slave,
+				(void *)&cmd_addbonding_slave_slaveid,
+				(void *)&cmd_addbonding_slave_port,
+				NULL
+		}
+};
+
+/* *** REMOVE SLAVE *** */
+struct cmd_remove_bonding_slave_result {
+	cmdline_fixed_string_t remove;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t slave;
+	portid_t slave_id;
+	portid_t port_id;
+};
+
+static void cmd_remove_bonding_slave_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_remove_bonding_slave_result *res = parsed_result;
+	portid_t master_port_id = res->port_id;
+	portid_t slave_port_id = res->slave_id;
+
+	/* remove the slave from a bonded device. */
+	if (0 != rte_eth_bond_slave_remove(master_port_id, slave_port_id)) {
+		printf("\t Failed to remove slave %d from master port = %d.\n",
+				slave_port_id, master_port_id);
+		return;
+	}
+	init_port_config();
+	clear_port_slave_flag(slave_port_id);
+}
+
+cmdline_parse_token_string_t cmd_removebonding_slave_remove =
+		TOKEN_STRING_INITIALIZER(struct cmd_remove_bonding_slave_result,
+				remove, "remove");
+cmdline_parse_token_string_t cmd_removebonding_slave_bonding =
+		TOKEN_STRING_INITIALIZER(struct cmd_remove_bonding_slave_result,
+				bonding, "bonding");
+cmdline_parse_token_string_t cmd_removebonding_slave_slave =
+		TOKEN_STRING_INITIALIZER(struct cmd_remove_bonding_slave_result,
+				slave, "slave");
+cmdline_parse_token_num_t cmd_removebonding_slave_slaveid =
+		TOKEN_NUM_INITIALIZER(struct cmd_remove_bonding_slave_result,
+				slave_id, UINT16);
+cmdline_parse_token_num_t cmd_removebonding_slave_port =
+		TOKEN_NUM_INITIALIZER(struct cmd_remove_bonding_slave_result,
+				port_id, UINT16);
+
+cmdline_parse_inst_t cmd_remove_bonding_slave = {
+		.f = cmd_remove_bonding_slave_parsed,
+		.help_str = "remove bonding slave <slave_id> <port_id>: "
+			"Remove a slave device from a bonded device",
+		.data = NULL,
+		.tokens = {
+				(void *)&cmd_removebonding_slave_remove,
+				(void *)&cmd_removebonding_slave_bonding,
+				(void *)&cmd_removebonding_slave_slave,
+				(void *)&cmd_removebonding_slave_slaveid,
+				(void *)&cmd_removebonding_slave_port,
+				NULL
+		}
+};
+
+/* *** CREATE BONDED DEVICE *** */
+struct cmd_create_bonded_device_result {
+	cmdline_fixed_string_t create;
+	cmdline_fixed_string_t bonded;
+	cmdline_fixed_string_t device;
+	uint8_t mode;
+	uint8_t socket;
+};
+
+static int bond_dev_num = 0;
+
+static void cmd_create_bonded_device_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_create_bonded_device_result *res = parsed_result;
+	char ethdev_name[RTE_ETH_NAME_MAX_LEN];
+	int port_id;
+	int ret;
+
+	if (test_done == 0) {
+		printf("Please stop forwarding first\n");
+		return;
+	}
+
+	snprintf(ethdev_name, RTE_ETH_NAME_MAX_LEN, "net_bonding_testpmd_%d",
+			bond_dev_num++);
+
+	/* Create a new bonded device. */
+	port_id = rte_eth_bond_create(ethdev_name, res->mode, res->socket);
+	if (port_id < 0) {
+		printf("\t Failed to create bonded device.\n");
+		return;
+	} else {
+		printf("Created new bonded device %s on (port %d).\n", ethdev_name,
+				port_id);
+
+		/* Update number of ports */
+		nb_ports = rte_eth_dev_count_avail();
+		reconfig(port_id, res->socket);
+		ret = rte_eth_promiscuous_enable(port_id);
+		if (ret != 0)
+			printf("Failed to enable promiscuous mode for port %u: %s - ignore\n",
+				port_id, rte_strerror(-ret));
+
+		ports[port_id].need_setup = 0;
+		ports[port_id].port_status = RTE_PORT_STOPPED;
+	}
+
+}
+
+cmdline_parse_token_string_t cmd_createbonded_device_create =
+		TOKEN_STRING_INITIALIZER(struct cmd_create_bonded_device_result,
+				create, "create");
+cmdline_parse_token_string_t cmd_createbonded_device_bonded =
+		TOKEN_STRING_INITIALIZER(struct cmd_create_bonded_device_result,
+				bonded, "bonded");
+cmdline_parse_token_string_t cmd_createbonded_device_device =
+		TOKEN_STRING_INITIALIZER(struct cmd_create_bonded_device_result,
+				device, "device");
+cmdline_parse_token_num_t cmd_createbonded_device_mode =
+		TOKEN_NUM_INITIALIZER(struct cmd_create_bonded_device_result,
+				mode, UINT8);
+cmdline_parse_token_num_t cmd_createbonded_device_socket =
+		TOKEN_NUM_INITIALIZER(struct cmd_create_bonded_device_result,
+				socket, UINT8);
+
+cmdline_parse_inst_t cmd_create_bonded_device = {
+		.f = cmd_create_bonded_device_parsed,
+		.help_str = "create bonded device <mode> <socket>: "
+			"Create a new bonded device with specific bonding mode and socket",
+		.data = NULL,
+		.tokens = {
+				(void *)&cmd_createbonded_device_create,
+				(void *)&cmd_createbonded_device_bonded,
+				(void *)&cmd_createbonded_device_device,
+				(void *)&cmd_createbonded_device_mode,
+				(void *)&cmd_createbonded_device_socket,
+				NULL
+		}
+};
+
+/* *** SET MAC ADDRESS IN BONDED DEVICE *** */
+struct cmd_set_bond_mac_addr_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t mac_addr;
+	uint16_t port_num;
+	struct rte_ether_addr address;
+};
+
+static void cmd_set_bond_mac_addr_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_set_bond_mac_addr_result *res = parsed_result;
+	int ret;
+
+	if (port_id_is_invalid(res->port_num, ENABLED_WARN))
+		return;
+
+	ret = rte_eth_bond_mac_address_set(res->port_num, &res->address);
+
+	/* check the return value and print it if is < 0 */
+	if (ret < 0)
+		printf("set_bond_mac_addr error: (%s)\n", strerror(-ret));
+}
+
+cmdline_parse_token_string_t cmd_set_bond_mac_addr_set =
+		TOKEN_STRING_INITIALIZER(struct cmd_set_bond_mac_addr_result, set, "set");
+cmdline_parse_token_string_t cmd_set_bond_mac_addr_bonding =
+		TOKEN_STRING_INITIALIZER(struct cmd_set_bond_mac_addr_result, bonding,
+				"bonding");
+cmdline_parse_token_string_t cmd_set_bond_mac_addr_mac =
+		TOKEN_STRING_INITIALIZER(struct cmd_set_bond_mac_addr_result, mac_addr,
+				"mac_addr");
+cmdline_parse_token_num_t cmd_set_bond_mac_addr_portnum =
+		TOKEN_NUM_INITIALIZER(struct cmd_set_bond_mac_addr_result,
+				port_num, UINT16);
+cmdline_parse_token_etheraddr_t cmd_set_bond_mac_addr_addr =
+		TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_bond_mac_addr_result, address);
+
+cmdline_parse_inst_t cmd_set_bond_mac_addr = {
+		.f = cmd_set_bond_mac_addr_parsed,
+		.data = (void *) 0,
+		.help_str = "set bonding mac_addr <port_id> <mac_addr>",
+		.tokens = {
+				(void *)&cmd_set_bond_mac_addr_set,
+				(void *)&cmd_set_bond_mac_addr_bonding,
+				(void *)&cmd_set_bond_mac_addr_mac,
+				(void *)&cmd_set_bond_mac_addr_portnum,
+				(void *)&cmd_set_bond_mac_addr_addr,
+				NULL
+		}
+};
+
+
+/* *** SET LINK STATUS MONITORING POLLING PERIOD ON BONDED DEVICE *** */
+struct cmd_set_bond_mon_period_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t mon_period;
+	uint16_t port_num;
+	uint32_t period_ms;
+};
+
+static void cmd_set_bond_mon_period_parsed(void *parsed_result,
+		__attribute__((unused))  struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_set_bond_mon_period_result *res = parsed_result;
+	int ret;
+
+	ret = rte_eth_bond_link_monitoring_set(res->port_num, res->period_ms);
+
+	/* check the return value and print it if is < 0 */
+	if (ret < 0)
+		printf("set_bond_mac_addr error: (%s)\n", strerror(-ret));
+}
+
+cmdline_parse_token_string_t cmd_set_bond_mon_period_set =
+		TOKEN_STRING_INITIALIZER(struct cmd_set_bond_mon_period_result,
+				set, "set");
+cmdline_parse_token_string_t cmd_set_bond_mon_period_bonding =
+		TOKEN_STRING_INITIALIZER(struct cmd_set_bond_mon_period_result,
+				bonding, "bonding");
+cmdline_parse_token_string_t cmd_set_bond_mon_period_mon_period =
+		TOKEN_STRING_INITIALIZER(struct cmd_set_bond_mon_period_result,
+				mon_period,	"mon_period");
+cmdline_parse_token_num_t cmd_set_bond_mon_period_portnum =
+		TOKEN_NUM_INITIALIZER(struct cmd_set_bond_mon_period_result,
+				port_num, UINT16);
+cmdline_parse_token_num_t cmd_set_bond_mon_period_period_ms =
+		TOKEN_NUM_INITIALIZER(struct cmd_set_bond_mon_period_result,
+				period_ms, UINT32);
+
+cmdline_parse_inst_t cmd_set_bond_mon_period = {
+		.f = cmd_set_bond_mon_period_parsed,
+		.data = (void *) 0,
+		.help_str = "set bonding mon_period <port_id> <period_ms>",
+		.tokens = {
+				(void *)&cmd_set_bond_mon_period_set,
+				(void *)&cmd_set_bond_mon_period_bonding,
+				(void *)&cmd_set_bond_mon_period_mon_period,
+				(void *)&cmd_set_bond_mon_period_portnum,
+				(void *)&cmd_set_bond_mon_period_period_ms,
+				NULL
+		}
+};
+
+
+
+struct cmd_set_bonding_agg_mode_policy_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t bonding;
+	cmdline_fixed_string_t agg_mode;
+	uint16_t port_num;
+	cmdline_fixed_string_t policy;
+};
+
+
+static void
+cmd_set_bonding_agg_mode(void *parsed_result,
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_set_bonding_agg_mode_policy_result *res = parsed_result;
+	uint8_t policy = AGG_BANDWIDTH;
+
+	if (!strcmp(res->policy, "bandwidth"))
+		policy = AGG_BANDWIDTH;
+	else if (!strcmp(res->policy, "stable"))
+		policy = AGG_STABLE;
+	else if (!strcmp(res->policy, "count"))
+		policy = AGG_COUNT;
+
+	rte_eth_bond_8023ad_agg_selection_set(res->port_num, policy);
+}
+
+
+cmdline_parse_token_string_t cmd_set_bonding_agg_mode_set =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_agg_mode_policy_result,
+				set, "set");
+cmdline_parse_token_string_t cmd_set_bonding_agg_mode_bonding =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_agg_mode_policy_result,
+				bonding, "bonding");
+
+cmdline_parse_token_string_t cmd_set_bonding_agg_mode_agg_mode =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_bonding_agg_mode_policy_result,
+				agg_mode, "agg_mode");
+
+cmdline_parse_token_num_t cmd_set_bonding_agg_mode_portnum =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_bonding_agg_mode_policy_result,
+				port_num, UINT16);
+
+cmdline_parse_token_string_t cmd_set_bonding_agg_mode_policy_string =
+	TOKEN_STRING_INITIALIZER(
+			struct cmd_set_bonding_balance_xmit_policy_result,
+		policy, "stable#bandwidth#count");
+
+cmdline_parse_inst_t cmd_set_bonding_agg_mode_policy = {
+	.f = cmd_set_bonding_agg_mode,
+	.data = (void *) 0,
+	.help_str = "set bonding mode IEEE802.3AD aggregator policy <port_id> <agg_name>",
+	.tokens = {
+			(void *)&cmd_set_bonding_agg_mode_set,
+			(void *)&cmd_set_bonding_agg_mode_bonding,
+			(void *)&cmd_set_bonding_agg_mode_agg_mode,
+			(void *)&cmd_set_bonding_agg_mode_portnum,
+			(void *)&cmd_set_bonding_agg_mode_policy_string,
+			NULL
+		}
+};
+
+
+#endif /* RTE_LIBRTE_PMD_BOND */
+
 /* *** SET FORWARDING MODE *** */
 struct cmd_set_fwd_mode_result {
 	cmdline_fixed_string_t set;
@@ -5512,8 +6416,8 @@
 };
 
 static void cmd_set_fwd_mode_parsed(void *parsed_result,
-				    __rte_unused struct cmdline *cl,
-				    __rte_unused void *data)
+				    __attribute__((unused)) struct cmdline *cl,
+				    __attribute__((unused)) void *data)
 {
 	struct cmd_set_fwd_mode_result *res = parsed_result;
 
@@ -5521,15 +6425,15 @@
 	set_pkt_forwarding_mode(res->mode);
 }
 
-static cmdline_parse_token_string_t cmd_setfwd_set =
+cmdline_parse_token_string_t cmd_setfwd_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_fwd_mode_result, set, "set");
-static cmdline_parse_token_string_t cmd_setfwd_fwd =
+cmdline_parse_token_string_t cmd_setfwd_fwd =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_fwd_mode_result, fwd, "fwd");
-static cmdline_parse_token_string_t cmd_setfwd_mode =
+cmdline_parse_token_string_t cmd_setfwd_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_fwd_mode_result, mode,
 		"" /* defined at init */);
 
-static cmdline_parse_inst_t cmd_set_fwd_mode = {
+cmdline_parse_inst_t cmd_set_fwd_mode = {
 	.f = cmd_set_fwd_mode_parsed,
 	.data = NULL,
 	.help_str = NULL, /* defined at init */
@@ -5572,8 +6476,8 @@
 };
 
 static void cmd_set_fwd_retry_mode_parsed(void *parsed_result,
-			    __rte_unused struct cmdline *cl,
-			    __rte_unused void *data)
+			    __attribute__((unused)) struct cmdline *cl,
+			    __attribute__((unused)) void *data)
 {
 	struct cmd_set_fwd_retry_mode_result *res = parsed_result;
 
@@ -5581,21 +6485,21 @@
 	set_pkt_forwarding_mode(res->mode);
 }
 
-static cmdline_parse_token_string_t cmd_setfwd_retry_set =
+cmdline_parse_token_string_t cmd_setfwd_retry_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_fwd_retry_mode_result,
 			set, "set");
-static cmdline_parse_token_string_t cmd_setfwd_retry_fwd =
+cmdline_parse_token_string_t cmd_setfwd_retry_fwd =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_fwd_retry_mode_result,
 			fwd, "fwd");
-static cmdline_parse_token_string_t cmd_setfwd_retry_mode =
+cmdline_parse_token_string_t cmd_setfwd_retry_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_fwd_retry_mode_result,
 			mode,
 		"" /* defined at init */);
-static cmdline_parse_token_string_t cmd_setfwd_retry_retry =
+cmdline_parse_token_string_t cmd_setfwd_retry_retry =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_fwd_retry_mode_result,
 			retry, "retry");
 
-static cmdline_parse_inst_t cmd_set_fwd_retry_mode = {
+cmdline_parse_inst_t cmd_set_fwd_retry_mode = {
 	.f = cmd_set_fwd_retry_mode_parsed,
 	.data = NULL,
 	.help_str = NULL, /* defined at init */
@@ -5643,8 +6547,8 @@
 };
 
 static void cmd_set_burst_tx_retry_parsed(void *parsed_result,
-					__rte_unused struct cmdline *cl,
-					__rte_unused void *data)
+					__attribute__((unused)) struct cmdline *cl,
+					__attribute__((unused)) void *data)
 {
 	struct cmd_set_burst_tx_retry_result *res = parsed_result;
 
@@ -5658,25 +6562,23 @@
 
 }
 
-static cmdline_parse_token_string_t cmd_set_burst_tx_retry_set =
+cmdline_parse_token_string_t cmd_set_burst_tx_retry_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_burst_tx_retry_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_burst_tx_retry_burst =
+cmdline_parse_token_string_t cmd_set_burst_tx_retry_burst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_burst_tx_retry_result, burst,
 				 "burst");
-static cmdline_parse_token_string_t cmd_set_burst_tx_retry_tx =
+cmdline_parse_token_string_t cmd_set_burst_tx_retry_tx =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_burst_tx_retry_result, tx, "tx");
-static cmdline_parse_token_string_t cmd_set_burst_tx_retry_delay =
+cmdline_parse_token_string_t cmd_set_burst_tx_retry_delay =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_burst_tx_retry_result, delay, "delay");
-static cmdline_parse_token_num_t cmd_set_burst_tx_retry_time =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_burst_tx_retry_result, time,
-				 RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_burst_tx_retry_retry =
+cmdline_parse_token_num_t cmd_set_burst_tx_retry_time =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_burst_tx_retry_result, time, UINT32);
+cmdline_parse_token_string_t cmd_set_burst_tx_retry_retry =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_burst_tx_retry_result, retry, "retry");
-static cmdline_parse_token_num_t cmd_set_burst_tx_retry_retry_num =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_burst_tx_retry_result, retry_num,
-				 RTE_UINT32);
+cmdline_parse_token_num_t cmd_set_burst_tx_retry_retry_num =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_burst_tx_retry_result, retry_num, UINT32);
 
-static cmdline_parse_inst_t cmd_set_burst_tx_retry = {
+cmdline_parse_inst_t cmd_set_burst_tx_retry = {
 	.f = cmd_set_burst_tx_retry_parsed,
 	.help_str = "set burst tx delay <delay_usec> retry <num_retry>",
 	.tokens = {
@@ -5701,7 +6603,7 @@
 };
 
 static void cmd_set_promisc_mode_parsed(void *parsed_result,
-					__rte_unused struct cmdline *cl,
+					__attribute__((unused)) struct cmdline *cl,
 					void *allports)
 {
 	struct cmd_set_promisc_mode_result *res = parsed_result;
@@ -5722,22 +6624,22 @@
 	}
 }
 
-static cmdline_parse_token_string_t cmd_setpromisc_set =
+cmdline_parse_token_string_t cmd_setpromisc_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_promisc_mode_result, set, "set");
-static cmdline_parse_token_string_t cmd_setpromisc_promisc =
+cmdline_parse_token_string_t cmd_setpromisc_promisc =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_promisc_mode_result, promisc,
 				 "promisc");
-static cmdline_parse_token_string_t cmd_setpromisc_portall =
+cmdline_parse_token_string_t cmd_setpromisc_portall =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_promisc_mode_result, port_all,
 				 "all");
-static cmdline_parse_token_num_t cmd_setpromisc_portnum =
+cmdline_parse_token_num_t cmd_setpromisc_portnum =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_promisc_mode_result, port_num,
-			      RTE_UINT16);
-static cmdline_parse_token_string_t cmd_setpromisc_mode =
+			      UINT16);
+cmdline_parse_token_string_t cmd_setpromisc_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_promisc_mode_result, mode,
 				 "on#off");
 
-static cmdline_parse_inst_t cmd_set_promisc_mode_all = {
+cmdline_parse_inst_t cmd_set_promisc_mode_all = {
 	.f = cmd_set_promisc_mode_parsed,
 	.data = (void *)1,
 	.help_str = "set promisc all on|off: Set promisc mode for all ports",
@@ -5750,7 +6652,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_promisc_mode_one = {
+cmdline_parse_inst_t cmd_set_promisc_mode_one = {
 	.f = cmd_set_promisc_mode_parsed,
 	.data = (void *)0,
 	.help_str = "set promisc <port_id> on|off: Set promisc mode on port_id",
@@ -5773,7 +6675,7 @@
 };
 
 static void cmd_set_allmulti_mode_parsed(void *parsed_result,
-					__rte_unused struct cmdline *cl,
+					__attribute__((unused)) struct cmdline *cl,
 					void *allports)
 {
 	struct cmd_set_allmulti_mode_result *res = parsed_result;
@@ -5796,22 +6698,22 @@
 	}
 }
 
-static cmdline_parse_token_string_t cmd_setallmulti_set =
+cmdline_parse_token_string_t cmd_setallmulti_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_allmulti_mode_result, set, "set");
-static cmdline_parse_token_string_t cmd_setallmulti_allmulti =
+cmdline_parse_token_string_t cmd_setallmulti_allmulti =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_allmulti_mode_result, allmulti,
 				 "allmulti");
-static cmdline_parse_token_string_t cmd_setallmulti_portall =
+cmdline_parse_token_string_t cmd_setallmulti_portall =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_allmulti_mode_result, port_all,
 				 "all");
-static cmdline_parse_token_num_t cmd_setallmulti_portnum =
+cmdline_parse_token_num_t cmd_setallmulti_portnum =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_allmulti_mode_result, port_num,
-			      RTE_UINT16);
-static cmdline_parse_token_string_t cmd_setallmulti_mode =
+			      UINT16);
+cmdline_parse_token_string_t cmd_setallmulti_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_allmulti_mode_result, mode,
 				 "on#off");
 
-static cmdline_parse_inst_t cmd_set_allmulti_mode_all = {
+cmdline_parse_inst_t cmd_set_allmulti_mode_all = {
 	.f = cmd_set_allmulti_mode_parsed,
 	.data = (void *)1,
 	.help_str = "set allmulti all on|off: Set allmulti mode for all ports",
@@ -5824,7 +6726,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_allmulti_mode_one = {
+cmdline_parse_inst_t cmd_set_allmulti_mode_one = {
 	.f = cmd_set_allmulti_mode_parsed,
 	.data = (void *)0,
 	.help_str = "set allmulti <port_id> on|off: "
@@ -5838,81 +6740,6 @@
 	},
 };
 
-/* *** GET CURRENT ETHERNET LINK FLOW CONTROL *** */
-struct cmd_link_flow_ctrl_show {
-	cmdline_fixed_string_t show;
-	cmdline_fixed_string_t port;
-	portid_t port_id;
-	cmdline_fixed_string_t flow_ctrl;
-};
-
-static cmdline_parse_token_string_t cmd_lfc_show_show =
-	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_show,
-				show, "show");
-static cmdline_parse_token_string_t cmd_lfc_show_port =
-	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_show,
-				port, "port");
-static cmdline_parse_token_num_t cmd_lfc_show_portid =
-	TOKEN_NUM_INITIALIZER(struct cmd_link_flow_ctrl_show,
-				port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_lfc_show_flow_ctrl =
-	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_show,
-				flow_ctrl, "flow_ctrl");
-
-static void
-cmd_link_flow_ctrl_show_parsed(void *parsed_result,
-			      __rte_unused struct cmdline *cl,
-			      __rte_unused void *data)
-{
-	struct cmd_link_flow_ctrl_show *res = parsed_result;
-	static const char *info_border = "*********************";
-	struct rte_eth_fc_conf fc_conf;
-	bool rx_fc_en = false;
-	bool tx_fc_en = false;
-	int ret;
-
-	ret = rte_eth_dev_flow_ctrl_get(res->port_id, &fc_conf);
-	if (ret != 0) {
-		fprintf(stderr,
-			"Failed to get current flow ctrl information: err = %d\n",
-			ret);
-		return;
-	}
-
-	if (fc_conf.mode == RTE_ETH_FC_RX_PAUSE || fc_conf.mode == RTE_ETH_FC_FULL)
-		rx_fc_en = true;
-	if (fc_conf.mode == RTE_ETH_FC_TX_PAUSE || fc_conf.mode == RTE_ETH_FC_FULL)
-		tx_fc_en = true;
-
-	printf("\n%s Flow control infos for port %-2d %s\n",
-		info_border, res->port_id, info_border);
-	printf("FC mode:\n");
-	printf("   Rx pause: %s\n", rx_fc_en ? "on" : "off");
-	printf("   Tx pause: %s\n", tx_fc_en ? "on" : "off");
-	printf("Autoneg: %s\n", fc_conf.autoneg ? "on" : "off");
-	printf("Pause time: 0x%x\n", fc_conf.pause_time);
-	printf("High waterline: 0x%x\n", fc_conf.high_water);
-	printf("Low waterline: 0x%x\n", fc_conf.low_water);
-	printf("Send XON: %s\n", fc_conf.send_xon ? "on" : "off");
-	printf("Forward MAC control frames: %s\n",
-		fc_conf.mac_ctrl_frame_fwd ? "on" : "off");
-	printf("\n%s**************   End  ***********%s\n",
-		info_border, info_border);
-}
-
-static cmdline_parse_inst_t cmd_link_flow_control_show = {
-	.f = cmd_link_flow_ctrl_show_parsed,
-	.data = NULL,
-	.help_str = "show port <port_id> flow_ctrl",
-	.tokens = {
-		(void *)&cmd_lfc_show_show,
-		(void *)&cmd_lfc_show_port,
-		(void *)&cmd_lfc_show_portid,
-		(void *)&cmd_lfc_show_flow_ctrl,
-		NULL,
-	},
-};
-
 /* *** SETUP ETHERNET LINK FLOW CONTROL *** */
 struct cmd_link_flow_ctrl_set_result {
 	cmdline_fixed_string_t set;
@@ -5936,70 +6763,70 @@
 	portid_t port_id;
 };
 
-static cmdline_parse_token_string_t cmd_lfc_set_set =
+cmdline_parse_token_string_t cmd_lfc_set_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				set, "set");
-static cmdline_parse_token_string_t cmd_lfc_set_flow_ctrl =
+cmdline_parse_token_string_t cmd_lfc_set_flow_ctrl =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				flow_ctrl, "flow_ctrl");
-static cmdline_parse_token_string_t cmd_lfc_set_rx =
+cmdline_parse_token_string_t cmd_lfc_set_rx =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				rx, "rx");
-static cmdline_parse_token_string_t cmd_lfc_set_rx_mode =
+cmdline_parse_token_string_t cmd_lfc_set_rx_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				rx_lfc_mode, "on#off");
-static cmdline_parse_token_string_t cmd_lfc_set_tx =
+cmdline_parse_token_string_t cmd_lfc_set_tx =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				tx, "tx");
-static cmdline_parse_token_string_t cmd_lfc_set_tx_mode =
+cmdline_parse_token_string_t cmd_lfc_set_tx_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				tx_lfc_mode, "on#off");
-static cmdline_parse_token_string_t cmd_lfc_set_high_water_str =
+cmdline_parse_token_string_t cmd_lfc_set_high_water_str =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				hw_str, "high_water");
-static cmdline_parse_token_num_t cmd_lfc_set_high_water =
+cmdline_parse_token_num_t cmd_lfc_set_high_water =
 	TOKEN_NUM_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
-				high_water, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_lfc_set_low_water_str =
+				high_water, UINT32);
+cmdline_parse_token_string_t cmd_lfc_set_low_water_str =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				lw_str, "low_water");
-static cmdline_parse_token_num_t cmd_lfc_set_low_water =
+cmdline_parse_token_num_t cmd_lfc_set_low_water =
 	TOKEN_NUM_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
-				low_water, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_lfc_set_pause_time_str =
+				low_water, UINT32);
+cmdline_parse_token_string_t cmd_lfc_set_pause_time_str =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				pt_str, "pause_time");
-static cmdline_parse_token_num_t cmd_lfc_set_pause_time =
+cmdline_parse_token_num_t cmd_lfc_set_pause_time =
 	TOKEN_NUM_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
-				pause_time, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_lfc_set_send_xon_str =
+				pause_time, UINT16);
+cmdline_parse_token_string_t cmd_lfc_set_send_xon_str =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				xon_str, "send_xon");
-static cmdline_parse_token_num_t cmd_lfc_set_send_xon =
+cmdline_parse_token_num_t cmd_lfc_set_send_xon =
 	TOKEN_NUM_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
-				send_xon, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_lfc_set_mac_ctrl_frame_fwd_mode =
+				send_xon, UINT16);
+cmdline_parse_token_string_t cmd_lfc_set_mac_ctrl_frame_fwd_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				mac_ctrl_frame_fwd, "mac_ctrl_frame_fwd");
-static cmdline_parse_token_string_t cmd_lfc_set_mac_ctrl_frame_fwd =
+cmdline_parse_token_string_t cmd_lfc_set_mac_ctrl_frame_fwd =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				mac_ctrl_frame_fwd_mode, "on#off");
-static cmdline_parse_token_string_t cmd_lfc_set_autoneg_str =
+cmdline_parse_token_string_t cmd_lfc_set_autoneg_str =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				autoneg_str, "autoneg");
-static cmdline_parse_token_string_t cmd_lfc_set_autoneg =
+cmdline_parse_token_string_t cmd_lfc_set_autoneg =
 	TOKEN_STRING_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
 				autoneg, "on#off");
-static cmdline_parse_token_num_t cmd_lfc_set_portid =
+cmdline_parse_token_num_t cmd_lfc_set_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_link_flow_ctrl_set_result,
-				port_id, RTE_UINT16);
+				port_id, UINT16);
 
 /* forward declaration */
 static void
 cmd_link_flow_ctrl_set_parsed(void *parsed_result, struct cmdline *cl,
 			      void *data);
 
-static cmdline_parse_inst_t cmd_link_flow_control_set = {
+cmdline_parse_inst_t cmd_link_flow_control_set = {
 	.f = cmd_link_flow_ctrl_set_parsed,
 	.data = NULL,
 	.help_str = "set flow_ctrl rx on|off tx on|off <high_water> "
@@ -6025,7 +6852,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_link_flow_control_set_rx = {
+cmdline_parse_inst_t cmd_link_flow_control_set_rx = {
 	.f = cmd_link_flow_ctrl_set_parsed,
 	.data = (void *)&cmd_link_flow_control_set_rx,
 	.help_str = "set flow_ctrl rx on|off <port_id>: "
@@ -6040,7 +6867,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_link_flow_control_set_tx = {
+cmdline_parse_inst_t cmd_link_flow_control_set_tx = {
 	.f = cmd_link_flow_ctrl_set_parsed,
 	.data = (void *)&cmd_link_flow_control_set_tx,
 	.help_str = "set flow_ctrl tx on|off <port_id>: "
@@ -6055,7 +6882,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_link_flow_control_set_hw = {
+cmdline_parse_inst_t cmd_link_flow_control_set_hw = {
 	.f = cmd_link_flow_ctrl_set_parsed,
 	.data = (void *)&cmd_link_flow_control_set_hw,
 	.help_str = "set flow_ctrl high_water <value> <port_id>: "
@@ -6070,7 +6897,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_link_flow_control_set_lw = {
+cmdline_parse_inst_t cmd_link_flow_control_set_lw = {
 	.f = cmd_link_flow_ctrl_set_parsed,
 	.data = (void *)&cmd_link_flow_control_set_lw,
 	.help_str = "set flow_ctrl low_water <value> <port_id>: "
@@ -6085,7 +6912,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_link_flow_control_set_pt = {
+cmdline_parse_inst_t cmd_link_flow_control_set_pt = {
 	.f = cmd_link_flow_ctrl_set_parsed,
 	.data = (void *)&cmd_link_flow_control_set_pt,
 	.help_str = "set flow_ctrl pause_time <value> <port_id>: "
@@ -6100,7 +6927,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_link_flow_control_set_xon = {
+cmdline_parse_inst_t cmd_link_flow_control_set_xon = {
 	.f = cmd_link_flow_ctrl_set_parsed,
 	.data = (void *)&cmd_link_flow_control_set_xon,
 	.help_str = "set flow_ctrl send_xon <value> <port_id>: "
@@ -6115,7 +6942,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_link_flow_control_set_macfwd = {
+cmdline_parse_inst_t cmd_link_flow_control_set_macfwd = {
 	.f = cmd_link_flow_ctrl_set_parsed,
 	.data = (void *)&cmd_link_flow_control_set_macfwd,
 	.help_str = "set flow_ctrl mac_ctrl_frame_fwd on|off <port_id>: "
@@ -6130,7 +6957,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_link_flow_control_set_autoneg = {
+cmdline_parse_inst_t cmd_link_flow_control_set_autoneg = {
 	.f = cmd_link_flow_ctrl_set_parsed,
 	.data = (void *)&cmd_link_flow_control_set_autoneg,
 	.help_str = "set flow_ctrl autoneg on|off <port_id>: "
@@ -6147,7 +6974,7 @@
 
 static void
 cmd_link_flow_ctrl_set_parsed(void *parsed_result,
-			      __rte_unused struct cmdline *cl,
+			      __attribute__((unused)) struct cmdline *cl,
 			      void *data)
 {
 	struct cmd_link_flow_ctrl_set_result *res = parsed_result;
@@ -6159,29 +6986,28 @@
 
 	/*
 	 * Rx on/off, flow control is enabled/disabled on RX side. This can indicate
-	 * the RTE_ETH_FC_TX_PAUSE, Transmit pause frame at the Rx side.
+	 * the RTE_FC_TX_PAUSE, Transmit pause frame at the Rx side.
 	 * Tx on/off, flow control is enabled/disabled on TX side. This can indicate
-	 * the RTE_ETH_FC_RX_PAUSE, Respond to the pause frame at the Tx side.
+	 * the RTE_FC_RX_PAUSE, Respond to the pause frame at the Tx side.
 	 */
 	static enum rte_eth_fc_mode rx_tx_onoff_2_lfc_mode[2][2] = {
-			{RTE_ETH_FC_NONE, RTE_ETH_FC_TX_PAUSE}, {RTE_ETH_FC_RX_PAUSE, RTE_ETH_FC_FULL}
+			{RTE_FC_NONE, RTE_FC_TX_PAUSE}, {RTE_FC_RX_PAUSE, RTE_FC_FULL}
 	};
 
 	/* Partial command line, retrieve current configuration */
 	if (cmd) {
 		ret = rte_eth_dev_flow_ctrl_get(res->port_id, &fc_conf);
 		if (ret != 0) {
-			fprintf(stderr,
-				"cannot get current flow ctrl parameters, return code = %d\n",
-				ret);
+			printf("cannot get current flow ctrl parameters, return"
+			       "code = %d\n", ret);
 			return;
 		}
 
-		if ((fc_conf.mode == RTE_ETH_FC_RX_PAUSE) ||
-		    (fc_conf.mode == RTE_ETH_FC_FULL))
+		if ((fc_conf.mode == RTE_FC_RX_PAUSE) ||
+		    (fc_conf.mode == RTE_FC_FULL))
 			rx_fc_en = 1;
-		if ((fc_conf.mode == RTE_ETH_FC_TX_PAUSE) ||
-		    (fc_conf.mode == RTE_ETH_FC_FULL))
+		if ((fc_conf.mode == RTE_FC_TX_PAUSE) ||
+		    (fc_conf.mode == RTE_FC_FULL))
 			tx_fc_en = 1;
 	}
 
@@ -6217,9 +7043,7 @@
 
 	ret = rte_eth_dev_flow_ctrl_set(res->port_id, &fc_conf);
 	if (ret != 0)
-		fprintf(stderr,
-			"bad flow control parameter, return code = %d\n",
-			ret);
+		printf("bad flow contrl parameter, return code = %d \n", ret);
 }
 
 /* *** SETUP ETHERNET PRIORITY FLOW CONTROL *** */
@@ -6239,8 +7063,8 @@
 
 static void
 cmd_priority_flow_ctrl_set_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	struct cmd_priority_flow_ctrl_set_result *res = parsed_result;
 	struct rte_eth_pfc_conf pfc_conf;
@@ -6249,15 +7073,14 @@
 
 	/*
 	 * Rx on/off, flow control is enabled/disabled on RX side. This can indicate
-	 * the RTE_ETH_FC_TX_PAUSE, Transmit pause frame at the Rx side.
+	 * the RTE_FC_TX_PAUSE, Transmit pause frame at the Rx side.
 	 * Tx on/off, flow control is enabled/disabled on TX side. This can indicate
-	 * the RTE_ETH_FC_RX_PAUSE, Respond to the pause frame at the Tx side.
+	 * the RTE_FC_RX_PAUSE, Respond to the pause frame at the Tx side.
 	 */
 	static enum rte_eth_fc_mode rx_tx_onoff_2_pfc_mode[2][2] = {
-		{RTE_ETH_FC_NONE, RTE_ETH_FC_TX_PAUSE}, {RTE_ETH_FC_RX_PAUSE, RTE_ETH_FC_FULL}
+			{RTE_FC_NONE, RTE_FC_RX_PAUSE}, {RTE_FC_TX_PAUSE, RTE_FC_FULL}
 	};
 
-	memset(&pfc_conf, 0, sizeof(struct rte_eth_pfc_conf));
 	rx_fc_enable = (!strncmp(res->rx_pfc_mode, "on",2)) ? 1 : 0;
 	tx_fc_enable = (!strncmp(res->tx_pfc_mode, "on",2)) ? 1 : 0;
 	pfc_conf.fc.mode       = rx_tx_onoff_2_pfc_mode[rx_fc_enable][tx_fc_enable];
@@ -6268,46 +7091,44 @@
 
 	ret = rte_eth_dev_priority_flow_ctrl_set(res->port_id, &pfc_conf);
 	if (ret != 0)
-		fprintf(stderr,
-			"bad priority flow control parameter, return code = %d\n",
-			ret);
+		printf("bad priority flow contrl parameter, return code = %d \n", ret);
 }
 
-static cmdline_parse_token_string_t cmd_pfc_set_set =
+cmdline_parse_token_string_t cmd_pfc_set_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
 				set, "set");
-static cmdline_parse_token_string_t cmd_pfc_set_flow_ctrl =
+cmdline_parse_token_string_t cmd_pfc_set_flow_ctrl =
 	TOKEN_STRING_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
 				pfc_ctrl, "pfc_ctrl");
-static cmdline_parse_token_string_t cmd_pfc_set_rx =
+cmdline_parse_token_string_t cmd_pfc_set_rx =
 	TOKEN_STRING_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
 				rx, "rx");
-static cmdline_parse_token_string_t cmd_pfc_set_rx_mode =
+cmdline_parse_token_string_t cmd_pfc_set_rx_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
 				rx_pfc_mode, "on#off");
-static cmdline_parse_token_string_t cmd_pfc_set_tx =
+cmdline_parse_token_string_t cmd_pfc_set_tx =
 	TOKEN_STRING_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
 				tx, "tx");
-static cmdline_parse_token_string_t cmd_pfc_set_tx_mode =
+cmdline_parse_token_string_t cmd_pfc_set_tx_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
 				tx_pfc_mode, "on#off");
-static cmdline_parse_token_num_t cmd_pfc_set_high_water =
+cmdline_parse_token_num_t cmd_pfc_set_high_water =
 	TOKEN_NUM_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
-				high_water, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_pfc_set_low_water =
+				high_water, UINT32);
+cmdline_parse_token_num_t cmd_pfc_set_low_water =
 	TOKEN_NUM_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
-				low_water, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_pfc_set_pause_time =
+				low_water, UINT32);
+cmdline_parse_token_num_t cmd_pfc_set_pause_time =
 	TOKEN_NUM_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
-				pause_time, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_pfc_set_priority =
+				pause_time, UINT16);
+cmdline_parse_token_num_t cmd_pfc_set_priority =
 	TOKEN_NUM_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
-				priority, RTE_UINT8);
-static cmdline_parse_token_num_t cmd_pfc_set_portid =
+				priority, UINT8);
+cmdline_parse_token_num_t cmd_pfc_set_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_priority_flow_ctrl_set_result,
-				port_id, RTE_UINT16);
+				port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_priority_flow_control_set = {
+cmdline_parse_inst_t cmd_priority_flow_control_set = {
 	.f = cmd_priority_flow_ctrl_set_parsed,
 	.data = NULL,
 	.help_str = "set pfc_ctrl rx on|off tx on|off <high_water> <low_water> "
@@ -6329,143 +7150,27 @@
 	},
 };
 
-struct cmd_queue_priority_flow_ctrl_set_result {
-	cmdline_fixed_string_t set;
-	cmdline_fixed_string_t pfc_queue_ctrl;
-	portid_t port_id;
-	cmdline_fixed_string_t rx;
-	cmdline_fixed_string_t rx_pfc_mode;
-	uint16_t tx_qid;
-	uint8_t  tx_tc;
-	cmdline_fixed_string_t tx;
-	cmdline_fixed_string_t tx_pfc_mode;
-	uint16_t rx_qid;
-	uint8_t  rx_tc;
-	uint16_t pause_time;
-};
-
-static void
-cmd_queue_priority_flow_ctrl_set_parsed(void *parsed_result,
-					__rte_unused struct cmdline *cl,
-					__rte_unused void *data)
-{
-	struct cmd_queue_priority_flow_ctrl_set_result *res = parsed_result;
-	struct rte_eth_pfc_queue_conf pfc_queue_conf;
-	int rx_fc_enable, tx_fc_enable;
-	int ret;
-
-	/*
-	 * Rx on/off, flow control is enabled/disabled on RX side. This can
-	 * indicate the RTE_ETH_FC_TX_PAUSE, Transmit pause frame at the Rx
-	 * side. Tx on/off, flow control is enabled/disabled on TX side. This
-	 * can indicate the RTE_ETH_FC_RX_PAUSE, Respond to the pause frame at
-	 * the Tx side.
-	 */
-	static enum rte_eth_fc_mode rx_tx_onoff_2_mode[2][2] = {
-		{RTE_ETH_FC_NONE, RTE_ETH_FC_TX_PAUSE},
-		{RTE_ETH_FC_RX_PAUSE, RTE_ETH_FC_FULL}
-	};
-
-	memset(&pfc_queue_conf, 0, sizeof(struct rte_eth_pfc_queue_conf));
-	rx_fc_enable = (!strncmp(res->rx_pfc_mode, "on", 2)) ? 1 : 0;
-	tx_fc_enable = (!strncmp(res->tx_pfc_mode, "on", 2)) ? 1 : 0;
-	pfc_queue_conf.mode = rx_tx_onoff_2_mode[rx_fc_enable][tx_fc_enable];
-	pfc_queue_conf.rx_pause.tc  = res->tx_tc;
-	pfc_queue_conf.rx_pause.tx_qid = res->tx_qid;
-	pfc_queue_conf.tx_pause.tc  = res->rx_tc;
-	pfc_queue_conf.tx_pause.rx_qid  = res->rx_qid;
-	pfc_queue_conf.tx_pause.pause_time = res->pause_time;
-
-	ret = rte_eth_dev_priority_flow_ctrl_queue_configure(res->port_id,
-							     &pfc_queue_conf);
-	if (ret != 0) {
-		fprintf(stderr,
-			"bad queue priority flow control parameter, rc = %d\n",
-			ret);
-	}
-}
-
-static cmdline_parse_token_string_t cmd_q_pfc_set_set =
-	TOKEN_STRING_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				set, "set");
-static cmdline_parse_token_string_t cmd_q_pfc_set_flow_ctrl =
-	TOKEN_STRING_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				pfc_queue_ctrl, "pfc_queue_ctrl");
-static cmdline_parse_token_num_t cmd_q_pfc_set_portid =
-	TOKEN_NUM_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_q_pfc_set_rx =
-	TOKEN_STRING_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				rx, "rx");
-static cmdline_parse_token_string_t cmd_q_pfc_set_rx_mode =
-	TOKEN_STRING_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				rx_pfc_mode, "on#off");
-static cmdline_parse_token_num_t cmd_q_pfc_set_tx_qid =
-	TOKEN_NUM_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				tx_qid, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_q_pfc_set_tx_tc =
-	TOKEN_NUM_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				tx_tc, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_q_pfc_set_tx =
-	TOKEN_STRING_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				tx, "tx");
-static cmdline_parse_token_string_t cmd_q_pfc_set_tx_mode =
-	TOKEN_STRING_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				tx_pfc_mode, "on#off");
-static cmdline_parse_token_num_t cmd_q_pfc_set_rx_qid =
-	TOKEN_NUM_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				rx_qid, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_q_pfc_set_rx_tc =
-	TOKEN_NUM_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				rx_tc, RTE_UINT8);
-static cmdline_parse_token_num_t cmd_q_pfc_set_pause_time =
-	TOKEN_NUM_INITIALIZER(struct cmd_queue_priority_flow_ctrl_set_result,
-				pause_time, RTE_UINT16);
-
-static cmdline_parse_inst_t cmd_queue_priority_flow_control_set = {
-	.f = cmd_queue_priority_flow_ctrl_set_parsed,
-	.data = NULL,
-	.help_str = "set pfc_queue_ctrl <port_id> rx <on|off> <tx_qid> <tx_tc> "
-		"tx <on|off> <rx_qid> <rx_tc> <pause_time>: "
-		"Configure the Ethernet queue priority flow control",
-	.tokens = {
-		(void *)&cmd_q_pfc_set_set,
-		(void *)&cmd_q_pfc_set_flow_ctrl,
-		(void *)&cmd_q_pfc_set_portid,
-		(void *)&cmd_q_pfc_set_rx,
-		(void *)&cmd_q_pfc_set_rx_mode,
-		(void *)&cmd_q_pfc_set_tx_qid,
-		(void *)&cmd_q_pfc_set_tx_tc,
-		(void *)&cmd_q_pfc_set_tx,
-		(void *)&cmd_q_pfc_set_tx_mode,
-		(void *)&cmd_q_pfc_set_rx_qid,
-		(void *)&cmd_q_pfc_set_rx_tc,
-		(void *)&cmd_q_pfc_set_pause_time,
-		NULL,
-	},
-};
-
 /* *** RESET CONFIGURATION *** */
 struct cmd_reset_result {
 	cmdline_fixed_string_t reset;
 	cmdline_fixed_string_t def;
 };
 
-static void cmd_reset_parsed(__rte_unused void *parsed_result,
+static void cmd_reset_parsed(__attribute__((unused)) void *parsed_result,
 			     struct cmdline *cl,
-			     __rte_unused void *data)
+			     __attribute__((unused)) void *data)
 {
 	cmdline_printf(cl, "Reset to default forwarding configuration...\n");
 	set_def_fwd_config();
 }
 
-static cmdline_parse_token_string_t cmd_reset_set =
+cmdline_parse_token_string_t cmd_reset_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_reset_result, reset, "set");
-static cmdline_parse_token_string_t cmd_reset_def =
+cmdline_parse_token_string_t cmd_reset_def =
 	TOKEN_STRING_INITIALIZER(struct cmd_reset_result, def,
 				 "default");
 
-static cmdline_parse_inst_t cmd_reset = {
+cmdline_parse_inst_t cmd_reset = {
 	.f = cmd_reset_parsed,
 	.data = NULL,
 	.help_str = "set default: Reset default forwarding configuration",
@@ -6481,17 +7186,17 @@
 	cmdline_fixed_string_t start;
 };
 
-static cmdline_parse_token_string_t cmd_start_start =
+cmdline_parse_token_string_t cmd_start_start =
 	TOKEN_STRING_INITIALIZER(struct cmd_start_result, start, "start");
 
-static void cmd_start_parsed(__rte_unused void *parsed_result,
-			     __rte_unused struct cmdline *cl,
-			     __rte_unused void *data)
+static void cmd_start_parsed(__attribute__((unused)) void *parsed_result,
+			     __attribute__((unused)) struct cmdline *cl,
+			     __attribute__((unused)) void *data)
 {
 	start_packet_forwarding(0);
 }
 
-static cmdline_parse_inst_t cmd_start = {
+cmdline_parse_inst_t cmd_start = {
 	.f = cmd_start_parsed,
 	.data = NULL,
 	.help_str = "start: Start packet forwarding",
@@ -6508,21 +7213,21 @@
 };
 
 static void
-cmd_start_tx_first_parsed(__rte_unused void *parsed_result,
-			  __rte_unused struct cmdline *cl,
-			  __rte_unused void *data)
+cmd_start_tx_first_parsed(__attribute__((unused)) void *parsed_result,
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
 {
 	start_packet_forwarding(1);
 }
 
-static cmdline_parse_token_string_t cmd_start_tx_first_start =
+cmdline_parse_token_string_t cmd_start_tx_first_start =
 	TOKEN_STRING_INITIALIZER(struct cmd_start_tx_first_result, start,
 				 "start");
-static cmdline_parse_token_string_t cmd_start_tx_first_tx_first =
+cmdline_parse_token_string_t cmd_start_tx_first_tx_first =
 	TOKEN_STRING_INITIALIZER(struct cmd_start_tx_first_result,
 				 tx_first, "tx_first");
 
-static cmdline_parse_inst_t cmd_start_tx_first = {
+cmdline_parse_inst_t cmd_start_tx_first = {
 	.f = cmd_start_tx_first_parsed,
 	.data = NULL,
 	.help_str = "start tx_first: Start packet forwarding, "
@@ -6543,25 +7248,25 @@
 
 static void
 cmd_start_tx_first_n_parsed(void *parsed_result,
-			  __rte_unused struct cmdline *cl,
-			  __rte_unused void *data)
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
 {
 	struct cmd_start_tx_first_n_result *res = parsed_result;
 
 	start_packet_forwarding(res->tx_num);
 }
 
-static cmdline_parse_token_string_t cmd_start_tx_first_n_start =
+cmdline_parse_token_string_t cmd_start_tx_first_n_start =
 	TOKEN_STRING_INITIALIZER(struct cmd_start_tx_first_n_result,
 			start, "start");
-static cmdline_parse_token_string_t cmd_start_tx_first_n_tx_first =
+cmdline_parse_token_string_t cmd_start_tx_first_n_tx_first =
 	TOKEN_STRING_INITIALIZER(struct cmd_start_tx_first_n_result,
 			tx_first, "tx_first");
-static cmdline_parse_token_num_t cmd_start_tx_first_n_tx_num =
+cmdline_parse_token_num_t cmd_start_tx_first_n_tx_num =
 	TOKEN_NUM_INITIALIZER(struct cmd_start_tx_first_n_result,
-			tx_num, RTE_UINT32);
+			tx_num, UINT32);
 
-static cmdline_parse_inst_t cmd_start_tx_first_n = {
+cmdline_parse_inst_t cmd_start_tx_first_n = {
 	.f = cmd_start_tx_first_n_parsed,
 	.data = NULL,
 	.help_str = "start tx_first <num>: "
@@ -6582,26 +7287,25 @@
 	portid_t port_id;
 };
 
-static cmdline_parse_token_string_t cmd_set_link_up_set =
+cmdline_parse_token_string_t cmd_set_link_up_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_link_up_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_link_up_link_up =
+cmdline_parse_token_string_t cmd_set_link_up_link_up =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_link_up_result, link_up,
 				"link-up");
-static cmdline_parse_token_string_t cmd_set_link_up_port =
+cmdline_parse_token_string_t cmd_set_link_up_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_link_up_result, port, "port");
-static cmdline_parse_token_num_t cmd_set_link_up_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_link_up_result, port_id,
-				RTE_UINT16);
-
-static void cmd_set_link_up_parsed(__rte_unused void *parsed_result,
-			     __rte_unused struct cmdline *cl,
-			     __rte_unused void *data)
+cmdline_parse_token_num_t cmd_set_link_up_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_link_up_result, port_id, UINT16);
+
+static void cmd_set_link_up_parsed(__attribute__((unused)) void *parsed_result,
+			     __attribute__((unused)) struct cmdline *cl,
+			     __attribute__((unused)) void *data)
 {
 	struct cmd_set_link_up_result *res = parsed_result;
 	dev_set_link_up(res->port_id);
 }
 
-static cmdline_parse_inst_t cmd_set_link_up = {
+cmdline_parse_inst_t cmd_set_link_up = {
 	.f = cmd_set_link_up_parsed,
 	.data = NULL,
 	.help_str = "set link-up port <port id>",
@@ -6622,27 +7326,26 @@
 	portid_t port_id;
 };
 
-static cmdline_parse_token_string_t cmd_set_link_down_set =
+cmdline_parse_token_string_t cmd_set_link_down_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_link_down_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_link_down_link_down =
+cmdline_parse_token_string_t cmd_set_link_down_link_down =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_link_down_result, link_down,
 				"link-down");
-static cmdline_parse_token_string_t cmd_set_link_down_port =
+cmdline_parse_token_string_t cmd_set_link_down_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_link_down_result, port, "port");
-static cmdline_parse_token_num_t cmd_set_link_down_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_link_down_result, port_id,
-				RTE_UINT16);
+cmdline_parse_token_num_t cmd_set_link_down_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_link_down_result, port_id, UINT16);
 
 static void cmd_set_link_down_parsed(
-				__rte_unused void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) void *parsed_result,
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_set_link_down_result *res = parsed_result;
 	dev_set_link_down(res->port_id);
 }
 
-static cmdline_parse_inst_t cmd_set_link_down = {
+cmdline_parse_inst_t cmd_set_link_down = {
 	.f = cmd_set_link_down_parsed,
 	.data = NULL,
 	.help_str = "set link-down port <port id>",
@@ -6663,8 +7366,8 @@
 };
 
 static void cmd_showcfg_parsed(void *parsed_result,
-			       __rte_unused struct cmdline *cl,
-			       __rte_unused void *data)
+			       __attribute__((unused)) struct cmdline *cl,
+			       __attribute__((unused)) void *data)
 {
 	struct cmd_showcfg_result *res = parsed_result;
 	if (!strcmp(res->what, "rxtx"))
@@ -6673,30 +7376,22 @@
 		fwd_lcores_config_display();
 	else if (!strcmp(res->what, "fwd"))
 		pkt_fwd_config_display(&cur_fwd_config);
-	else if (!strcmp(res->what, "rxoffs"))
-		show_rx_pkt_offsets();
-	else if (!strcmp(res->what, "rxpkts"))
-		show_rx_pkt_segments();
-	else if (!strcmp(res->what, "rxhdrs"))
-		show_rx_pkt_hdrs();
 	else if (!strcmp(res->what, "txpkts"))
 		show_tx_pkt_segments();
-	else if (!strcmp(res->what, "txtimes"))
-		show_tx_pkt_times();
 }
 
-static cmdline_parse_token_string_t cmd_showcfg_show =
+cmdline_parse_token_string_t cmd_showcfg_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_showcfg_result, show, "show");
-static cmdline_parse_token_string_t cmd_showcfg_port =
+cmdline_parse_token_string_t cmd_showcfg_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_showcfg_result, cfg, "config");
-static cmdline_parse_token_string_t cmd_showcfg_what =
+cmdline_parse_token_string_t cmd_showcfg_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_showcfg_result, what,
-				 "rxtx#cores#fwd#rxoffs#rxpkts#rxhdrs#txpkts#txtimes");
+				 "rxtx#cores#fwd#txpkts");
 
-static cmdline_parse_inst_t cmd_showcfg = {
+cmdline_parse_inst_t cmd_showcfg = {
 	.f = cmd_showcfg_parsed,
 	.data = NULL,
-	.help_str = "show config rxtx|cores|fwd|rxoffs|rxpkts|rxhdrs|txpkts|txtimes",
+	.help_str = "show config rxtx|cores|fwd|txpkts",
 	.tokens = {
 		(void *)&cmd_showcfg_show,
 		(void *)&cmd_showcfg_port,
@@ -6714,8 +7409,8 @@
 };
 
 static void cmd_showportall_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	portid_t i;
 
@@ -6741,31 +7436,35 @@
 	else if (!strcmp(res->what, "xstats"))
 		RTE_ETH_FOREACH_DEV(i)
 			nic_xstats_display(i);
-#if defined(RTE_NET_I40E) || defined(RTE_NET_IXGBE)
 	else if (!strcmp(res->what, "fdir"))
 		RTE_ETH_FOREACH_DEV(i)
 			fdir_get_infos(i);
-#endif
+	else if (!strcmp(res->what, "stat_qmap"))
+		RTE_ETH_FOREACH_DEV(i)
+			nic_stats_mapping_display(i);
 	else if (!strcmp(res->what, "dcb_tc"))
 		RTE_ETH_FOREACH_DEV(i)
 			port_dcb_info_display(i);
+	else if (!strcmp(res->what, "cap"))
+		RTE_ETH_FOREACH_DEV(i)
+			port_offload_cap_display(i);
 }
 
-static cmdline_parse_token_string_t cmd_showportall_show =
+cmdline_parse_token_string_t cmd_showportall_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_showportall_result, show,
 				 "show#clear");
-static cmdline_parse_token_string_t cmd_showportall_port =
+cmdline_parse_token_string_t cmd_showportall_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_showportall_result, port, "port");
-static cmdline_parse_token_string_t cmd_showportall_what =
+cmdline_parse_token_string_t cmd_showportall_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_showportall_result, what,
-				 "info#summary#stats#xstats#fdir#dcb_tc");
-static cmdline_parse_token_string_t cmd_showportall_all =
+				 "info#summary#stats#xstats#fdir#stat_qmap#dcb_tc#cap");
+cmdline_parse_token_string_t cmd_showportall_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_showportall_result, all, "all");
-static cmdline_parse_inst_t cmd_showportall = {
+cmdline_parse_inst_t cmd_showportall = {
 	.f = cmd_showportall_parsed,
 	.data = NULL,
 	.help_str = "show|clear port "
-		"info|summary|stats|xstats|fdir|dcb_tc all",
+		"info|summary|stats|xstats|fdir|stat_qmap|dcb_tc|cap all",
 	.tokens = {
 		(void *)&cmd_showportall_show,
 		(void *)&cmd_showportall_port,
@@ -6784,8 +7483,8 @@
 };
 
 static void cmd_showport_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_showport_result *res = parsed_result;
 	if (!strcmp(res->show, "clear")) {
@@ -6803,30 +7502,32 @@
 		nic_stats_display(res->portnum);
 	else if (!strcmp(res->what, "xstats"))
 		nic_xstats_display(res->portnum);
-#if defined(RTE_NET_I40E) || defined(RTE_NET_IXGBE)
 	else if (!strcmp(res->what, "fdir"))
 		 fdir_get_infos(res->portnum);
-#endif
+	else if (!strcmp(res->what, "stat_qmap"))
+		nic_stats_mapping_display(res->portnum);
 	else if (!strcmp(res->what, "dcb_tc"))
 		port_dcb_info_display(res->portnum);
+	else if (!strcmp(res->what, "cap"))
+		port_offload_cap_display(res->portnum);
 }
 
-static cmdline_parse_token_string_t cmd_showport_show =
+cmdline_parse_token_string_t cmd_showport_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_result, show,
 				 "show#clear");
-static cmdline_parse_token_string_t cmd_showport_port =
+cmdline_parse_token_string_t cmd_showport_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_result, port, "port");
-static cmdline_parse_token_string_t cmd_showport_what =
+cmdline_parse_token_string_t cmd_showport_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_showport_result, what,
-				 "info#summary#stats#xstats#fdir#dcb_tc");
-static cmdline_parse_token_num_t cmd_showport_portnum =
-	TOKEN_NUM_INITIALIZER(struct cmd_showport_result, portnum, RTE_UINT16);
+				 "info#summary#stats#xstats#fdir#stat_qmap#dcb_tc#cap");
+cmdline_parse_token_num_t cmd_showport_portnum =
+	TOKEN_NUM_INITIALIZER(struct cmd_showport_result, portnum, UINT16);
 
-static cmdline_parse_inst_t cmd_showport = {
+cmdline_parse_inst_t cmd_showport = {
 	.f = cmd_showport_parsed,
 	.data = NULL,
 	.help_str = "show|clear port "
-		"info|summary|stats|xstats|fdir|dcb_tc "
+		"info|summary|stats|xstats|fdir|stat_qmap|dcb_tc|cap "
 		"<port_id>",
 	.tokens = {
 		(void *)&cmd_showport_show,
@@ -6837,137 +7538,6 @@
 	},
 };
 
-/* *** show port representors information *** */
-struct cmd_representor_info_result {
-	cmdline_fixed_string_t cmd_show;
-	cmdline_fixed_string_t cmd_port;
-	cmdline_fixed_string_t cmd_info;
-	cmdline_fixed_string_t cmd_keyword;
-	portid_t cmd_pid;
-};
-
-static void
-cmd_representor_info_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
-{
-	struct cmd_representor_info_result *res = parsed_result;
-	struct rte_eth_representor_info *info;
-	struct rte_eth_representor_range *range;
-	uint32_t range_diff;
-	uint32_t i;
-	int ret;
-	int num;
-
-	if (!rte_eth_dev_is_valid_port(res->cmd_pid)) {
-		fprintf(stderr, "Invalid port id %u\n", res->cmd_pid);
-		return;
-	}
-
-	ret = rte_eth_representor_info_get(res->cmd_pid, NULL);
-	if (ret < 0) {
-		fprintf(stderr,
-			"Failed to get the number of representor info ranges for port %hu: %s\n",
-			res->cmd_pid, rte_strerror(-ret));
-		return;
-	}
-	num = ret;
-
-	info = calloc(1, sizeof(*info) + num * sizeof(info->ranges[0]));
-	if (info == NULL) {
-		fprintf(stderr,
-			"Failed to allocate memory for representor info for port %hu\n",
-			res->cmd_pid);
-		return;
-	}
-	info->nb_ranges_alloc = num;
-
-	ret = rte_eth_representor_info_get(res->cmd_pid, info);
-	if (ret < 0) {
-		fprintf(stderr,
-			"Failed to get the representor info for port %hu: %s\n",
-			res->cmd_pid, rte_strerror(-ret));
-		free(info);
-		return;
-	}
-
-	printf("Port controller: %hu\n", info->controller);
-	printf("Port PF: %hu\n", info->pf);
-
-	printf("Ranges: %u\n", info->nb_ranges);
-	for (i = 0; i < info->nb_ranges; i++) {
-		range = &info->ranges[i];
-		range_diff = range->id_end - range->id_base;
-
-		printf("%u. ", i + 1);
-		printf("'%s' ", range->name);
-		if (range_diff > 0)
-			printf("[%u-%u]: ", range->id_base, range->id_end);
-		else
-			printf("[%u]: ", range->id_base);
-
-		printf("Controller %d, PF %d", range->controller, range->pf);
-
-		switch (range->type) {
-		case RTE_ETH_REPRESENTOR_NONE:
-			printf(", NONE\n");
-			break;
-		case RTE_ETH_REPRESENTOR_VF:
-			if (range_diff > 0)
-				printf(", VF %d..%d\n", range->vf,
-				       range->vf + range_diff);
-			else
-				printf(", VF %d\n", range->vf);
-			break;
-		case RTE_ETH_REPRESENTOR_SF:
-			printf(", SF %d\n", range->sf);
-			break;
-		case RTE_ETH_REPRESENTOR_PF:
-			if (range_diff > 0)
-				printf("..%d\n", range->pf + range_diff);
-			else
-				printf("\n");
-			break;
-		default:
-			printf(", UNKNOWN TYPE %d\n", range->type);
-			break;
-		}
-	}
-
-	free(info);
-}
-
-static cmdline_parse_token_string_t cmd_representor_info_show =
-	TOKEN_STRING_INITIALIZER(struct cmd_representor_info_result,
-			cmd_show, "show");
-static cmdline_parse_token_string_t cmd_representor_info_port =
-	TOKEN_STRING_INITIALIZER(struct cmd_representor_info_result,
-			cmd_port, "port");
-static cmdline_parse_token_string_t cmd_representor_info_info =
-	TOKEN_STRING_INITIALIZER(struct cmd_representor_info_result,
-			cmd_info, "info");
-static cmdline_parse_token_num_t cmd_representor_info_pid =
-	TOKEN_NUM_INITIALIZER(struct cmd_representor_info_result,
-			cmd_pid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_representor_info_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_representor_info_result,
-			cmd_keyword, "representor");
-
-static cmdline_parse_inst_t cmd_representor_info = {
-	.f = cmd_representor_info_parsed,
-	.data = NULL,
-	.help_str = "show port info <port_id> representor",
-	.tokens = {
-		(void *)&cmd_representor_info_show,
-		(void *)&cmd_representor_info_port,
-		(void *)&cmd_representor_info_info,
-		(void *)&cmd_representor_info_pid,
-		(void *)&cmd_representor_info_keyword,
-		NULL,
-	},
-};
-
-
 /* *** SHOW DEVICE INFO *** */
 struct cmd_showdevice_result {
 	cmdline_fixed_string_t show;
@@ -6977,8 +7547,8 @@
 };
 
 static void cmd_showdevice_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_showdevice_result *res = parsed_result;
 	if (!strcmp(res->what, "info")) {
@@ -6989,19 +7559,19 @@
 	}
 }
 
-static cmdline_parse_token_string_t cmd_showdevice_show =
+cmdline_parse_token_string_t cmd_showdevice_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_showdevice_result, show,
 				 "show");
-static cmdline_parse_token_string_t cmd_showdevice_device =
+cmdline_parse_token_string_t cmd_showdevice_device =
 	TOKEN_STRING_INITIALIZER(struct cmd_showdevice_result, device, "device");
-static cmdline_parse_token_string_t cmd_showdevice_what =
+cmdline_parse_token_string_t cmd_showdevice_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_showdevice_result, what,
 				 "info");
-static cmdline_parse_token_string_t cmd_showdevice_identifier =
+cmdline_parse_token_string_t cmd_showdevice_identifier =
 	TOKEN_STRING_INITIALIZER(struct cmd_showdevice_result,
 			identifier, NULL);
 
-static cmdline_parse_inst_t cmd_showdevice = {
+cmdline_parse_inst_t cmd_showdevice = {
 	.f = cmd_showdevice_parsed,
 	.data = NULL,
 	.help_str = "show device info <identifier>|all",
@@ -7013,52 +7583,6 @@
 		NULL,
 	},
 };
-
-/* *** SHOW MODULE EEPROM/EEPROM port INFO *** */
-struct cmd_showeeprom_result {
-	cmdline_fixed_string_t show;
-	cmdline_fixed_string_t port;
-	uint16_t portnum;
-	cmdline_fixed_string_t type;
-};
-
-static void cmd_showeeprom_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
-{
-	struct cmd_showeeprom_result *res = parsed_result;
-
-	if (!strcmp(res->type, "eeprom"))
-		port_eeprom_display(res->portnum);
-	else if (!strcmp(res->type, "module_eeprom"))
-		port_module_eeprom_display(res->portnum);
-	else
-		fprintf(stderr, "Unknown argument\n");
-}
-
-static cmdline_parse_token_string_t cmd_showeeprom_show =
-	TOKEN_STRING_INITIALIZER(struct cmd_showeeprom_result, show, "show");
-static cmdline_parse_token_string_t cmd_showeeprom_port =
-	TOKEN_STRING_INITIALIZER(struct cmd_showeeprom_result, port, "port");
-static cmdline_parse_token_num_t cmd_showeeprom_portnum =
-	TOKEN_NUM_INITIALIZER(struct cmd_showeeprom_result, portnum,
-			RTE_UINT16);
-static cmdline_parse_token_string_t cmd_showeeprom_type =
-	TOKEN_STRING_INITIALIZER(struct cmd_showeeprom_result, type, "module_eeprom#eeprom");
-
-static cmdline_parse_inst_t cmd_showeeprom = {
-	.f = cmd_showeeprom_parsed,
-	.data = NULL,
-	.help_str = "show port <port_id> module_eeprom|eeprom",
-	.tokens = {
-		(void *)&cmd_showeeprom_show,
-		(void *)&cmd_showeeprom_port,
-		(void *)&cmd_showeeprom_portnum,
-		(void *)&cmd_showeeprom_type,
-		NULL,
-	},
-};
-
 /* *** SHOW QUEUE INFO *** */
 struct cmd_showqueue_result {
 	cmdline_fixed_string_t show;
@@ -7070,8 +7594,8 @@
 
 static void
 cmd_showqueue_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_showqueue_result *res = parsed_result;
 
@@ -7081,20 +7605,18 @@
 		tx_queue_infos_display(res->portnum, res->queuenum);
 }
 
-static cmdline_parse_token_string_t cmd_showqueue_show =
+cmdline_parse_token_string_t cmd_showqueue_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_showqueue_result, show, "show");
-static cmdline_parse_token_string_t cmd_showqueue_type =
+cmdline_parse_token_string_t cmd_showqueue_type =
 	TOKEN_STRING_INITIALIZER(struct cmd_showqueue_result, type, "rxq#txq");
-static cmdline_parse_token_string_t cmd_showqueue_what =
+cmdline_parse_token_string_t cmd_showqueue_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_showqueue_result, what, "info");
-static cmdline_parse_token_num_t cmd_showqueue_portnum =
-	TOKEN_NUM_INITIALIZER(struct cmd_showqueue_result, portnum,
-		RTE_UINT16);
-static cmdline_parse_token_num_t cmd_showqueue_queuenum =
-	TOKEN_NUM_INITIALIZER(struct cmd_showqueue_result, queuenum,
-		RTE_UINT16);
+cmdline_parse_token_num_t cmd_showqueue_portnum =
+	TOKEN_NUM_INITIALIZER(struct cmd_showqueue_result, portnum, UINT16);
+cmdline_parse_token_num_t cmd_showqueue_queuenum =
+	TOKEN_NUM_INITIALIZER(struct cmd_showqueue_result, queuenum, UINT16);
 
-static cmdline_parse_inst_t cmd_showqueue = {
+cmdline_parse_inst_t cmd_showqueue = {
 	.f = cmd_showqueue_parsed,
 	.data = NULL,
 	.help_str = "show rxq|txq info <port_id> <queue_id>",
@@ -7116,13 +7638,13 @@
 	cmdline_fixed_string_t all;
 };
 
-static cmdline_parse_token_string_t cmd_fwd_action =
+cmdline_parse_token_string_t cmd_fwd_action =
 	TOKEN_STRING_INITIALIZER(struct fwd_result, action, "show#clear");
-static cmdline_parse_token_string_t cmd_fwd_fwd =
+cmdline_parse_token_string_t cmd_fwd_fwd =
 	TOKEN_STRING_INITIALIZER(struct fwd_result, fwd, "fwd");
-static cmdline_parse_token_string_t cmd_fwd_stats =
+cmdline_parse_token_string_t cmd_fwd_stats =
 	TOKEN_STRING_INITIALIZER(struct fwd_result, stats, "stats");
-static cmdline_parse_token_string_t cmd_fwd_all =
+cmdline_parse_token_string_t cmd_fwd_all =
 	TOKEN_STRING_INITIALIZER(struct fwd_result, all, "all");
 
 static void
@@ -7151,6 +7673,298 @@
 	},
 };
 
+/* *** READ PORT REGISTER *** */
+struct cmd_read_reg_result {
+	cmdline_fixed_string_t read;
+	cmdline_fixed_string_t reg;
+	portid_t port_id;
+	uint32_t reg_off;
+};
+
+static void
+cmd_read_reg_parsed(void *parsed_result,
+		    __attribute__((unused)) struct cmdline *cl,
+		    __attribute__((unused)) void *data)
+{
+	struct cmd_read_reg_result *res = parsed_result;
+	port_reg_display(res->port_id, res->reg_off);
+}
+
+cmdline_parse_token_string_t cmd_read_reg_read =
+	TOKEN_STRING_INITIALIZER(struct cmd_read_reg_result, read, "read");
+cmdline_parse_token_string_t cmd_read_reg_reg =
+	TOKEN_STRING_INITIALIZER(struct cmd_read_reg_result, reg, "reg");
+cmdline_parse_token_num_t cmd_read_reg_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_reg_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_read_reg_reg_off =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_reg_result, reg_off, UINT32);
+
+cmdline_parse_inst_t cmd_read_reg = {
+	.f = cmd_read_reg_parsed,
+	.data = NULL,
+	.help_str = "read reg <port_id> <reg_off>",
+	.tokens = {
+		(void *)&cmd_read_reg_read,
+		(void *)&cmd_read_reg_reg,
+		(void *)&cmd_read_reg_port_id,
+		(void *)&cmd_read_reg_reg_off,
+		NULL,
+	},
+};
+
+/* *** READ PORT REGISTER BIT FIELD *** */
+struct cmd_read_reg_bit_field_result {
+	cmdline_fixed_string_t read;
+	cmdline_fixed_string_t regfield;
+	portid_t port_id;
+	uint32_t reg_off;
+	uint8_t bit1_pos;
+	uint8_t bit2_pos;
+};
+
+static void
+cmd_read_reg_bit_field_parsed(void *parsed_result,
+			      __attribute__((unused)) struct cmdline *cl,
+			      __attribute__((unused)) void *data)
+{
+	struct cmd_read_reg_bit_field_result *res = parsed_result;
+	port_reg_bit_field_display(res->port_id, res->reg_off,
+				   res->bit1_pos, res->bit2_pos);
+}
+
+cmdline_parse_token_string_t cmd_read_reg_bit_field_read =
+	TOKEN_STRING_INITIALIZER(struct cmd_read_reg_bit_field_result, read,
+				 "read");
+cmdline_parse_token_string_t cmd_read_reg_bit_field_regfield =
+	TOKEN_STRING_INITIALIZER(struct cmd_read_reg_bit_field_result,
+				 regfield, "regfield");
+cmdline_parse_token_num_t cmd_read_reg_bit_field_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_reg_bit_field_result, port_id,
+			      UINT16);
+cmdline_parse_token_num_t cmd_read_reg_bit_field_reg_off =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_reg_bit_field_result, reg_off,
+			      UINT32);
+cmdline_parse_token_num_t cmd_read_reg_bit_field_bit1_pos =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_reg_bit_field_result, bit1_pos,
+			      UINT8);
+cmdline_parse_token_num_t cmd_read_reg_bit_field_bit2_pos =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_reg_bit_field_result, bit2_pos,
+			      UINT8);
+
+cmdline_parse_inst_t cmd_read_reg_bit_field = {
+	.f = cmd_read_reg_bit_field_parsed,
+	.data = NULL,
+	.help_str = "read regfield <port_id> <reg_off> <bit_x> <bit_y>: "
+	"Read register bit field between bit_x and bit_y included",
+	.tokens = {
+		(void *)&cmd_read_reg_bit_field_read,
+		(void *)&cmd_read_reg_bit_field_regfield,
+		(void *)&cmd_read_reg_bit_field_port_id,
+		(void *)&cmd_read_reg_bit_field_reg_off,
+		(void *)&cmd_read_reg_bit_field_bit1_pos,
+		(void *)&cmd_read_reg_bit_field_bit2_pos,
+		NULL,
+	},
+};
+
+/* *** READ PORT REGISTER BIT *** */
+struct cmd_read_reg_bit_result {
+	cmdline_fixed_string_t read;
+	cmdline_fixed_string_t regbit;
+	portid_t port_id;
+	uint32_t reg_off;
+	uint8_t bit_pos;
+};
+
+static void
+cmd_read_reg_bit_parsed(void *parsed_result,
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
+{
+	struct cmd_read_reg_bit_result *res = parsed_result;
+	port_reg_bit_display(res->port_id, res->reg_off, res->bit_pos);
+}
+
+cmdline_parse_token_string_t cmd_read_reg_bit_read =
+	TOKEN_STRING_INITIALIZER(struct cmd_read_reg_bit_result, read, "read");
+cmdline_parse_token_string_t cmd_read_reg_bit_regbit =
+	TOKEN_STRING_INITIALIZER(struct cmd_read_reg_bit_result,
+				 regbit, "regbit");
+cmdline_parse_token_num_t cmd_read_reg_bit_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_reg_bit_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_read_reg_bit_reg_off =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_reg_bit_result, reg_off, UINT32);
+cmdline_parse_token_num_t cmd_read_reg_bit_bit_pos =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_reg_bit_result, bit_pos, UINT8);
+
+cmdline_parse_inst_t cmd_read_reg_bit = {
+	.f = cmd_read_reg_bit_parsed,
+	.data = NULL,
+	.help_str = "read regbit <port_id> <reg_off> <bit_x>: 0 <= bit_x <= 31",
+	.tokens = {
+		(void *)&cmd_read_reg_bit_read,
+		(void *)&cmd_read_reg_bit_regbit,
+		(void *)&cmd_read_reg_bit_port_id,
+		(void *)&cmd_read_reg_bit_reg_off,
+		(void *)&cmd_read_reg_bit_bit_pos,
+		NULL,
+	},
+};
+
+/* *** WRITE PORT REGISTER *** */
+struct cmd_write_reg_result {
+	cmdline_fixed_string_t write;
+	cmdline_fixed_string_t reg;
+	portid_t port_id;
+	uint32_t reg_off;
+	uint32_t value;
+};
+
+static void
+cmd_write_reg_parsed(void *parsed_result,
+		     __attribute__((unused)) struct cmdline *cl,
+		     __attribute__((unused)) void *data)
+{
+	struct cmd_write_reg_result *res = parsed_result;
+	port_reg_set(res->port_id, res->reg_off, res->value);
+}
+
+cmdline_parse_token_string_t cmd_write_reg_write =
+	TOKEN_STRING_INITIALIZER(struct cmd_write_reg_result, write, "write");
+cmdline_parse_token_string_t cmd_write_reg_reg =
+	TOKEN_STRING_INITIALIZER(struct cmd_write_reg_result, reg, "reg");
+cmdline_parse_token_num_t cmd_write_reg_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_write_reg_reg_off =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_result, reg_off, UINT32);
+cmdline_parse_token_num_t cmd_write_reg_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_result, value, UINT32);
+
+cmdline_parse_inst_t cmd_write_reg = {
+	.f = cmd_write_reg_parsed,
+	.data = NULL,
+	.help_str = "write reg <port_id> <reg_off> <reg_value>",
+	.tokens = {
+		(void *)&cmd_write_reg_write,
+		(void *)&cmd_write_reg_reg,
+		(void *)&cmd_write_reg_port_id,
+		(void *)&cmd_write_reg_reg_off,
+		(void *)&cmd_write_reg_value,
+		NULL,
+	},
+};
+
+/* *** WRITE PORT REGISTER BIT FIELD *** */
+struct cmd_write_reg_bit_field_result {
+	cmdline_fixed_string_t write;
+	cmdline_fixed_string_t regfield;
+	portid_t port_id;
+	uint32_t reg_off;
+	uint8_t bit1_pos;
+	uint8_t bit2_pos;
+	uint32_t value;
+};
+
+static void
+cmd_write_reg_bit_field_parsed(void *parsed_result,
+			       __attribute__((unused)) struct cmdline *cl,
+			       __attribute__((unused)) void *data)
+{
+	struct cmd_write_reg_bit_field_result *res = parsed_result;
+	port_reg_bit_field_set(res->port_id, res->reg_off,
+			  res->bit1_pos, res->bit2_pos, res->value);
+}
+
+cmdline_parse_token_string_t cmd_write_reg_bit_field_write =
+	TOKEN_STRING_INITIALIZER(struct cmd_write_reg_bit_field_result, write,
+				 "write");
+cmdline_parse_token_string_t cmd_write_reg_bit_field_regfield =
+	TOKEN_STRING_INITIALIZER(struct cmd_write_reg_bit_field_result,
+				 regfield, "regfield");
+cmdline_parse_token_num_t cmd_write_reg_bit_field_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_bit_field_result, port_id,
+			      UINT16);
+cmdline_parse_token_num_t cmd_write_reg_bit_field_reg_off =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_bit_field_result, reg_off,
+			      UINT32);
+cmdline_parse_token_num_t cmd_write_reg_bit_field_bit1_pos =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_bit_field_result, bit1_pos,
+			      UINT8);
+cmdline_parse_token_num_t cmd_write_reg_bit_field_bit2_pos =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_bit_field_result, bit2_pos,
+			      UINT8);
+cmdline_parse_token_num_t cmd_write_reg_bit_field_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_bit_field_result, value,
+			      UINT32);
+
+cmdline_parse_inst_t cmd_write_reg_bit_field = {
+	.f = cmd_write_reg_bit_field_parsed,
+	.data = NULL,
+	.help_str = "write regfield <port_id> <reg_off> <bit_x> <bit_y> "
+		"<reg_value>: "
+		"Set register bit field between bit_x and bit_y included",
+	.tokens = {
+		(void *)&cmd_write_reg_bit_field_write,
+		(void *)&cmd_write_reg_bit_field_regfield,
+		(void *)&cmd_write_reg_bit_field_port_id,
+		(void *)&cmd_write_reg_bit_field_reg_off,
+		(void *)&cmd_write_reg_bit_field_bit1_pos,
+		(void *)&cmd_write_reg_bit_field_bit2_pos,
+		(void *)&cmd_write_reg_bit_field_value,
+		NULL,
+	},
+};
+
+/* *** WRITE PORT REGISTER BIT *** */
+struct cmd_write_reg_bit_result {
+	cmdline_fixed_string_t write;
+	cmdline_fixed_string_t regbit;
+	portid_t port_id;
+	uint32_t reg_off;
+	uint8_t bit_pos;
+	uint8_t value;
+};
+
+static void
+cmd_write_reg_bit_parsed(void *parsed_result,
+			 __attribute__((unused)) struct cmdline *cl,
+			 __attribute__((unused)) void *data)
+{
+	struct cmd_write_reg_bit_result *res = parsed_result;
+	port_reg_bit_set(res->port_id, res->reg_off, res->bit_pos, res->value);
+}
+
+cmdline_parse_token_string_t cmd_write_reg_bit_write =
+	TOKEN_STRING_INITIALIZER(struct cmd_write_reg_bit_result, write,
+				 "write");
+cmdline_parse_token_string_t cmd_write_reg_bit_regbit =
+	TOKEN_STRING_INITIALIZER(struct cmd_write_reg_bit_result,
+				 regbit, "regbit");
+cmdline_parse_token_num_t cmd_write_reg_bit_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_bit_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_write_reg_bit_reg_off =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_bit_result, reg_off, UINT32);
+cmdline_parse_token_num_t cmd_write_reg_bit_bit_pos =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_bit_result, bit_pos, UINT8);
+cmdline_parse_token_num_t cmd_write_reg_bit_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_write_reg_bit_result, value, UINT8);
+
+cmdline_parse_inst_t cmd_write_reg_bit = {
+	.f = cmd_write_reg_bit_parsed,
+	.data = NULL,
+	.help_str = "write regbit <port_id> <reg_off> <bit_x> 0|1: "
+		"0 <= bit_x <= 31",
+	.tokens = {
+		(void *)&cmd_write_reg_bit_write,
+		(void *)&cmd_write_reg_bit_regbit,
+		(void *)&cmd_write_reg_bit_port_id,
+		(void *)&cmd_write_reg_bit_reg_off,
+		(void *)&cmd_write_reg_bit_bit_pos,
+		(void *)&cmd_write_reg_bit_value,
+		NULL,
+	},
+};
+
 /* *** READ A RING DESCRIPTOR OF A PORT RX/TX QUEUE *** */
 struct cmd_read_rxd_txd_result {
 	cmdline_fixed_string_t read;
@@ -7162,8 +7976,8 @@
 
 static void
 cmd_read_rxd_txd_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_read_rxd_txd_result *res = parsed_result;
 
@@ -7173,22 +7987,19 @@
 		tx_ring_desc_display(res->port_id, res->queue_id, res->desc_id);
 }
 
-static cmdline_parse_token_string_t cmd_read_rxd_txd_read =
+cmdline_parse_token_string_t cmd_read_rxd_txd_read =
 	TOKEN_STRING_INITIALIZER(struct cmd_read_rxd_txd_result, read, "read");
-static cmdline_parse_token_string_t cmd_read_rxd_txd_rxd_txd =
+cmdline_parse_token_string_t cmd_read_rxd_txd_rxd_txd =
 	TOKEN_STRING_INITIALIZER(struct cmd_read_rxd_txd_result, rxd_txd,
 				 "rxd#txd");
-static cmdline_parse_token_num_t cmd_read_rxd_txd_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_read_rxd_txd_result, port_id,
-				 RTE_UINT16);
-static cmdline_parse_token_num_t cmd_read_rxd_txd_queue_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_read_rxd_txd_result, queue_id,
-				 RTE_UINT16);
-static cmdline_parse_token_num_t cmd_read_rxd_txd_desc_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_read_rxd_txd_result, desc_id,
-				 RTE_UINT16);
+cmdline_parse_token_num_t cmd_read_rxd_txd_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_rxd_txd_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_read_rxd_txd_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_rxd_txd_result, queue_id, UINT16);
+cmdline_parse_token_num_t cmd_read_rxd_txd_desc_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_read_rxd_txd_result, desc_id, UINT16);
 
-static cmdline_parse_inst_t cmd_read_rxd_txd = {
+cmdline_parse_inst_t cmd_read_rxd_txd = {
 	.f = cmd_read_rxd_txd_parsed,
 	.data = NULL,
 	.help_str = "read rxd|txd <port_id> <queue_id> <desc_id>",
@@ -7207,18 +8018,17 @@
 	cmdline_fixed_string_t quit;
 };
 
-static void cmd_quit_parsed(__rte_unused void *parsed_result,
+static void cmd_quit_parsed(__attribute__((unused)) void *parsed_result,
 			    struct cmdline *cl,
-			    __rte_unused void *data)
+			    __attribute__((unused)) void *data)
 {
 	cmdline_quit(cl);
-	cl_quit = 1;
 }
 
-static cmdline_parse_token_string_t cmd_quit_quit =
+cmdline_parse_token_string_t cmd_quit_quit =
 	TOKEN_STRING_INITIALIZER(struct cmd_quit_result, quit, "quit");
 
-static cmdline_parse_inst_t cmd_quit = {
+cmdline_parse_inst_t cmd_quit = {
 	.f = cmd_quit_parsed,
 	.data = NULL,
 	.help_str = "quit: Exit application",
@@ -7237,8 +8047,8 @@
 };
 
 static void cmd_mac_addr_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_mac_addr_result *res = parsed_result;
 	int ret;
@@ -7253,23 +8063,23 @@
 
 	/* check the return value and print it if is < 0 */
 	if(ret < 0)
-		fprintf(stderr, "mac_addr_cmd error: (%s)\n", strerror(-ret));
+		printf("mac_addr_cmd error: (%s)\n", strerror(-ret));
 
 }
 
-static cmdline_parse_token_string_t cmd_mac_addr_cmd =
+cmdline_parse_token_string_t cmd_mac_addr_cmd =
 	TOKEN_STRING_INITIALIZER(struct cmd_mac_addr_result, mac_addr_cmd,
 				"mac_addr");
-static cmdline_parse_token_string_t cmd_mac_addr_what =
+cmdline_parse_token_string_t cmd_mac_addr_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_mac_addr_result, what,
 				"add#remove#set");
-static cmdline_parse_token_num_t cmd_mac_addr_portnum =
+cmdline_parse_token_num_t cmd_mac_addr_portnum =
 		TOKEN_NUM_INITIALIZER(struct cmd_mac_addr_result, port_num,
-					RTE_UINT16);
-static cmdline_parse_token_etheraddr_t cmd_mac_addr_addr =
+					UINT16);
+cmdline_parse_token_etheraddr_t cmd_mac_addr_addr =
 		TOKEN_ETHERADDR_INITIALIZER(struct cmd_mac_addr_result, address);
 
-static cmdline_parse_inst_t cmd_mac_addr = {
+cmdline_parse_inst_t cmd_mac_addr = {
 	.f = cmd_mac_addr_parsed,
 	.data = (void *)0,
 	.help_str = "mac_addr add|remove|set <port_id> <mac_addr>: "
@@ -7292,13 +8102,13 @@
 };
 
 static void cmd_set_eth_peer_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 		struct cmd_eth_peer_result *res = parsed_result;
 
 		if (test_done == 0) {
-			fprintf(stderr, "Please stop forwarding first\n");
+			printf("Please stop forwarding first\n");
 			return;
 		}
 		if (!strcmp(res->eth_peer, "eth-peer")) {
@@ -7306,17 +8116,16 @@
 			fwd_config_setup();
 		}
 }
-static cmdline_parse_token_string_t cmd_eth_peer_set =
+cmdline_parse_token_string_t cmd_eth_peer_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_eth_peer_result, set, "set");
-static cmdline_parse_token_string_t cmd_eth_peer =
+cmdline_parse_token_string_t cmd_eth_peer =
 	TOKEN_STRING_INITIALIZER(struct cmd_eth_peer_result, eth_peer, "eth-peer");
-static cmdline_parse_token_num_t cmd_eth_peer_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_eth_peer_result, port_id,
-		RTE_UINT16);
-static cmdline_parse_token_string_t cmd_eth_peer_addr =
+cmdline_parse_token_num_t cmd_eth_peer_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_eth_peer_result, port_id, UINT16);
+cmdline_parse_token_string_t cmd_eth_peer_addr =
 	TOKEN_STRING_INITIALIZER(struct cmd_eth_peer_result, peer_addr, NULL);
 
-static cmdline_parse_inst_t cmd_set_fwd_eth_peer = {
+cmdline_parse_inst_t cmd_set_fwd_eth_peer = {
 	.f = cmd_set_eth_peer_parsed,
 	.data = NULL,
 	.help_str = "set eth-peer <port_id> <peer_mac>",
@@ -7341,8 +8150,8 @@
 
 static void
 cmd_set_qmap_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	struct cmd_set_qmap_result *res = parsed_result;
 	int is_rx = (strcmp(res->what, "tx") == 0) ? 0 : 1;
@@ -7350,26 +8159,26 @@
 	set_qmap(res->port_id, (uint8_t)is_rx, res->queue_id, res->map_value);
 }
 
-static cmdline_parse_token_string_t cmd_setqmap_set =
+cmdline_parse_token_string_t cmd_setqmap_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_qmap_result,
 				 set, "set");
-static cmdline_parse_token_string_t cmd_setqmap_qmap =
+cmdline_parse_token_string_t cmd_setqmap_qmap =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_qmap_result,
 				 qmap, "stat_qmap");
-static cmdline_parse_token_string_t cmd_setqmap_what =
+cmdline_parse_token_string_t cmd_setqmap_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_qmap_result,
 				 what, "tx#rx");
-static cmdline_parse_token_num_t cmd_setqmap_portid =
+cmdline_parse_token_num_t cmd_setqmap_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_qmap_result,
-			      port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_setqmap_queueid =
+			      port_id, UINT16);
+cmdline_parse_token_num_t cmd_setqmap_queueid =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_qmap_result,
-			      queue_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_setqmap_mapvalue =
+			      queue_id, UINT16);
+cmdline_parse_token_num_t cmd_setqmap_mapvalue =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_qmap_result,
-			      map_value, RTE_UINT8);
+			      map_value, UINT8);
 
-static cmdline_parse_inst_t cmd_set_qmap = {
+cmdline_parse_inst_t cmd_set_qmap = {
 	.f = cmd_set_qmap_parsed,
 	.data = NULL,
 	.help_str = "set stat_qmap rx|tx <port_id> <queue_id> <map_value>: "
@@ -7394,8 +8203,8 @@
 
 static void
 cmd_set_xstats_hide_zero_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
 {
 	struct cmd_set_xstats_hide_zero_result *res;
 	uint16_t on_off = 0;
@@ -7405,17 +8214,17 @@
 	set_xstats_hide_zero(on_off);
 }
 
-static cmdline_parse_token_string_t cmd_set_xstats_hide_zero_keyword =
+cmdline_parse_token_string_t cmd_set_xstats_hide_zero_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_xstats_hide_zero_result,
 				 keyword, "set");
-static cmdline_parse_token_string_t cmd_set_xstats_hide_zero_name =
+cmdline_parse_token_string_t cmd_set_xstats_hide_zero_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_xstats_hide_zero_result,
 				 name, "xstats-hide-zero");
-static cmdline_parse_token_string_t cmd_set_xstats_hide_zero_on_off =
+cmdline_parse_token_string_t cmd_set_xstats_hide_zero_on_off =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_xstats_hide_zero_result,
 				 on_off, "on#off");
 
-static cmdline_parse_inst_t cmd_set_xstats_hide_zero = {
+cmdline_parse_inst_t cmd_set_xstats_hide_zero = {
 	.f = cmd_set_xstats_hide_zero_parsed,
 	.data = NULL,
 	.help_str = "set xstats-hide-zero on|off",
@@ -7427,90 +8236,6 @@
 	},
 };
 
-/* *** SET OPTION TO ENABLE MEASUREMENT OF CPU CYCLES *** */
-struct cmd_set_record_core_cycles_result {
-	cmdline_fixed_string_t keyword;
-	cmdline_fixed_string_t name;
-	cmdline_fixed_string_t on_off;
-};
-
-static void
-cmd_set_record_core_cycles_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
-{
-	struct cmd_set_record_core_cycles_result *res;
-	uint16_t on_off = 0;
-
-	res = parsed_result;
-	on_off = !strcmp(res->on_off, "on") ? 1 : 0;
-	set_record_core_cycles(on_off);
-}
-
-static cmdline_parse_token_string_t cmd_set_record_core_cycles_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_record_core_cycles_result,
-				 keyword, "set");
-static cmdline_parse_token_string_t cmd_set_record_core_cycles_name =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_record_core_cycles_result,
-				 name, "record-core-cycles");
-static cmdline_parse_token_string_t cmd_set_record_core_cycles_on_off =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_record_core_cycles_result,
-				 on_off, "on#off");
-
-static cmdline_parse_inst_t cmd_set_record_core_cycles = {
-	.f = cmd_set_record_core_cycles_parsed,
-	.data = NULL,
-	.help_str = "set record-core-cycles on|off",
-	.tokens = {
-		(void *)&cmd_set_record_core_cycles_keyword,
-		(void *)&cmd_set_record_core_cycles_name,
-		(void *)&cmd_set_record_core_cycles_on_off,
-		NULL,
-	},
-};
-
-/* *** SET OPTION TO ENABLE DISPLAY OF RX AND TX BURSTS *** */
-struct cmd_set_record_burst_stats_result {
-	cmdline_fixed_string_t keyword;
-	cmdline_fixed_string_t name;
-	cmdline_fixed_string_t on_off;
-};
-
-static void
-cmd_set_record_burst_stats_parsed(void *parsed_result,
-			__rte_unused struct cmdline *cl,
-			__rte_unused void *data)
-{
-	struct cmd_set_record_burst_stats_result *res;
-	uint16_t on_off = 0;
-
-	res = parsed_result;
-	on_off = !strcmp(res->on_off, "on") ? 1 : 0;
-	set_record_burst_stats(on_off);
-}
-
-static cmdline_parse_token_string_t cmd_set_record_burst_stats_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_record_burst_stats_result,
-				 keyword, "set");
-static cmdline_parse_token_string_t cmd_set_record_burst_stats_name =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_record_burst_stats_result,
-				 name, "record-burst-stats");
-static cmdline_parse_token_string_t cmd_set_record_burst_stats_on_off =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_record_burst_stats_result,
-				 on_off, "on#off");
-
-static cmdline_parse_inst_t cmd_set_record_burst_stats = {
-	.f = cmd_set_record_burst_stats_parsed,
-	.data = NULL,
-	.help_str = "set record-burst-stats on|off",
-	.tokens = {
-		(void *)&cmd_set_record_burst_stats_keyword,
-		(void *)&cmd_set_record_burst_stats_name,
-		(void *)&cmd_set_record_burst_stats_on_off,
-		NULL,
-	},
-};
-
 /* *** CONFIGURE UNICAST HASH TABLE *** */
 struct cmd_set_uc_hash_table {
 	cmdline_fixed_string_t set;
@@ -7523,8 +8248,8 @@
 
 static void
 cmd_set_uc_hash_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	int ret=0;
 	struct cmd_set_uc_hash_table *res = parsed_result;
@@ -7535,32 +8260,30 @@
 		ret = rte_eth_dev_uc_hash_table_set(res->port_id,
 						&res->address,(uint8_t)is_on);
 	if (ret < 0)
-		fprintf(stderr,
-			"bad unicast hash table parameter, return code = %d\n",
-			ret);
+		printf("bad unicast hash table parameter, return code = %d \n", ret);
 
 }
 
-static cmdline_parse_token_string_t cmd_set_uc_hash_set =
+cmdline_parse_token_string_t cmd_set_uc_hash_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_uc_hash_table,
 				 set, "set");
-static cmdline_parse_token_string_t cmd_set_uc_hash_port =
+cmdline_parse_token_string_t cmd_set_uc_hash_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_uc_hash_table,
 				 port, "port");
-static cmdline_parse_token_num_t cmd_set_uc_hash_portid =
+cmdline_parse_token_num_t cmd_set_uc_hash_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_uc_hash_table,
-			      port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_uc_hash_what =
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_set_uc_hash_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_uc_hash_table,
 				 what, "uta");
-static cmdline_parse_token_etheraddr_t cmd_set_uc_hash_mac =
+cmdline_parse_token_etheraddr_t cmd_set_uc_hash_mac =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_uc_hash_table,
 				address);
-static cmdline_parse_token_string_t cmd_set_uc_hash_mode =
+cmdline_parse_token_string_t cmd_set_uc_hash_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_uc_hash_table,
 				 mode, "on#off");
 
-static cmdline_parse_inst_t cmd_set_uc_hash_filter = {
+cmdline_parse_inst_t cmd_set_uc_hash_filter = {
 	.f = cmd_set_uc_hash_parsed,
 	.data = NULL,
 	.help_str = "set port <port_id> uta <mac_addr> on|off)",
@@ -7586,8 +8309,8 @@
 
 static void
 cmd_set_uc_all_hash_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	int ret=0;
 	struct cmd_set_uc_all_hash_table *res = parsed_result;
@@ -7598,31 +8321,30 @@
 		(strcmp(res->value, "all") == 0))
 		ret = rte_eth_dev_uc_all_hash_table_set(res->port_id,(uint8_t) is_on);
 	if (ret < 0)
-		fprintf(stderr,
-			"bad unicast hash table parameter, return code = %d\n",
-			ret);
+		printf("bad unicast hash table parameter,"
+			"return code = %d \n", ret);
 }
 
-static cmdline_parse_token_string_t cmd_set_uc_all_hash_set =
+cmdline_parse_token_string_t cmd_set_uc_all_hash_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_uc_all_hash_table,
 				 set, "set");
-static cmdline_parse_token_string_t cmd_set_uc_all_hash_port =
+cmdline_parse_token_string_t cmd_set_uc_all_hash_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_uc_all_hash_table,
 				 port, "port");
-static cmdline_parse_token_num_t cmd_set_uc_all_hash_portid =
+cmdline_parse_token_num_t cmd_set_uc_all_hash_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_uc_all_hash_table,
-			      port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_uc_all_hash_what =
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_set_uc_all_hash_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_uc_all_hash_table,
 				 what, "uta");
-static cmdline_parse_token_string_t cmd_set_uc_all_hash_value =
+cmdline_parse_token_string_t cmd_set_uc_all_hash_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_uc_all_hash_table,
 				value,"all");
-static cmdline_parse_token_string_t cmd_set_uc_all_hash_mode =
+cmdline_parse_token_string_t cmd_set_uc_all_hash_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_uc_all_hash_table,
 				 mode, "on#off");
 
-static cmdline_parse_inst_t cmd_set_uc_all_hash_filter = {
+cmdline_parse_inst_t cmd_set_uc_all_hash_filter = {
 	.f = cmd_set_uc_all_hash_parsed,
 	.data = NULL,
 	.help_str = "set port <port_id> uta all on|off",
@@ -7637,6 +8359,110 @@
 	},
 };
 
+/* *** CONFIGURE MACVLAN FILTER FOR VF(s) *** */
+struct cmd_set_vf_macvlan_filter {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t vf;
+	uint8_t vf_id;
+	struct rte_ether_addr address;
+	cmdline_fixed_string_t filter_type;
+	cmdline_fixed_string_t mode;
+};
+
+static void
+cmd_set_vf_macvlan_parsed(void *parsed_result,
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
+{
+	int is_on, ret = 0;
+	struct cmd_set_vf_macvlan_filter *res = parsed_result;
+	struct rte_eth_mac_filter filter;
+
+	memset(&filter, 0, sizeof(struct rte_eth_mac_filter));
+
+	rte_memcpy(&filter.mac_addr, &res->address, RTE_ETHER_ADDR_LEN);
+
+	/* set VF MAC filter */
+	filter.is_vf = 1;
+
+	/* set VF ID */
+	filter.dst_id = res->vf_id;
+
+	if (!strcmp(res->filter_type, "exact-mac"))
+		filter.filter_type = RTE_MAC_PERFECT_MATCH;
+	else if (!strcmp(res->filter_type, "exact-mac-vlan"))
+		filter.filter_type = RTE_MACVLAN_PERFECT_MATCH;
+	else if (!strcmp(res->filter_type, "hashmac"))
+		filter.filter_type = RTE_MAC_HASH_MATCH;
+	else if (!strcmp(res->filter_type, "hashmac-vlan"))
+		filter.filter_type = RTE_MACVLAN_HASH_MATCH;
+
+	is_on = (strcmp(res->mode, "on") == 0) ? 1 : 0;
+
+	if (is_on)
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+					RTE_ETH_FILTER_MACVLAN,
+					RTE_ETH_FILTER_ADD,
+					 &filter);
+	else
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+					RTE_ETH_FILTER_MACVLAN,
+					RTE_ETH_FILTER_DELETE,
+					&filter);
+
+	if (ret < 0)
+		printf("bad set MAC hash parameter, return code = %d\n", ret);
+
+}
+
+cmdline_parse_token_string_t cmd_set_vf_macvlan_set =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_macvlan_filter,
+				 set, "set");
+cmdline_parse_token_string_t cmd_set_vf_macvlan_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_macvlan_filter,
+				 port, "port");
+cmdline_parse_token_num_t cmd_set_vf_macvlan_portid =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_vf_macvlan_filter,
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_set_vf_macvlan_vf =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_macvlan_filter,
+				 vf, "vf");
+cmdline_parse_token_num_t cmd_set_vf_macvlan_vf_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_vf_macvlan_filter,
+				vf_id, UINT8);
+cmdline_parse_token_etheraddr_t cmd_set_vf_macvlan_mac =
+	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_vf_macvlan_filter,
+				address);
+cmdline_parse_token_string_t cmd_set_vf_macvlan_filter_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_macvlan_filter,
+				filter_type, "exact-mac#exact-mac-vlan"
+				"#hashmac#hashmac-vlan");
+cmdline_parse_token_string_t cmd_set_vf_macvlan_mode =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_macvlan_filter,
+				 mode, "on#off");
+
+cmdline_parse_inst_t cmd_set_vf_macvlan_filter = {
+	.f = cmd_set_vf_macvlan_parsed,
+	.data = NULL,
+	.help_str = "set port <port_id> vf <vf_id> <mac_addr> "
+		"exact-mac|exact-mac-vlan|hashmac|hashmac-vlan on|off: "
+		"Exact match rule: exact match of MAC or MAC and VLAN; "
+		"hash match rule: hash match of MAC and exact match of VLAN",
+	.tokens = {
+		(void *)&cmd_set_vf_macvlan_set,
+		(void *)&cmd_set_vf_macvlan_port,
+		(void *)&cmd_set_vf_macvlan_portid,
+		(void *)&cmd_set_vf_macvlan_vf,
+		(void *)&cmd_set_vf_macvlan_vf_id,
+		(void *)&cmd_set_vf_macvlan_mac,
+		(void *)&cmd_set_vf_macvlan_filter_type,
+		(void *)&cmd_set_vf_macvlan_mode,
+		NULL,
+	},
+};
+
 /* *** CONFIGURE VF TRAFFIC CONTROL *** */
 struct cmd_set_vf_traffic {
 	cmdline_fixed_string_t set;
@@ -7650,8 +8476,8 @@
 
 static void
 cmd_set_vf_traffic_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	struct cmd_set_vf_traffic *res = parsed_result;
 	int is_rx = (strcmp(res->what, "rx") == 0) ? 1 : 0;
@@ -7660,29 +8486,29 @@
 	set_vf_traffic(res->port_id, (uint8_t)is_rx, res->vf_id,(uint8_t) is_on);
 }
 
-static cmdline_parse_token_string_t cmd_setvf_traffic_set =
+cmdline_parse_token_string_t cmd_setvf_traffic_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_traffic,
 				 set, "set");
-static cmdline_parse_token_string_t cmd_setvf_traffic_port =
+cmdline_parse_token_string_t cmd_setvf_traffic_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_traffic,
 				 port, "port");
-static cmdline_parse_token_num_t cmd_setvf_traffic_portid =
+cmdline_parse_token_num_t cmd_setvf_traffic_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_vf_traffic,
-			      port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_setvf_traffic_vf =
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_setvf_traffic_vf =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_traffic,
 				 vf, "vf");
-static cmdline_parse_token_num_t cmd_setvf_traffic_vfid =
+cmdline_parse_token_num_t cmd_setvf_traffic_vfid =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_vf_traffic,
-			      vf_id, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_setvf_traffic_what =
+			      vf_id, UINT8);
+cmdline_parse_token_string_t cmd_setvf_traffic_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_traffic,
 				 what, "tx#rx");
-static cmdline_parse_token_string_t cmd_setvf_traffic_mode =
+cmdline_parse_token_string_t cmd_setvf_traffic_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_traffic,
 				 mode, "on#off");
 
-static cmdline_parse_inst_t cmd_set_vf_traffic = {
+cmdline_parse_inst_t cmd_set_vf_traffic = {
 	.f = cmd_set_vf_traffic_parsed,
 	.data = NULL,
 	.help_str = "set port <port_id> vf <vf_id> rx|tx on|off",
@@ -7712,8 +8538,8 @@
 
 static void
 cmd_set_vf_rxmode_parsed(void *parsed_result,
-		       __rte_unused struct cmdline *cl,
-		       __rte_unused void *data)
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
 {
 	int ret = -ENOTSUP;
 	uint16_t vf_rxmode = 0;
@@ -7722,60 +8548,58 @@
 	int is_on = (strcmp(res->on, "on") == 0) ? 1 : 0;
 	if (!strcmp(res->what,"rxmode")) {
 		if (!strcmp(res->mode, "AUPE"))
-			vf_rxmode |= RTE_ETH_VMDQ_ACCEPT_UNTAG;
+			vf_rxmode |= ETH_VMDQ_ACCEPT_UNTAG;
 		else if (!strcmp(res->mode, "ROPE"))
-			vf_rxmode |= RTE_ETH_VMDQ_ACCEPT_HASH_UC;
+			vf_rxmode |= ETH_VMDQ_ACCEPT_HASH_UC;
 		else if (!strcmp(res->mode, "BAM"))
-			vf_rxmode |= RTE_ETH_VMDQ_ACCEPT_BROADCAST;
+			vf_rxmode |= ETH_VMDQ_ACCEPT_BROADCAST;
 		else if (!strncmp(res->mode, "MPE",3))
-			vf_rxmode |= RTE_ETH_VMDQ_ACCEPT_MULTICAST;
+			vf_rxmode |= ETH_VMDQ_ACCEPT_MULTICAST;
 	}
 
 	RTE_SET_USED(is_on);
-	RTE_SET_USED(vf_rxmode);
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_ixgbe_set_vf_rxmode(res->port_id, res->vf_id,
 						  vf_rxmode, (uint8_t)is_on);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_set_vf_rxmode(res->port_id, res->vf_id,
 						 vf_rxmode, (uint8_t)is_on);
 #endif
 	if (ret < 0)
-		fprintf(stderr,
-			"bad VF receive mode parameter, return code = %d\n",
-			ret);
+		printf("bad VF receive mode parameter, return code = %d \n",
+		ret);
 }
 
-static cmdline_parse_token_string_t cmd_set_vf_rxmode_set =
+cmdline_parse_token_string_t cmd_set_vf_rxmode_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_rxmode,
 				 set, "set");
-static cmdline_parse_token_string_t cmd_set_vf_rxmode_port =
+cmdline_parse_token_string_t cmd_set_vf_rxmode_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_rxmode,
 				 port, "port");
-static cmdline_parse_token_num_t cmd_set_vf_rxmode_portid =
+cmdline_parse_token_num_t cmd_set_vf_rxmode_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_vf_rxmode,
-			      port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_vf_rxmode_vf =
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_set_vf_rxmode_vf =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_rxmode,
 				 vf, "vf");
-static cmdline_parse_token_num_t cmd_set_vf_rxmode_vfid =
+cmdline_parse_token_num_t cmd_set_vf_rxmode_vfid =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_vf_rxmode,
-			      vf_id, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_set_vf_rxmode_what =
+			      vf_id, UINT8);
+cmdline_parse_token_string_t cmd_set_vf_rxmode_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_rxmode,
 				 what, "rxmode");
-static cmdline_parse_token_string_t cmd_set_vf_rxmode_mode =
+cmdline_parse_token_string_t cmd_set_vf_rxmode_mode =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_rxmode,
 				 mode, "AUPE#ROPE#BAM#MPE");
-static cmdline_parse_token_string_t cmd_set_vf_rxmode_on =
+cmdline_parse_token_string_t cmd_set_vf_rxmode_on =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vf_rxmode,
 				 on, "on#off");
 
-static cmdline_parse_inst_t cmd_set_vf_rxmode = {
+cmdline_parse_inst_t cmd_set_vf_rxmode = {
 	.f = cmd_set_vf_rxmode_parsed,
 	.data = NULL,
 	.help_str = "set port <port_id> vf <vf_id> rxmode "
@@ -7805,8 +8629,8 @@
 };
 
 static void cmd_vf_mac_addr_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_vf_mac_addr_result *res = parsed_result;
 	int ret = -ENOTSUP;
@@ -7814,45 +8638,45 @@
 	if (strcmp(res->what, "add") != 0)
 		return;
 
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_add_vf_mac_addr(res->port_num, res->vf_num,
 						   &res->address);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_mac_addr_add(res->port_num, &res->address,
 						res->vf_num);
 #endif
 
 	if(ret < 0)
-		fprintf(stderr, "vf_mac_addr_cmd error: (%s)\n", strerror(-ret));
+		printf("vf_mac_addr_cmd error: (%s)\n", strerror(-ret));
 
 }
 
-static cmdline_parse_token_string_t cmd_vf_mac_addr_cmd =
+cmdline_parse_token_string_t cmd_vf_mac_addr_cmd =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_mac_addr_result,
 				mac_addr_cmd,"mac_addr");
-static cmdline_parse_token_string_t cmd_vf_mac_addr_what =
+cmdline_parse_token_string_t cmd_vf_mac_addr_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_mac_addr_result,
 				what,"add");
-static cmdline_parse_token_string_t cmd_vf_mac_addr_port =
+cmdline_parse_token_string_t cmd_vf_mac_addr_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_mac_addr_result,
 				port,"port");
-static cmdline_parse_token_num_t cmd_vf_mac_addr_portnum =
+cmdline_parse_token_num_t cmd_vf_mac_addr_portnum =
 	TOKEN_NUM_INITIALIZER(struct cmd_vf_mac_addr_result,
-				port_num, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_vf_mac_addr_vf =
+				port_num, UINT16);
+cmdline_parse_token_string_t cmd_vf_mac_addr_vf =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_mac_addr_result,
 				vf,"vf");
-static cmdline_parse_token_num_t cmd_vf_mac_addr_vfnum =
+cmdline_parse_token_num_t cmd_vf_mac_addr_vfnum =
 	TOKEN_NUM_INITIALIZER(struct cmd_vf_mac_addr_result,
-				vf_num, RTE_UINT8);
-static cmdline_parse_token_etheraddr_t cmd_vf_mac_addr_addr =
+				vf_num, UINT8);
+cmdline_parse_token_etheraddr_t cmd_vf_mac_addr_addr =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_vf_mac_addr_result,
 				address);
 
-static cmdline_parse_inst_t cmd_vf_mac_addr_filter = {
+cmdline_parse_inst_t cmd_vf_mac_addr_filter = {
 	.f = cmd_vf_mac_addr_parsed,
 	.data = (void *)0,
 	.help_str = "mac_addr add port <port_id> vf <vf_id> <mac_addr>: "
@@ -7882,25 +8706,25 @@
 
 static void
 cmd_vf_rx_vlan_filter_parsed(void *parsed_result,
-			  __rte_unused struct cmdline *cl,
-			  __rte_unused void *data)
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
 {
 	struct cmd_vf_rx_vlan_filter *res = parsed_result;
 	int ret = -ENOTSUP;
 
 	__rte_unused int is_add = (strcmp(res->what, "add") == 0) ? 1 : 0;
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_ixgbe_set_vf_vlan_filter(res->port_id,
 				res->vlan_id, res->vf_mask, is_add);
 #endif
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_set_vf_vlan_filter(res->port_id,
 				res->vlan_id, res->vf_mask, is_add);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_set_vf_vlan_filter(res->port_id,
 				res->vlan_id, res->vf_mask, is_add);
@@ -7910,43 +8734,43 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid vlan_id %d or vf_mask %"PRIu64"\n",
-			res->vlan_id, res->vf_mask);
+		printf("invalid vlan_id %d or vf_mask %"PRIu64"\n",
+				res->vlan_id, res->vf_mask);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented or supported\n");
+		printf("function not implemented or supported\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 }
 
-static cmdline_parse_token_string_t cmd_vf_rx_vlan_filter_rx_vlan =
+cmdline_parse_token_string_t cmd_vf_rx_vlan_filter_rx_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_rx_vlan_filter,
 				 rx_vlan, "rx_vlan");
-static cmdline_parse_token_string_t cmd_vf_rx_vlan_filter_what =
+cmdline_parse_token_string_t cmd_vf_rx_vlan_filter_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_rx_vlan_filter,
 				 what, "add#rm");
-static cmdline_parse_token_num_t cmd_vf_rx_vlan_filter_vlanid =
+cmdline_parse_token_num_t cmd_vf_rx_vlan_filter_vlanid =
 	TOKEN_NUM_INITIALIZER(struct cmd_vf_rx_vlan_filter,
-			      vlan_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_vf_rx_vlan_filter_port =
+			      vlan_id, UINT16);
+cmdline_parse_token_string_t cmd_vf_rx_vlan_filter_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_rx_vlan_filter,
 				 port, "port");
-static cmdline_parse_token_num_t cmd_vf_rx_vlan_filter_portid =
+cmdline_parse_token_num_t cmd_vf_rx_vlan_filter_portid =
 	TOKEN_NUM_INITIALIZER(struct cmd_vf_rx_vlan_filter,
-			      port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_vf_rx_vlan_filter_vf =
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_vf_rx_vlan_filter_vf =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_rx_vlan_filter,
 				 vf, "vf");
-static cmdline_parse_token_num_t cmd_vf_rx_vlan_filter_vf_mask =
+cmdline_parse_token_num_t cmd_vf_rx_vlan_filter_vf_mask =
 	TOKEN_NUM_INITIALIZER(struct cmd_vf_rx_vlan_filter,
-			      vf_mask, RTE_UINT64);
+			      vf_mask, UINT64);
 
-static cmdline_parse_inst_t cmd_vf_rxvlan_filter = {
+cmdline_parse_inst_t cmd_vf_rxvlan_filter = {
 	.f = cmd_vf_rx_vlan_filter_parsed,
 	.data = NULL,
 	.help_str = "rx_vlan add|rm <vlan_id> port <port_id> vf <vf_mask>: "
@@ -7971,12 +8795,12 @@
 	cmdline_fixed_string_t queue;
 	uint8_t queue_num;
 	cmdline_fixed_string_t rate;
-	uint32_t rate_num;
+	uint16_t rate_num;
 };
 
 static void cmd_queue_rate_limit_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_queue_rate_limit_result *res = parsed_result;
 	int ret = 0;
@@ -7987,34 +8811,33 @@
 		ret = set_queue_rate_limit(res->port_num, res->queue_num,
 					res->rate_num);
 	if (ret < 0)
-		fprintf(stderr, "queue_rate_limit_cmd error: (%s)\n",
-			strerror(-ret));
+		printf("queue_rate_limit_cmd error: (%s)\n", strerror(-ret));
 
 }
 
-static cmdline_parse_token_string_t cmd_queue_rate_limit_set =
+cmdline_parse_token_string_t cmd_queue_rate_limit_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_queue_rate_limit_result,
 				set, "set");
-static cmdline_parse_token_string_t cmd_queue_rate_limit_port =
+cmdline_parse_token_string_t cmd_queue_rate_limit_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_queue_rate_limit_result,
 				port, "port");
-static cmdline_parse_token_num_t cmd_queue_rate_limit_portnum =
+cmdline_parse_token_num_t cmd_queue_rate_limit_portnum =
 	TOKEN_NUM_INITIALIZER(struct cmd_queue_rate_limit_result,
-				port_num, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_queue_rate_limit_queue =
+				port_num, UINT16);
+cmdline_parse_token_string_t cmd_queue_rate_limit_queue =
 	TOKEN_STRING_INITIALIZER(struct cmd_queue_rate_limit_result,
 				queue, "queue");
-static cmdline_parse_token_num_t cmd_queue_rate_limit_queuenum =
+cmdline_parse_token_num_t cmd_queue_rate_limit_queuenum =
 	TOKEN_NUM_INITIALIZER(struct cmd_queue_rate_limit_result,
-				queue_num, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_queue_rate_limit_rate =
+				queue_num, UINT8);
+cmdline_parse_token_string_t cmd_queue_rate_limit_rate =
 	TOKEN_STRING_INITIALIZER(struct cmd_queue_rate_limit_result,
 				rate, "rate");
-static cmdline_parse_token_num_t cmd_queue_rate_limit_ratenum =
+cmdline_parse_token_num_t cmd_queue_rate_limit_ratenum =
 	TOKEN_NUM_INITIALIZER(struct cmd_queue_rate_limit_result,
-				rate_num, RTE_UINT32);
+				rate_num, UINT16);
 
-static cmdline_parse_inst_t cmd_queue_rate_limit = {
+cmdline_parse_inst_t cmd_queue_rate_limit = {
 	.f = cmd_queue_rate_limit_parsed,
 	.data = (void *)0,
 	.help_str = "set port <port_id> queue <queue_id> rate <rate_value>: "
@@ -8039,14 +8862,14 @@
 	cmdline_fixed_string_t vf;
 	uint8_t vf_num;
 	cmdline_fixed_string_t rate;
-	uint32_t rate_num;
+	uint16_t rate_num;
 	cmdline_fixed_string_t q_msk;
 	uint64_t q_msk_val;
 };
 
 static void cmd_vf_rate_limit_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_vf_rate_limit_result *res = parsed_result;
 	int ret = 0;
@@ -8058,40 +8881,39 @@
 		ret = set_vf_rate_limit(res->port_num, res->vf_num,
 					res->rate_num, res->q_msk_val);
 	if (ret < 0)
-		fprintf(stderr, "vf_rate_limit_cmd error: (%s)\n",
-			strerror(-ret));
+		printf("vf_rate_limit_cmd error: (%s)\n", strerror(-ret));
 
 }
 
-static cmdline_parse_token_string_t cmd_vf_rate_limit_set =
+cmdline_parse_token_string_t cmd_vf_rate_limit_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_rate_limit_result,
 				set, "set");
-static cmdline_parse_token_string_t cmd_vf_rate_limit_port =
+cmdline_parse_token_string_t cmd_vf_rate_limit_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_rate_limit_result,
 				port, "port");
-static cmdline_parse_token_num_t cmd_vf_rate_limit_portnum =
+cmdline_parse_token_num_t cmd_vf_rate_limit_portnum =
 	TOKEN_NUM_INITIALIZER(struct cmd_vf_rate_limit_result,
-				port_num, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_vf_rate_limit_vf =
+				port_num, UINT16);
+cmdline_parse_token_string_t cmd_vf_rate_limit_vf =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_rate_limit_result,
 				vf, "vf");
-static cmdline_parse_token_num_t cmd_vf_rate_limit_vfnum =
+cmdline_parse_token_num_t cmd_vf_rate_limit_vfnum =
 	TOKEN_NUM_INITIALIZER(struct cmd_vf_rate_limit_result,
-				vf_num, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_vf_rate_limit_rate =
+				vf_num, UINT8);
+cmdline_parse_token_string_t cmd_vf_rate_limit_rate =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_rate_limit_result,
 				rate, "rate");
-static cmdline_parse_token_num_t cmd_vf_rate_limit_ratenum =
+cmdline_parse_token_num_t cmd_vf_rate_limit_ratenum =
 	TOKEN_NUM_INITIALIZER(struct cmd_vf_rate_limit_result,
-				rate_num, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_vf_rate_limit_q_msk =
+				rate_num, UINT16);
+cmdline_parse_token_string_t cmd_vf_rate_limit_q_msk =
 	TOKEN_STRING_INITIALIZER(struct cmd_vf_rate_limit_result,
 				q_msk, "queue_mask");
-static cmdline_parse_token_num_t cmd_vf_rate_limit_q_msk_val =
+cmdline_parse_token_num_t cmd_vf_rate_limit_q_msk_val =
 	TOKEN_NUM_INITIALIZER(struct cmd_vf_rate_limit_result,
-				q_msk_val, RTE_UINT64);
+				q_msk_val, UINT64);
 
-static cmdline_parse_inst_t cmd_vf_rate_limit = {
+cmdline_parse_inst_t cmd_vf_rate_limit = {
 	.f = cmd_vf_rate_limit_parsed,
 	.data = (void *)0,
 	.help_str = "set port <port_id> vf <vf_id> rate <rate_value> "
@@ -8111,9 +8933,160 @@
 	},
 };
 
+/* *** ADD TUNNEL FILTER OF A PORT *** */
+struct cmd_tunnel_filter_result {
+	cmdline_fixed_string_t cmd;
+	cmdline_fixed_string_t what;
+	portid_t port_id;
+	struct rte_ether_addr outer_mac;
+	struct rte_ether_addr inner_mac;
+	cmdline_ipaddr_t ip_value;
+	uint16_t inner_vlan;
+	cmdline_fixed_string_t tunnel_type;
+	cmdline_fixed_string_t filter_type;
+	uint32_t tenant_id;
+	uint16_t queue_num;
+};
+
+static void
+cmd_tunnel_filter_parsed(void *parsed_result,
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
+{
+	struct cmd_tunnel_filter_result *res = parsed_result;
+	struct rte_eth_tunnel_filter_conf tunnel_filter_conf;
+	int ret = 0;
+
+	memset(&tunnel_filter_conf, 0, sizeof(tunnel_filter_conf));
+
+	rte_ether_addr_copy(&res->outer_mac, &tunnel_filter_conf.outer_mac);
+	rte_ether_addr_copy(&res->inner_mac, &tunnel_filter_conf.inner_mac);
+	tunnel_filter_conf.inner_vlan = res->inner_vlan;
+
+	if (res->ip_value.family == AF_INET) {
+		tunnel_filter_conf.ip_addr.ipv4_addr =
+			res->ip_value.addr.ipv4.s_addr;
+		tunnel_filter_conf.ip_type = RTE_TUNNEL_IPTYPE_IPV4;
+	} else {
+		memcpy(&(tunnel_filter_conf.ip_addr.ipv6_addr),
+			&(res->ip_value.addr.ipv6),
+			sizeof(struct in6_addr));
+		tunnel_filter_conf.ip_type = RTE_TUNNEL_IPTYPE_IPV6;
+	}
+
+	if (!strcmp(res->filter_type, "imac-ivlan"))
+		tunnel_filter_conf.filter_type = RTE_TUNNEL_FILTER_IMAC_IVLAN;
+	else if (!strcmp(res->filter_type, "imac-ivlan-tenid"))
+		tunnel_filter_conf.filter_type =
+			RTE_TUNNEL_FILTER_IMAC_IVLAN_TENID;
+	else if (!strcmp(res->filter_type, "imac-tenid"))
+		tunnel_filter_conf.filter_type = RTE_TUNNEL_FILTER_IMAC_TENID;
+	else if (!strcmp(res->filter_type, "imac"))
+		tunnel_filter_conf.filter_type = ETH_TUNNEL_FILTER_IMAC;
+	else if (!strcmp(res->filter_type, "omac-imac-tenid"))
+		tunnel_filter_conf.filter_type =
+			RTE_TUNNEL_FILTER_OMAC_TENID_IMAC;
+	else if (!strcmp(res->filter_type, "oip"))
+		tunnel_filter_conf.filter_type = ETH_TUNNEL_FILTER_OIP;
+	else if (!strcmp(res->filter_type, "iip"))
+		tunnel_filter_conf.filter_type = ETH_TUNNEL_FILTER_IIP;
+	else {
+		printf("The filter type is not supported");
+		return;
+	}
+
+	if (!strcmp(res->tunnel_type, "vxlan"))
+		tunnel_filter_conf.tunnel_type = RTE_TUNNEL_TYPE_VXLAN;
+	else if (!strcmp(res->tunnel_type, "vxlan-gpe"))
+		tunnel_filter_conf.tunnel_type = RTE_TUNNEL_TYPE_VXLAN_GPE;
+	else if (!strcmp(res->tunnel_type, "nvgre"))
+		tunnel_filter_conf.tunnel_type = RTE_TUNNEL_TYPE_NVGRE;
+	else if (!strcmp(res->tunnel_type, "ipingre"))
+		tunnel_filter_conf.tunnel_type = RTE_TUNNEL_TYPE_IP_IN_GRE;
+	else {
+		printf("The tunnel type %s not supported.\n", res->tunnel_type);
+		return;
+	}
+
+	tunnel_filter_conf.tenant_id = res->tenant_id;
+	tunnel_filter_conf.queue_id = res->queue_num;
+	if (!strcmp(res->what, "add"))
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+					RTE_ETH_FILTER_TUNNEL,
+					RTE_ETH_FILTER_ADD,
+					&tunnel_filter_conf);
+	else
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+					RTE_ETH_FILTER_TUNNEL,
+					RTE_ETH_FILTER_DELETE,
+					&tunnel_filter_conf);
+	if (ret < 0)
+		printf("cmd_tunnel_filter_parsed error: (%s)\n",
+				strerror(-ret));
+
+}
+cmdline_parse_token_string_t cmd_tunnel_filter_cmd =
+	TOKEN_STRING_INITIALIZER(struct cmd_tunnel_filter_result,
+	cmd, "tunnel_filter");
+cmdline_parse_token_string_t cmd_tunnel_filter_what =
+	TOKEN_STRING_INITIALIZER(struct cmd_tunnel_filter_result,
+	what, "add#rm");
+cmdline_parse_token_num_t cmd_tunnel_filter_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_tunnel_filter_result,
+	port_id, UINT16);
+cmdline_parse_token_etheraddr_t cmd_tunnel_filter_outer_mac =
+	TOKEN_ETHERADDR_INITIALIZER(struct cmd_tunnel_filter_result,
+	outer_mac);
+cmdline_parse_token_etheraddr_t cmd_tunnel_filter_inner_mac =
+	TOKEN_ETHERADDR_INITIALIZER(struct cmd_tunnel_filter_result,
+	inner_mac);
+cmdline_parse_token_num_t cmd_tunnel_filter_innner_vlan =
+	TOKEN_NUM_INITIALIZER(struct cmd_tunnel_filter_result,
+	inner_vlan, UINT16);
+cmdline_parse_token_ipaddr_t cmd_tunnel_filter_ip_value =
+	TOKEN_IPADDR_INITIALIZER(struct cmd_tunnel_filter_result,
+	ip_value);
+cmdline_parse_token_string_t cmd_tunnel_filter_tunnel_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_tunnel_filter_result,
+	tunnel_type, "vxlan#nvgre#ipingre#vxlan-gpe");
+
+cmdline_parse_token_string_t cmd_tunnel_filter_filter_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_tunnel_filter_result,
+	filter_type, "oip#iip#imac-ivlan#imac-ivlan-tenid#imac-tenid#"
+		"imac#omac-imac-tenid");
+cmdline_parse_token_num_t cmd_tunnel_filter_tenant_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_tunnel_filter_result,
+	tenant_id, UINT32);
+cmdline_parse_token_num_t cmd_tunnel_filter_queue_num =
+	TOKEN_NUM_INITIALIZER(struct cmd_tunnel_filter_result,
+	queue_num, UINT16);
+
+cmdline_parse_inst_t cmd_tunnel_filter = {
+	.f = cmd_tunnel_filter_parsed,
+	.data = (void *)0,
+	.help_str = "tunnel_filter add|rm <port_id> <outer_mac> <inner_mac> "
+		"<ip> <inner_vlan> vxlan|nvgre|ipingre oip|iip|imac-ivlan|"
+		"imac-ivlan-tenid|imac-tenid|imac|omac-imac-tenid <tenant_id> "
+		"<queue_id>: Add/Rm tunnel filter of a port",
+	.tokens = {
+		(void *)&cmd_tunnel_filter_cmd,
+		(void *)&cmd_tunnel_filter_what,
+		(void *)&cmd_tunnel_filter_port_id,
+		(void *)&cmd_tunnel_filter_outer_mac,
+		(void *)&cmd_tunnel_filter_inner_mac,
+		(void *)&cmd_tunnel_filter_ip_value,
+		(void *)&cmd_tunnel_filter_innner_vlan,
+		(void *)&cmd_tunnel_filter_tunnel_type,
+		(void *)&cmd_tunnel_filter_filter_type,
+		(void *)&cmd_tunnel_filter_tenant_id,
+		(void *)&cmd_tunnel_filter_queue_num,
+		NULL,
+	},
+};
+
 /* *** CONFIGURE TUNNEL UDP PORT *** */
 struct cmd_tunnel_udp_config {
-	cmdline_fixed_string_t rx_vxlan_port;
+	cmdline_fixed_string_t cmd;
 	cmdline_fixed_string_t what;
 	uint16_t udp_port;
 	portid_t port_id;
@@ -8121,15 +9094,17 @@
 
 static void
 cmd_tunnel_udp_config_parsed(void *parsed_result,
-			  __rte_unused struct cmdline *cl,
-			  __rte_unused void *data)
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
 {
 	struct cmd_tunnel_udp_config *res = parsed_result;
 	struct rte_eth_udp_tunnel tunnel_udp;
 	int ret;
 
 	tunnel_udp.udp_port = res->udp_port;
-	tunnel_udp.prot_type = RTE_ETH_TUNNEL_TYPE_VXLAN;
+
+	if (!strcmp(res->cmd, "rx_vxlan_port"))
+		tunnel_udp.prot_type = RTE_TUNNEL_TYPE_VXLAN;
 
 	if (!strcmp(res->what, "add"))
 		ret = rte_eth_dev_udp_tunnel_port_add(res->port_id,
@@ -8139,30 +9114,29 @@
 							 &tunnel_udp);
 
 	if (ret < 0)
-		fprintf(stderr, "udp tunneling add error: (%s)\n",
-			strerror(-ret));
+		printf("udp tunneling add error: (%s)\n", strerror(-ret));
 }
 
-static cmdline_parse_token_string_t cmd_tunnel_udp_config_rx_vxlan_port =
+cmdline_parse_token_string_t cmd_tunnel_udp_config_cmd =
 	TOKEN_STRING_INITIALIZER(struct cmd_tunnel_udp_config,
-				rx_vxlan_port, "rx_vxlan_port");
-static cmdline_parse_token_string_t cmd_tunnel_udp_config_what =
+				cmd, "rx_vxlan_port");
+cmdline_parse_token_string_t cmd_tunnel_udp_config_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_tunnel_udp_config,
 				what, "add#rm");
-static cmdline_parse_token_num_t cmd_tunnel_udp_config_udp_port =
+cmdline_parse_token_num_t cmd_tunnel_udp_config_udp_port =
 	TOKEN_NUM_INITIALIZER(struct cmd_tunnel_udp_config,
-				udp_port, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_tunnel_udp_config_port_id =
+				udp_port, UINT16);
+cmdline_parse_token_num_t cmd_tunnel_udp_config_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_tunnel_udp_config,
-				port_id, RTE_UINT16);
+				port_id, UINT16);
 
-static cmdline_parse_inst_t cmd_tunnel_udp_config = {
+cmdline_parse_inst_t cmd_tunnel_udp_config = {
 	.f = cmd_tunnel_udp_config_parsed,
 	.data = (void *)0,
 	.help_str = "rx_vxlan_port add|rm <udp_port> <port_id>: "
 		"Add/Remove a tunneling UDP port filter",
 	.tokens = {
-		(void *)&cmd_tunnel_udp_config_rx_vxlan_port,
+		(void *)&cmd_tunnel_udp_config_cmd,
 		(void *)&cmd_tunnel_udp_config_what,
 		(void *)&cmd_tunnel_udp_config_udp_port,
 		(void *)&cmd_tunnel_udp_config_port_id,
@@ -8182,8 +9156,8 @@
 
 static void
 cmd_cfg_tunnel_udp_port_parsed(void *parsed_result,
-			       __rte_unused struct cmdline *cl,
-			       __rte_unused void *data)
+			       __attribute__((unused)) struct cmdline *cl,
+			       __attribute__((unused)) void *data)
 {
 	struct cmd_config_tunnel_udp_port *res = parsed_result;
 	struct rte_eth_udp_tunnel tunnel_udp;
@@ -8195,15 +9169,13 @@
 	tunnel_udp.udp_port = res->udp_port;
 
 	if (!strcmp(res->tunnel_type, "vxlan")) {
-		tunnel_udp.prot_type = RTE_ETH_TUNNEL_TYPE_VXLAN;
+		tunnel_udp.prot_type = RTE_TUNNEL_TYPE_VXLAN;
 	} else if (!strcmp(res->tunnel_type, "geneve")) {
-		tunnel_udp.prot_type = RTE_ETH_TUNNEL_TYPE_GENEVE;
+		tunnel_udp.prot_type = RTE_TUNNEL_TYPE_GENEVE;
 	} else if (!strcmp(res->tunnel_type, "vxlan-gpe")) {
-		tunnel_udp.prot_type = RTE_ETH_TUNNEL_TYPE_VXLAN_GPE;
-	} else if (!strcmp(res->tunnel_type, "ecpri")) {
-		tunnel_udp.prot_type = RTE_ETH_TUNNEL_TYPE_ECPRI;
+		tunnel_udp.prot_type = RTE_TUNNEL_TYPE_VXLAN_GPE;
 	} else {
-		fprintf(stderr, "Invalid tunnel type\n");
+		printf("Invalid tunnel type\n");
 		return;
 	}
 
@@ -8215,38 +9187,36 @@
 							 &tunnel_udp);
 
 	if (ret < 0)
-		fprintf(stderr, "udp tunneling port add error: (%s)\n",
-			strerror(-ret));
+		printf("udp tunneling port add error: (%s)\n", strerror(-ret));
 }
 
-static cmdline_parse_token_string_t cmd_config_tunnel_udp_port_port =
+cmdline_parse_token_string_t cmd_config_tunnel_udp_port_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_tunnel_udp_port, port,
 				 "port");
-static cmdline_parse_token_string_t cmd_config_tunnel_udp_port_config =
+cmdline_parse_token_string_t cmd_config_tunnel_udp_port_config =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_tunnel_udp_port, config,
 				 "config");
-static cmdline_parse_token_num_t cmd_config_tunnel_udp_port_port_id =
+cmdline_parse_token_num_t cmd_config_tunnel_udp_port_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_tunnel_udp_port, port_id,
-			      RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_tunnel_udp_port_tunnel_port =
+			      UINT16);
+cmdline_parse_token_string_t cmd_config_tunnel_udp_port_tunnel_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_tunnel_udp_port,
 				 udp_tunnel_port,
 				 "udp_tunnel_port");
-static cmdline_parse_token_string_t cmd_config_tunnel_udp_port_action =
+cmdline_parse_token_string_t cmd_config_tunnel_udp_port_action =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_tunnel_udp_port, action,
 				 "add#rm");
-static cmdline_parse_token_string_t cmd_config_tunnel_udp_port_tunnel_type =
+cmdline_parse_token_string_t cmd_config_tunnel_udp_port_tunnel_type =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_tunnel_udp_port, tunnel_type,
-				 "vxlan#geneve#vxlan-gpe#ecpri");
-static cmdline_parse_token_num_t cmd_config_tunnel_udp_port_value =
+				 "vxlan#geneve#vxlan-gpe");
+cmdline_parse_token_num_t cmd_config_tunnel_udp_port_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_tunnel_udp_port, udp_port,
-			      RTE_UINT16);
+			      UINT16);
 
-static cmdline_parse_inst_t cmd_cfg_tunnel_udp_port = {
+cmdline_parse_inst_t cmd_cfg_tunnel_udp_port = {
 	.f = cmd_cfg_tunnel_udp_port_parsed,
 	.data = NULL,
-	.help_str = "port config <port_id> udp_tunnel_port add|rm vxlan|"
-		"geneve|vxlan-gpe|ecpri <udp_port>",
+	.help_str = "port config <port_id> udp_tunnel_port add|rm vxlan|geneve|vxlan-gpe <udp_port>",
 	.tokens = {
 		(void *)&cmd_config_tunnel_udp_port_port,
 		(void *)&cmd_config_tunnel_udp_port_config,
@@ -8259,6 +9229,316 @@
 	},
 };
 
+/* *** GLOBAL CONFIG *** */
+struct cmd_global_config_result {
+	cmdline_fixed_string_t cmd;
+	portid_t port_id;
+	cmdline_fixed_string_t cfg_type;
+	uint8_t len;
+};
+
+static void
+cmd_global_config_parsed(void *parsed_result,
+			 __attribute__((unused)) struct cmdline *cl,
+			 __attribute__((unused)) void *data)
+{
+	struct cmd_global_config_result *res = parsed_result;
+	struct rte_eth_global_cfg conf;
+	int ret;
+
+	memset(&conf, 0, sizeof(conf));
+	conf.cfg_type = RTE_ETH_GLOBAL_CFG_TYPE_GRE_KEY_LEN;
+	conf.cfg.gre_key_len = res->len;
+	ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_NONE,
+				      RTE_ETH_FILTER_SET, &conf);
+	if (ret != 0)
+		printf("Global config error\n");
+}
+
+cmdline_parse_token_string_t cmd_global_config_cmd =
+	TOKEN_STRING_INITIALIZER(struct cmd_global_config_result, cmd,
+		"global_config");
+cmdline_parse_token_num_t cmd_global_config_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_global_config_result, port_id,
+			       UINT16);
+cmdline_parse_token_string_t cmd_global_config_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_global_config_result,
+		cfg_type, "gre-key-len");
+cmdline_parse_token_num_t cmd_global_config_gre_key_len =
+	TOKEN_NUM_INITIALIZER(struct cmd_global_config_result,
+		len, UINT8);
+
+cmdline_parse_inst_t cmd_global_config = {
+	.f = cmd_global_config_parsed,
+	.data = (void *)NULL,
+	.help_str = "global_config <port_id> gre-key-len <key_len>",
+	.tokens = {
+		(void *)&cmd_global_config_cmd,
+		(void *)&cmd_global_config_port_id,
+		(void *)&cmd_global_config_type,
+		(void *)&cmd_global_config_gre_key_len,
+		NULL,
+	},
+};
+
+/* *** CONFIGURE VM MIRROR VLAN/POOL RULE *** */
+struct cmd_set_mirror_mask_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t mirror;
+	uint8_t rule_id;
+	cmdline_fixed_string_t what;
+	cmdline_fixed_string_t value;
+	cmdline_fixed_string_t dstpool;
+	uint8_t dstpool_id;
+	cmdline_fixed_string_t on;
+};
+
+cmdline_parse_token_string_t cmd_mirror_mask_set =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_mask_result,
+				set, "set");
+cmdline_parse_token_string_t cmd_mirror_mask_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_mask_result,
+				port, "port");
+cmdline_parse_token_num_t cmd_mirror_mask_portid =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_mirror_mask_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_mirror_mask_mirror =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_mask_result,
+				mirror, "mirror-rule");
+cmdline_parse_token_num_t cmd_mirror_mask_ruleid =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_mirror_mask_result,
+				rule_id, UINT8);
+cmdline_parse_token_string_t cmd_mirror_mask_what =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_mask_result,
+				what, "pool-mirror-up#pool-mirror-down"
+				      "#vlan-mirror");
+cmdline_parse_token_string_t cmd_mirror_mask_value =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_mask_result,
+				value, NULL);
+cmdline_parse_token_string_t cmd_mirror_mask_dstpool =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_mask_result,
+				dstpool, "dst-pool");
+cmdline_parse_token_num_t cmd_mirror_mask_poolid =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_mirror_mask_result,
+				dstpool_id, UINT8);
+cmdline_parse_token_string_t cmd_mirror_mask_on =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_mask_result,
+				on, "on#off");
+
+static void
+cmd_set_mirror_mask_parsed(void *parsed_result,
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
+{
+	int ret,nb_item,i;
+	struct cmd_set_mirror_mask_result *res = parsed_result;
+	struct rte_eth_mirror_conf mr_conf;
+
+	memset(&mr_conf, 0, sizeof(struct rte_eth_mirror_conf));
+
+	unsigned int vlan_list[ETH_MIRROR_MAX_VLANS];
+
+	mr_conf.dst_pool = res->dstpool_id;
+
+	if (!strcmp(res->what, "pool-mirror-up")) {
+		mr_conf.pool_mask = strtoull(res->value, NULL, 16);
+		mr_conf.rule_type = ETH_MIRROR_VIRTUAL_POOL_UP;
+	} else if (!strcmp(res->what, "pool-mirror-down")) {
+		mr_conf.pool_mask = strtoull(res->value, NULL, 16);
+		mr_conf.rule_type = ETH_MIRROR_VIRTUAL_POOL_DOWN;
+	} else if (!strcmp(res->what, "vlan-mirror")) {
+		mr_conf.rule_type = ETH_MIRROR_VLAN;
+		nb_item = parse_item_list(res->value, "vlan",
+				ETH_MIRROR_MAX_VLANS, vlan_list, 1);
+		if (nb_item <= 0)
+			return;
+
+		for (i = 0; i < nb_item; i++) {
+			if (vlan_list[i] > RTE_ETHER_MAX_VLAN_ID) {
+				printf("Invalid vlan_id: must be < 4096\n");
+				return;
+			}
+
+			mr_conf.vlan.vlan_id[i] = (uint16_t)vlan_list[i];
+			mr_conf.vlan.vlan_mask |= 1ULL << i;
+		}
+	}
+
+	if (!strcmp(res->on, "on"))
+		ret = rte_eth_mirror_rule_set(res->port_id, &mr_conf,
+						res->rule_id, 1);
+	else
+		ret = rte_eth_mirror_rule_set(res->port_id, &mr_conf,
+						res->rule_id, 0);
+	if (ret < 0)
+		printf("mirror rule add error: (%s)\n", strerror(-ret));
+}
+
+cmdline_parse_inst_t cmd_set_mirror_mask = {
+		.f = cmd_set_mirror_mask_parsed,
+		.data = NULL,
+		.help_str = "set port <port_id> mirror-rule <rule_id> "
+			"pool-mirror-up|pool-mirror-down|vlan-mirror "
+			"<pool_mask|vlan_id[,vlan_id]*> dst-pool <pool_id> on|off",
+		.tokens = {
+			(void *)&cmd_mirror_mask_set,
+			(void *)&cmd_mirror_mask_port,
+			(void *)&cmd_mirror_mask_portid,
+			(void *)&cmd_mirror_mask_mirror,
+			(void *)&cmd_mirror_mask_ruleid,
+			(void *)&cmd_mirror_mask_what,
+			(void *)&cmd_mirror_mask_value,
+			(void *)&cmd_mirror_mask_dstpool,
+			(void *)&cmd_mirror_mask_poolid,
+			(void *)&cmd_mirror_mask_on,
+			NULL,
+		},
+};
+
+/* *** CONFIGURE VM MIRROR UPLINK/DOWNLINK RULE *** */
+struct cmd_set_mirror_link_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t mirror;
+	uint8_t rule_id;
+	cmdline_fixed_string_t what;
+	cmdline_fixed_string_t dstpool;
+	uint8_t dstpool_id;
+	cmdline_fixed_string_t on;
+};
+
+cmdline_parse_token_string_t cmd_mirror_link_set =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_link_result,
+				 set, "set");
+cmdline_parse_token_string_t cmd_mirror_link_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_link_result,
+				port, "port");
+cmdline_parse_token_num_t cmd_mirror_link_portid =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_mirror_link_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_mirror_link_mirror =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_link_result,
+				mirror, "mirror-rule");
+cmdline_parse_token_num_t cmd_mirror_link_ruleid =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_mirror_link_result,
+			    rule_id, UINT8);
+cmdline_parse_token_string_t cmd_mirror_link_what =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_link_result,
+				what, "uplink-mirror#downlink-mirror");
+cmdline_parse_token_string_t cmd_mirror_link_dstpool =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_link_result,
+				dstpool, "dst-pool");
+cmdline_parse_token_num_t cmd_mirror_link_poolid =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_mirror_link_result,
+				dstpool_id, UINT8);
+cmdline_parse_token_string_t cmd_mirror_link_on =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_mirror_link_result,
+				on, "on#off");
+
+static void
+cmd_set_mirror_link_parsed(void *parsed_result,
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
+{
+	int ret;
+	struct cmd_set_mirror_link_result *res = parsed_result;
+	struct rte_eth_mirror_conf mr_conf;
+
+	memset(&mr_conf, 0, sizeof(struct rte_eth_mirror_conf));
+	if (!strcmp(res->what, "uplink-mirror"))
+		mr_conf.rule_type = ETH_MIRROR_UPLINK_PORT;
+	else
+		mr_conf.rule_type = ETH_MIRROR_DOWNLINK_PORT;
+
+	mr_conf.dst_pool = res->dstpool_id;
+
+	if (!strcmp(res->on, "on"))
+		ret = rte_eth_mirror_rule_set(res->port_id, &mr_conf,
+						res->rule_id, 1);
+	else
+		ret = rte_eth_mirror_rule_set(res->port_id, &mr_conf,
+						res->rule_id, 0);
+
+	/* check the return value and print it if is < 0 */
+	if (ret < 0)
+		printf("mirror rule add error: (%s)\n", strerror(-ret));
+
+}
+
+cmdline_parse_inst_t cmd_set_mirror_link = {
+		.f = cmd_set_mirror_link_parsed,
+		.data = NULL,
+		.help_str = "set port <port_id> mirror-rule <rule_id> "
+			"uplink-mirror|downlink-mirror dst-pool <pool_id> on|off",
+		.tokens = {
+			(void *)&cmd_mirror_link_set,
+			(void *)&cmd_mirror_link_port,
+			(void *)&cmd_mirror_link_portid,
+			(void *)&cmd_mirror_link_mirror,
+			(void *)&cmd_mirror_link_ruleid,
+			(void *)&cmd_mirror_link_what,
+			(void *)&cmd_mirror_link_dstpool,
+			(void *)&cmd_mirror_link_poolid,
+			(void *)&cmd_mirror_link_on,
+			NULL,
+		},
+};
+
+/* *** RESET VM MIRROR RULE *** */
+struct cmd_rm_mirror_rule_result {
+	cmdline_fixed_string_t reset;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t mirror;
+	uint8_t rule_id;
+};
+
+cmdline_parse_token_string_t cmd_rm_mirror_rule_reset =
+	TOKEN_STRING_INITIALIZER(struct cmd_rm_mirror_rule_result,
+				 reset, "reset");
+cmdline_parse_token_string_t cmd_rm_mirror_rule_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_rm_mirror_rule_result,
+				port, "port");
+cmdline_parse_token_num_t cmd_rm_mirror_rule_portid =
+	TOKEN_NUM_INITIALIZER(struct cmd_rm_mirror_rule_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_rm_mirror_rule_mirror =
+	TOKEN_STRING_INITIALIZER(struct cmd_rm_mirror_rule_result,
+				mirror, "mirror-rule");
+cmdline_parse_token_num_t cmd_rm_mirror_rule_ruleid =
+	TOKEN_NUM_INITIALIZER(struct cmd_rm_mirror_rule_result,
+				rule_id, UINT8);
+
+static void
+cmd_reset_mirror_rule_parsed(void *parsed_result,
+		       __attribute__((unused)) struct cmdline *cl,
+		       __attribute__((unused)) void *data)
+{
+	int ret;
+	struct cmd_set_mirror_link_result *res = parsed_result;
+        /* check rule_id */
+	ret = rte_eth_mirror_rule_reset(res->port_id,res->rule_id);
+	if(ret < 0)
+		printf("mirror rule remove error: (%s)\n", strerror(-ret));
+}
+
+cmdline_parse_inst_t cmd_reset_mirror_rule = {
+		.f = cmd_reset_mirror_rule_parsed,
+		.data = NULL,
+		.help_str = "reset port <port_id> mirror-rule <rule_id>",
+		.tokens = {
+			(void *)&cmd_rm_mirror_rule_reset,
+			(void *)&cmd_rm_mirror_rule_port,
+			(void *)&cmd_rm_mirror_rule_portid,
+			(void *)&cmd_rm_mirror_rule_mirror,
+			(void *)&cmd_rm_mirror_rule_ruleid,
+			NULL,
+		},
+};
+
 /* ******************************************************************************** */
 
 struct cmd_dump_result {
@@ -8275,66 +9555,14 @@
 #undef DUMP_SIZE
 }
 
-
-/* Dump the socket memory statistics on console */
-static void
-dump_socket_mem(FILE *f)
-{
-	struct rte_malloc_socket_stats socket_stats;
-	unsigned int i;
-	size_t total = 0;
-	size_t alloc = 0;
-	size_t free = 0;
-	unsigned int n_alloc = 0;
-	unsigned int n_free = 0;
-	static size_t last_allocs;
-	static size_t last_total;
-
-
-	for (i = 0; i < RTE_MAX_NUMA_NODES; i++) {
-		if (rte_malloc_get_socket_stats(i, &socket_stats) ||
-		    !socket_stats.heap_totalsz_bytes)
-			continue;
-		total += socket_stats.heap_totalsz_bytes;
-		alloc += socket_stats.heap_allocsz_bytes;
-		free += socket_stats.heap_freesz_bytes;
-		n_alloc += socket_stats.alloc_count;
-		n_free += socket_stats.free_count;
-		fprintf(f,
-			"Socket %u: size(M) total: %.6lf alloc: %.6lf(%.3lf%%) free: %.6lf \tcount alloc: %-4u free: %u\n",
-			i,
-			(double)socket_stats.heap_totalsz_bytes / (1024 * 1024),
-			(double)socket_stats.heap_allocsz_bytes / (1024 * 1024),
-			(double)socket_stats.heap_allocsz_bytes * 100 /
-			(double)socket_stats.heap_totalsz_bytes,
-			(double)socket_stats.heap_freesz_bytes / (1024 * 1024),
-			socket_stats.alloc_count,
-			socket_stats.free_count);
-	}
-	fprintf(f,
-		"Total   : size(M) total: %.6lf alloc: %.6lf(%.3lf%%) free: %.6lf \tcount alloc: %-4u free: %u\n",
-		(double)total / (1024 * 1024), (double)alloc / (1024 * 1024),
-		total ? ((double)alloc * 100 / (double)total) : 0,
-		(double)free / (1024 * 1024),
-		n_alloc, n_free);
-	if (last_allocs)
-		fprintf(stdout, "Memory total change: %.6lf(M), allocation change: %.6lf(M)\n",
-			((double)total - (double)last_total) / (1024 * 1024),
-			(double)(alloc - (double)last_allocs) / 1024 / 1024);
-	last_allocs = alloc;
-	last_total = total;
-}
-
 static void cmd_dump_parsed(void *parsed_result,
-			    __rte_unused struct cmdline *cl,
-			    __rte_unused void *data)
+			    __attribute__((unused)) struct cmdline *cl,
+			    __attribute__((unused)) void *data)
 {
 	struct cmd_dump_result *res = parsed_result;
 
 	if (!strcmp(res->dump, "dump_physmem"))
 		rte_dump_physmem_layout(stdout);
-	else if (!strcmp(res->dump, "dump_socket_mem"))
-		dump_socket_mem(stdout);
 	else if (!strcmp(res->dump, "dump_memzone"))
 		rte_memzone_dump(stdout);
 	else if (!strcmp(res->dump, "dump_struct_sizes"))
@@ -8349,18 +9577,17 @@
 		rte_log_dump(stdout);
 }
 
-static cmdline_parse_token_string_t cmd_dump_dump =
+cmdline_parse_token_string_t cmd_dump_dump =
 	TOKEN_STRING_INITIALIZER(struct cmd_dump_result, dump,
 		"dump_physmem#"
 		"dump_memzone#"
-		"dump_socket_mem#"
 		"dump_struct_sizes#"
 		"dump_ring#"
 		"dump_mempool#"
 		"dump_devargs#"
 		"dump_log_types");
 
-static cmdline_parse_inst_t cmd_dump = {
+cmdline_parse_inst_t cmd_dump = {
 	.f = cmd_dump_parsed,  /* function to call */
 	.data = NULL,      /* 2nd arg of func */
 	.help_str = "Dump status",
@@ -8378,7 +9605,7 @@
 };
 
 static void cmd_dump_one_parsed(void *parsed_result, struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) void *data)
 {
 	struct cmd_dump_one_result *res = parsed_result;
 
@@ -8401,14 +9628,14 @@
 	}
 }
 
-static cmdline_parse_token_string_t cmd_dump_one_dump =
+cmdline_parse_token_string_t cmd_dump_one_dump =
 	TOKEN_STRING_INITIALIZER(struct cmd_dump_one_result, dump,
 				 "dump_ring#dump_mempool");
 
-static cmdline_parse_token_string_t cmd_dump_one_name =
+cmdline_parse_token_string_t cmd_dump_one_name =
 	TOKEN_STRING_INITIALIZER(struct cmd_dump_one_result, name, NULL);
 
-static cmdline_parse_inst_t cmd_dump_one = {
+cmdline_parse_inst_t cmd_dump_one = {
 	.f = cmd_dump_one_parsed,  /* function to call */
 	.data = NULL,      /* 2nd arg of func */
 	.help_str = "dump_ring|dump_mempool <name>: Dump one ring/mempool",
@@ -8419,14 +9646,1336 @@
 	},
 };
 
+/* *** Add/Del syn filter *** */
+struct cmd_syn_filter_result {
+	cmdline_fixed_string_t filter;
+	portid_t port_id;
+	cmdline_fixed_string_t ops;
+	cmdline_fixed_string_t priority;
+	cmdline_fixed_string_t high;
+	cmdline_fixed_string_t queue;
+	uint16_t queue_id;
+};
+
+static void
+cmd_syn_filter_parsed(void *parsed_result,
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
+{
+	struct cmd_syn_filter_result *res = parsed_result;
+	struct rte_eth_syn_filter syn_filter;
+	int ret = 0;
+
+	ret = rte_eth_dev_filter_supported(res->port_id,
+					RTE_ETH_FILTER_SYN);
+	if (ret < 0) {
+		printf("syn filter is not supported on port %u.\n",
+				res->port_id);
+		return;
+	}
+
+	memset(&syn_filter, 0, sizeof(syn_filter));
+
+	if (!strcmp(res->ops, "add")) {
+		if (!strcmp(res->high, "high"))
+			syn_filter.hig_pri = 1;
+		else
+			syn_filter.hig_pri = 0;
+
+		syn_filter.queue = res->queue_id;
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+						RTE_ETH_FILTER_SYN,
+						RTE_ETH_FILTER_ADD,
+						&syn_filter);
+	} else
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+						RTE_ETH_FILTER_SYN,
+						RTE_ETH_FILTER_DELETE,
+						&syn_filter);
+
+	if (ret < 0)
+		printf("syn filter programming error: (%s)\n",
+				strerror(-ret));
+}
+
+cmdline_parse_token_string_t cmd_syn_filter_filter =
+	TOKEN_STRING_INITIALIZER(struct cmd_syn_filter_result,
+	filter, "syn_filter");
+cmdline_parse_token_num_t cmd_syn_filter_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_syn_filter_result,
+	port_id, UINT16);
+cmdline_parse_token_string_t cmd_syn_filter_ops =
+	TOKEN_STRING_INITIALIZER(struct cmd_syn_filter_result,
+	ops, "add#del");
+cmdline_parse_token_string_t cmd_syn_filter_priority =
+	TOKEN_STRING_INITIALIZER(struct cmd_syn_filter_result,
+				priority, "priority");
+cmdline_parse_token_string_t cmd_syn_filter_high =
+	TOKEN_STRING_INITIALIZER(struct cmd_syn_filter_result,
+				high, "high#low");
+cmdline_parse_token_string_t cmd_syn_filter_queue =
+	TOKEN_STRING_INITIALIZER(struct cmd_syn_filter_result,
+				queue, "queue");
+cmdline_parse_token_num_t cmd_syn_filter_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_syn_filter_result,
+				queue_id, UINT16);
+
+cmdline_parse_inst_t cmd_syn_filter = {
+	.f = cmd_syn_filter_parsed,
+	.data = NULL,
+	.help_str = "syn_filter <port_id> add|del priority high|low queue "
+		"<queue_id>: Add/Delete syn filter",
+	.tokens = {
+		(void *)&cmd_syn_filter_filter,
+		(void *)&cmd_syn_filter_port_id,
+		(void *)&cmd_syn_filter_ops,
+		(void *)&cmd_syn_filter_priority,
+		(void *)&cmd_syn_filter_high,
+		(void *)&cmd_syn_filter_queue,
+		(void *)&cmd_syn_filter_queue_id,
+		NULL,
+	},
+};
+
+/* *** queue region set *** */
+struct cmd_queue_region_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t cmd;
+	cmdline_fixed_string_t region;
+	uint8_t  region_id;
+	cmdline_fixed_string_t queue_start_index;
+	uint8_t  queue_id;
+	cmdline_fixed_string_t queue_num;
+	uint8_t  queue_num_value;
+};
+
+static void
+cmd_queue_region_parsed(void *parsed_result,
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
+{
+	struct cmd_queue_region_result *res = parsed_result;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct rte_pmd_i40e_queue_region_conf region_conf;
+	enum rte_pmd_i40e_queue_region_op op_type;
+#endif
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	memset(&region_conf, 0, sizeof(region_conf));
+	op_type = RTE_PMD_I40E_RSS_QUEUE_REGION_SET;
+	region_conf.region_id = res->region_id;
+	region_conf.queue_num = res->queue_num_value;
+	region_conf.queue_start_index = res->queue_id;
+
+	ret = rte_pmd_i40e_rss_queue_region_conf(res->port_id,
+				op_type, &region_conf);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENOTSUP:
+		printf("function not implemented or supported\n");
+		break;
+	default:
+		printf("queue region config error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_token_string_t cmd_queue_region_set =
+TOKEN_STRING_INITIALIZER(struct cmd_queue_region_result,
+		set, "set");
+cmdline_parse_token_string_t cmd_queue_region_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_queue_region_result, port, "port");
+cmdline_parse_token_num_t cmd_queue_region_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_queue_region_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_queue_region_cmd =
+	TOKEN_STRING_INITIALIZER(struct cmd_queue_region_result,
+				 cmd, "queue-region");
+cmdline_parse_token_string_t cmd_queue_region_id =
+	TOKEN_STRING_INITIALIZER(struct cmd_queue_region_result,
+				region, "region_id");
+cmdline_parse_token_num_t cmd_queue_region_index =
+	TOKEN_NUM_INITIALIZER(struct cmd_queue_region_result,
+				region_id, UINT8);
+cmdline_parse_token_string_t cmd_queue_region_queue_start_index =
+	TOKEN_STRING_INITIALIZER(struct cmd_queue_region_result,
+				queue_start_index, "queue_start_index");
+cmdline_parse_token_num_t cmd_queue_region_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_queue_region_result,
+				queue_id, UINT8);
+cmdline_parse_token_string_t cmd_queue_region_queue_num =
+	TOKEN_STRING_INITIALIZER(struct cmd_queue_region_result,
+				queue_num, "queue_num");
+cmdline_parse_token_num_t cmd_queue_region_queue_num_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_queue_region_result,
+				queue_num_value, UINT8);
+
+cmdline_parse_inst_t cmd_queue_region = {
+	.f = cmd_queue_region_parsed,
+	.data = NULL,
+	.help_str = "set port <port_id> queue-region region_id <value> "
+		"queue_start_index <value> queue_num <value>: Set a queue region",
+	.tokens = {
+		(void *)&cmd_queue_region_set,
+		(void *)&cmd_queue_region_port,
+		(void *)&cmd_queue_region_port_id,
+		(void *)&cmd_queue_region_cmd,
+		(void *)&cmd_queue_region_id,
+		(void *)&cmd_queue_region_index,
+		(void *)&cmd_queue_region_queue_start_index,
+		(void *)&cmd_queue_region_queue_id,
+		(void *)&cmd_queue_region_queue_num,
+		(void *)&cmd_queue_region_queue_num_value,
+		NULL,
+	},
+};
+
+/* *** queue region and flowtype set *** */
+struct cmd_region_flowtype_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t cmd;
+	cmdline_fixed_string_t region;
+	uint8_t  region_id;
+	cmdline_fixed_string_t flowtype;
+	uint8_t  flowtype_id;
+};
+
+static void
+cmd_region_flowtype_parsed(void *parsed_result,
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
+{
+	struct cmd_region_flowtype_result *res = parsed_result;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct rte_pmd_i40e_queue_region_conf region_conf;
+	enum rte_pmd_i40e_queue_region_op op_type;
+#endif
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	memset(&region_conf, 0, sizeof(region_conf));
+
+	op_type = RTE_PMD_I40E_RSS_QUEUE_REGION_FLOWTYPE_SET;
+	region_conf.region_id = res->region_id;
+	region_conf.hw_flowtype = res->flowtype_id;
+
+	ret = rte_pmd_i40e_rss_queue_region_conf(res->port_id,
+			op_type, &region_conf);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENOTSUP:
+		printf("function not implemented or supported\n");
+		break;
+	default:
+		printf("region flowtype config error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_token_string_t cmd_region_flowtype_set =
+TOKEN_STRING_INITIALIZER(struct cmd_region_flowtype_result,
+				set, "set");
+cmdline_parse_token_string_t cmd_region_flowtype_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_region_flowtype_result,
+				port, "port");
+cmdline_parse_token_num_t cmd_region_flowtype_port_index =
+	TOKEN_NUM_INITIALIZER(struct cmd_region_flowtype_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_region_flowtype_cmd =
+	TOKEN_STRING_INITIALIZER(struct cmd_region_flowtype_result,
+				cmd, "queue-region");
+cmdline_parse_token_string_t cmd_region_flowtype_index =
+	TOKEN_STRING_INITIALIZER(struct cmd_region_flowtype_result,
+				region, "region_id");
+cmdline_parse_token_num_t cmd_region_flowtype_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_region_flowtype_result,
+				region_id, UINT8);
+cmdline_parse_token_string_t cmd_region_flowtype_flow_index =
+	TOKEN_STRING_INITIALIZER(struct cmd_region_flowtype_result,
+				flowtype, "flowtype");
+cmdline_parse_token_num_t cmd_region_flowtype_flow_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_region_flowtype_result,
+				flowtype_id, UINT8);
+cmdline_parse_inst_t cmd_region_flowtype = {
+	.f = cmd_region_flowtype_parsed,
+	.data = NULL,
+	.help_str = "set port <port_id> queue-region region_id <value> "
+		"flowtype <value>: Set a flowtype region index",
+	.tokens = {
+		(void *)&cmd_region_flowtype_set,
+		(void *)&cmd_region_flowtype_port,
+		(void *)&cmd_region_flowtype_port_index,
+		(void *)&cmd_region_flowtype_cmd,
+		(void *)&cmd_region_flowtype_index,
+		(void *)&cmd_region_flowtype_id,
+		(void *)&cmd_region_flowtype_flow_index,
+		(void *)&cmd_region_flowtype_flow_id,
+		NULL,
+	},
+};
+
+/* *** User Priority (UP) to queue region (region_id) set *** */
+struct cmd_user_priority_region_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t cmd;
+	cmdline_fixed_string_t user_priority;
+	uint8_t  user_priority_id;
+	cmdline_fixed_string_t region;
+	uint8_t  region_id;
+};
+
+static void
+cmd_user_priority_region_parsed(void *parsed_result,
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
+{
+	struct cmd_user_priority_region_result *res = parsed_result;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct rte_pmd_i40e_queue_region_conf region_conf;
+	enum rte_pmd_i40e_queue_region_op op_type;
+#endif
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	memset(&region_conf, 0, sizeof(region_conf));
+	op_type = RTE_PMD_I40E_RSS_QUEUE_REGION_USER_PRIORITY_SET;
+	region_conf.user_priority = res->user_priority_id;
+	region_conf.region_id = res->region_id;
+
+	ret = rte_pmd_i40e_rss_queue_region_conf(res->port_id,
+				op_type, &region_conf);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENOTSUP:
+		printf("function not implemented or supported\n");
+		break;
+	default:
+		printf("user_priority region config error: (%s)\n",
+				strerror(-ret));
+	}
+}
+
+cmdline_parse_token_string_t cmd_user_priority_region_set =
+	TOKEN_STRING_INITIALIZER(struct cmd_user_priority_region_result,
+				set, "set");
+cmdline_parse_token_string_t cmd_user_priority_region_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_user_priority_region_result,
+				port, "port");
+cmdline_parse_token_num_t cmd_user_priority_region_port_index =
+	TOKEN_NUM_INITIALIZER(struct cmd_user_priority_region_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_user_priority_region_cmd =
+	TOKEN_STRING_INITIALIZER(struct cmd_user_priority_region_result,
+				cmd, "queue-region");
+cmdline_parse_token_string_t cmd_user_priority_region_UP =
+	TOKEN_STRING_INITIALIZER(struct cmd_user_priority_region_result,
+				user_priority, "UP");
+cmdline_parse_token_num_t cmd_user_priority_region_UP_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_user_priority_region_result,
+				user_priority_id, UINT8);
+cmdline_parse_token_string_t cmd_user_priority_region_region =
+	TOKEN_STRING_INITIALIZER(struct cmd_user_priority_region_result,
+				region, "region_id");
+cmdline_parse_token_num_t cmd_user_priority_region_region_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_user_priority_region_result,
+				region_id, UINT8);
+
+cmdline_parse_inst_t cmd_user_priority_region = {
+	.f = cmd_user_priority_region_parsed,
+	.data = NULL,
+	.help_str = "set port <port_id> queue-region UP <value> "
+		"region_id <value>: Set the mapping of User Priority (UP) "
+		"to queue region (region_id) ",
+	.tokens = {
+		(void *)&cmd_user_priority_region_set,
+		(void *)&cmd_user_priority_region_port,
+		(void *)&cmd_user_priority_region_port_index,
+		(void *)&cmd_user_priority_region_cmd,
+		(void *)&cmd_user_priority_region_UP,
+		(void *)&cmd_user_priority_region_UP_id,
+		(void *)&cmd_user_priority_region_region,
+		(void *)&cmd_user_priority_region_region_id,
+		NULL,
+	},
+};
+
+/* *** flush all queue region related configuration *** */
+struct cmd_flush_queue_region_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t cmd;
+	cmdline_fixed_string_t flush;
+	cmdline_fixed_string_t what;
+};
+
+static void
+cmd_flush_queue_region_parsed(void *parsed_result,
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
+{
+	struct cmd_flush_queue_region_result *res = parsed_result;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct rte_pmd_i40e_queue_region_conf region_conf;
+	enum rte_pmd_i40e_queue_region_op op_type;
+#endif
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	memset(&region_conf, 0, sizeof(region_conf));
+
+	if (strcmp(res->what, "on") == 0)
+		op_type = RTE_PMD_I40E_RSS_QUEUE_REGION_ALL_FLUSH_ON;
+	else
+		op_type = RTE_PMD_I40E_RSS_QUEUE_REGION_ALL_FLUSH_OFF;
+
+	ret = rte_pmd_i40e_rss_queue_region_conf(res->port_id,
+				op_type, &region_conf);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENOTSUP:
+		printf("function not implemented or supported\n");
+		break;
+	default:
+		printf("queue region config flush error: (%s)\n",
+				strerror(-ret));
+	}
+}
+
+cmdline_parse_token_string_t cmd_flush_queue_region_set =
+	TOKEN_STRING_INITIALIZER(struct cmd_flush_queue_region_result,
+				set, "set");
+cmdline_parse_token_string_t cmd_flush_queue_region_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_flush_queue_region_result,
+				port, "port");
+cmdline_parse_token_num_t cmd_flush_queue_region_port_index =
+	TOKEN_NUM_INITIALIZER(struct cmd_flush_queue_region_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_flush_queue_region_cmd =
+	TOKEN_STRING_INITIALIZER(struct cmd_flush_queue_region_result,
+				cmd, "queue-region");
+cmdline_parse_token_string_t cmd_flush_queue_region_flush =
+	TOKEN_STRING_INITIALIZER(struct cmd_flush_queue_region_result,
+				flush, "flush");
+cmdline_parse_token_string_t cmd_flush_queue_region_what =
+	TOKEN_STRING_INITIALIZER(struct cmd_flush_queue_region_result,
+				what, "on#off");
+
+cmdline_parse_inst_t cmd_flush_queue_region = {
+	.f = cmd_flush_queue_region_parsed,
+	.data = NULL,
+	.help_str = "set port <port_id> queue-region flush on|off"
+		": flush all queue region related configuration",
+	.tokens = {
+		(void *)&cmd_flush_queue_region_set,
+		(void *)&cmd_flush_queue_region_port,
+		(void *)&cmd_flush_queue_region_port_index,
+		(void *)&cmd_flush_queue_region_cmd,
+		(void *)&cmd_flush_queue_region_flush,
+		(void *)&cmd_flush_queue_region_what,
+		NULL,
+	},
+};
+
+/* *** get all queue region related configuration info *** */
+struct cmd_show_queue_region_info {
+	cmdline_fixed_string_t show;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t cmd;
+};
+
+static void
+cmd_show_queue_region_info_parsed(void *parsed_result,
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
+{
+	struct cmd_show_queue_region_info *res = parsed_result;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct rte_pmd_i40e_queue_regions rte_pmd_regions;
+	enum rte_pmd_i40e_queue_region_op op_type;
+#endif
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	memset(&rte_pmd_regions, 0, sizeof(rte_pmd_regions));
+
+	op_type = RTE_PMD_I40E_RSS_QUEUE_REGION_INFO_GET;
+
+	ret = rte_pmd_i40e_rss_queue_region_conf(res->port_id,
+					op_type, &rte_pmd_regions);
+
+	port_queue_region_info_display(res->port_id, &rte_pmd_regions);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENOTSUP:
+		printf("function not implemented or supported\n");
+		break;
+	default:
+		printf("queue region config info show error: (%s)\n",
+				strerror(-ret));
+	}
+}
+
+cmdline_parse_token_string_t cmd_show_queue_region_info_get =
+TOKEN_STRING_INITIALIZER(struct cmd_show_queue_region_info,
+				show, "show");
+cmdline_parse_token_string_t cmd_show_queue_region_info_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_show_queue_region_info,
+				port, "port");
+cmdline_parse_token_num_t cmd_show_queue_region_info_port_index =
+	TOKEN_NUM_INITIALIZER(struct cmd_show_queue_region_info,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_show_queue_region_info_cmd =
+	TOKEN_STRING_INITIALIZER(struct cmd_show_queue_region_info,
+				cmd, "queue-region");
+
+cmdline_parse_inst_t cmd_show_queue_region_info_all = {
+	.f = cmd_show_queue_region_info_parsed,
+	.data = NULL,
+	.help_str = "show port <port_id> queue-region"
+		": show all queue region related configuration info",
+	.tokens = {
+		(void *)&cmd_show_queue_region_info_get,
+		(void *)&cmd_show_queue_region_info_port,
+		(void *)&cmd_show_queue_region_info_port_index,
+		(void *)&cmd_show_queue_region_info_cmd,
+		NULL,
+	},
+};
+
+/* *** ADD/REMOVE A 2tuple FILTER *** */
+struct cmd_2tuple_filter_result {
+	cmdline_fixed_string_t filter;
+	portid_t port_id;
+	cmdline_fixed_string_t ops;
+	cmdline_fixed_string_t dst_port;
+	uint16_t dst_port_value;
+	cmdline_fixed_string_t protocol;
+	uint8_t protocol_value;
+	cmdline_fixed_string_t mask;
+	uint8_t  mask_value;
+	cmdline_fixed_string_t tcp_flags;
+	uint8_t tcp_flags_value;
+	cmdline_fixed_string_t priority;
+	uint8_t  priority_value;
+	cmdline_fixed_string_t queue;
+	uint16_t  queue_id;
+};
+
+static void
+cmd_2tuple_filter_parsed(void *parsed_result,
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
+{
+	struct rte_eth_ntuple_filter filter;
+	struct cmd_2tuple_filter_result *res = parsed_result;
+	int ret = 0;
+
+	ret = rte_eth_dev_filter_supported(res->port_id, RTE_ETH_FILTER_NTUPLE);
+	if (ret < 0) {
+		printf("ntuple filter is not supported on port %u.\n",
+			res->port_id);
+		return;
+	}
+
+	memset(&filter, 0, sizeof(struct rte_eth_ntuple_filter));
+
+	filter.flags = RTE_2TUPLE_FLAGS;
+	filter.dst_port_mask = (res->mask_value & 0x02) ? UINT16_MAX : 0;
+	filter.proto_mask = (res->mask_value & 0x01) ? UINT8_MAX : 0;
+	filter.proto = res->protocol_value;
+	filter.priority = res->priority_value;
+	if (res->tcp_flags_value != 0 && filter.proto != IPPROTO_TCP) {
+		printf("nonzero tcp_flags is only meaningful"
+			" when protocol is TCP.\n");
+		return;
+	}
+	if (res->tcp_flags_value > RTE_NTUPLE_TCP_FLAGS_MASK) {
+		printf("invalid TCP flags.\n");
+		return;
+	}
+
+	if (res->tcp_flags_value != 0) {
+		filter.flags |= RTE_NTUPLE_FLAGS_TCP_FLAG;
+		filter.tcp_flags = res->tcp_flags_value;
+	}
+
+	/* need convert to big endian. */
+	filter.dst_port = rte_cpu_to_be_16(res->dst_port_value);
+	filter.queue = res->queue_id;
+
+	if (!strcmp(res->ops, "add"))
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+				RTE_ETH_FILTER_NTUPLE,
+				RTE_ETH_FILTER_ADD,
+				&filter);
+	else
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+				RTE_ETH_FILTER_NTUPLE,
+				RTE_ETH_FILTER_DELETE,
+				&filter);
+	if (ret < 0)
+		printf("2tuple filter programming error: (%s)\n",
+			strerror(-ret));
+
+}
+
+cmdline_parse_token_string_t cmd_2tuple_filter_filter =
+	TOKEN_STRING_INITIALIZER(struct cmd_2tuple_filter_result,
+				 filter, "2tuple_filter");
+cmdline_parse_token_num_t cmd_2tuple_filter_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_2tuple_filter_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_2tuple_filter_ops =
+	TOKEN_STRING_INITIALIZER(struct cmd_2tuple_filter_result,
+				 ops, "add#del");
+cmdline_parse_token_string_t cmd_2tuple_filter_dst_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_2tuple_filter_result,
+				dst_port, "dst_port");
+cmdline_parse_token_num_t cmd_2tuple_filter_dst_port_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_2tuple_filter_result,
+				dst_port_value, UINT16);
+cmdline_parse_token_string_t cmd_2tuple_filter_protocol =
+	TOKEN_STRING_INITIALIZER(struct cmd_2tuple_filter_result,
+				protocol, "protocol");
+cmdline_parse_token_num_t cmd_2tuple_filter_protocol_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_2tuple_filter_result,
+				protocol_value, UINT8);
+cmdline_parse_token_string_t cmd_2tuple_filter_mask =
+	TOKEN_STRING_INITIALIZER(struct cmd_2tuple_filter_result,
+				mask, "mask");
+cmdline_parse_token_num_t cmd_2tuple_filter_mask_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_2tuple_filter_result,
+				mask_value, INT8);
+cmdline_parse_token_string_t cmd_2tuple_filter_tcp_flags =
+	TOKEN_STRING_INITIALIZER(struct cmd_2tuple_filter_result,
+				tcp_flags, "tcp_flags");
+cmdline_parse_token_num_t cmd_2tuple_filter_tcp_flags_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_2tuple_filter_result,
+				tcp_flags_value, UINT8);
+cmdline_parse_token_string_t cmd_2tuple_filter_priority =
+	TOKEN_STRING_INITIALIZER(struct cmd_2tuple_filter_result,
+				priority, "priority");
+cmdline_parse_token_num_t cmd_2tuple_filter_priority_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_2tuple_filter_result,
+				priority_value, UINT8);
+cmdline_parse_token_string_t cmd_2tuple_filter_queue =
+	TOKEN_STRING_INITIALIZER(struct cmd_2tuple_filter_result,
+				queue, "queue");
+cmdline_parse_token_num_t cmd_2tuple_filter_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_2tuple_filter_result,
+				queue_id, UINT16);
+
+cmdline_parse_inst_t cmd_2tuple_filter = {
+	.f = cmd_2tuple_filter_parsed,
+	.data = NULL,
+	.help_str = "2tuple_filter <port_id> add|del dst_port <value> protocol "
+		"<value> mask <value> tcp_flags <value> priority <value> queue "
+		"<queue_id>: Add a 2tuple filter",
+	.tokens = {
+		(void *)&cmd_2tuple_filter_filter,
+		(void *)&cmd_2tuple_filter_port_id,
+		(void *)&cmd_2tuple_filter_ops,
+		(void *)&cmd_2tuple_filter_dst_port,
+		(void *)&cmd_2tuple_filter_dst_port_value,
+		(void *)&cmd_2tuple_filter_protocol,
+		(void *)&cmd_2tuple_filter_protocol_value,
+		(void *)&cmd_2tuple_filter_mask,
+		(void *)&cmd_2tuple_filter_mask_value,
+		(void *)&cmd_2tuple_filter_tcp_flags,
+		(void *)&cmd_2tuple_filter_tcp_flags_value,
+		(void *)&cmd_2tuple_filter_priority,
+		(void *)&cmd_2tuple_filter_priority_value,
+		(void *)&cmd_2tuple_filter_queue,
+		(void *)&cmd_2tuple_filter_queue_id,
+		NULL,
+	},
+};
+
+/* *** ADD/REMOVE A 5tuple FILTER *** */
+struct cmd_5tuple_filter_result {
+	cmdline_fixed_string_t filter;
+	portid_t port_id;
+	cmdline_fixed_string_t ops;
+	cmdline_fixed_string_t dst_ip;
+	cmdline_ipaddr_t dst_ip_value;
+	cmdline_fixed_string_t src_ip;
+	cmdline_ipaddr_t src_ip_value;
+	cmdline_fixed_string_t dst_port;
+	uint16_t dst_port_value;
+	cmdline_fixed_string_t src_port;
+	uint16_t src_port_value;
+	cmdline_fixed_string_t protocol;
+	uint8_t protocol_value;
+	cmdline_fixed_string_t mask;
+	uint8_t  mask_value;
+	cmdline_fixed_string_t tcp_flags;
+	uint8_t tcp_flags_value;
+	cmdline_fixed_string_t priority;
+	uint8_t  priority_value;
+	cmdline_fixed_string_t queue;
+	uint16_t  queue_id;
+};
+
+static void
+cmd_5tuple_filter_parsed(void *parsed_result,
+			__attribute__((unused)) struct cmdline *cl,
+			__attribute__((unused)) void *data)
+{
+	struct rte_eth_ntuple_filter filter;
+	struct cmd_5tuple_filter_result *res = parsed_result;
+	int ret = 0;
+
+	ret = rte_eth_dev_filter_supported(res->port_id, RTE_ETH_FILTER_NTUPLE);
+	if (ret < 0) {
+		printf("ntuple filter is not supported on port %u.\n",
+			res->port_id);
+		return;
+	}
+
+	memset(&filter, 0, sizeof(struct rte_eth_ntuple_filter));
+
+	filter.flags = RTE_5TUPLE_FLAGS;
+	filter.dst_ip_mask = (res->mask_value & 0x10) ? UINT32_MAX : 0;
+	filter.src_ip_mask = (res->mask_value & 0x08) ? UINT32_MAX : 0;
+	filter.dst_port_mask = (res->mask_value & 0x04) ? UINT16_MAX : 0;
+	filter.src_port_mask = (res->mask_value & 0x02) ? UINT16_MAX : 0;
+	filter.proto_mask = (res->mask_value & 0x01) ? UINT8_MAX : 0;
+	filter.proto = res->protocol_value;
+	filter.priority = res->priority_value;
+	if (res->tcp_flags_value != 0 && filter.proto != IPPROTO_TCP) {
+		printf("nonzero tcp_flags is only meaningful"
+			" when protocol is TCP.\n");
+		return;
+	}
+	if (res->tcp_flags_value > RTE_NTUPLE_TCP_FLAGS_MASK) {
+		printf("invalid TCP flags.\n");
+		return;
+	}
+
+	if (res->tcp_flags_value != 0) {
+		filter.flags |= RTE_NTUPLE_FLAGS_TCP_FLAG;
+		filter.tcp_flags = res->tcp_flags_value;
+	}
+
+	if (res->dst_ip_value.family == AF_INET)
+		/* no need to convert, already big endian. */
+		filter.dst_ip = res->dst_ip_value.addr.ipv4.s_addr;
+	else {
+		if (filter.dst_ip_mask == 0) {
+			printf("can not support ipv6 involved compare.\n");
+			return;
+		}
+		filter.dst_ip = 0;
+	}
+
+	if (res->src_ip_value.family == AF_INET)
+		/* no need to convert, already big endian. */
+		filter.src_ip = res->src_ip_value.addr.ipv4.s_addr;
+	else {
+		if (filter.src_ip_mask == 0) {
+			printf("can not support ipv6 involved compare.\n");
+			return;
+		}
+		filter.src_ip = 0;
+	}
+	/* need convert to big endian. */
+	filter.dst_port = rte_cpu_to_be_16(res->dst_port_value);
+	filter.src_port = rte_cpu_to_be_16(res->src_port_value);
+	filter.queue = res->queue_id;
+
+	if (!strcmp(res->ops, "add"))
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+				RTE_ETH_FILTER_NTUPLE,
+				RTE_ETH_FILTER_ADD,
+				&filter);
+	else
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+				RTE_ETH_FILTER_NTUPLE,
+				RTE_ETH_FILTER_DELETE,
+				&filter);
+	if (ret < 0)
+		printf("5tuple filter programming error: (%s)\n",
+			strerror(-ret));
+}
+
+cmdline_parse_token_string_t cmd_5tuple_filter_filter =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				 filter, "5tuple_filter");
+cmdline_parse_token_num_t cmd_5tuple_filter_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_5tuple_filter_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_5tuple_filter_ops =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				 ops, "add#del");
+cmdline_parse_token_string_t cmd_5tuple_filter_dst_ip =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				dst_ip, "dst_ip");
+cmdline_parse_token_ipaddr_t cmd_5tuple_filter_dst_ip_value =
+	TOKEN_IPADDR_INITIALIZER(struct cmd_5tuple_filter_result,
+				dst_ip_value);
+cmdline_parse_token_string_t cmd_5tuple_filter_src_ip =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				src_ip, "src_ip");
+cmdline_parse_token_ipaddr_t cmd_5tuple_filter_src_ip_value =
+	TOKEN_IPADDR_INITIALIZER(struct cmd_5tuple_filter_result,
+				src_ip_value);
+cmdline_parse_token_string_t cmd_5tuple_filter_dst_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				dst_port, "dst_port");
+cmdline_parse_token_num_t cmd_5tuple_filter_dst_port_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_5tuple_filter_result,
+				dst_port_value, UINT16);
+cmdline_parse_token_string_t cmd_5tuple_filter_src_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				src_port, "src_port");
+cmdline_parse_token_num_t cmd_5tuple_filter_src_port_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_5tuple_filter_result,
+				src_port_value, UINT16);
+cmdline_parse_token_string_t cmd_5tuple_filter_protocol =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				protocol, "protocol");
+cmdline_parse_token_num_t cmd_5tuple_filter_protocol_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_5tuple_filter_result,
+				protocol_value, UINT8);
+cmdline_parse_token_string_t cmd_5tuple_filter_mask =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				mask, "mask");
+cmdline_parse_token_num_t cmd_5tuple_filter_mask_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_5tuple_filter_result,
+				mask_value, INT8);
+cmdline_parse_token_string_t cmd_5tuple_filter_tcp_flags =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				tcp_flags, "tcp_flags");
+cmdline_parse_token_num_t cmd_5tuple_filter_tcp_flags_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_5tuple_filter_result,
+				tcp_flags_value, UINT8);
+cmdline_parse_token_string_t cmd_5tuple_filter_priority =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				priority, "priority");
+cmdline_parse_token_num_t cmd_5tuple_filter_priority_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_5tuple_filter_result,
+				priority_value, UINT8);
+cmdline_parse_token_string_t cmd_5tuple_filter_queue =
+	TOKEN_STRING_INITIALIZER(struct cmd_5tuple_filter_result,
+				queue, "queue");
+cmdline_parse_token_num_t cmd_5tuple_filter_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_5tuple_filter_result,
+				queue_id, UINT16);
+
+cmdline_parse_inst_t cmd_5tuple_filter = {
+	.f = cmd_5tuple_filter_parsed,
+	.data = NULL,
+	.help_str = "5tuple_filter <port_id> add|del dst_ip <value> "
+		"src_ip <value> dst_port <value> src_port <value> "
+		"protocol <value>  mask <value> tcp_flags <value> "
+		"priority <value> queue <queue_id>: Add/Del a 5tuple filter",
+	.tokens = {
+		(void *)&cmd_5tuple_filter_filter,
+		(void *)&cmd_5tuple_filter_port_id,
+		(void *)&cmd_5tuple_filter_ops,
+		(void *)&cmd_5tuple_filter_dst_ip,
+		(void *)&cmd_5tuple_filter_dst_ip_value,
+		(void *)&cmd_5tuple_filter_src_ip,
+		(void *)&cmd_5tuple_filter_src_ip_value,
+		(void *)&cmd_5tuple_filter_dst_port,
+		(void *)&cmd_5tuple_filter_dst_port_value,
+		(void *)&cmd_5tuple_filter_src_port,
+		(void *)&cmd_5tuple_filter_src_port_value,
+		(void *)&cmd_5tuple_filter_protocol,
+		(void *)&cmd_5tuple_filter_protocol_value,
+		(void *)&cmd_5tuple_filter_mask,
+		(void *)&cmd_5tuple_filter_mask_value,
+		(void *)&cmd_5tuple_filter_tcp_flags,
+		(void *)&cmd_5tuple_filter_tcp_flags_value,
+		(void *)&cmd_5tuple_filter_priority,
+		(void *)&cmd_5tuple_filter_priority_value,
+		(void *)&cmd_5tuple_filter_queue,
+		(void *)&cmd_5tuple_filter_queue_id,
+		NULL,
+	},
+};
+
+/* *** ADD/REMOVE A flex FILTER *** */
+struct cmd_flex_filter_result {
+	cmdline_fixed_string_t filter;
+	cmdline_fixed_string_t ops;
+	portid_t port_id;
+	cmdline_fixed_string_t len;
+	uint8_t len_value;
+	cmdline_fixed_string_t bytes;
+	cmdline_fixed_string_t bytes_value;
+	cmdline_fixed_string_t mask;
+	cmdline_fixed_string_t mask_value;
+	cmdline_fixed_string_t priority;
+	uint8_t priority_value;
+	cmdline_fixed_string_t queue;
+	uint16_t queue_id;
+};
+
+static int xdigit2val(unsigned char c)
+{
+	int val;
+	if (isdigit(c))
+		val = c - '0';
+	else if (isupper(c))
+		val = c - 'A' + 10;
+	else
+		val = c - 'a' + 10;
+	return val;
+}
+
+static void
+cmd_flex_filter_parsed(void *parsed_result,
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
+{
+	int ret = 0;
+	struct rte_eth_flex_filter filter;
+	struct cmd_flex_filter_result *res = parsed_result;
+	char *bytes_ptr, *mask_ptr;
+	uint16_t len, i, j = 0;
+	char c;
+	int val;
+	uint8_t byte = 0;
+
+	if (res->len_value > RTE_FLEX_FILTER_MAXLEN) {
+		printf("the len exceed the max length 128\n");
+		return;
+	}
+	memset(&filter, 0, sizeof(struct rte_eth_flex_filter));
+	filter.len = res->len_value;
+	filter.priority = res->priority_value;
+	filter.queue = res->queue_id;
+	bytes_ptr = res->bytes_value;
+	mask_ptr = res->mask_value;
+
+	 /* translate bytes string to array. */
+	if (bytes_ptr[0] == '0' && ((bytes_ptr[1] == 'x') ||
+		(bytes_ptr[1] == 'X')))
+		bytes_ptr += 2;
+	len = strnlen(bytes_ptr, res->len_value * 2);
+	if (len == 0 || (len % 8 != 0)) {
+		printf("please check len and bytes input\n");
+		return;
+	}
+	for (i = 0; i < len; i++) {
+		c = bytes_ptr[i];
+		if (isxdigit(c) == 0) {
+			/* invalid characters. */
+			printf("invalid input\n");
+			return;
+		}
+		val = xdigit2val(c);
+		if (i % 2) {
+			byte |= val;
+			filter.bytes[j] = byte;
+			printf("bytes[%d]:%02x ", j, filter.bytes[j]);
+			j++;
+			byte = 0;
+		} else
+			byte |= val << 4;
+	}
+	printf("\n");
+	 /* translate mask string to uint8_t array. */
+	if (mask_ptr[0] == '0' && ((mask_ptr[1] == 'x') ||
+		(mask_ptr[1] == 'X')))
+		mask_ptr += 2;
+	len = strnlen(mask_ptr, (res->len_value + 3) / 4);
+	if (len == 0) {
+		printf("invalid input\n");
+		return;
+	}
+	j = 0;
+	byte = 0;
+	for (i = 0; i < len; i++) {
+		c = mask_ptr[i];
+		if (isxdigit(c) == 0) {
+			/* invalid characters. */
+			printf("invalid input\n");
+			return;
+		}
+		val = xdigit2val(c);
+		if (i % 2) {
+			byte |= val;
+			filter.mask[j] = byte;
+			printf("mask[%d]:%02x ", j, filter.mask[j]);
+			j++;
+			byte = 0;
+		} else
+			byte |= val << 4;
+	}
+	printf("\n");
+
+	if (!strcmp(res->ops, "add"))
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+				RTE_ETH_FILTER_FLEXIBLE,
+				RTE_ETH_FILTER_ADD,
+				&filter);
+	else
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+				RTE_ETH_FILTER_FLEXIBLE,
+				RTE_ETH_FILTER_DELETE,
+				&filter);
+
+	if (ret < 0)
+		printf("flex filter setting error: (%s)\n", strerror(-ret));
+}
+
+cmdline_parse_token_string_t cmd_flex_filter_filter =
+	TOKEN_STRING_INITIALIZER(struct cmd_flex_filter_result,
+				filter, "flex_filter");
+cmdline_parse_token_num_t cmd_flex_filter_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_flex_filter_result,
+				port_id, UINT16);
+cmdline_parse_token_string_t cmd_flex_filter_ops =
+	TOKEN_STRING_INITIALIZER(struct cmd_flex_filter_result,
+				ops, "add#del");
+cmdline_parse_token_string_t cmd_flex_filter_len =
+	TOKEN_STRING_INITIALIZER(struct cmd_flex_filter_result,
+				len, "len");
+cmdline_parse_token_num_t cmd_flex_filter_len_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flex_filter_result,
+				len_value, UINT8);
+cmdline_parse_token_string_t cmd_flex_filter_bytes =
+	TOKEN_STRING_INITIALIZER(struct cmd_flex_filter_result,
+				bytes, "bytes");
+cmdline_parse_token_string_t cmd_flex_filter_bytes_value =
+	TOKEN_STRING_INITIALIZER(struct cmd_flex_filter_result,
+				bytes_value, NULL);
+cmdline_parse_token_string_t cmd_flex_filter_mask =
+	TOKEN_STRING_INITIALIZER(struct cmd_flex_filter_result,
+				mask, "mask");
+cmdline_parse_token_string_t cmd_flex_filter_mask_value =
+	TOKEN_STRING_INITIALIZER(struct cmd_flex_filter_result,
+				mask_value, NULL);
+cmdline_parse_token_string_t cmd_flex_filter_priority =
+	TOKEN_STRING_INITIALIZER(struct cmd_flex_filter_result,
+				priority, "priority");
+cmdline_parse_token_num_t cmd_flex_filter_priority_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flex_filter_result,
+				priority_value, UINT8);
+cmdline_parse_token_string_t cmd_flex_filter_queue =
+	TOKEN_STRING_INITIALIZER(struct cmd_flex_filter_result,
+				queue, "queue");
+cmdline_parse_token_num_t cmd_flex_filter_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_flex_filter_result,
+				queue_id, UINT16);
+cmdline_parse_inst_t cmd_flex_filter = {
+	.f = cmd_flex_filter_parsed,
+	.data = NULL,
+	.help_str = "flex_filter <port_id> add|del len <value> bytes "
+		"<value> mask <value> priority <value> queue <queue_id>: "
+		"Add/Del a flex filter",
+	.tokens = {
+		(void *)&cmd_flex_filter_filter,
+		(void *)&cmd_flex_filter_port_id,
+		(void *)&cmd_flex_filter_ops,
+		(void *)&cmd_flex_filter_len,
+		(void *)&cmd_flex_filter_len_value,
+		(void *)&cmd_flex_filter_bytes,
+		(void *)&cmd_flex_filter_bytes_value,
+		(void *)&cmd_flex_filter_mask,
+		(void *)&cmd_flex_filter_mask_value,
+		(void *)&cmd_flex_filter_priority,
+		(void *)&cmd_flex_filter_priority_value,
+		(void *)&cmd_flex_filter_queue,
+		(void *)&cmd_flex_filter_queue_id,
+		NULL,
+	},
+};
+
 /* *** Filters Control *** */
 
+/* *** deal with ethertype filter *** */
+struct cmd_ethertype_filter_result {
+	cmdline_fixed_string_t filter;
+	portid_t port_id;
+	cmdline_fixed_string_t ops;
+	cmdline_fixed_string_t mac;
+	struct rte_ether_addr mac_addr;
+	cmdline_fixed_string_t ethertype;
+	uint16_t ethertype_value;
+	cmdline_fixed_string_t drop;
+	cmdline_fixed_string_t queue;
+	uint16_t  queue_id;
+};
+
+cmdline_parse_token_string_t cmd_ethertype_filter_filter =
+	TOKEN_STRING_INITIALIZER(struct cmd_ethertype_filter_result,
+				 filter, "ethertype_filter");
+cmdline_parse_token_num_t cmd_ethertype_filter_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_ethertype_filter_result,
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_ethertype_filter_ops =
+	TOKEN_STRING_INITIALIZER(struct cmd_ethertype_filter_result,
+				 ops, "add#del");
+cmdline_parse_token_string_t cmd_ethertype_filter_mac =
+	TOKEN_STRING_INITIALIZER(struct cmd_ethertype_filter_result,
+				 mac, "mac_addr#mac_ignr");
+cmdline_parse_token_etheraddr_t cmd_ethertype_filter_mac_addr =
+	TOKEN_ETHERADDR_INITIALIZER(struct cmd_ethertype_filter_result,
+				     mac_addr);
+cmdline_parse_token_string_t cmd_ethertype_filter_ethertype =
+	TOKEN_STRING_INITIALIZER(struct cmd_ethertype_filter_result,
+				 ethertype, "ethertype");
+cmdline_parse_token_num_t cmd_ethertype_filter_ethertype_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_ethertype_filter_result,
+			      ethertype_value, UINT16);
+cmdline_parse_token_string_t cmd_ethertype_filter_drop =
+	TOKEN_STRING_INITIALIZER(struct cmd_ethertype_filter_result,
+				 drop, "drop#fwd");
+cmdline_parse_token_string_t cmd_ethertype_filter_queue =
+	TOKEN_STRING_INITIALIZER(struct cmd_ethertype_filter_result,
+				 queue, "queue");
+cmdline_parse_token_num_t cmd_ethertype_filter_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_ethertype_filter_result,
+			      queue_id, UINT16);
+
+static void
+cmd_ethertype_filter_parsed(void *parsed_result,
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
+{
+	struct cmd_ethertype_filter_result *res = parsed_result;
+	struct rte_eth_ethertype_filter filter;
+	int ret = 0;
+
+	ret = rte_eth_dev_filter_supported(res->port_id,
+			RTE_ETH_FILTER_ETHERTYPE);
+	if (ret < 0) {
+		printf("ethertype filter is not supported on port %u.\n",
+			res->port_id);
+		return;
+	}
+
+	memset(&filter, 0, sizeof(filter));
+	if (!strcmp(res->mac, "mac_addr")) {
+		filter.flags |= RTE_ETHTYPE_FLAGS_MAC;
+		rte_memcpy(&filter.mac_addr, &res->mac_addr,
+			sizeof(struct rte_ether_addr));
+	}
+	if (!strcmp(res->drop, "drop"))
+		filter.flags |= RTE_ETHTYPE_FLAGS_DROP;
+	filter.ether_type = res->ethertype_value;
+	filter.queue = res->queue_id;
+
+	if (!strcmp(res->ops, "add"))
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+				RTE_ETH_FILTER_ETHERTYPE,
+				RTE_ETH_FILTER_ADD,
+				&filter);
+	else
+		ret = rte_eth_dev_filter_ctrl(res->port_id,
+				RTE_ETH_FILTER_ETHERTYPE,
+				RTE_ETH_FILTER_DELETE,
+				&filter);
+	if (ret < 0)
+		printf("ethertype filter programming error: (%s)\n",
+			strerror(-ret));
+}
+
+cmdline_parse_inst_t cmd_ethertype_filter = {
+	.f = cmd_ethertype_filter_parsed,
+	.data = NULL,
+	.help_str = "ethertype_filter <port_id> add|del mac_addr|mac_ignr "
+		"<mac_addr> ethertype <value> drop|fw queue <queue_id>: "
+		"Add or delete an ethertype filter entry",
+	.tokens = {
+		(void *)&cmd_ethertype_filter_filter,
+		(void *)&cmd_ethertype_filter_port_id,
+		(void *)&cmd_ethertype_filter_ops,
+		(void *)&cmd_ethertype_filter_mac,
+		(void *)&cmd_ethertype_filter_mac_addr,
+		(void *)&cmd_ethertype_filter_ethertype,
+		(void *)&cmd_ethertype_filter_ethertype_value,
+		(void *)&cmd_ethertype_filter_drop,
+		(void *)&cmd_ethertype_filter_queue,
+		(void *)&cmd_ethertype_filter_queue_id,
+		NULL,
+	},
+};
+
+/* *** deal with flow director filter *** */
+struct cmd_flow_director_result {
+	cmdline_fixed_string_t flow_director_filter;
+	portid_t port_id;
+	cmdline_fixed_string_t mode;
+	cmdline_fixed_string_t mode_value;
+	cmdline_fixed_string_t ops;
+	cmdline_fixed_string_t flow;
+	cmdline_fixed_string_t flow_type;
+	cmdline_fixed_string_t ether;
+	uint16_t ether_type;
+	cmdline_fixed_string_t src;
+	cmdline_ipaddr_t ip_src;
+	uint16_t port_src;
+	cmdline_fixed_string_t dst;
+	cmdline_ipaddr_t ip_dst;
+	uint16_t port_dst;
+	cmdline_fixed_string_t verify_tag;
+	uint32_t verify_tag_value;
+	cmdline_fixed_string_t tos;
+	uint8_t tos_value;
+	cmdline_fixed_string_t proto;
+	uint8_t proto_value;
+	cmdline_fixed_string_t ttl;
+	uint8_t ttl_value;
+	cmdline_fixed_string_t vlan;
+	uint16_t vlan_value;
+	cmdline_fixed_string_t flexbytes;
+	cmdline_fixed_string_t flexbytes_value;
+	cmdline_fixed_string_t pf_vf;
+	cmdline_fixed_string_t drop;
+	cmdline_fixed_string_t queue;
+	uint16_t  queue_id;
+	cmdline_fixed_string_t fd_id;
+	uint32_t  fd_id_value;
+	cmdline_fixed_string_t mac;
+	struct rte_ether_addr mac_addr;
+	cmdline_fixed_string_t tunnel;
+	cmdline_fixed_string_t tunnel_type;
+	cmdline_fixed_string_t tunnel_id;
+	uint32_t tunnel_id_value;
+	cmdline_fixed_string_t packet;
+	char filepath[];
+};
+
+static inline int
+parse_flexbytes(const char *q_arg, uint8_t *flexbytes, uint16_t max_num)
+{
+	char s[256];
+	const char *p, *p0 = q_arg;
+	char *end;
+	unsigned long int_fld;
+	char *str_fld[max_num];
+	int i;
+	unsigned size;
+	int ret = -1;
+
+	p = strchr(p0, '(');
+	if (p == NULL)
+		return -1;
+	++p;
+	p0 = strchr(p, ')');
+	if (p0 == NULL)
+		return -1;
+
+	size = p0 - p;
+	if (size >= sizeof(s))
+		return -1;
+
+	snprintf(s, sizeof(s), "%.*s", size, p);
+	ret = rte_strsplit(s, sizeof(s), str_fld, max_num, ',');
+	if (ret < 0 || ret > max_num)
+		return -1;
+	for (i = 0; i < ret; i++) {
+		errno = 0;
+		int_fld = strtoul(str_fld[i], &end, 0);
+		if (errno != 0 || *end != '\0' || int_fld > UINT8_MAX)
+			return -1;
+		flexbytes[i] = (uint8_t)int_fld;
+	}
+	return ret;
+}
+
+static uint16_t
+str2flowtype(char *string)
+{
+	uint8_t i = 0;
+	static const struct {
+		char str[32];
+		uint16_t type;
+	} flowtype_str[] = {
+		{"raw", RTE_ETH_FLOW_RAW},
+		{"ipv4", RTE_ETH_FLOW_IPV4},
+		{"ipv4-frag", RTE_ETH_FLOW_FRAG_IPV4},
+		{"ipv4-tcp", RTE_ETH_FLOW_NONFRAG_IPV4_TCP},
+		{"ipv4-udp", RTE_ETH_FLOW_NONFRAG_IPV4_UDP},
+		{"ipv4-sctp", RTE_ETH_FLOW_NONFRAG_IPV4_SCTP},
+		{"ipv4-other", RTE_ETH_FLOW_NONFRAG_IPV4_OTHER},
+		{"ipv6", RTE_ETH_FLOW_IPV6},
+		{"ipv6-frag", RTE_ETH_FLOW_FRAG_IPV6},
+		{"ipv6-tcp", RTE_ETH_FLOW_NONFRAG_IPV6_TCP},
+		{"ipv6-udp", RTE_ETH_FLOW_NONFRAG_IPV6_UDP},
+		{"ipv6-sctp", RTE_ETH_FLOW_NONFRAG_IPV6_SCTP},
+		{"ipv6-other", RTE_ETH_FLOW_NONFRAG_IPV6_OTHER},
+		{"l2_payload", RTE_ETH_FLOW_L2_PAYLOAD},
+	};
+
+	for (i = 0; i < RTE_DIM(flowtype_str); i++) {
+		if (!strcmp(flowtype_str[i].str, string))
+			return flowtype_str[i].type;
+	}
+
+	if (isdigit(string[0]) && atoi(string) > 0 && atoi(string) < 64)
+		return (uint16_t)atoi(string);
+
+	return RTE_ETH_FLOW_UNKNOWN;
+}
+
+static enum rte_eth_fdir_tunnel_type
+str2fdir_tunneltype(char *string)
+{
+	uint8_t i = 0;
+
+	static const struct {
+		char str[32];
+		enum rte_eth_fdir_tunnel_type type;
+	} tunneltype_str[] = {
+		{"NVGRE", RTE_FDIR_TUNNEL_TYPE_NVGRE},
+		{"VxLAN", RTE_FDIR_TUNNEL_TYPE_VXLAN},
+	};
+
+	for (i = 0; i < RTE_DIM(tunneltype_str); i++) {
+		if (!strcmp(tunneltype_str[i].str, string))
+			return tunneltype_str[i].type;
+	}
+	return RTE_FDIR_TUNNEL_TYPE_UNKNOWN;
+}
+
 #define IPV4_ADDR_TO_UINT(ip_addr, ip) \
 do { \
 	if ((ip_addr).family == AF_INET) \
 		(ip) = (ip_addr).addr.ipv4.s_addr; \
 	else { \
-		fprintf(stderr, "invalid parameter.\n"); \
+		printf("invalid parameter.\n"); \
 		return; \
 	} \
 } while (0)
@@ -8438,14 +10987,1632 @@
 				 &((ip_addr).addr.ipv6), \
 				 sizeof(struct in6_addr)); \
 	else { \
-		fprintf(stderr, "invalid parameter.\n"); \
+		printf("invalid parameter.\n"); \
 		return; \
 	} \
 } while (0)
 
+static void
+cmd_flow_director_filter_parsed(void *parsed_result,
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
+{
+	struct cmd_flow_director_result *res = parsed_result;
+	struct rte_eth_fdir_filter entry;
+	uint8_t flexbytes[RTE_ETH_FDIR_MAX_FLEXLEN];
+	char *end;
+	unsigned long vf_id;
+	int ret = 0;
+
+	ret = rte_eth_dev_filter_supported(res->port_id, RTE_ETH_FILTER_FDIR);
+	if (ret < 0) {
+		printf("flow director is not supported on port %u.\n",
+			res->port_id);
+		return;
+	}
+	memset(flexbytes, 0, sizeof(flexbytes));
+	memset(&entry, 0, sizeof(struct rte_eth_fdir_filter));
+
+	if (fdir_conf.mode ==  RTE_FDIR_MODE_PERFECT_MAC_VLAN) {
+		if (strcmp(res->mode_value, "MAC-VLAN")) {
+			printf("Please set mode to MAC-VLAN.\n");
+			return;
+		}
+	} else if (fdir_conf.mode ==  RTE_FDIR_MODE_PERFECT_TUNNEL) {
+		if (strcmp(res->mode_value, "Tunnel")) {
+			printf("Please set mode to Tunnel.\n");
+			return;
+		}
+	} else {
+		if (!strcmp(res->mode_value, "raw")) {
+#ifdef RTE_LIBRTE_I40E_PMD
+			struct rte_pmd_i40e_flow_type_mapping
+					mapping[RTE_PMD_I40E_FLOW_TYPE_MAX];
+			struct rte_pmd_i40e_pkt_template_conf conf;
+			uint16_t flow_type = str2flowtype(res->flow_type);
+			uint16_t i, port = res->port_id;
+			uint8_t add;
+
+			memset(&conf, 0, sizeof(conf));
+
+			if (flow_type == RTE_ETH_FLOW_UNKNOWN) {
+				printf("Invalid flow type specified.\n");
+				return;
+			}
+			ret = rte_pmd_i40e_flow_type_mapping_get(res->port_id,
+								 mapping);
+			if (ret)
+				return;
+			if (mapping[flow_type].pctype == 0ULL) {
+				printf("Invalid flow type specified.\n");
+				return;
+			}
+			for (i = 0; i < RTE_PMD_I40E_PCTYPE_MAX; i++) {
+				if (mapping[flow_type].pctype & (1ULL << i)) {
+					conf.input.pctype = i;
+					break;
+				}
+			}
+
+			conf.input.packet = open_file(res->filepath,
+						&conf.input.length);
+			if (!conf.input.packet)
+				return;
+			if (!strcmp(res->drop, "drop"))
+				conf.action.behavior =
+					RTE_PMD_I40E_PKT_TEMPLATE_REJECT;
+			else
+				conf.action.behavior =
+					RTE_PMD_I40E_PKT_TEMPLATE_ACCEPT;
+			conf.action.report_status =
+					RTE_PMD_I40E_PKT_TEMPLATE_REPORT_ID;
+			conf.action.rx_queue = res->queue_id;
+			conf.soft_id = res->fd_id_value;
+			add  = strcmp(res->ops, "del") ? 1 : 0;
+			ret = rte_pmd_i40e_flow_add_del_packet_template(port,
+									&conf,
+									add);
+			if (ret < 0)
+				printf("flow director config error: (%s)\n",
+				       strerror(-ret));
+			close_file(conf.input.packet);
+#endif
+			return;
+		} else if (strcmp(res->mode_value, "IP")) {
+			printf("Please set mode to IP or raw.\n");
+			return;
+		}
+		entry.input.flow_type = str2flowtype(res->flow_type);
+	}
+
+	ret = parse_flexbytes(res->flexbytes_value,
+					flexbytes,
+					RTE_ETH_FDIR_MAX_FLEXLEN);
+	if (ret < 0) {
+		printf("error: Cannot parse flexbytes input.\n");
+		return;
+	}
+
+	switch (entry.input.flow_type) {
+	case RTE_ETH_FLOW_FRAG_IPV4:
+	case RTE_ETH_FLOW_NONFRAG_IPV4_OTHER:
+		entry.input.flow.ip4_flow.proto = res->proto_value;
+		/* fall-through */
+	case RTE_ETH_FLOW_NONFRAG_IPV4_UDP:
+	case RTE_ETH_FLOW_NONFRAG_IPV4_TCP:
+		IPV4_ADDR_TO_UINT(res->ip_dst,
+			entry.input.flow.ip4_flow.dst_ip);
+		IPV4_ADDR_TO_UINT(res->ip_src,
+			entry.input.flow.ip4_flow.src_ip);
+		entry.input.flow.ip4_flow.tos = res->tos_value;
+		entry.input.flow.ip4_flow.ttl = res->ttl_value;
+		/* need convert to big endian. */
+		entry.input.flow.udp4_flow.dst_port =
+				rte_cpu_to_be_16(res->port_dst);
+		entry.input.flow.udp4_flow.src_port =
+				rte_cpu_to_be_16(res->port_src);
+		break;
+	case RTE_ETH_FLOW_NONFRAG_IPV4_SCTP:
+		IPV4_ADDR_TO_UINT(res->ip_dst,
+			entry.input.flow.sctp4_flow.ip.dst_ip);
+		IPV4_ADDR_TO_UINT(res->ip_src,
+			entry.input.flow.sctp4_flow.ip.src_ip);
+		entry.input.flow.ip4_flow.tos = res->tos_value;
+		entry.input.flow.ip4_flow.ttl = res->ttl_value;
+		/* need convert to big endian. */
+		entry.input.flow.sctp4_flow.dst_port =
+				rte_cpu_to_be_16(res->port_dst);
+		entry.input.flow.sctp4_flow.src_port =
+				rte_cpu_to_be_16(res->port_src);
+		entry.input.flow.sctp4_flow.verify_tag =
+				rte_cpu_to_be_32(res->verify_tag_value);
+		break;
+	case RTE_ETH_FLOW_FRAG_IPV6:
+	case RTE_ETH_FLOW_NONFRAG_IPV6_OTHER:
+		entry.input.flow.ipv6_flow.proto = res->proto_value;
+		/* fall-through */
+	case RTE_ETH_FLOW_NONFRAG_IPV6_UDP:
+	case RTE_ETH_FLOW_NONFRAG_IPV6_TCP:
+		IPV6_ADDR_TO_ARRAY(res->ip_dst,
+			entry.input.flow.ipv6_flow.dst_ip);
+		IPV6_ADDR_TO_ARRAY(res->ip_src,
+			entry.input.flow.ipv6_flow.src_ip);
+		entry.input.flow.ipv6_flow.tc = res->tos_value;
+		entry.input.flow.ipv6_flow.hop_limits = res->ttl_value;
+		/* need convert to big endian. */
+		entry.input.flow.udp6_flow.dst_port =
+				rte_cpu_to_be_16(res->port_dst);
+		entry.input.flow.udp6_flow.src_port =
+				rte_cpu_to_be_16(res->port_src);
+		break;
+	case RTE_ETH_FLOW_NONFRAG_IPV6_SCTP:
+		IPV6_ADDR_TO_ARRAY(res->ip_dst,
+			entry.input.flow.sctp6_flow.ip.dst_ip);
+		IPV6_ADDR_TO_ARRAY(res->ip_src,
+			entry.input.flow.sctp6_flow.ip.src_ip);
+		entry.input.flow.ipv6_flow.tc = res->tos_value;
+		entry.input.flow.ipv6_flow.hop_limits = res->ttl_value;
+		/* need convert to big endian. */
+		entry.input.flow.sctp6_flow.dst_port =
+				rte_cpu_to_be_16(res->port_dst);
+		entry.input.flow.sctp6_flow.src_port =
+				rte_cpu_to_be_16(res->port_src);
+		entry.input.flow.sctp6_flow.verify_tag =
+				rte_cpu_to_be_32(res->verify_tag_value);
+		break;
+	case RTE_ETH_FLOW_L2_PAYLOAD:
+		entry.input.flow.l2_flow.ether_type =
+			rte_cpu_to_be_16(res->ether_type);
+		break;
+	default:
+		break;
+	}
+
+	if (fdir_conf.mode ==  RTE_FDIR_MODE_PERFECT_MAC_VLAN)
+		rte_memcpy(&entry.input.flow.mac_vlan_flow.mac_addr,
+				 &res->mac_addr,
+				 sizeof(struct rte_ether_addr));
+
+	if (fdir_conf.mode ==  RTE_FDIR_MODE_PERFECT_TUNNEL) {
+		rte_memcpy(&entry.input.flow.tunnel_flow.mac_addr,
+				 &res->mac_addr,
+				 sizeof(struct rte_ether_addr));
+		entry.input.flow.tunnel_flow.tunnel_type =
+			str2fdir_tunneltype(res->tunnel_type);
+		entry.input.flow.tunnel_flow.tunnel_id =
+			rte_cpu_to_be_32(res->tunnel_id_value);
+	}
+
+	rte_memcpy(entry.input.flow_ext.flexbytes,
+		   flexbytes,
+		   RTE_ETH_FDIR_MAX_FLEXLEN);
+
+	entry.input.flow_ext.vlan_tci = rte_cpu_to_be_16(res->vlan_value);
+
+	entry.action.flex_off = 0;  /*use 0 by default */
+	if (!strcmp(res->drop, "drop"))
+		entry.action.behavior = RTE_ETH_FDIR_REJECT;
+	else
+		entry.action.behavior = RTE_ETH_FDIR_ACCEPT;
+
+	if (fdir_conf.mode !=  RTE_FDIR_MODE_PERFECT_MAC_VLAN &&
+	    fdir_conf.mode !=  RTE_FDIR_MODE_PERFECT_TUNNEL) {
+		if (!strcmp(res->pf_vf, "pf"))
+			entry.input.flow_ext.is_vf = 0;
+		else if (!strncmp(res->pf_vf, "vf", 2)) {
+			struct rte_eth_dev_info dev_info;
+
+			ret = eth_dev_info_get_print_err(res->port_id,
+						&dev_info);
+			if (ret != 0)
+				return;
+
+			errno = 0;
+			vf_id = strtoul(res->pf_vf + 2, &end, 10);
+			if (errno != 0 || *end != '\0' ||
+			    vf_id >= dev_info.max_vfs) {
+				printf("invalid parameter %s.\n", res->pf_vf);
+				return;
+			}
+			entry.input.flow_ext.is_vf = 1;
+			entry.input.flow_ext.dst_id = (uint16_t)vf_id;
+		} else {
+			printf("invalid parameter %s.\n", res->pf_vf);
+			return;
+		}
+	}
+
+	/* set to report FD ID by default */
+	entry.action.report_status = RTE_ETH_FDIR_REPORT_ID;
+	entry.action.rx_queue = res->queue_id;
+	entry.soft_id = res->fd_id_value;
+	if (!strcmp(res->ops, "add"))
+		ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_FDIR,
+					     RTE_ETH_FILTER_ADD, &entry);
+	else if (!strcmp(res->ops, "del"))
+		ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_FDIR,
+					     RTE_ETH_FILTER_DELETE, &entry);
+	else
+		ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_FDIR,
+					     RTE_ETH_FILTER_UPDATE, &entry);
+	if (ret < 0)
+		printf("flow director programming error: (%s)\n",
+			strerror(-ret));
+}
+
+cmdline_parse_token_string_t cmd_flow_director_filter =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 flow_director_filter, "flow_director_filter");
+cmdline_parse_token_num_t cmd_flow_director_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_ops =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 ops, "add#del#update");
+cmdline_parse_token_string_t cmd_flow_director_flow =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 flow, "flow");
+cmdline_parse_token_string_t cmd_flow_director_flow_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+		flow_type, NULL);
+cmdline_parse_token_string_t cmd_flow_director_ether =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 ether, "ether");
+cmdline_parse_token_num_t cmd_flow_director_ether_type =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      ether_type, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_src =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 src, "src");
+cmdline_parse_token_ipaddr_t cmd_flow_director_ip_src =
+	TOKEN_IPADDR_INITIALIZER(struct cmd_flow_director_result,
+				 ip_src);
+cmdline_parse_token_num_t cmd_flow_director_port_src =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      port_src, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_dst =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 dst, "dst");
+cmdline_parse_token_ipaddr_t cmd_flow_director_ip_dst =
+	TOKEN_IPADDR_INITIALIZER(struct cmd_flow_director_result,
+				 ip_dst);
+cmdline_parse_token_num_t cmd_flow_director_port_dst =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      port_dst, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_verify_tag =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				  verify_tag, "verify_tag");
+cmdline_parse_token_num_t cmd_flow_director_verify_tag_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      verify_tag_value, UINT32);
+cmdline_parse_token_string_t cmd_flow_director_tos =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 tos, "tos");
+cmdline_parse_token_num_t cmd_flow_director_tos_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      tos_value, UINT8);
+cmdline_parse_token_string_t cmd_flow_director_proto =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 proto, "proto");
+cmdline_parse_token_num_t cmd_flow_director_proto_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      proto_value, UINT8);
+cmdline_parse_token_string_t cmd_flow_director_ttl =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 ttl, "ttl");
+cmdline_parse_token_num_t cmd_flow_director_ttl_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      ttl_value, UINT8);
+cmdline_parse_token_string_t cmd_flow_director_vlan =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 vlan, "vlan");
+cmdline_parse_token_num_t cmd_flow_director_vlan_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      vlan_value, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_flexbytes =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 flexbytes, "flexbytes");
+cmdline_parse_token_string_t cmd_flow_director_flexbytes_value =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+			      flexbytes_value, NULL);
+cmdline_parse_token_string_t cmd_flow_director_drop =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 drop, "drop#fwd");
+cmdline_parse_token_string_t cmd_flow_director_pf_vf =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+			      pf_vf, NULL);
+cmdline_parse_token_string_t cmd_flow_director_queue =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 queue, "queue");
+cmdline_parse_token_num_t cmd_flow_director_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      queue_id, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_fd_id =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 fd_id, "fd_id");
+cmdline_parse_token_num_t cmd_flow_director_fd_id_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      fd_id_value, UINT32);
+
+cmdline_parse_token_string_t cmd_flow_director_mode =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 mode, "mode");
+cmdline_parse_token_string_t cmd_flow_director_mode_ip =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 mode_value, "IP");
+cmdline_parse_token_string_t cmd_flow_director_mode_mac_vlan =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 mode_value, "MAC-VLAN");
+cmdline_parse_token_string_t cmd_flow_director_mode_tunnel =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 mode_value, "Tunnel");
+cmdline_parse_token_string_t cmd_flow_director_mode_raw =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 mode_value, "raw");
+cmdline_parse_token_string_t cmd_flow_director_mac =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 mac, "mac");
+cmdline_parse_token_etheraddr_t cmd_flow_director_mac_addr =
+	TOKEN_ETHERADDR_INITIALIZER(struct cmd_flow_director_result,
+				    mac_addr);
+cmdline_parse_token_string_t cmd_flow_director_tunnel =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 tunnel, "tunnel");
+cmdline_parse_token_string_t cmd_flow_director_tunnel_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 tunnel_type, "NVGRE#VxLAN");
+cmdline_parse_token_string_t cmd_flow_director_tunnel_id =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 tunnel_id, "tunnel-id");
+cmdline_parse_token_num_t cmd_flow_director_tunnel_id_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_result,
+			      tunnel_id_value, UINT32);
+cmdline_parse_token_string_t cmd_flow_director_packet =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 packet, "packet");
+cmdline_parse_token_string_t cmd_flow_director_filepath =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_result,
+				 filepath, NULL);
+
+cmdline_parse_inst_t cmd_add_del_ip_flow_director = {
+	.f = cmd_flow_director_filter_parsed,
+	.data = NULL,
+	.help_str = "flow_director_filter <port_id> mode IP add|del|update flow"
+		" ipv4-other|ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|"
+		"ipv6-other|ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|"
+		"l2_payload src <src_ip> dst <dst_ip> tos <tos_value> "
+		"proto <proto_value> ttl <ttl_value> vlan <vlan_value> "
+		"flexbytes <flexbyte_values> drop|fw <pf_vf> queue <queue_id> "
+		"fd_id <fd_id_value>: "
+		"Add or delete an ip flow director entry on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_filter,
+		(void *)&cmd_flow_director_port_id,
+		(void *)&cmd_flow_director_mode,
+		(void *)&cmd_flow_director_mode_ip,
+		(void *)&cmd_flow_director_ops,
+		(void *)&cmd_flow_director_flow,
+		(void *)&cmd_flow_director_flow_type,
+		(void *)&cmd_flow_director_src,
+		(void *)&cmd_flow_director_ip_src,
+		(void *)&cmd_flow_director_dst,
+		(void *)&cmd_flow_director_ip_dst,
+		(void *)&cmd_flow_director_tos,
+		(void *)&cmd_flow_director_tos_value,
+		(void *)&cmd_flow_director_proto,
+		(void *)&cmd_flow_director_proto_value,
+		(void *)&cmd_flow_director_ttl,
+		(void *)&cmd_flow_director_ttl_value,
+		(void *)&cmd_flow_director_vlan,
+		(void *)&cmd_flow_director_vlan_value,
+		(void *)&cmd_flow_director_flexbytes,
+		(void *)&cmd_flow_director_flexbytes_value,
+		(void *)&cmd_flow_director_drop,
+		(void *)&cmd_flow_director_pf_vf,
+		(void *)&cmd_flow_director_queue,
+		(void *)&cmd_flow_director_queue_id,
+		(void *)&cmd_flow_director_fd_id,
+		(void *)&cmd_flow_director_fd_id_value,
+		NULL,
+	},
+};
+
+cmdline_parse_inst_t cmd_add_del_udp_flow_director = {
+	.f = cmd_flow_director_filter_parsed,
+	.data = NULL,
+	.help_str = "flow_director_filter ... : Add or delete an udp/tcp flow "
+		"director entry on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_filter,
+		(void *)&cmd_flow_director_port_id,
+		(void *)&cmd_flow_director_mode,
+		(void *)&cmd_flow_director_mode_ip,
+		(void *)&cmd_flow_director_ops,
+		(void *)&cmd_flow_director_flow,
+		(void *)&cmd_flow_director_flow_type,
+		(void *)&cmd_flow_director_src,
+		(void *)&cmd_flow_director_ip_src,
+		(void *)&cmd_flow_director_port_src,
+		(void *)&cmd_flow_director_dst,
+		(void *)&cmd_flow_director_ip_dst,
+		(void *)&cmd_flow_director_port_dst,
+		(void *)&cmd_flow_director_tos,
+		(void *)&cmd_flow_director_tos_value,
+		(void *)&cmd_flow_director_ttl,
+		(void *)&cmd_flow_director_ttl_value,
+		(void *)&cmd_flow_director_vlan,
+		(void *)&cmd_flow_director_vlan_value,
+		(void *)&cmd_flow_director_flexbytes,
+		(void *)&cmd_flow_director_flexbytes_value,
+		(void *)&cmd_flow_director_drop,
+		(void *)&cmd_flow_director_pf_vf,
+		(void *)&cmd_flow_director_queue,
+		(void *)&cmd_flow_director_queue_id,
+		(void *)&cmd_flow_director_fd_id,
+		(void *)&cmd_flow_director_fd_id_value,
+		NULL,
+	},
+};
+
+cmdline_parse_inst_t cmd_add_del_sctp_flow_director = {
+	.f = cmd_flow_director_filter_parsed,
+	.data = NULL,
+	.help_str = "flow_director_filter ... : Add or delete a sctp flow "
+		"director entry on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_filter,
+		(void *)&cmd_flow_director_port_id,
+		(void *)&cmd_flow_director_mode,
+		(void *)&cmd_flow_director_mode_ip,
+		(void *)&cmd_flow_director_ops,
+		(void *)&cmd_flow_director_flow,
+		(void *)&cmd_flow_director_flow_type,
+		(void *)&cmd_flow_director_src,
+		(void *)&cmd_flow_director_ip_src,
+		(void *)&cmd_flow_director_port_src,
+		(void *)&cmd_flow_director_dst,
+		(void *)&cmd_flow_director_ip_dst,
+		(void *)&cmd_flow_director_port_dst,
+		(void *)&cmd_flow_director_verify_tag,
+		(void *)&cmd_flow_director_verify_tag_value,
+		(void *)&cmd_flow_director_tos,
+		(void *)&cmd_flow_director_tos_value,
+		(void *)&cmd_flow_director_ttl,
+		(void *)&cmd_flow_director_ttl_value,
+		(void *)&cmd_flow_director_vlan,
+		(void *)&cmd_flow_director_vlan_value,
+		(void *)&cmd_flow_director_flexbytes,
+		(void *)&cmd_flow_director_flexbytes_value,
+		(void *)&cmd_flow_director_drop,
+		(void *)&cmd_flow_director_pf_vf,
+		(void *)&cmd_flow_director_queue,
+		(void *)&cmd_flow_director_queue_id,
+		(void *)&cmd_flow_director_fd_id,
+		(void *)&cmd_flow_director_fd_id_value,
+		NULL,
+	},
+};
+
+cmdline_parse_inst_t cmd_add_del_l2_flow_director = {
+	.f = cmd_flow_director_filter_parsed,
+	.data = NULL,
+	.help_str = "flow_director_filter ... : Add or delete a L2 flow "
+		"director entry on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_filter,
+		(void *)&cmd_flow_director_port_id,
+		(void *)&cmd_flow_director_mode,
+		(void *)&cmd_flow_director_mode_ip,
+		(void *)&cmd_flow_director_ops,
+		(void *)&cmd_flow_director_flow,
+		(void *)&cmd_flow_director_flow_type,
+		(void *)&cmd_flow_director_ether,
+		(void *)&cmd_flow_director_ether_type,
+		(void *)&cmd_flow_director_flexbytes,
+		(void *)&cmd_flow_director_flexbytes_value,
+		(void *)&cmd_flow_director_drop,
+		(void *)&cmd_flow_director_pf_vf,
+		(void *)&cmd_flow_director_queue,
+		(void *)&cmd_flow_director_queue_id,
+		(void *)&cmd_flow_director_fd_id,
+		(void *)&cmd_flow_director_fd_id_value,
+		NULL,
+	},
+};
+
+cmdline_parse_inst_t cmd_add_del_mac_vlan_flow_director = {
+	.f = cmd_flow_director_filter_parsed,
+	.data = NULL,
+	.help_str = "flow_director_filter ... : Add or delete a MAC VLAN flow "
+		"director entry on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_filter,
+		(void *)&cmd_flow_director_port_id,
+		(void *)&cmd_flow_director_mode,
+		(void *)&cmd_flow_director_mode_mac_vlan,
+		(void *)&cmd_flow_director_ops,
+		(void *)&cmd_flow_director_mac,
+		(void *)&cmd_flow_director_mac_addr,
+		(void *)&cmd_flow_director_vlan,
+		(void *)&cmd_flow_director_vlan_value,
+		(void *)&cmd_flow_director_flexbytes,
+		(void *)&cmd_flow_director_flexbytes_value,
+		(void *)&cmd_flow_director_drop,
+		(void *)&cmd_flow_director_queue,
+		(void *)&cmd_flow_director_queue_id,
+		(void *)&cmd_flow_director_fd_id,
+		(void *)&cmd_flow_director_fd_id_value,
+		NULL,
+	},
+};
+
+cmdline_parse_inst_t cmd_add_del_tunnel_flow_director = {
+	.f = cmd_flow_director_filter_parsed,
+	.data = NULL,
+	.help_str = "flow_director_filter ... : Add or delete a tunnel flow "
+		"director entry on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_filter,
+		(void *)&cmd_flow_director_port_id,
+		(void *)&cmd_flow_director_mode,
+		(void *)&cmd_flow_director_mode_tunnel,
+		(void *)&cmd_flow_director_ops,
+		(void *)&cmd_flow_director_mac,
+		(void *)&cmd_flow_director_mac_addr,
+		(void *)&cmd_flow_director_vlan,
+		(void *)&cmd_flow_director_vlan_value,
+		(void *)&cmd_flow_director_tunnel,
+		(void *)&cmd_flow_director_tunnel_type,
+		(void *)&cmd_flow_director_tunnel_id,
+		(void *)&cmd_flow_director_tunnel_id_value,
+		(void *)&cmd_flow_director_flexbytes,
+		(void *)&cmd_flow_director_flexbytes_value,
+		(void *)&cmd_flow_director_drop,
+		(void *)&cmd_flow_director_queue,
+		(void *)&cmd_flow_director_queue_id,
+		(void *)&cmd_flow_director_fd_id,
+		(void *)&cmd_flow_director_fd_id_value,
+		NULL,
+	},
+};
+
+cmdline_parse_inst_t cmd_add_del_raw_flow_director = {
+	.f = cmd_flow_director_filter_parsed,
+	.data = NULL,
+	.help_str = "flow_director_filter ... : Add or delete a raw flow "
+		"director entry on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_filter,
+		(void *)&cmd_flow_director_port_id,
+		(void *)&cmd_flow_director_mode,
+		(void *)&cmd_flow_director_mode_raw,
+		(void *)&cmd_flow_director_ops,
+		(void *)&cmd_flow_director_flow,
+		(void *)&cmd_flow_director_flow_type,
+		(void *)&cmd_flow_director_drop,
+		(void *)&cmd_flow_director_queue,
+		(void *)&cmd_flow_director_queue_id,
+		(void *)&cmd_flow_director_fd_id,
+		(void *)&cmd_flow_director_fd_id_value,
+		(void *)&cmd_flow_director_packet,
+		(void *)&cmd_flow_director_filepath,
+		NULL,
+	},
+};
+
+struct cmd_flush_flow_director_result {
+	cmdline_fixed_string_t flush_flow_director;
+	portid_t port_id;
+};
+
+cmdline_parse_token_string_t cmd_flush_flow_director_flush =
+	TOKEN_STRING_INITIALIZER(struct cmd_flush_flow_director_result,
+				 flush_flow_director, "flush_flow_director");
+cmdline_parse_token_num_t cmd_flush_flow_director_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_flush_flow_director_result,
+			      port_id, UINT16);
+
+static void
+cmd_flush_flow_director_parsed(void *parsed_result,
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
+{
+	struct cmd_flow_director_result *res = parsed_result;
+	int ret = 0;
+
+	ret = rte_eth_dev_filter_supported(res->port_id, RTE_ETH_FILTER_FDIR);
+	if (ret < 0) {
+		printf("flow director is not supported on port %u.\n",
+			res->port_id);
+		return;
+	}
+
+	ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_FDIR,
+			RTE_ETH_FILTER_FLUSH, NULL);
+	if (ret < 0)
+		printf("flow director table flushing error: (%s)\n",
+			strerror(-ret));
+}
+
+cmdline_parse_inst_t cmd_flush_flow_director = {
+	.f = cmd_flush_flow_director_parsed,
+	.data = NULL,
+	.help_str = "flush_flow_director <port_id>: "
+		"Flush all flow director entries of a device on NIC",
+	.tokens = {
+		(void *)&cmd_flush_flow_director_flush,
+		(void *)&cmd_flush_flow_director_port_id,
+		NULL,
+	},
+};
+
+/* *** deal with flow director mask *** */
+struct cmd_flow_director_mask_result {
+	cmdline_fixed_string_t flow_director_mask;
+	portid_t port_id;
+	cmdline_fixed_string_t mode;
+	cmdline_fixed_string_t mode_value;
+	cmdline_fixed_string_t vlan;
+	uint16_t vlan_mask;
+	cmdline_fixed_string_t src_mask;
+	cmdline_ipaddr_t ipv4_src;
+	cmdline_ipaddr_t ipv6_src;
+	uint16_t port_src;
+	cmdline_fixed_string_t dst_mask;
+	cmdline_ipaddr_t ipv4_dst;
+	cmdline_ipaddr_t ipv6_dst;
+	uint16_t port_dst;
+	cmdline_fixed_string_t mac;
+	uint8_t mac_addr_byte_mask;
+	cmdline_fixed_string_t tunnel_id;
+	uint32_t tunnel_id_mask;
+	cmdline_fixed_string_t tunnel_type;
+	uint8_t tunnel_type_mask;
+};
+
+static void
+cmd_flow_director_mask_parsed(void *parsed_result,
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
+{
+	struct cmd_flow_director_mask_result *res = parsed_result;
+	struct rte_eth_fdir_masks *mask;
+	struct rte_port *port;
+
+	port = &ports[res->port_id];
+	/** Check if the port is not started **/
+	if (port->port_status != RTE_PORT_STOPPED) {
+		printf("Please stop port %d first\n", res->port_id);
+		return;
+	}
+
+	mask = &port->dev_conf.fdir_conf.mask;
+
+	if (fdir_conf.mode ==  RTE_FDIR_MODE_PERFECT_MAC_VLAN) {
+		if (strcmp(res->mode_value, "MAC-VLAN")) {
+			printf("Please set mode to MAC-VLAN.\n");
+			return;
+		}
+
+		mask->vlan_tci_mask = rte_cpu_to_be_16(res->vlan_mask);
+	} else if (fdir_conf.mode ==  RTE_FDIR_MODE_PERFECT_TUNNEL) {
+		if (strcmp(res->mode_value, "Tunnel")) {
+			printf("Please set mode to Tunnel.\n");
+			return;
+		}
+
+		mask->vlan_tci_mask = rte_cpu_to_be_16(res->vlan_mask);
+		mask->mac_addr_byte_mask = res->mac_addr_byte_mask;
+		mask->tunnel_id_mask = rte_cpu_to_be_32(res->tunnel_id_mask);
+		mask->tunnel_type_mask = res->tunnel_type_mask;
+	} else {
+		if (strcmp(res->mode_value, "IP")) {
+			printf("Please set mode to IP.\n");
+			return;
+		}
+
+		mask->vlan_tci_mask = rte_cpu_to_be_16(res->vlan_mask);
+		IPV4_ADDR_TO_UINT(res->ipv4_src, mask->ipv4_mask.src_ip);
+		IPV4_ADDR_TO_UINT(res->ipv4_dst, mask->ipv4_mask.dst_ip);
+		IPV6_ADDR_TO_ARRAY(res->ipv6_src, mask->ipv6_mask.src_ip);
+		IPV6_ADDR_TO_ARRAY(res->ipv6_dst, mask->ipv6_mask.dst_ip);
+		mask->src_port_mask = rte_cpu_to_be_16(res->port_src);
+		mask->dst_port_mask = rte_cpu_to_be_16(res->port_dst);
+	}
+
+	cmd_reconfig_device_queue(res->port_id, 1, 1);
+}
+
+cmdline_parse_token_string_t cmd_flow_director_mask =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 flow_director_mask, "flow_director_mask");
+cmdline_parse_token_num_t cmd_flow_director_mask_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_mask_result,
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_mask_vlan =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 vlan, "vlan");
+cmdline_parse_token_num_t cmd_flow_director_mask_vlan_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_mask_result,
+			      vlan_mask, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_mask_src =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 src_mask, "src_mask");
+cmdline_parse_token_ipaddr_t cmd_flow_director_mask_ipv4_src =
+	TOKEN_IPADDR_INITIALIZER(struct cmd_flow_director_mask_result,
+				 ipv4_src);
+cmdline_parse_token_ipaddr_t cmd_flow_director_mask_ipv6_src =
+	TOKEN_IPADDR_INITIALIZER(struct cmd_flow_director_mask_result,
+				 ipv6_src);
+cmdline_parse_token_num_t cmd_flow_director_mask_port_src =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_mask_result,
+			      port_src, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_mask_dst =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 dst_mask, "dst_mask");
+cmdline_parse_token_ipaddr_t cmd_flow_director_mask_ipv4_dst =
+	TOKEN_IPADDR_INITIALIZER(struct cmd_flow_director_mask_result,
+				 ipv4_dst);
+cmdline_parse_token_ipaddr_t cmd_flow_director_mask_ipv6_dst =
+	TOKEN_IPADDR_INITIALIZER(struct cmd_flow_director_mask_result,
+				 ipv6_dst);
+cmdline_parse_token_num_t cmd_flow_director_mask_port_dst =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_mask_result,
+			      port_dst, UINT16);
+
+cmdline_parse_token_string_t cmd_flow_director_mask_mode =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 mode, "mode");
+cmdline_parse_token_string_t cmd_flow_director_mask_mode_ip =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 mode_value, "IP");
+cmdline_parse_token_string_t cmd_flow_director_mask_mode_mac_vlan =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 mode_value, "MAC-VLAN");
+cmdline_parse_token_string_t cmd_flow_director_mask_mode_tunnel =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 mode_value, "Tunnel");
+cmdline_parse_token_string_t cmd_flow_director_mask_mac =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 mac, "mac");
+cmdline_parse_token_num_t cmd_flow_director_mask_mac_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_mask_result,
+			      mac_addr_byte_mask, UINT8);
+cmdline_parse_token_string_t cmd_flow_director_mask_tunnel_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 tunnel_type, "tunnel-type");
+cmdline_parse_token_num_t cmd_flow_director_mask_tunnel_type_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_mask_result,
+			      tunnel_type_mask, UINT8);
+cmdline_parse_token_string_t cmd_flow_director_mask_tunnel_id =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_mask_result,
+				 tunnel_id, "tunnel-id");
+cmdline_parse_token_num_t cmd_flow_director_mask_tunnel_id_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_mask_result,
+			      tunnel_id_mask, UINT32);
+
+cmdline_parse_inst_t cmd_set_flow_director_ip_mask = {
+	.f = cmd_flow_director_mask_parsed,
+	.data = NULL,
+	.help_str = "flow_director_mask ... : "
+		"Set IP mode flow director's mask on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_mask,
+		(void *)&cmd_flow_director_mask_port_id,
+		(void *)&cmd_flow_director_mask_mode,
+		(void *)&cmd_flow_director_mask_mode_ip,
+		(void *)&cmd_flow_director_mask_vlan,
+		(void *)&cmd_flow_director_mask_vlan_value,
+		(void *)&cmd_flow_director_mask_src,
+		(void *)&cmd_flow_director_mask_ipv4_src,
+		(void *)&cmd_flow_director_mask_ipv6_src,
+		(void *)&cmd_flow_director_mask_port_src,
+		(void *)&cmd_flow_director_mask_dst,
+		(void *)&cmd_flow_director_mask_ipv4_dst,
+		(void *)&cmd_flow_director_mask_ipv6_dst,
+		(void *)&cmd_flow_director_mask_port_dst,
+		NULL,
+	},
+};
+
+cmdline_parse_inst_t cmd_set_flow_director_mac_vlan_mask = {
+	.f = cmd_flow_director_mask_parsed,
+	.data = NULL,
+	.help_str = "flow_director_mask ... : Set MAC VLAN mode "
+		"flow director's mask on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_mask,
+		(void *)&cmd_flow_director_mask_port_id,
+		(void *)&cmd_flow_director_mask_mode,
+		(void *)&cmd_flow_director_mask_mode_mac_vlan,
+		(void *)&cmd_flow_director_mask_vlan,
+		(void *)&cmd_flow_director_mask_vlan_value,
+		NULL,
+	},
+};
+
+cmdline_parse_inst_t cmd_set_flow_director_tunnel_mask = {
+	.f = cmd_flow_director_mask_parsed,
+	.data = NULL,
+	.help_str = "flow_director_mask ... : Set tunnel mode "
+		"flow director's mask on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_mask,
+		(void *)&cmd_flow_director_mask_port_id,
+		(void *)&cmd_flow_director_mask_mode,
+		(void *)&cmd_flow_director_mask_mode_tunnel,
+		(void *)&cmd_flow_director_mask_vlan,
+		(void *)&cmd_flow_director_mask_vlan_value,
+		(void *)&cmd_flow_director_mask_mac,
+		(void *)&cmd_flow_director_mask_mac_value,
+		(void *)&cmd_flow_director_mask_tunnel_type,
+		(void *)&cmd_flow_director_mask_tunnel_type_value,
+		(void *)&cmd_flow_director_mask_tunnel_id,
+		(void *)&cmd_flow_director_mask_tunnel_id_value,
+		NULL,
+	},
+};
+
+/* *** deal with flow director mask on flexible payload *** */
+struct cmd_flow_director_flex_mask_result {
+	cmdline_fixed_string_t flow_director_flexmask;
+	portid_t port_id;
+	cmdline_fixed_string_t flow;
+	cmdline_fixed_string_t flow_type;
+	cmdline_fixed_string_t mask;
+};
+
+static void
+cmd_flow_director_flex_mask_parsed(void *parsed_result,
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
+{
+	struct cmd_flow_director_flex_mask_result *res = parsed_result;
+	struct rte_eth_fdir_info fdir_info;
+	struct rte_eth_fdir_flex_mask flex_mask;
+	struct rte_port *port;
+	uint64_t flow_type_mask;
+	uint16_t i;
+	int ret;
+
+	port = &ports[res->port_id];
+	/** Check if the port is not started **/
+	if (port->port_status != RTE_PORT_STOPPED) {
+		printf("Please stop port %d first\n", res->port_id);
+		return;
+	}
+
+	memset(&flex_mask, 0, sizeof(struct rte_eth_fdir_flex_mask));
+	ret = parse_flexbytes(res->mask,
+			flex_mask.mask,
+			RTE_ETH_FDIR_MAX_FLEXLEN);
+	if (ret < 0) {
+		printf("error: Cannot parse mask input.\n");
+		return;
+	}
+
+	memset(&fdir_info, 0, sizeof(fdir_info));
+	ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_FDIR,
+				RTE_ETH_FILTER_INFO, &fdir_info);
+	if (ret < 0) {
+		printf("Cannot get FDir filter info\n");
+		return;
+	}
+
+	if (!strcmp(res->flow_type, "none")) {
+		/* means don't specify the flow type */
+		flex_mask.flow_type = RTE_ETH_FLOW_UNKNOWN;
+		for (i = 0; i < RTE_ETH_FLOW_MAX; i++)
+			memset(&port->dev_conf.fdir_conf.flex_conf.flex_mask[i],
+			       0, sizeof(struct rte_eth_fdir_flex_mask));
+		port->dev_conf.fdir_conf.flex_conf.nb_flexmasks = 1;
+		rte_memcpy(&port->dev_conf.fdir_conf.flex_conf.flex_mask[0],
+				 &flex_mask,
+				 sizeof(struct rte_eth_fdir_flex_mask));
+		cmd_reconfig_device_queue(res->port_id, 1, 1);
+		return;
+	}
+	flow_type_mask = fdir_info.flow_types_mask[0];
+	if (!strcmp(res->flow_type, "all")) {
+		if (!flow_type_mask) {
+			printf("No flow type supported\n");
+			return;
+		}
+		for (i = RTE_ETH_FLOW_UNKNOWN; i < RTE_ETH_FLOW_MAX; i++) {
+			if (flow_type_mask & (1ULL << i)) {
+				flex_mask.flow_type = i;
+				fdir_set_flex_mask(res->port_id, &flex_mask);
+			}
+		}
+		cmd_reconfig_device_queue(res->port_id, 1, 1);
+		return;
+	}
+	flex_mask.flow_type = str2flowtype(res->flow_type);
+	if (!(flow_type_mask & (1ULL << flex_mask.flow_type))) {
+		printf("Flow type %s not supported on port %d\n",
+				res->flow_type, res->port_id);
+		return;
+	}
+	fdir_set_flex_mask(res->port_id, &flex_mask);
+	cmd_reconfig_device_queue(res->port_id, 1, 1);
+}
+
+cmdline_parse_token_string_t cmd_flow_director_flexmask =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_flex_mask_result,
+				 flow_director_flexmask,
+				 "flow_director_flex_mask");
+cmdline_parse_token_num_t cmd_flow_director_flexmask_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_flex_mask_result,
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_flexmask_flow =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_flex_mask_result,
+				 flow, "flow");
+cmdline_parse_token_string_t cmd_flow_director_flexmask_flow_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_flex_mask_result,
+		flow_type, "none#ipv4-other#ipv4-frag#ipv4-tcp#ipv4-udp#ipv4-sctp#"
+		"ipv6-other#ipv6-frag#ipv6-tcp#ipv6-udp#ipv6-sctp#l2_payload#all");
+cmdline_parse_token_string_t cmd_flow_director_flexmask_mask =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_flex_mask_result,
+				 mask, NULL);
+
+cmdline_parse_inst_t cmd_set_flow_director_flex_mask = {
+	.f = cmd_flow_director_flex_mask_parsed,
+	.data = NULL,
+	.help_str = "flow_director_flex_mask ... : "
+		"Set flow director's flex mask on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_flexmask,
+		(void *)&cmd_flow_director_flexmask_port_id,
+		(void *)&cmd_flow_director_flexmask_flow,
+		(void *)&cmd_flow_director_flexmask_flow_type,
+		(void *)&cmd_flow_director_flexmask_mask,
+		NULL,
+	},
+};
+
+/* *** deal with flow director flexible payload configuration *** */
+struct cmd_flow_director_flexpayload_result {
+	cmdline_fixed_string_t flow_director_flexpayload;
+	portid_t port_id;
+	cmdline_fixed_string_t payload_layer;
+	cmdline_fixed_string_t payload_cfg;
+};
+
+static inline int
+parse_offsets(const char *q_arg, uint16_t *offsets, uint16_t max_num)
+{
+	char s[256];
+	const char *p, *p0 = q_arg;
+	char *end;
+	unsigned long int_fld;
+	char *str_fld[max_num];
+	int i;
+	unsigned size;
+	int ret = -1;
+
+	p = strchr(p0, '(');
+	if (p == NULL)
+		return -1;
+	++p;
+	p0 = strchr(p, ')');
+	if (p0 == NULL)
+		return -1;
+
+	size = p0 - p;
+	if (size >= sizeof(s))
+		return -1;
+
+	snprintf(s, sizeof(s), "%.*s", size, p);
+	ret = rte_strsplit(s, sizeof(s), str_fld, max_num, ',');
+	if (ret < 0 || ret > max_num)
+		return -1;
+	for (i = 0; i < ret; i++) {
+		errno = 0;
+		int_fld = strtoul(str_fld[i], &end, 0);
+		if (errno != 0 || *end != '\0' || int_fld > UINT16_MAX)
+			return -1;
+		offsets[i] = (uint16_t)int_fld;
+	}
+	return ret;
+}
+
+static void
+cmd_flow_director_flxpld_parsed(void *parsed_result,
+			  __attribute__((unused)) struct cmdline *cl,
+			  __attribute__((unused)) void *data)
+{
+	struct cmd_flow_director_flexpayload_result *res = parsed_result;
+	struct rte_eth_flex_payload_cfg flex_cfg;
+	struct rte_port *port;
+	int ret = 0;
+
+	port = &ports[res->port_id];
+	/** Check if the port is not started **/
+	if (port->port_status != RTE_PORT_STOPPED) {
+		printf("Please stop port %d first\n", res->port_id);
+		return;
+	}
+
+	memset(&flex_cfg, 0, sizeof(struct rte_eth_flex_payload_cfg));
+
+	if (!strcmp(res->payload_layer, "raw"))
+		flex_cfg.type = RTE_ETH_RAW_PAYLOAD;
+	else if (!strcmp(res->payload_layer, "l2"))
+		flex_cfg.type = RTE_ETH_L2_PAYLOAD;
+	else if (!strcmp(res->payload_layer, "l3"))
+		flex_cfg.type = RTE_ETH_L3_PAYLOAD;
+	else if (!strcmp(res->payload_layer, "l4"))
+		flex_cfg.type = RTE_ETH_L4_PAYLOAD;
+
+	ret = parse_offsets(res->payload_cfg, flex_cfg.src_offset,
+			    RTE_ETH_FDIR_MAX_FLEXLEN);
+	if (ret < 0) {
+		printf("error: Cannot parse flex payload input.\n");
+		return;
+	}
+
+	fdir_set_flex_payload(res->port_id, &flex_cfg);
+	cmd_reconfig_device_queue(res->port_id, 1, 1);
+}
+
+cmdline_parse_token_string_t cmd_flow_director_flexpayload =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_flexpayload_result,
+				 flow_director_flexpayload,
+				 "flow_director_flex_payload");
+cmdline_parse_token_num_t cmd_flow_director_flexpayload_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_flow_director_flexpayload_result,
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_flow_director_flexpayload_payload_layer =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_flexpayload_result,
+				 payload_layer, "raw#l2#l3#l4");
+cmdline_parse_token_string_t cmd_flow_director_flexpayload_payload_cfg =
+	TOKEN_STRING_INITIALIZER(struct cmd_flow_director_flexpayload_result,
+				 payload_cfg, NULL);
+
+cmdline_parse_inst_t cmd_set_flow_director_flex_payload = {
+	.f = cmd_flow_director_flxpld_parsed,
+	.data = NULL,
+	.help_str = "flow_director_flexpayload ... : "
+		"Set flow director's flex payload on NIC",
+	.tokens = {
+		(void *)&cmd_flow_director_flexpayload,
+		(void *)&cmd_flow_director_flexpayload_port_id,
+		(void *)&cmd_flow_director_flexpayload_payload_layer,
+		(void *)&cmd_flow_director_flexpayload_payload_cfg,
+		NULL,
+	},
+};
+
 /* Generic flow interface command. */
 extern cmdline_parse_inst_t cmd_flow;
 
+/* *** Classification Filters Control *** */
+/* *** Get symmetric hash enable per port *** */
+struct cmd_get_sym_hash_ena_per_port_result {
+	cmdline_fixed_string_t get_sym_hash_ena_per_port;
+	portid_t port_id;
+};
+
+static void
+cmd_get_sym_hash_per_port_parsed(void *parsed_result,
+				 __rte_unused struct cmdline *cl,
+				 __rte_unused void *data)
+{
+	struct cmd_get_sym_hash_ena_per_port_result *res = parsed_result;
+	struct rte_eth_hash_filter_info info;
+	int ret;
+
+	if (rte_eth_dev_filter_supported(res->port_id,
+				RTE_ETH_FILTER_HASH) < 0) {
+		printf("RTE_ETH_FILTER_HASH not supported on port: %d\n",
+							res->port_id);
+		return;
+	}
+
+	memset(&info, 0, sizeof(info));
+	info.info_type = RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT;
+	ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_HASH,
+						RTE_ETH_FILTER_GET, &info);
+
+	if (ret < 0) {
+		printf("Cannot get symmetric hash enable per port "
+					"on port %u\n", res->port_id);
+		return;
+	}
+
+	printf("Symmetric hash is %s on port %u\n", info.info.enable ?
+				"enabled" : "disabled", res->port_id);
+}
+
+cmdline_parse_token_string_t cmd_get_sym_hash_ena_per_port_all =
+	TOKEN_STRING_INITIALIZER(struct cmd_get_sym_hash_ena_per_port_result,
+		get_sym_hash_ena_per_port, "get_sym_hash_ena_per_port");
+cmdline_parse_token_num_t cmd_get_sym_hash_ena_per_port_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_get_sym_hash_ena_per_port_result,
+		port_id, UINT16);
+
+cmdline_parse_inst_t cmd_get_sym_hash_ena_per_port = {
+	.f = cmd_get_sym_hash_per_port_parsed,
+	.data = NULL,
+	.help_str = "get_sym_hash_ena_per_port <port_id>",
+	.tokens = {
+		(void *)&cmd_get_sym_hash_ena_per_port_all,
+		(void *)&cmd_get_sym_hash_ena_per_port_port_id,
+		NULL,
+	},
+};
+
+/* *** Set symmetric hash enable per port *** */
+struct cmd_set_sym_hash_ena_per_port_result {
+	cmdline_fixed_string_t set_sym_hash_ena_per_port;
+	cmdline_fixed_string_t enable;
+	portid_t port_id;
+};
+
+static void
+cmd_set_sym_hash_per_port_parsed(void *parsed_result,
+				 __rte_unused struct cmdline *cl,
+				 __rte_unused void *data)
+{
+	struct cmd_set_sym_hash_ena_per_port_result *res = parsed_result;
+	struct rte_eth_hash_filter_info info;
+	int ret;
+
+	if (rte_eth_dev_filter_supported(res->port_id,
+				RTE_ETH_FILTER_HASH) < 0) {
+		printf("RTE_ETH_FILTER_HASH not supported on port: %d\n",
+							res->port_id);
+		return;
+	}
+
+	memset(&info, 0, sizeof(info));
+	info.info_type = RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT;
+	if (!strcmp(res->enable, "enable"))
+		info.info.enable = 1;
+	ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_HASH,
+					RTE_ETH_FILTER_SET, &info);
+	if (ret < 0) {
+		printf("Cannot set symmetric hash enable per port on "
+					"port %u\n", res->port_id);
+		return;
+	}
+	printf("Symmetric hash has been set to %s on port %u\n",
+					res->enable, res->port_id);
+}
+
+cmdline_parse_token_string_t cmd_set_sym_hash_ena_per_port_all =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_sym_hash_ena_per_port_result,
+		set_sym_hash_ena_per_port, "set_sym_hash_ena_per_port");
+cmdline_parse_token_num_t cmd_set_sym_hash_ena_per_port_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_sym_hash_ena_per_port_result,
+		port_id, UINT16);
+cmdline_parse_token_string_t cmd_set_sym_hash_ena_per_port_enable =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_sym_hash_ena_per_port_result,
+		enable, "enable#disable");
+
+cmdline_parse_inst_t cmd_set_sym_hash_ena_per_port = {
+	.f = cmd_set_sym_hash_per_port_parsed,
+	.data = NULL,
+	.help_str = "set_sym_hash_ena_per_port <port_id> enable|disable",
+	.tokens = {
+		(void *)&cmd_set_sym_hash_ena_per_port_all,
+		(void *)&cmd_set_sym_hash_ena_per_port_port_id,
+		(void *)&cmd_set_sym_hash_ena_per_port_enable,
+		NULL,
+	},
+};
+
+/* Get global config of hash function */
+struct cmd_get_hash_global_config_result {
+	cmdline_fixed_string_t get_hash_global_config;
+	portid_t port_id;
+};
+
+static char *
+flowtype_to_str(uint16_t ftype)
+{
+	uint16_t i;
+	static struct {
+		char str[16];
+		uint16_t ftype;
+	} ftype_table[] = {
+		{"ipv4", RTE_ETH_FLOW_IPV4},
+		{"ipv4-frag", RTE_ETH_FLOW_FRAG_IPV4},
+		{"ipv4-tcp", RTE_ETH_FLOW_NONFRAG_IPV4_TCP},
+		{"ipv4-udp", RTE_ETH_FLOW_NONFRAG_IPV4_UDP},
+		{"ipv4-sctp", RTE_ETH_FLOW_NONFRAG_IPV4_SCTP},
+		{"ipv4-other", RTE_ETH_FLOW_NONFRAG_IPV4_OTHER},
+		{"ipv6", RTE_ETH_FLOW_IPV6},
+		{"ipv6-frag", RTE_ETH_FLOW_FRAG_IPV6},
+		{"ipv6-tcp", RTE_ETH_FLOW_NONFRAG_IPV6_TCP},
+		{"ipv6-udp", RTE_ETH_FLOW_NONFRAG_IPV6_UDP},
+		{"ipv6-sctp", RTE_ETH_FLOW_NONFRAG_IPV6_SCTP},
+		{"ipv6-other", RTE_ETH_FLOW_NONFRAG_IPV6_OTHER},
+		{"l2_payload", RTE_ETH_FLOW_L2_PAYLOAD},
+		{"port", RTE_ETH_FLOW_PORT},
+		{"vxlan", RTE_ETH_FLOW_VXLAN},
+		{"geneve", RTE_ETH_FLOW_GENEVE},
+		{"nvgre", RTE_ETH_FLOW_NVGRE},
+		{"vxlan-gpe", RTE_ETH_FLOW_VXLAN_GPE},
+	};
+
+	for (i = 0; i < RTE_DIM(ftype_table); i++) {
+		if (ftype_table[i].ftype == ftype)
+			return ftype_table[i].str;
+	}
+
+	return NULL;
+}
+
+static void
+cmd_get_hash_global_config_parsed(void *parsed_result,
+				  __rte_unused struct cmdline *cl,
+				  __rte_unused void *data)
+{
+	struct cmd_get_hash_global_config_result *res = parsed_result;
+	struct rte_eth_hash_filter_info info;
+	uint32_t idx, offset;
+	uint16_t i;
+	char *str;
+	int ret;
+
+	if (rte_eth_dev_filter_supported(res->port_id,
+			RTE_ETH_FILTER_HASH) < 0) {
+		printf("RTE_ETH_FILTER_HASH not supported on port %d\n",
+							res->port_id);
+		return;
+	}
+
+	memset(&info, 0, sizeof(info));
+	info.info_type = RTE_ETH_HASH_FILTER_GLOBAL_CONFIG;
+	ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_HASH,
+					RTE_ETH_FILTER_GET, &info);
+	if (ret < 0) {
+		printf("Cannot get hash global configurations by port %d\n",
+							res->port_id);
+		return;
+	}
+
+	switch (info.info.global_conf.hash_func) {
+	case RTE_ETH_HASH_FUNCTION_TOEPLITZ:
+		printf("Hash function is Toeplitz\n");
+		break;
+	case RTE_ETH_HASH_FUNCTION_SIMPLE_XOR:
+		printf("Hash function is Simple XOR\n");
+		break;
+	case RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ:
+		printf("Hash function is Symmetric Toeplitz\n");
+		break;
+	default:
+		printf("Unknown hash function\n");
+		break;
+	}
+
+	for (i = 0; i < RTE_ETH_FLOW_MAX; i++) {
+		idx = i / UINT64_BIT;
+		offset = i % UINT64_BIT;
+		if (!(info.info.global_conf.valid_bit_mask[idx] &
+						(1ULL << offset)))
+			continue;
+		str = flowtype_to_str(i);
+		if (!str)
+			continue;
+		printf("Symmetric hash is %s globally for flow type %s "
+							"by port %d\n",
+			((info.info.global_conf.sym_hash_enable_mask[idx] &
+			(1ULL << offset)) ? "enabled" : "disabled"), str,
+							res->port_id);
+	}
+}
+
+cmdline_parse_token_string_t cmd_get_hash_global_config_all =
+	TOKEN_STRING_INITIALIZER(struct cmd_get_hash_global_config_result,
+		get_hash_global_config, "get_hash_global_config");
+cmdline_parse_token_num_t cmd_get_hash_global_config_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_get_hash_global_config_result,
+		port_id, UINT16);
+
+cmdline_parse_inst_t cmd_get_hash_global_config = {
+	.f = cmd_get_hash_global_config_parsed,
+	.data = NULL,
+	.help_str = "get_hash_global_config <port_id>",
+	.tokens = {
+		(void *)&cmd_get_hash_global_config_all,
+		(void *)&cmd_get_hash_global_config_port_id,
+		NULL,
+	},
+};
+
+/* Set global config of hash function */
+struct cmd_set_hash_global_config_result {
+	cmdline_fixed_string_t set_hash_global_config;
+	portid_t port_id;
+	cmdline_fixed_string_t hash_func;
+	cmdline_fixed_string_t flow_type;
+	cmdline_fixed_string_t enable;
+};
+
+static void
+cmd_set_hash_global_config_parsed(void *parsed_result,
+				  __rte_unused struct cmdline *cl,
+				  __rte_unused void *data)
+{
+	struct cmd_set_hash_global_config_result *res = parsed_result;
+	struct rte_eth_hash_filter_info info;
+	uint32_t ftype, idx, offset;
+	int ret;
+
+	if (rte_eth_dev_filter_supported(res->port_id,
+				RTE_ETH_FILTER_HASH) < 0) {
+		printf("RTE_ETH_FILTER_HASH not supported on port %d\n",
+							res->port_id);
+		return;
+	}
+	memset(&info, 0, sizeof(info));
+	info.info_type = RTE_ETH_HASH_FILTER_GLOBAL_CONFIG;
+	if (!strcmp(res->hash_func, "toeplitz"))
+		info.info.global_conf.hash_func =
+			RTE_ETH_HASH_FUNCTION_TOEPLITZ;
+	else if (!strcmp(res->hash_func, "simple_xor"))
+		info.info.global_conf.hash_func =
+			RTE_ETH_HASH_FUNCTION_SIMPLE_XOR;
+	else if (!strcmp(res->hash_func, "symmetric_toeplitz"))
+		info.info.global_conf.hash_func =
+			RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ;
+	else if (!strcmp(res->hash_func, "default"))
+		info.info.global_conf.hash_func =
+			RTE_ETH_HASH_FUNCTION_DEFAULT;
+
+	ftype = str2flowtype(res->flow_type);
+	idx = ftype / UINT64_BIT;
+	offset = ftype % UINT64_BIT;
+	info.info.global_conf.valid_bit_mask[idx] |= (1ULL << offset);
+	if (!strcmp(res->enable, "enable"))
+		info.info.global_conf.sym_hash_enable_mask[idx] |=
+						(1ULL << offset);
+	ret = rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_HASH,
+					RTE_ETH_FILTER_SET, &info);
+	if (ret < 0)
+		printf("Cannot set global hash configurations by port %d\n",
+							res->port_id);
+	else
+		printf("Global hash configurations have been set "
+			"successfully by port %d\n", res->port_id);
+}
+
+cmdline_parse_token_string_t cmd_set_hash_global_config_all =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_hash_global_config_result,
+		set_hash_global_config, "set_hash_global_config");
+cmdline_parse_token_num_t cmd_set_hash_global_config_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_hash_global_config_result,
+		port_id, UINT16);
+cmdline_parse_token_string_t cmd_set_hash_global_config_hash_func =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_hash_global_config_result,
+		hash_func, "toeplitz#simple_xor#symmetric_toeplitz#default");
+cmdline_parse_token_string_t cmd_set_hash_global_config_flow_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_hash_global_config_result,
+		flow_type,
+		"ipv4#ipv4-frag#ipv4-tcp#ipv4-udp#ipv4-sctp#ipv4-other#ipv6#"
+		"ipv6-frag#ipv6-tcp#ipv6-udp#ipv6-sctp#ipv6-other#l2_payload");
+cmdline_parse_token_string_t cmd_set_hash_global_config_enable =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_hash_global_config_result,
+		enable, "enable#disable");
+
+cmdline_parse_inst_t cmd_set_hash_global_config = {
+	.f = cmd_set_hash_global_config_parsed,
+	.data = NULL,
+	.help_str = "set_hash_global_config <port_id> "
+		"toeplitz|simple_xor|symmetric_toeplitz|default "
+		"ipv4|ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|ipv4-other|"
+		"ipv6|ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|ipv6-other|"
+		"l2_payload enable|disable",
+	.tokens = {
+		(void *)&cmd_set_hash_global_config_all,
+		(void *)&cmd_set_hash_global_config_port_id,
+		(void *)&cmd_set_hash_global_config_hash_func,
+		(void *)&cmd_set_hash_global_config_flow_type,
+		(void *)&cmd_set_hash_global_config_enable,
+		NULL,
+	},
+};
+
+/* Set hash input set */
+struct cmd_set_hash_input_set_result {
+	cmdline_fixed_string_t set_hash_input_set;
+	portid_t port_id;
+	cmdline_fixed_string_t flow_type;
+	cmdline_fixed_string_t inset_field;
+	cmdline_fixed_string_t select;
+};
+
+static enum rte_eth_input_set_field
+str2inset(char *string)
+{
+	uint16_t i;
+
+	static const struct {
+		char str[32];
+		enum rte_eth_input_set_field inset;
+	} inset_table[] = {
+		{"ethertype", RTE_ETH_INPUT_SET_L2_ETHERTYPE},
+		{"ovlan", RTE_ETH_INPUT_SET_L2_OUTER_VLAN},
+		{"ivlan", RTE_ETH_INPUT_SET_L2_INNER_VLAN},
+		{"src-ipv4", RTE_ETH_INPUT_SET_L3_SRC_IP4},
+		{"dst-ipv4", RTE_ETH_INPUT_SET_L3_DST_IP4},
+		{"ipv4-tos", RTE_ETH_INPUT_SET_L3_IP4_TOS},
+		{"ipv4-proto", RTE_ETH_INPUT_SET_L3_IP4_PROTO},
+		{"ipv4-ttl", RTE_ETH_INPUT_SET_L3_IP4_TTL},
+		{"src-ipv6", RTE_ETH_INPUT_SET_L3_SRC_IP6},
+		{"dst-ipv6", RTE_ETH_INPUT_SET_L3_DST_IP6},
+		{"ipv6-tc", RTE_ETH_INPUT_SET_L3_IP6_TC},
+		{"ipv6-next-header", RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER},
+		{"ipv6-hop-limits", RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS},
+		{"udp-src-port", RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT},
+		{"udp-dst-port", RTE_ETH_INPUT_SET_L4_UDP_DST_PORT},
+		{"tcp-src-port", RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT},
+		{"tcp-dst-port", RTE_ETH_INPUT_SET_L4_TCP_DST_PORT},
+		{"sctp-src-port", RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT},
+		{"sctp-dst-port", RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT},
+		{"sctp-veri-tag", RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG},
+		{"udp-key", RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY},
+		{"gre-key", RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY},
+		{"fld-1st", RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD},
+		{"fld-2nd", RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD},
+		{"fld-3rd", RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD},
+		{"fld-4th", RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD},
+		{"fld-5th", RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD},
+		{"fld-6th", RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD},
+		{"fld-7th", RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD},
+		{"fld-8th", RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD},
+		{"none", RTE_ETH_INPUT_SET_NONE},
+	};
+
+	for (i = 0; i < RTE_DIM(inset_table); i++) {
+		if (!strcmp(string, inset_table[i].str))
+			return inset_table[i].inset;
+	}
+
+	return RTE_ETH_INPUT_SET_UNKNOWN;
+}
+
+static void
+cmd_set_hash_input_set_parsed(void *parsed_result,
+			      __rte_unused struct cmdline *cl,
+			      __rte_unused void *data)
+{
+	struct cmd_set_hash_input_set_result *res = parsed_result;
+	struct rte_eth_hash_filter_info info;
+
+	memset(&info, 0, sizeof(info));
+	info.info_type = RTE_ETH_HASH_FILTER_INPUT_SET_SELECT;
+	info.info.input_set_conf.flow_type = str2flowtype(res->flow_type);
+	info.info.input_set_conf.field[0] = str2inset(res->inset_field);
+	info.info.input_set_conf.inset_size = 1;
+	if (!strcmp(res->select, "select"))
+		info.info.input_set_conf.op = RTE_ETH_INPUT_SET_SELECT;
+	else if (!strcmp(res->select, "add"))
+		info.info.input_set_conf.op = RTE_ETH_INPUT_SET_ADD;
+	rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_HASH,
+				RTE_ETH_FILTER_SET, &info);
+}
+
+cmdline_parse_token_string_t cmd_set_hash_input_set_cmd =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_hash_input_set_result,
+		set_hash_input_set, "set_hash_input_set");
+cmdline_parse_token_num_t cmd_set_hash_input_set_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_hash_input_set_result,
+		port_id, UINT16);
+cmdline_parse_token_string_t cmd_set_hash_input_set_flow_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_hash_input_set_result,
+		flow_type, NULL);
+cmdline_parse_token_string_t cmd_set_hash_input_set_field =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_hash_input_set_result,
+		inset_field,
+		"ovlan#ivlan#src-ipv4#dst-ipv4#src-ipv6#dst-ipv6#"
+		"ipv4-tos#ipv4-proto#ipv6-tc#ipv6-next-header#udp-src-port#"
+		"udp-dst-port#tcp-src-port#tcp-dst-port#sctp-src-port#"
+		"sctp-dst-port#sctp-veri-tag#udp-key#gre-key#fld-1st#"
+		"fld-2nd#fld-3rd#fld-4th#fld-5th#fld-6th#fld-7th#"
+		"fld-8th#none");
+cmdline_parse_token_string_t cmd_set_hash_input_set_select =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_hash_input_set_result,
+		select, "select#add");
+
+cmdline_parse_inst_t cmd_set_hash_input_set = {
+	.f = cmd_set_hash_input_set_parsed,
+	.data = NULL,
+	.help_str = "set_hash_input_set <port_id> "
+	"ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|ipv4-other|"
+	"ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|ipv6-other|l2_payload|<flowtype_id> "
+	"ovlan|ivlan|src-ipv4|dst-ipv4|src-ipv6|dst-ipv6|ipv4-tos|ipv4-proto|"
+	"ipv6-tc|ipv6-next-header|udp-src-port|udp-dst-port|tcp-src-port|"
+	"tcp-dst-port|sctp-src-port|sctp-dst-port|sctp-veri-tag|udp-key|"
+	"gre-key|fld-1st|fld-2nd|fld-3rd|fld-4th|fld-5th|fld-6th|"
+	"fld-7th|fld-8th|none select|add",
+	.tokens = {
+		(void *)&cmd_set_hash_input_set_cmd,
+		(void *)&cmd_set_hash_input_set_port_id,
+		(void *)&cmd_set_hash_input_set_flow_type,
+		(void *)&cmd_set_hash_input_set_field,
+		(void *)&cmd_set_hash_input_set_select,
+		NULL,
+	},
+};
+
+/* Set flow director input set */
+struct cmd_set_fdir_input_set_result {
+	cmdline_fixed_string_t set_fdir_input_set;
+	portid_t port_id;
+	cmdline_fixed_string_t flow_type;
+	cmdline_fixed_string_t inset_field;
+	cmdline_fixed_string_t select;
+};
+
+static void
+cmd_set_fdir_input_set_parsed(void *parsed_result,
+	__rte_unused struct cmdline *cl,
+	__rte_unused void *data)
+{
+	struct cmd_set_fdir_input_set_result *res = parsed_result;
+	struct rte_eth_fdir_filter_info info;
+
+	memset(&info, 0, sizeof(info));
+	info.info_type = RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT;
+	info.info.input_set_conf.flow_type = str2flowtype(res->flow_type);
+	info.info.input_set_conf.field[0] = str2inset(res->inset_field);
+	info.info.input_set_conf.inset_size = 1;
+	if (!strcmp(res->select, "select"))
+		info.info.input_set_conf.op = RTE_ETH_INPUT_SET_SELECT;
+	else if (!strcmp(res->select, "add"))
+		info.info.input_set_conf.op = RTE_ETH_INPUT_SET_ADD;
+	rte_eth_dev_filter_ctrl(res->port_id, RTE_ETH_FILTER_FDIR,
+		RTE_ETH_FILTER_SET, &info);
+}
+
+cmdline_parse_token_string_t cmd_set_fdir_input_set_cmd =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_fdir_input_set_result,
+	set_fdir_input_set, "set_fdir_input_set");
+cmdline_parse_token_num_t cmd_set_fdir_input_set_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_fdir_input_set_result,
+	port_id, UINT16);
+cmdline_parse_token_string_t cmd_set_fdir_input_set_flow_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_fdir_input_set_result,
+	flow_type,
+	"ipv4-frag#ipv4-tcp#ipv4-udp#ipv4-sctp#ipv4-other#"
+	"ipv6-frag#ipv6-tcp#ipv6-udp#ipv6-sctp#ipv6-other#l2_payload");
+cmdline_parse_token_string_t cmd_set_fdir_input_set_field =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_fdir_input_set_result,
+	inset_field,
+	"ivlan#ethertype#src-ipv4#dst-ipv4#src-ipv6#dst-ipv6#"
+	"ipv4-tos#ipv4-proto#ipv4-ttl#ipv6-tc#ipv6-next-header#"
+	"ipv6-hop-limits#udp-src-port#udp-dst-port#"
+	"tcp-src-port#tcp-dst-port#sctp-src-port#sctp-dst-port#"
+	"sctp-veri-tag#none");
+cmdline_parse_token_string_t cmd_set_fdir_input_set_select =
+	TOKEN_STRING_INITIALIZER(struct cmd_set_fdir_input_set_result,
+	select, "select#add");
+
+cmdline_parse_inst_t cmd_set_fdir_input_set = {
+	.f = cmd_set_fdir_input_set_parsed,
+	.data = NULL,
+	.help_str = "set_fdir_input_set <port_id> "
+	"ipv4-frag|ipv4-tcp|ipv4-udp|ipv4-sctp|ipv4-other|"
+	"ipv6-frag|ipv6-tcp|ipv6-udp|ipv6-sctp|ipv6-other|l2_payload "
+	"ivlan|ethertype|src-ipv4|dst-ipv4|src-ipv6|dst-ipv6|"
+	"ipv4-tos|ipv4-proto|ipv4-ttl|ipv6-tc|ipv6-next-header|"
+	"ipv6-hop-limits|udp-src-port|udp-dst-port|"
+	"tcp-src-port|tcp-dst-port|sctp-src-port|sctp-dst-port|"
+	"sctp-veri-tag|none select|add",
+	.tokens = {
+		(void *)&cmd_set_fdir_input_set_cmd,
+		(void *)&cmd_set_fdir_input_set_port_id,
+		(void *)&cmd_set_fdir_input_set_flow_type,
+		(void *)&cmd_set_fdir_input_set_field,
+		(void *)&cmd_set_fdir_input_set_select,
+		NULL,
+	},
+};
+
 /* *** ADD/REMOVE A MULTICAST MAC ADDRESS TO/FROM A PORT *** */
 struct cmd_mcast_addr_result {
 	cmdline_fixed_string_t mcast_addr_cmd;
@@ -8455,15 +12622,16 @@
 };
 
 static void cmd_mcast_addr_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_mcast_addr_result *res = parsed_result;
 
 	if (!rte_is_multicast_ether_addr(&res->mc_addr)) {
-		fprintf(stderr,
-			"Invalid multicast addr " RTE_ETHER_ADDR_PRT_FMT "\n",
-			RTE_ETHER_ADDR_BYTES(&res->mc_addr));
+		printf("Invalid multicast addr %02X:%02X:%02X:%02X:%02X:%02X\n",
+		       res->mc_addr.addr_bytes[0], res->mc_addr.addr_bytes[1],
+		       res->mc_addr.addr_bytes[2], res->mc_addr.addr_bytes[3],
+		       res->mc_addr.addr_bytes[4], res->mc_addr.addr_bytes[5]);
 		return;
 	}
 	if (strcmp(res->what, "add") == 0)
@@ -8472,19 +12640,18 @@
 		mcast_addr_remove(res->port_num, &res->mc_addr);
 }
 
-static cmdline_parse_token_string_t cmd_mcast_addr_cmd =
+cmdline_parse_token_string_t cmd_mcast_addr_cmd =
 	TOKEN_STRING_INITIALIZER(struct cmd_mcast_addr_result,
 				 mcast_addr_cmd, "mcast_addr");
-static cmdline_parse_token_string_t cmd_mcast_addr_what =
+cmdline_parse_token_string_t cmd_mcast_addr_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_mcast_addr_result, what,
 				 "add#remove");
-static cmdline_parse_token_num_t cmd_mcast_addr_portnum =
-	TOKEN_NUM_INITIALIZER(struct cmd_mcast_addr_result, port_num,
-				 RTE_UINT16);
-static cmdline_parse_token_etheraddr_t cmd_mcast_addr_addr =
+cmdline_parse_token_num_t cmd_mcast_addr_portnum =
+	TOKEN_NUM_INITIALIZER(struct cmd_mcast_addr_result, port_num, UINT16);
+cmdline_parse_token_etheraddr_t cmd_mcast_addr_addr =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_mac_addr_result, address);
 
-static cmdline_parse_inst_t cmd_mcast_addr = {
+cmdline_parse_inst_t cmd_mcast_addr = {
 	.f = cmd_mcast_addr_parsed,
 	.data = (void *)0,
 	.help_str = "mcast_addr add|remove <port_id> <mcast_addr>: "
@@ -8498,6 +12665,667 @@
 	},
 };
 
+/* l2 tunnel config
+ * only support E-tag now.
+ */
+
+/* Ether type config */
+struct cmd_config_l2_tunnel_eth_type_result {
+	cmdline_fixed_string_t port;
+	cmdline_fixed_string_t config;
+	cmdline_fixed_string_t all;
+	portid_t id;
+	cmdline_fixed_string_t l2_tunnel;
+	cmdline_fixed_string_t l2_tunnel_type;
+	cmdline_fixed_string_t eth_type;
+	uint16_t eth_type_val;
+};
+
+cmdline_parse_token_string_t cmd_config_l2_tunnel_eth_type_port =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_eth_type_result,
+		 port, "port");
+cmdline_parse_token_string_t cmd_config_l2_tunnel_eth_type_config =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_eth_type_result,
+		 config, "config");
+cmdline_parse_token_string_t cmd_config_l2_tunnel_eth_type_all_str =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_eth_type_result,
+		 all, "all");
+cmdline_parse_token_num_t cmd_config_l2_tunnel_eth_type_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_config_l2_tunnel_eth_type_result,
+		 id, UINT16);
+cmdline_parse_token_string_t cmd_config_l2_tunnel_eth_type_l2_tunnel =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_eth_type_result,
+		 l2_tunnel, "l2-tunnel");
+cmdline_parse_token_string_t cmd_config_l2_tunnel_eth_type_l2_tunnel_type =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_eth_type_result,
+		 l2_tunnel_type, "E-tag");
+cmdline_parse_token_string_t cmd_config_l2_tunnel_eth_type_eth_type =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_eth_type_result,
+		 eth_type, "ether-type");
+cmdline_parse_token_num_t cmd_config_l2_tunnel_eth_type_eth_type_val =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_config_l2_tunnel_eth_type_result,
+		 eth_type_val, UINT16);
+
+static enum rte_eth_tunnel_type
+str2fdir_l2_tunnel_type(char *string)
+{
+	uint32_t i = 0;
+
+	static const struct {
+		char str[32];
+		enum rte_eth_tunnel_type type;
+	} l2_tunnel_type_str[] = {
+		{"E-tag", RTE_L2_TUNNEL_TYPE_E_TAG},
+	};
+
+	for (i = 0; i < RTE_DIM(l2_tunnel_type_str); i++) {
+		if (!strcmp(l2_tunnel_type_str[i].str, string))
+			return l2_tunnel_type_str[i].type;
+	}
+	return RTE_TUNNEL_TYPE_NONE;
+}
+
+/* ether type config for all ports */
+static void
+cmd_config_l2_tunnel_eth_type_all_parsed
+	(void *parsed_result,
+	 __attribute__((unused)) struct cmdline *cl,
+	 __attribute__((unused)) void *data)
+{
+	struct cmd_config_l2_tunnel_eth_type_result *res = parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+	portid_t pid;
+
+	entry.l2_tunnel_type = str2fdir_l2_tunnel_type(res->l2_tunnel_type);
+	entry.ether_type = res->eth_type_val;
+
+	RTE_ETH_FOREACH_DEV(pid) {
+		rte_eth_dev_l2_tunnel_eth_type_conf(pid, &entry);
+	}
+}
+
+cmdline_parse_inst_t cmd_config_l2_tunnel_eth_type_all = {
+	.f = cmd_config_l2_tunnel_eth_type_all_parsed,
+	.data = NULL,
+	.help_str = "port config all l2-tunnel E-tag ether-type <value>",
+	.tokens = {
+		(void *)&cmd_config_l2_tunnel_eth_type_port,
+		(void *)&cmd_config_l2_tunnel_eth_type_config,
+		(void *)&cmd_config_l2_tunnel_eth_type_all_str,
+		(void *)&cmd_config_l2_tunnel_eth_type_l2_tunnel,
+		(void *)&cmd_config_l2_tunnel_eth_type_l2_tunnel_type,
+		(void *)&cmd_config_l2_tunnel_eth_type_eth_type,
+		(void *)&cmd_config_l2_tunnel_eth_type_eth_type_val,
+		NULL,
+	},
+};
+
+/* ether type config for a specific port */
+static void
+cmd_config_l2_tunnel_eth_type_specific_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_config_l2_tunnel_eth_type_result *res =
+		 parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+
+	if (port_id_is_invalid(res->id, ENABLED_WARN))
+		return;
+
+	entry.l2_tunnel_type = str2fdir_l2_tunnel_type(res->l2_tunnel_type);
+	entry.ether_type = res->eth_type_val;
+
+	rte_eth_dev_l2_tunnel_eth_type_conf(res->id, &entry);
+}
+
+cmdline_parse_inst_t cmd_config_l2_tunnel_eth_type_specific = {
+	.f = cmd_config_l2_tunnel_eth_type_specific_parsed,
+	.data = NULL,
+	.help_str = "port config <port_id> l2-tunnel E-tag ether-type <value>",
+	.tokens = {
+		(void *)&cmd_config_l2_tunnel_eth_type_port,
+		(void *)&cmd_config_l2_tunnel_eth_type_config,
+		(void *)&cmd_config_l2_tunnel_eth_type_id,
+		(void *)&cmd_config_l2_tunnel_eth_type_l2_tunnel,
+		(void *)&cmd_config_l2_tunnel_eth_type_l2_tunnel_type,
+		(void *)&cmd_config_l2_tunnel_eth_type_eth_type,
+		(void *)&cmd_config_l2_tunnel_eth_type_eth_type_val,
+		NULL,
+	},
+};
+
+/* Enable/disable l2 tunnel */
+struct cmd_config_l2_tunnel_en_dis_result {
+	cmdline_fixed_string_t port;
+	cmdline_fixed_string_t config;
+	cmdline_fixed_string_t all;
+	portid_t id;
+	cmdline_fixed_string_t l2_tunnel;
+	cmdline_fixed_string_t l2_tunnel_type;
+	cmdline_fixed_string_t en_dis;
+};
+
+cmdline_parse_token_string_t cmd_config_l2_tunnel_en_dis_port =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_en_dis_result,
+		 port, "port");
+cmdline_parse_token_string_t cmd_config_l2_tunnel_en_dis_config =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_en_dis_result,
+		 config, "config");
+cmdline_parse_token_string_t cmd_config_l2_tunnel_en_dis_all_str =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_en_dis_result,
+		 all, "all");
+cmdline_parse_token_num_t cmd_config_l2_tunnel_en_dis_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_config_l2_tunnel_en_dis_result,
+		 id, UINT16);
+cmdline_parse_token_string_t cmd_config_l2_tunnel_en_dis_l2_tunnel =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_en_dis_result,
+		 l2_tunnel, "l2-tunnel");
+cmdline_parse_token_string_t cmd_config_l2_tunnel_en_dis_l2_tunnel_type =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_en_dis_result,
+		 l2_tunnel_type, "E-tag");
+cmdline_parse_token_string_t cmd_config_l2_tunnel_en_dis_en_dis =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_l2_tunnel_en_dis_result,
+		 en_dis, "enable#disable");
+
+/* enable/disable l2 tunnel for all ports */
+static void
+cmd_config_l2_tunnel_en_dis_all_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_config_l2_tunnel_en_dis_result *res = parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+	portid_t pid;
+	uint8_t en;
+
+	entry.l2_tunnel_type = str2fdir_l2_tunnel_type(res->l2_tunnel_type);
+
+	if (!strcmp("enable", res->en_dis))
+		en = 1;
+	else
+		en = 0;
+
+	RTE_ETH_FOREACH_DEV(pid) {
+		rte_eth_dev_l2_tunnel_offload_set(pid,
+						  &entry,
+						  ETH_L2_TUNNEL_ENABLE_MASK,
+						  en);
+	}
+}
+
+cmdline_parse_inst_t cmd_config_l2_tunnel_en_dis_all = {
+	.f = cmd_config_l2_tunnel_en_dis_all_parsed,
+	.data = NULL,
+	.help_str = "port config all l2-tunnel E-tag enable|disable",
+	.tokens = {
+		(void *)&cmd_config_l2_tunnel_en_dis_port,
+		(void *)&cmd_config_l2_tunnel_en_dis_config,
+		(void *)&cmd_config_l2_tunnel_en_dis_all_str,
+		(void *)&cmd_config_l2_tunnel_en_dis_l2_tunnel,
+		(void *)&cmd_config_l2_tunnel_en_dis_l2_tunnel_type,
+		(void *)&cmd_config_l2_tunnel_en_dis_en_dis,
+		NULL,
+	},
+};
+
+/* enable/disable l2 tunnel for a port */
+static void
+cmd_config_l2_tunnel_en_dis_specific_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_config_l2_tunnel_en_dis_result *res =
+		parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+
+	if (port_id_is_invalid(res->id, ENABLED_WARN))
+		return;
+
+	entry.l2_tunnel_type = str2fdir_l2_tunnel_type(res->l2_tunnel_type);
+
+	if (!strcmp("enable", res->en_dis))
+		rte_eth_dev_l2_tunnel_offload_set(res->id,
+						  &entry,
+						  ETH_L2_TUNNEL_ENABLE_MASK,
+						  1);
+	else
+		rte_eth_dev_l2_tunnel_offload_set(res->id,
+						  &entry,
+						  ETH_L2_TUNNEL_ENABLE_MASK,
+						  0);
+}
+
+cmdline_parse_inst_t cmd_config_l2_tunnel_en_dis_specific = {
+	.f = cmd_config_l2_tunnel_en_dis_specific_parsed,
+	.data = NULL,
+	.help_str = "port config <port_id> l2-tunnel E-tag enable|disable",
+	.tokens = {
+		(void *)&cmd_config_l2_tunnel_en_dis_port,
+		(void *)&cmd_config_l2_tunnel_en_dis_config,
+		(void *)&cmd_config_l2_tunnel_en_dis_id,
+		(void *)&cmd_config_l2_tunnel_en_dis_l2_tunnel,
+		(void *)&cmd_config_l2_tunnel_en_dis_l2_tunnel_type,
+		(void *)&cmd_config_l2_tunnel_en_dis_en_dis,
+		NULL,
+	},
+};
+
+/* E-tag configuration */
+
+/* Common result structure for all E-tag configuration */
+struct cmd_config_e_tag_result {
+	cmdline_fixed_string_t e_tag;
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t insertion;
+	cmdline_fixed_string_t stripping;
+	cmdline_fixed_string_t forwarding;
+	cmdline_fixed_string_t filter;
+	cmdline_fixed_string_t add;
+	cmdline_fixed_string_t del;
+	cmdline_fixed_string_t on;
+	cmdline_fixed_string_t off;
+	cmdline_fixed_string_t on_off;
+	cmdline_fixed_string_t port_tag_id;
+	uint32_t port_tag_id_val;
+	cmdline_fixed_string_t e_tag_id;
+	uint16_t e_tag_id_val;
+	cmdline_fixed_string_t dst_pool;
+	uint8_t dst_pool_val;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t vf;
+	uint8_t vf_id;
+};
+
+/* Common CLI fields for all E-tag configuration */
+cmdline_parse_token_string_t cmd_config_e_tag_e_tag =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 e_tag, "E-tag");
+cmdline_parse_token_string_t cmd_config_e_tag_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_config_e_tag_insertion =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 insertion, "insertion");
+cmdline_parse_token_string_t cmd_config_e_tag_stripping =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 stripping, "stripping");
+cmdline_parse_token_string_t cmd_config_e_tag_forwarding =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 forwarding, "forwarding");
+cmdline_parse_token_string_t cmd_config_e_tag_filter =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 filter, "filter");
+cmdline_parse_token_string_t cmd_config_e_tag_add =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 add, "add");
+cmdline_parse_token_string_t cmd_config_e_tag_del =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 del, "del");
+cmdline_parse_token_string_t cmd_config_e_tag_on =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 on, "on");
+cmdline_parse_token_string_t cmd_config_e_tag_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 off, "off");
+cmdline_parse_token_string_t cmd_config_e_tag_on_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 on_off, "on#off");
+cmdline_parse_token_string_t cmd_config_e_tag_port_tag_id =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 port_tag_id, "port-tag-id");
+cmdline_parse_token_num_t cmd_config_e_tag_port_tag_id_val =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 port_tag_id_val, UINT32);
+cmdline_parse_token_string_t cmd_config_e_tag_e_tag_id =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 e_tag_id, "e-tag-id");
+cmdline_parse_token_num_t cmd_config_e_tag_e_tag_id_val =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 e_tag_id_val, UINT16);
+cmdline_parse_token_string_t cmd_config_e_tag_dst_pool =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 dst_pool, "dst-pool");
+cmdline_parse_token_num_t cmd_config_e_tag_dst_pool_val =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 dst_pool_val, UINT8);
+cmdline_parse_token_string_t cmd_config_e_tag_port =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 port, "port");
+cmdline_parse_token_num_t cmd_config_e_tag_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_e_tag_vf =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 vf, "vf");
+cmdline_parse_token_num_t cmd_config_e_tag_vf_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_config_e_tag_result,
+		 vf_id, UINT8);
+
+/* E-tag insertion configuration */
+static void
+cmd_config_e_tag_insertion_en_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_config_e_tag_result *res =
+		parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+	entry.l2_tunnel_type = RTE_L2_TUNNEL_TYPE_E_TAG;
+	entry.tunnel_id = res->port_tag_id_val;
+	entry.vf_id = res->vf_id;
+	rte_eth_dev_l2_tunnel_offload_set(res->port_id,
+					  &entry,
+					  ETH_L2_TUNNEL_INSERTION_MASK,
+					  1);
+}
+
+static void
+cmd_config_e_tag_insertion_dis_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_config_e_tag_result *res =
+		parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+	entry.l2_tunnel_type = RTE_L2_TUNNEL_TYPE_E_TAG;
+	entry.vf_id = res->vf_id;
+
+	rte_eth_dev_l2_tunnel_offload_set(res->port_id,
+					  &entry,
+					  ETH_L2_TUNNEL_INSERTION_MASK,
+					  0);
+}
+
+cmdline_parse_inst_t cmd_config_e_tag_insertion_en = {
+	.f = cmd_config_e_tag_insertion_en_parsed,
+	.data = NULL,
+	.help_str = "E-tag ... : E-tag insertion enable",
+	.tokens = {
+		(void *)&cmd_config_e_tag_e_tag,
+		(void *)&cmd_config_e_tag_set,
+		(void *)&cmd_config_e_tag_insertion,
+		(void *)&cmd_config_e_tag_on,
+		(void *)&cmd_config_e_tag_port_tag_id,
+		(void *)&cmd_config_e_tag_port_tag_id_val,
+		(void *)&cmd_config_e_tag_port,
+		(void *)&cmd_config_e_tag_port_id,
+		(void *)&cmd_config_e_tag_vf,
+		(void *)&cmd_config_e_tag_vf_id,
+		NULL,
+	},
+};
+
+cmdline_parse_inst_t cmd_config_e_tag_insertion_dis = {
+	.f = cmd_config_e_tag_insertion_dis_parsed,
+	.data = NULL,
+	.help_str = "E-tag ... : E-tag insertion disable",
+	.tokens = {
+		(void *)&cmd_config_e_tag_e_tag,
+		(void *)&cmd_config_e_tag_set,
+		(void *)&cmd_config_e_tag_insertion,
+		(void *)&cmd_config_e_tag_off,
+		(void *)&cmd_config_e_tag_port,
+		(void *)&cmd_config_e_tag_port_id,
+		(void *)&cmd_config_e_tag_vf,
+		(void *)&cmd_config_e_tag_vf_id,
+		NULL,
+	},
+};
+
+/* E-tag stripping configuration */
+static void
+cmd_config_e_tag_stripping_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_config_e_tag_result *res =
+		parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+	entry.l2_tunnel_type = RTE_L2_TUNNEL_TYPE_E_TAG;
+
+	if (!strcmp(res->on_off, "on"))
+		rte_eth_dev_l2_tunnel_offload_set
+			(res->port_id,
+			 &entry,
+			 ETH_L2_TUNNEL_STRIPPING_MASK,
+			 1);
+	else
+		rte_eth_dev_l2_tunnel_offload_set
+			(res->port_id,
+			 &entry,
+			 ETH_L2_TUNNEL_STRIPPING_MASK,
+			 0);
+}
+
+cmdline_parse_inst_t cmd_config_e_tag_stripping_en_dis = {
+	.f = cmd_config_e_tag_stripping_parsed,
+	.data = NULL,
+	.help_str = "E-tag ... : E-tag stripping enable/disable",
+	.tokens = {
+		(void *)&cmd_config_e_tag_e_tag,
+		(void *)&cmd_config_e_tag_set,
+		(void *)&cmd_config_e_tag_stripping,
+		(void *)&cmd_config_e_tag_on_off,
+		(void *)&cmd_config_e_tag_port,
+		(void *)&cmd_config_e_tag_port_id,
+		NULL,
+	},
+};
+
+/* E-tag forwarding configuration */
+static void
+cmd_config_e_tag_forwarding_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_config_e_tag_result *res = parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+	entry.l2_tunnel_type = RTE_L2_TUNNEL_TYPE_E_TAG;
+
+	if (!strcmp(res->on_off, "on"))
+		rte_eth_dev_l2_tunnel_offload_set
+			(res->port_id,
+			 &entry,
+			 ETH_L2_TUNNEL_FORWARDING_MASK,
+			 1);
+	else
+		rte_eth_dev_l2_tunnel_offload_set
+			(res->port_id,
+			 &entry,
+			 ETH_L2_TUNNEL_FORWARDING_MASK,
+			 0);
+}
+
+cmdline_parse_inst_t cmd_config_e_tag_forwarding_en_dis = {
+	.f = cmd_config_e_tag_forwarding_parsed,
+	.data = NULL,
+	.help_str = "E-tag ... : E-tag forwarding enable/disable",
+	.tokens = {
+		(void *)&cmd_config_e_tag_e_tag,
+		(void *)&cmd_config_e_tag_set,
+		(void *)&cmd_config_e_tag_forwarding,
+		(void *)&cmd_config_e_tag_on_off,
+		(void *)&cmd_config_e_tag_port,
+		(void *)&cmd_config_e_tag_port_id,
+		NULL,
+	},
+};
+
+/* E-tag filter configuration */
+static void
+cmd_config_e_tag_filter_add_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_config_e_tag_result *res = parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+	int ret = 0;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+	if (res->e_tag_id_val > 0x3fff) {
+		printf("e-tag-id must be equal or less than 0x3fff.\n");
+		return;
+	}
+
+	ret = rte_eth_dev_filter_supported(res->port_id,
+					   RTE_ETH_FILTER_L2_TUNNEL);
+	if (ret < 0) {
+		printf("E-tag filter is not supported on port %u.\n",
+		       res->port_id);
+		return;
+	}
+
+	entry.l2_tunnel_type = RTE_L2_TUNNEL_TYPE_E_TAG;
+	entry.tunnel_id = res->e_tag_id_val;
+	entry.pool = res->dst_pool_val;
+
+	ret = rte_eth_dev_filter_ctrl(res->port_id,
+				      RTE_ETH_FILTER_L2_TUNNEL,
+				      RTE_ETH_FILTER_ADD,
+				      &entry);
+	if (ret < 0)
+		printf("E-tag filter programming error: (%s)\n",
+		       strerror(-ret));
+}
+
+cmdline_parse_inst_t cmd_config_e_tag_filter_add = {
+	.f = cmd_config_e_tag_filter_add_parsed,
+	.data = NULL,
+	.help_str = "E-tag ... : E-tag filter add",
+	.tokens = {
+		(void *)&cmd_config_e_tag_e_tag,
+		(void *)&cmd_config_e_tag_set,
+		(void *)&cmd_config_e_tag_filter,
+		(void *)&cmd_config_e_tag_add,
+		(void *)&cmd_config_e_tag_e_tag_id,
+		(void *)&cmd_config_e_tag_e_tag_id_val,
+		(void *)&cmd_config_e_tag_dst_pool,
+		(void *)&cmd_config_e_tag_dst_pool_val,
+		(void *)&cmd_config_e_tag_port,
+		(void *)&cmd_config_e_tag_port_id,
+		NULL,
+	},
+};
+
+static void
+cmd_config_e_tag_filter_del_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_config_e_tag_result *res = parsed_result;
+	struct rte_eth_l2_tunnel_conf entry;
+	int ret = 0;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+	if (res->e_tag_id_val > 0x3fff) {
+		printf("e-tag-id must be less than 0x3fff.\n");
+		return;
+	}
+
+	ret = rte_eth_dev_filter_supported(res->port_id,
+					   RTE_ETH_FILTER_L2_TUNNEL);
+	if (ret < 0) {
+		printf("E-tag filter is not supported on port %u.\n",
+		       res->port_id);
+		return;
+	}
+
+	entry.l2_tunnel_type = RTE_L2_TUNNEL_TYPE_E_TAG;
+	entry.tunnel_id = res->e_tag_id_val;
+
+	ret = rte_eth_dev_filter_ctrl(res->port_id,
+				      RTE_ETH_FILTER_L2_TUNNEL,
+				      RTE_ETH_FILTER_DELETE,
+				      &entry);
+	if (ret < 0)
+		printf("E-tag filter programming error: (%s)\n",
+		       strerror(-ret));
+}
+
+cmdline_parse_inst_t cmd_config_e_tag_filter_del = {
+	.f = cmd_config_e_tag_filter_del_parsed,
+	.data = NULL,
+	.help_str = "E-tag ... : E-tag filter delete",
+	.tokens = {
+		(void *)&cmd_config_e_tag_e_tag,
+		(void *)&cmd_config_e_tag_set,
+		(void *)&cmd_config_e_tag_filter,
+		(void *)&cmd_config_e_tag_del,
+		(void *)&cmd_config_e_tag_e_tag_id,
+		(void *)&cmd_config_e_tag_e_tag_id_val,
+		(void *)&cmd_config_e_tag_port,
+		(void *)&cmd_config_e_tag_port_id,
+		NULL,
+	},
+};
+
 /* vf vlan anti spoof configuration */
 
 /* Common result structure for vf vlan anti spoof */
@@ -8512,31 +13340,31 @@
 };
 
 /* Common CLI fields for vf vlan anti spoof enable disable */
-static cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_set =
+cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_set =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_anti_spoof_result,
 		 set, "set");
-static cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_vf =
+cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_vf =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_anti_spoof_result,
 		 vf, "vf");
-static cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_vlan =
+cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_vlan =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_anti_spoof_result,
 		 vlan, "vlan");
-static cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_antispoof =
+cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_antispoof =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_anti_spoof_result,
 		 antispoof, "antispoof");
-static cmdline_parse_token_num_t cmd_vf_vlan_anti_spoof_port_id =
+cmdline_parse_token_num_t cmd_vf_vlan_anti_spoof_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_vf_vlan_anti_spoof_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_vf_vlan_anti_spoof_vf_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_vlan_anti_spoof_vf_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_vf_vlan_anti_spoof_result,
-		 vf_id, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_on_off =
+		 vf_id, UINT32);
+cmdline_parse_token_string_t cmd_vf_vlan_anti_spoof_on_off =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_anti_spoof_result,
 		 on_off, "on#off");
@@ -8544,8 +13372,8 @@
 static void
 cmd_set_vf_vlan_anti_spoof_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_vf_vlan_anti_spoof_result *res = parsed_result;
 	int ret = -ENOTSUP;
@@ -8555,17 +13383,17 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_ixgbe_set_vf_vlan_anti_spoof(res->port_id,
 				res->vf_id, is_on);
 #endif
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_set_vf_vlan_anti_spoof(res->port_id,
 				res->vf_id, is_on);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_set_vf_vlan_anti_spoof(res->port_id,
 				res->vf_id, is_on);
@@ -8575,20 +13403,20 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid vf_id %d\n", res->vf_id);
+		printf("invalid vf_id %d\n", res->vf_id);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented\n");
+		printf("function not implemented\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 }
 
-static cmdline_parse_inst_t cmd_set_vf_vlan_anti_spoof = {
+cmdline_parse_inst_t cmd_set_vf_vlan_anti_spoof = {
 	.f = cmd_set_vf_vlan_anti_spoof_parsed,
 	.data = NULL,
 	.help_str = "set vf vlan antispoof <port_id> <vf_id> on|off",
@@ -8618,31 +13446,31 @@
 };
 
 /* Common CLI fields for vf mac anti spoof enable disable */
-static cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_set =
+cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_set =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_mac_anti_spoof_result,
 		 set, "set");
-static cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_vf =
+cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_vf =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_mac_anti_spoof_result,
 		 vf, "vf");
-static cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_mac =
+cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_mac =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_mac_anti_spoof_result,
 		 mac, "mac");
-static cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_antispoof =
+cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_antispoof =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_mac_anti_spoof_result,
 		 antispoof, "antispoof");
-static cmdline_parse_token_num_t cmd_vf_mac_anti_spoof_port_id =
+cmdline_parse_token_num_t cmd_vf_mac_anti_spoof_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_vf_mac_anti_spoof_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_vf_mac_anti_spoof_vf_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_mac_anti_spoof_vf_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_vf_mac_anti_spoof_result,
-		 vf_id, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_on_off =
+		 vf_id, UINT32);
+cmdline_parse_token_string_t cmd_vf_mac_anti_spoof_on_off =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_mac_anti_spoof_result,
 		 on_off, "on#off");
@@ -8650,8 +13478,8 @@
 static void
 cmd_set_vf_mac_anti_spoof_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_vf_mac_anti_spoof_result *res = parsed_result;
 	int ret = -ENOTSUP;
@@ -8661,17 +13489,17 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_ixgbe_set_vf_mac_anti_spoof(res->port_id,
 			res->vf_id, is_on);
 #endif
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_set_vf_mac_anti_spoof(res->port_id,
 			res->vf_id, is_on);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_set_vf_mac_anti_spoof(res->port_id,
 			res->vf_id, is_on);
@@ -8681,21 +13509,20 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid vf_id %d or is_on %d\n",
-			res->vf_id, is_on);
+		printf("invalid vf_id %d or is_on %d\n", res->vf_id, is_on);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented\n");
+		printf("function not implemented\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 }
 
-static cmdline_parse_inst_t cmd_set_vf_mac_anti_spoof = {
+cmdline_parse_inst_t cmd_set_vf_mac_anti_spoof = {
 	.f = cmd_set_vf_mac_anti_spoof_parsed,
 	.data = NULL,
 	.help_str = "set vf mac antispoof <port_id> <vf_id> on|off",
@@ -8725,31 +13552,31 @@
 };
 
 /* Common CLI fields for vf vlan strip enable disable */
-static cmdline_parse_token_string_t cmd_vf_vlan_stripq_set =
+cmdline_parse_token_string_t cmd_vf_vlan_stripq_set =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_stripq_result,
 		 set, "set");
-static cmdline_parse_token_string_t cmd_vf_vlan_stripq_vf =
+cmdline_parse_token_string_t cmd_vf_vlan_stripq_vf =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_stripq_result,
 		 vf, "vf");
-static cmdline_parse_token_string_t cmd_vf_vlan_stripq_vlan =
+cmdline_parse_token_string_t cmd_vf_vlan_stripq_vlan =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_stripq_result,
 		 vlan, "vlan");
-static cmdline_parse_token_string_t cmd_vf_vlan_stripq_stripq =
+cmdline_parse_token_string_t cmd_vf_vlan_stripq_stripq =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_stripq_result,
 		 stripq, "stripq");
-static cmdline_parse_token_num_t cmd_vf_vlan_stripq_port_id =
+cmdline_parse_token_num_t cmd_vf_vlan_stripq_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_vf_vlan_stripq_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_vf_vlan_stripq_vf_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_vlan_stripq_vf_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_vf_vlan_stripq_result,
-		 vf_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_vf_vlan_stripq_on_off =
+		 vf_id, UINT16);
+cmdline_parse_token_string_t cmd_vf_vlan_stripq_on_off =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_stripq_result,
 		 on_off, "on#off");
@@ -8757,8 +13584,8 @@
 static void
 cmd_set_vf_vlan_stripq_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_vf_vlan_stripq_result *res = parsed_result;
 	int ret = -ENOTSUP;
@@ -8768,17 +13595,17 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_ixgbe_set_vf_vlan_stripq(res->port_id,
 			res->vf_id, is_on);
 #endif
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_set_vf_vlan_stripq(res->port_id,
 			res->vf_id, is_on);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_set_vf_vlan_stripq(res->port_id,
 			res->vf_id, is_on);
@@ -8788,21 +13615,20 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid vf_id %d or is_on %d\n",
-			res->vf_id, is_on);
+		printf("invalid vf_id %d or is_on %d\n", res->vf_id, is_on);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented\n");
+		printf("function not implemented\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 }
 
-static cmdline_parse_inst_t cmd_set_vf_vlan_stripq = {
+cmdline_parse_inst_t cmd_set_vf_vlan_stripq = {
 	.f = cmd_set_vf_vlan_stripq_parsed,
 	.data = NULL,
 	.help_str = "set vf vlan stripq <port_id> <vf_id> on|off",
@@ -8832,40 +13658,40 @@
 };
 
 /* Common CLI fields for vf vlan insert enable disable */
-static cmdline_parse_token_string_t cmd_vf_vlan_insert_set =
+cmdline_parse_token_string_t cmd_vf_vlan_insert_set =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_insert_result,
 		 set, "set");
-static cmdline_parse_token_string_t cmd_vf_vlan_insert_vf =
+cmdline_parse_token_string_t cmd_vf_vlan_insert_vf =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_insert_result,
 		 vf, "vf");
-static cmdline_parse_token_string_t cmd_vf_vlan_insert_vlan =
+cmdline_parse_token_string_t cmd_vf_vlan_insert_vlan =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_insert_result,
 		 vlan, "vlan");
-static cmdline_parse_token_string_t cmd_vf_vlan_insert_insert =
+cmdline_parse_token_string_t cmd_vf_vlan_insert_insert =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_vf_vlan_insert_result,
 		 insert, "insert");
-static cmdline_parse_token_num_t cmd_vf_vlan_insert_port_id =
+cmdline_parse_token_num_t cmd_vf_vlan_insert_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_vf_vlan_insert_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_vf_vlan_insert_vf_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_vlan_insert_vf_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_vf_vlan_insert_result,
-		 vf_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_vf_vlan_insert_vlan_id =
+		 vf_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_vlan_insert_vlan_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_vf_vlan_insert_result,
-		 vlan_id, RTE_UINT16);
+		 vlan_id, UINT16);
 
 static void
 cmd_set_vf_vlan_insert_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_vf_vlan_insert_result *res = parsed_result;
 	int ret = -ENOTSUP;
@@ -8873,17 +13699,17 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_ixgbe_set_vf_vlan_insert(res->port_id, res->vf_id,
 			res->vlan_id);
 #endif
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_set_vf_vlan_insert(res->port_id, res->vf_id,
 			res->vlan_id);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_set_vf_vlan_insert(res->port_id, res->vf_id,
 			res->vlan_id);
@@ -8893,21 +13719,20 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid vf_id %d or vlan_id %d\n",
-			res->vf_id, res->vlan_id);
+		printf("invalid vf_id %d or vlan_id %d\n", res->vf_id, res->vlan_id);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented\n");
+		printf("function not implemented\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 }
 
-static cmdline_parse_inst_t cmd_set_vf_vlan_insert = {
+cmdline_parse_inst_t cmd_set_vf_vlan_insert = {
 	.f = cmd_set_vf_vlan_insert_parsed,
 	.data = NULL,
 	.help_str = "set vf vlan insert <port_id> <vf_id> <vlan_id>",
@@ -8935,23 +13760,23 @@
 };
 
 /* Common CLI fields for tx loopback enable disable */
-static cmdline_parse_token_string_t cmd_tx_loopback_set =
+cmdline_parse_token_string_t cmd_tx_loopback_set =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_loopback_result,
 		 set, "set");
-static cmdline_parse_token_string_t cmd_tx_loopback_tx =
+cmdline_parse_token_string_t cmd_tx_loopback_tx =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_loopback_result,
 		 tx, "tx");
-static cmdline_parse_token_string_t cmd_tx_loopback_loopback =
+cmdline_parse_token_string_t cmd_tx_loopback_loopback =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_loopback_result,
 		 loopback, "loopback");
-static cmdline_parse_token_num_t cmd_tx_loopback_port_id =
+cmdline_parse_token_num_t cmd_tx_loopback_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_tx_loopback_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_tx_loopback_on_off =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_tx_loopback_on_off =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_loopback_result,
 		 on_off, "on#off");
@@ -8959,8 +13784,8 @@
 static void
 cmd_set_tx_loopback_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_tx_loopback_result *res = parsed_result;
 	int ret = -ENOTSUP;
@@ -8970,19 +13795,19 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_ixgbe_set_tx_loopback(res->port_id, is_on);
 #endif
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_set_tx_loopback(res->port_id, is_on);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_set_tx_loopback(res->port_id, is_on);
 #endif
-#if defined RTE_BUS_DPAA && defined RTE_NET_DPAA
+#if defined RTE_LIBRTE_DPAA_BUS && defined RTE_LIBRTE_DPAA_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_dpaa_set_tx_loopback(res->port_id, is_on);
 #endif
@@ -8991,20 +13816,20 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid is_on %d\n", is_on);
+		printf("invalid is_on %d\n", is_on);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented\n");
+		printf("function not implemented\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 }
 
-static cmdline_parse_inst_t cmd_set_tx_loopback = {
+cmdline_parse_inst_t cmd_set_tx_loopback = {
 	.f = cmd_set_tx_loopback_parsed,
 	.data = NULL,
 	.help_str = "set tx loopback <port_id> on|off",
@@ -9031,27 +13856,27 @@
 };
 
 /* Common CLI fields for tx loopback enable disable */
-static cmdline_parse_token_string_t cmd_all_queues_drop_en_set =
+cmdline_parse_token_string_t cmd_all_queues_drop_en_set =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_all_queues_drop_en_result,
 		 set, "set");
-static cmdline_parse_token_string_t cmd_all_queues_drop_en_all =
+cmdline_parse_token_string_t cmd_all_queues_drop_en_all =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_all_queues_drop_en_result,
 		 all, "all");
-static cmdline_parse_token_string_t cmd_all_queues_drop_en_queues =
+cmdline_parse_token_string_t cmd_all_queues_drop_en_queues =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_all_queues_drop_en_result,
 		 queues, "queues");
-static cmdline_parse_token_string_t cmd_all_queues_drop_en_drop =
+cmdline_parse_token_string_t cmd_all_queues_drop_en_drop =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_all_queues_drop_en_result,
 		 drop, "drop");
-static cmdline_parse_token_num_t cmd_all_queues_drop_en_port_id =
+cmdline_parse_token_num_t cmd_all_queues_drop_en_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_all_queues_drop_en_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_all_queues_drop_en_on_off =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_all_queues_drop_en_on_off =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_all_queues_drop_en_result,
 		 on_off, "on#off");
@@ -9059,8 +13884,8 @@
 static void
 cmd_set_all_queues_drop_en_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_all_queues_drop_en_result *res = parsed_result;
 	int ret = -ENOTSUP;
@@ -9069,11 +13894,11 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_ixgbe_set_all_queues_drop_en(res->port_id, is_on);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_set_all_queues_drop_en(res->port_id, is_on);
 #endif
@@ -9081,20 +13906,20 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid is_on %d\n", is_on);
+		printf("invalid is_on %d\n", is_on);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented\n");
+		printf("function not implemented\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 }
 
-static cmdline_parse_inst_t cmd_set_all_queues_drop_en = {
+cmdline_parse_inst_t cmd_set_all_queues_drop_en = {
 	.f = cmd_set_all_queues_drop_en_parsed,
 	.data = NULL,
 	.help_str = "set all queues drop <port_id> on|off",
@@ -9109,6 +13934,99 @@
 	},
 };
 
+/* vf split drop enable configuration */
+
+/* Common result structure for vf split drop enable */
+struct cmd_vf_split_drop_en_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t vf;
+	cmdline_fixed_string_t split;
+	cmdline_fixed_string_t drop;
+	portid_t port_id;
+	uint16_t vf_id;
+	cmdline_fixed_string_t on_off;
+};
+
+/* Common CLI fields for vf split drop enable disable */
+cmdline_parse_token_string_t cmd_vf_split_drop_en_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_split_drop_en_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_vf_split_drop_en_vf =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_split_drop_en_result,
+		 vf, "vf");
+cmdline_parse_token_string_t cmd_vf_split_drop_en_split =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_split_drop_en_result,
+		 split, "split");
+cmdline_parse_token_string_t cmd_vf_split_drop_en_drop =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_split_drop_en_result,
+		 drop, "drop");
+cmdline_parse_token_num_t cmd_vf_split_drop_en_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_split_drop_en_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_split_drop_en_vf_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_split_drop_en_result,
+		 vf_id, UINT16);
+cmdline_parse_token_string_t cmd_vf_split_drop_en_on_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_split_drop_en_result,
+		 on_off, "on#off");
+
+static void
+cmd_set_vf_split_drop_en_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_vf_split_drop_en_result *res = parsed_result;
+	int ret = -ENOTSUP;
+	int is_on = (strcmp(res->on_off, "on") == 0) ? 1 : 0;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_IXGBE_PMD
+	ret = rte_pmd_ixgbe_set_vf_split_drop_en(res->port_id, res->vf_id,
+			is_on);
+#endif
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid vf_id %d or is_on %d\n", res->vf_id, is_on);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("not supported on port %d\n", res->port_id);
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_set_vf_split_drop_en = {
+	.f = cmd_set_vf_split_drop_en_parsed,
+	.data = NULL,
+	.help_str = "set vf split drop <port_id> <vf_id> on|off",
+	.tokens = {
+		(void *)&cmd_vf_split_drop_en_set,
+		(void *)&cmd_vf_split_drop_en_vf,
+		(void *)&cmd_vf_split_drop_en_split,
+		(void *)&cmd_vf_split_drop_en_drop,
+		(void *)&cmd_vf_split_drop_en_port_id,
+		(void *)&cmd_vf_split_drop_en_vf_id,
+		(void *)&cmd_vf_split_drop_en_on_off,
+		NULL,
+	},
+};
+
 /* vf mac address configuration */
 
 /* Common result structure for vf mac address */
@@ -9124,39 +14042,39 @@
 };
 
 /* Common CLI fields for vf split drop enable disable */
-static cmdline_parse_token_string_t cmd_set_vf_mac_addr_set =
+cmdline_parse_token_string_t cmd_set_vf_mac_addr_set =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_set_vf_mac_addr_result,
 		 set, "set");
-static cmdline_parse_token_string_t cmd_set_vf_mac_addr_vf =
+cmdline_parse_token_string_t cmd_set_vf_mac_addr_vf =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_set_vf_mac_addr_result,
 		 vf, "vf");
-static cmdline_parse_token_string_t cmd_set_vf_mac_addr_mac =
+cmdline_parse_token_string_t cmd_set_vf_mac_addr_mac =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_set_vf_mac_addr_result,
 		 mac, "mac");
-static cmdline_parse_token_string_t cmd_set_vf_mac_addr_addr =
+cmdline_parse_token_string_t cmd_set_vf_mac_addr_addr =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_set_vf_mac_addr_result,
 		 addr, "addr");
-static cmdline_parse_token_num_t cmd_set_vf_mac_addr_port_id =
+cmdline_parse_token_num_t cmd_set_vf_mac_addr_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_set_vf_mac_addr_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_set_vf_mac_addr_vf_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_set_vf_mac_addr_vf_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_set_vf_mac_addr_result,
-		 vf_id, RTE_UINT16);
-static cmdline_parse_token_etheraddr_t cmd_set_vf_mac_addr_mac_addr =
+		 vf_id, UINT16);
+cmdline_parse_token_etheraddr_t cmd_set_vf_mac_addr_mac_addr =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_vf_mac_addr_result,
 		 mac_addr);
 
 static void
 cmd_set_vf_mac_addr_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_vf_mac_addr_result *res = parsed_result;
 	int ret = -ENOTSUP;
@@ -9164,17 +14082,17 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_ixgbe_set_vf_mac_addr(res->port_id, res->vf_id,
 				&res->mac_addr);
 #endif
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_set_vf_mac_addr(res->port_id, res->vf_id,
 				&res->mac_addr);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_set_vf_mac_addr(res->port_id, res->vf_id,
 				&res->mac_addr);
@@ -9184,20 +14102,20 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid vf_id %d or mac_addr\n", res->vf_id);
+		printf("invalid vf_id %d or mac_addr\n", res->vf_id);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented\n");
+		printf("function not implemented\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 }
 
-static cmdline_parse_inst_t cmd_set_vf_mac_addr = {
+cmdline_parse_inst_t cmd_set_vf_mac_addr = {
 	.f = cmd_set_vf_mac_addr_parsed,
 	.data = NULL,
 	.help_str = "set vf mac addr <port_id> <vf_id> <mac_addr>",
@@ -9213,6 +14131,1209 @@
 	},
 };
 
+/* MACsec configuration */
+
+/* Common result structure for MACsec offload enable */
+struct cmd_macsec_offload_on_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t macsec;
+	cmdline_fixed_string_t offload;
+	portid_t port_id;
+	cmdline_fixed_string_t on;
+	cmdline_fixed_string_t encrypt;
+	cmdline_fixed_string_t en_on_off;
+	cmdline_fixed_string_t replay_protect;
+	cmdline_fixed_string_t rp_on_off;
+};
+
+/* Common CLI fields for MACsec offload disable */
+cmdline_parse_token_string_t cmd_macsec_offload_on_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_on_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_macsec_offload_on_macsec =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_on_result,
+		 macsec, "macsec");
+cmdline_parse_token_string_t cmd_macsec_offload_on_offload =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_on_result,
+		 offload, "offload");
+cmdline_parse_token_num_t cmd_macsec_offload_on_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_macsec_offload_on_result,
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_macsec_offload_on_on =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_on_result,
+		 on, "on");
+cmdline_parse_token_string_t cmd_macsec_offload_on_encrypt =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_on_result,
+		 encrypt, "encrypt");
+cmdline_parse_token_string_t cmd_macsec_offload_on_en_on_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_on_result,
+		 en_on_off, "on#off");
+cmdline_parse_token_string_t cmd_macsec_offload_on_replay_protect =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_on_result,
+		 replay_protect, "replay-protect");
+cmdline_parse_token_string_t cmd_macsec_offload_on_rp_on_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_on_result,
+		 rp_on_off, "on#off");
+
+static void
+cmd_set_macsec_offload_on_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_macsec_offload_on_result *res = parsed_result;
+	int ret = -ENOTSUP;
+	portid_t port_id = res->port_id;
+	int en = (strcmp(res->en_on_off, "on") == 0) ? 1 : 0;
+	int rp = (strcmp(res->rp_on_off, "on") == 0) ? 1 : 0;
+	struct rte_eth_dev_info dev_info;
+
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+	if (!port_is_stopped(port_id)) {
+		printf("Please stop port %d first\n", port_id);
+		return;
+	}
+
+	ret = eth_dev_info_get_print_err(port_id, &dev_info);
+	if (ret != 0)
+		return;
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_MACSEC_INSERT) {
+#ifdef RTE_LIBRTE_IXGBE_PMD
+		ret = rte_pmd_ixgbe_macsec_enable(port_id, en, rp);
+#endif
+	}
+	RTE_SET_USED(en);
+	RTE_SET_USED(rp);
+
+	switch (ret) {
+	case 0:
+		ports[port_id].dev_conf.txmode.offloads |=
+						DEV_TX_OFFLOAD_MACSEC_INSERT;
+		cmd_reconfig_device_queue(port_id, 1, 1);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", port_id);
+		break;
+	case -ENOTSUP:
+		printf("not supported on port %d\n", port_id);
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_set_macsec_offload_on = {
+	.f = cmd_set_macsec_offload_on_parsed,
+	.data = NULL,
+	.help_str = "set macsec offload <port_id> on "
+		"encrypt on|off replay-protect on|off",
+	.tokens = {
+		(void *)&cmd_macsec_offload_on_set,
+		(void *)&cmd_macsec_offload_on_macsec,
+		(void *)&cmd_macsec_offload_on_offload,
+		(void *)&cmd_macsec_offload_on_port_id,
+		(void *)&cmd_macsec_offload_on_on,
+		(void *)&cmd_macsec_offload_on_encrypt,
+		(void *)&cmd_macsec_offload_on_en_on_off,
+		(void *)&cmd_macsec_offload_on_replay_protect,
+		(void *)&cmd_macsec_offload_on_rp_on_off,
+		NULL,
+	},
+};
+
+/* Common result structure for MACsec offload disable */
+struct cmd_macsec_offload_off_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t macsec;
+	cmdline_fixed_string_t offload;
+	portid_t port_id;
+	cmdline_fixed_string_t off;
+};
+
+/* Common CLI fields for MACsec offload disable */
+cmdline_parse_token_string_t cmd_macsec_offload_off_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_off_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_macsec_offload_off_macsec =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_off_result,
+		 macsec, "macsec");
+cmdline_parse_token_string_t cmd_macsec_offload_off_offload =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_off_result,
+		 offload, "offload");
+cmdline_parse_token_num_t cmd_macsec_offload_off_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_macsec_offload_off_result,
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_macsec_offload_off_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_offload_off_result,
+		 off, "off");
+
+static void
+cmd_set_macsec_offload_off_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_macsec_offload_off_result *res = parsed_result;
+	int ret = -ENOTSUP;
+	struct rte_eth_dev_info dev_info;
+	portid_t port_id = res->port_id;
+
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+	if (!port_is_stopped(port_id)) {
+		printf("Please stop port %d first\n", port_id);
+		return;
+	}
+
+	ret = eth_dev_info_get_print_err(port_id, &dev_info);
+	if (ret != 0)
+		return;
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_MACSEC_INSERT) {
+#ifdef RTE_LIBRTE_IXGBE_PMD
+		ret = rte_pmd_ixgbe_macsec_disable(port_id);
+#endif
+	}
+	switch (ret) {
+	case 0:
+		ports[port_id].dev_conf.txmode.offloads &=
+						~DEV_TX_OFFLOAD_MACSEC_INSERT;
+		cmd_reconfig_device_queue(port_id, 1, 1);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", port_id);
+		break;
+	case -ENOTSUP:
+		printf("not supported on port %d\n", port_id);
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_set_macsec_offload_off = {
+	.f = cmd_set_macsec_offload_off_parsed,
+	.data = NULL,
+	.help_str = "set macsec offload <port_id> off",
+	.tokens = {
+		(void *)&cmd_macsec_offload_off_set,
+		(void *)&cmd_macsec_offload_off_macsec,
+		(void *)&cmd_macsec_offload_off_offload,
+		(void *)&cmd_macsec_offload_off_port_id,
+		(void *)&cmd_macsec_offload_off_off,
+		NULL,
+	},
+};
+
+/* Common result structure for MACsec secure connection configure */
+struct cmd_macsec_sc_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t macsec;
+	cmdline_fixed_string_t sc;
+	cmdline_fixed_string_t tx_rx;
+	portid_t port_id;
+	struct rte_ether_addr mac;
+	uint16_t pi;
+};
+
+/* Common CLI fields for MACsec secure connection configure */
+cmdline_parse_token_string_t cmd_macsec_sc_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_sc_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_macsec_sc_macsec =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_sc_result,
+		 macsec, "macsec");
+cmdline_parse_token_string_t cmd_macsec_sc_sc =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_sc_result,
+		 sc, "sc");
+cmdline_parse_token_string_t cmd_macsec_sc_tx_rx =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_sc_result,
+		 tx_rx, "tx#rx");
+cmdline_parse_token_num_t cmd_macsec_sc_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_macsec_sc_result,
+		 port_id, UINT16);
+cmdline_parse_token_etheraddr_t cmd_macsec_sc_mac =
+	TOKEN_ETHERADDR_INITIALIZER
+		(struct cmd_macsec_sc_result,
+		 mac);
+cmdline_parse_token_num_t cmd_macsec_sc_pi =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_macsec_sc_result,
+		 pi, UINT16);
+
+static void
+cmd_set_macsec_sc_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_macsec_sc_result *res = parsed_result;
+	int ret = -ENOTSUP;
+	int is_tx = (strcmp(res->tx_rx, "tx") == 0) ? 1 : 0;
+
+#ifdef RTE_LIBRTE_IXGBE_PMD
+	ret = is_tx ?
+		rte_pmd_ixgbe_macsec_config_txsc(res->port_id,
+				res->mac.addr_bytes) :
+		rte_pmd_ixgbe_macsec_config_rxsc(res->port_id,
+				res->mac.addr_bytes, res->pi);
+#endif
+	RTE_SET_USED(is_tx);
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("not supported on port %d\n", res->port_id);
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_set_macsec_sc = {
+	.f = cmd_set_macsec_sc_parsed,
+	.data = NULL,
+	.help_str = "set macsec sc tx|rx <port_id> <mac> <pi>",
+	.tokens = {
+		(void *)&cmd_macsec_sc_set,
+		(void *)&cmd_macsec_sc_macsec,
+		(void *)&cmd_macsec_sc_sc,
+		(void *)&cmd_macsec_sc_tx_rx,
+		(void *)&cmd_macsec_sc_port_id,
+		(void *)&cmd_macsec_sc_mac,
+		(void *)&cmd_macsec_sc_pi,
+		NULL,
+	},
+};
+
+/* Common result structure for MACsec secure connection configure */
+struct cmd_macsec_sa_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t macsec;
+	cmdline_fixed_string_t sa;
+	cmdline_fixed_string_t tx_rx;
+	portid_t port_id;
+	uint8_t idx;
+	uint8_t an;
+	uint32_t pn;
+	cmdline_fixed_string_t key;
+};
+
+/* Common CLI fields for MACsec secure connection configure */
+cmdline_parse_token_string_t cmd_macsec_sa_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_sa_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_macsec_sa_macsec =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_sa_result,
+		 macsec, "macsec");
+cmdline_parse_token_string_t cmd_macsec_sa_sa =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_sa_result,
+		 sa, "sa");
+cmdline_parse_token_string_t cmd_macsec_sa_tx_rx =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_sa_result,
+		 tx_rx, "tx#rx");
+cmdline_parse_token_num_t cmd_macsec_sa_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_macsec_sa_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_macsec_sa_idx =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_macsec_sa_result,
+		 idx, UINT8);
+cmdline_parse_token_num_t cmd_macsec_sa_an =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_macsec_sa_result,
+		 an, UINT8);
+cmdline_parse_token_num_t cmd_macsec_sa_pn =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_macsec_sa_result,
+		 pn, UINT32);
+cmdline_parse_token_string_t cmd_macsec_sa_key =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_macsec_sa_result,
+		 key, NULL);
+
+static void
+cmd_set_macsec_sa_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_macsec_sa_result *res = parsed_result;
+	int ret = -ENOTSUP;
+	int is_tx = (strcmp(res->tx_rx, "tx") == 0) ? 1 : 0;
+	uint8_t key[16] = { 0 };
+	uint8_t xdgt0;
+	uint8_t xdgt1;
+	int key_len;
+	int i;
+
+	key_len = strlen(res->key) / 2;
+	if (key_len > 16)
+		key_len = 16;
+
+	for (i = 0; i < key_len; i++) {
+		xdgt0 = parse_and_check_key_hexa_digit(res->key, (i * 2));
+		if (xdgt0 == 0xFF)
+			return;
+		xdgt1 = parse_and_check_key_hexa_digit(res->key, (i * 2) + 1);
+		if (xdgt1 == 0xFF)
+			return;
+		key[i] = (uint8_t) ((xdgt0 * 16) + xdgt1);
+	}
+
+#ifdef RTE_LIBRTE_IXGBE_PMD
+	ret = is_tx ?
+		rte_pmd_ixgbe_macsec_select_txsa(res->port_id,
+			res->idx, res->an, res->pn, key) :
+		rte_pmd_ixgbe_macsec_select_rxsa(res->port_id,
+			res->idx, res->an, res->pn, key);
+#endif
+	RTE_SET_USED(is_tx);
+	RTE_SET_USED(key);
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid idx %d or an %d\n", res->idx, res->an);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("not supported on port %d\n", res->port_id);
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_set_macsec_sa = {
+	.f = cmd_set_macsec_sa_parsed,
+	.data = NULL,
+	.help_str = "set macsec sa tx|rx <port_id> <idx> <an> <pn> <key>",
+	.tokens = {
+		(void *)&cmd_macsec_sa_set,
+		(void *)&cmd_macsec_sa_macsec,
+		(void *)&cmd_macsec_sa_sa,
+		(void *)&cmd_macsec_sa_tx_rx,
+		(void *)&cmd_macsec_sa_port_id,
+		(void *)&cmd_macsec_sa_idx,
+		(void *)&cmd_macsec_sa_an,
+		(void *)&cmd_macsec_sa_pn,
+		(void *)&cmd_macsec_sa_key,
+		NULL,
+	},
+};
+
+/* VF unicast promiscuous mode configuration */
+
+/* Common result structure for VF unicast promiscuous mode */
+struct cmd_vf_promisc_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t vf;
+	cmdline_fixed_string_t promisc;
+	portid_t port_id;
+	uint32_t vf_id;
+	cmdline_fixed_string_t on_off;
+};
+
+/* Common CLI fields for VF unicast promiscuous mode enable disable */
+cmdline_parse_token_string_t cmd_vf_promisc_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_promisc_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_vf_promisc_vf =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_promisc_result,
+		 vf, "vf");
+cmdline_parse_token_string_t cmd_vf_promisc_promisc =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_promisc_result,
+		 promisc, "promisc");
+cmdline_parse_token_num_t cmd_vf_promisc_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_promisc_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_promisc_vf_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_promisc_result,
+		 vf_id, UINT32);
+cmdline_parse_token_string_t cmd_vf_promisc_on_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_promisc_result,
+		 on_off, "on#off");
+
+static void
+cmd_set_vf_promisc_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_vf_promisc_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	__rte_unused int is_on = (strcmp(res->on_off, "on") == 0) ? 1 : 0;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_set_vf_unicast_promisc(res->port_id,
+						  res->vf_id, is_on);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid vf_id %d\n", res->vf_id);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_set_vf_promisc = {
+	.f = cmd_set_vf_promisc_parsed,
+	.data = NULL,
+	.help_str = "set vf promisc <port_id> <vf_id> on|off: "
+		"Set unicast promiscuous mode for a VF from the PF",
+	.tokens = {
+		(void *)&cmd_vf_promisc_set,
+		(void *)&cmd_vf_promisc_vf,
+		(void *)&cmd_vf_promisc_promisc,
+		(void *)&cmd_vf_promisc_port_id,
+		(void *)&cmd_vf_promisc_vf_id,
+		(void *)&cmd_vf_promisc_on_off,
+		NULL,
+	},
+};
+
+/* VF multicast promiscuous mode configuration */
+
+/* Common result structure for VF multicast promiscuous mode */
+struct cmd_vf_allmulti_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t vf;
+	cmdline_fixed_string_t allmulti;
+	portid_t port_id;
+	uint32_t vf_id;
+	cmdline_fixed_string_t on_off;
+};
+
+/* Common CLI fields for VF multicast promiscuous mode enable disable */
+cmdline_parse_token_string_t cmd_vf_allmulti_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_allmulti_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_vf_allmulti_vf =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_allmulti_result,
+		 vf, "vf");
+cmdline_parse_token_string_t cmd_vf_allmulti_allmulti =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_allmulti_result,
+		 allmulti, "allmulti");
+cmdline_parse_token_num_t cmd_vf_allmulti_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_allmulti_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_allmulti_vf_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_allmulti_result,
+		 vf_id, UINT32);
+cmdline_parse_token_string_t cmd_vf_allmulti_on_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_allmulti_result,
+		 on_off, "on#off");
+
+static void
+cmd_set_vf_allmulti_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_vf_allmulti_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	__rte_unused int is_on = (strcmp(res->on_off, "on") == 0) ? 1 : 0;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_set_vf_multicast_promisc(res->port_id,
+						    res->vf_id, is_on);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid vf_id %d\n", res->vf_id);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_set_vf_allmulti = {
+	.f = cmd_set_vf_allmulti_parsed,
+	.data = NULL,
+	.help_str = "set vf allmulti <port_id> <vf_id> on|off: "
+		"Set multicast promiscuous mode for a VF from the PF",
+	.tokens = {
+		(void *)&cmd_vf_allmulti_set,
+		(void *)&cmd_vf_allmulti_vf,
+		(void *)&cmd_vf_allmulti_allmulti,
+		(void *)&cmd_vf_allmulti_port_id,
+		(void *)&cmd_vf_allmulti_vf_id,
+		(void *)&cmd_vf_allmulti_on_off,
+		NULL,
+	},
+};
+
+/* vf broadcast mode configuration */
+
+/* Common result structure for vf broadcast */
+struct cmd_set_vf_broadcast_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t vf;
+	cmdline_fixed_string_t broadcast;
+	portid_t port_id;
+	uint16_t vf_id;
+	cmdline_fixed_string_t on_off;
+};
+
+/* Common CLI fields for vf broadcast enable disable */
+cmdline_parse_token_string_t cmd_set_vf_broadcast_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_set_vf_broadcast_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_set_vf_broadcast_vf =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_set_vf_broadcast_result,
+		 vf, "vf");
+cmdline_parse_token_string_t cmd_set_vf_broadcast_broadcast =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_set_vf_broadcast_result,
+		 broadcast, "broadcast");
+cmdline_parse_token_num_t cmd_set_vf_broadcast_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_set_vf_broadcast_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_set_vf_broadcast_vf_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_set_vf_broadcast_result,
+		 vf_id, UINT16);
+cmdline_parse_token_string_t cmd_set_vf_broadcast_on_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_set_vf_broadcast_result,
+		 on_off, "on#off");
+
+static void
+cmd_set_vf_broadcast_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_set_vf_broadcast_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	__rte_unused int is_on = (strcmp(res->on_off, "on") == 0) ? 1 : 0;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_set_vf_broadcast(res->port_id,
+					    res->vf_id, is_on);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid vf_id %d or is_on %d\n", res->vf_id, is_on);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_set_vf_broadcast = {
+	.f = cmd_set_vf_broadcast_parsed,
+	.data = NULL,
+	.help_str = "set vf broadcast <port_id> <vf_id> on|off",
+	.tokens = {
+		(void *)&cmd_set_vf_broadcast_set,
+		(void *)&cmd_set_vf_broadcast_vf,
+		(void *)&cmd_set_vf_broadcast_broadcast,
+		(void *)&cmd_set_vf_broadcast_port_id,
+		(void *)&cmd_set_vf_broadcast_vf_id,
+		(void *)&cmd_set_vf_broadcast_on_off,
+		NULL,
+	},
+};
+
+/* vf vlan tag configuration */
+
+/* Common result structure for vf vlan tag */
+struct cmd_set_vf_vlan_tag_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t vf;
+	cmdline_fixed_string_t vlan;
+	cmdline_fixed_string_t tag;
+	portid_t port_id;
+	uint16_t vf_id;
+	cmdline_fixed_string_t on_off;
+};
+
+/* Common CLI fields for vf vlan tag enable disable */
+cmdline_parse_token_string_t cmd_set_vf_vlan_tag_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_set_vf_vlan_tag_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_set_vf_vlan_tag_vf =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_set_vf_vlan_tag_result,
+		 vf, "vf");
+cmdline_parse_token_string_t cmd_set_vf_vlan_tag_vlan =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_set_vf_vlan_tag_result,
+		 vlan, "vlan");
+cmdline_parse_token_string_t cmd_set_vf_vlan_tag_tag =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_set_vf_vlan_tag_result,
+		 tag, "tag");
+cmdline_parse_token_num_t cmd_set_vf_vlan_tag_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_set_vf_vlan_tag_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_set_vf_vlan_tag_vf_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_set_vf_vlan_tag_result,
+		 vf_id, UINT16);
+cmdline_parse_token_string_t cmd_set_vf_vlan_tag_on_off =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_set_vf_vlan_tag_result,
+		 on_off, "on#off");
+
+static void
+cmd_set_vf_vlan_tag_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_set_vf_vlan_tag_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	__rte_unused int is_on = (strcmp(res->on_off, "on") == 0) ? 1 : 0;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_set_vf_vlan_tag(res->port_id,
+					   res->vf_id, is_on);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid vf_id %d or is_on %d\n", res->vf_id, is_on);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_set_vf_vlan_tag = {
+	.f = cmd_set_vf_vlan_tag_parsed,
+	.data = NULL,
+	.help_str = "set vf vlan tag <port_id> <vf_id> on|off",
+	.tokens = {
+		(void *)&cmd_set_vf_vlan_tag_set,
+		(void *)&cmd_set_vf_vlan_tag_vf,
+		(void *)&cmd_set_vf_vlan_tag_vlan,
+		(void *)&cmd_set_vf_vlan_tag_tag,
+		(void *)&cmd_set_vf_vlan_tag_port_id,
+		(void *)&cmd_set_vf_vlan_tag_vf_id,
+		(void *)&cmd_set_vf_vlan_tag_on_off,
+		NULL,
+	},
+};
+
+/* Common definition of VF and TC TX bandwidth configuration */
+struct cmd_vf_tc_bw_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t vf;
+	cmdline_fixed_string_t tc;
+	cmdline_fixed_string_t tx;
+	cmdline_fixed_string_t min_bw;
+	cmdline_fixed_string_t max_bw;
+	cmdline_fixed_string_t strict_link_prio;
+	portid_t port_id;
+	uint16_t vf_id;
+	uint8_t tc_no;
+	uint32_t bw;
+	cmdline_fixed_string_t bw_list;
+	uint8_t tc_map;
+};
+
+cmdline_parse_token_string_t cmd_vf_tc_bw_set =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 set, "set");
+cmdline_parse_token_string_t cmd_vf_tc_bw_vf =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 vf, "vf");
+cmdline_parse_token_string_t cmd_vf_tc_bw_tc =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 tc, "tc");
+cmdline_parse_token_string_t cmd_vf_tc_bw_tx =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 tx, "tx");
+cmdline_parse_token_string_t cmd_vf_tc_bw_strict_link_prio =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 strict_link_prio, "strict-link-priority");
+cmdline_parse_token_string_t cmd_vf_tc_bw_min_bw =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 min_bw, "min-bandwidth");
+cmdline_parse_token_string_t cmd_vf_tc_bw_max_bw =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 max_bw, "max-bandwidth");
+cmdline_parse_token_num_t cmd_vf_tc_bw_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_tc_bw_vf_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 vf_id, UINT16);
+cmdline_parse_token_num_t cmd_vf_tc_bw_tc_no =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 tc_no, UINT8);
+cmdline_parse_token_num_t cmd_vf_tc_bw_bw =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 bw, UINT32);
+cmdline_parse_token_string_t cmd_vf_tc_bw_bw_list =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 bw_list, NULL);
+cmdline_parse_token_num_t cmd_vf_tc_bw_tc_map =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_vf_tc_bw_result,
+		 tc_map, UINT8);
+
+/* VF max bandwidth setting */
+static void
+cmd_vf_max_bw_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_vf_tc_bw_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_set_vf_max_bw(res->port_id,
+					 res->vf_id, res->bw);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid vf_id %d or bandwidth %d\n",
+		       res->vf_id, res->bw);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_vf_max_bw = {
+	.f = cmd_vf_max_bw_parsed,
+	.data = NULL,
+	.help_str = "set vf tx max-bandwidth <port_id> <vf_id> <bandwidth>",
+	.tokens = {
+		(void *)&cmd_vf_tc_bw_set,
+		(void *)&cmd_vf_tc_bw_vf,
+		(void *)&cmd_vf_tc_bw_tx,
+		(void *)&cmd_vf_tc_bw_max_bw,
+		(void *)&cmd_vf_tc_bw_port_id,
+		(void *)&cmd_vf_tc_bw_vf_id,
+		(void *)&cmd_vf_tc_bw_bw,
+		NULL,
+	},
+};
+
+static int
+vf_tc_min_bw_parse_bw_list(uint8_t *bw_list,
+			   uint8_t *tc_num,
+			   char *str)
+{
+	uint32_t size;
+	const char *p, *p0 = str;
+	char s[256];
+	char *end;
+	char *str_fld[16];
+	uint16_t i;
+	int ret;
+
+	p = strchr(p0, '(');
+	if (p == NULL) {
+		printf("The bandwidth-list should be '(bw1, bw2, ...)'\n");
+		return -1;
+	}
+	p++;
+	p0 = strchr(p, ')');
+	if (p0 == NULL) {
+		printf("The bandwidth-list should be '(bw1, bw2, ...)'\n");
+		return -1;
+	}
+	size = p0 - p;
+	if (size >= sizeof(s)) {
+		printf("The string size exceeds the internal buffer size\n");
+		return -1;
+	}
+	snprintf(s, sizeof(s), "%.*s", size, p);
+	ret = rte_strsplit(s, sizeof(s), str_fld, 16, ',');
+	if (ret <= 0) {
+		printf("Failed to get the bandwidth list. ");
+		return -1;
+	}
+	*tc_num = ret;
+	for (i = 0; i < ret; i++)
+		bw_list[i] = (uint8_t)strtoul(str_fld[i], &end, 0);
+
+	return 0;
+}
+
+/* TC min bandwidth setting */
+static void
+cmd_vf_tc_min_bw_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_vf_tc_bw_result *res = parsed_result;
+	uint8_t tc_num;
+	uint8_t bw[16];
+	int ret = -ENOTSUP;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+	ret = vf_tc_min_bw_parse_bw_list(bw, &tc_num, res->bw_list);
+	if (ret)
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_set_vf_tc_bw_alloc(res->port_id, res->vf_id,
+					      tc_num, bw);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid vf_id %d or bandwidth\n", res->vf_id);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_vf_tc_min_bw = {
+	.f = cmd_vf_tc_min_bw_parsed,
+	.data = NULL,
+	.help_str = "set vf tc tx min-bandwidth <port_id> <vf_id>"
+		    " <bw1, bw2, ...>",
+	.tokens = {
+		(void *)&cmd_vf_tc_bw_set,
+		(void *)&cmd_vf_tc_bw_vf,
+		(void *)&cmd_vf_tc_bw_tc,
+		(void *)&cmd_vf_tc_bw_tx,
+		(void *)&cmd_vf_tc_bw_min_bw,
+		(void *)&cmd_vf_tc_bw_port_id,
+		(void *)&cmd_vf_tc_bw_vf_id,
+		(void *)&cmd_vf_tc_bw_bw_list,
+		NULL,
+	},
+};
+
+static void
+cmd_tc_min_bw_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_vf_tc_bw_result *res = parsed_result;
+	struct rte_port *port;
+	uint8_t tc_num;
+	uint8_t bw[16];
+	int ret = -ENOTSUP;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+	port = &ports[res->port_id];
+	/** Check if the port is not started **/
+	if (port->port_status != RTE_PORT_STOPPED) {
+		printf("Please stop port %d first\n", res->port_id);
+		return;
+	}
+
+	ret = vf_tc_min_bw_parse_bw_list(bw, &tc_num, res->bw_list);
+	if (ret)
+		return;
+
+#ifdef RTE_LIBRTE_IXGBE_PMD
+	ret = rte_pmd_ixgbe_set_tc_bw_alloc(res->port_id, tc_num, bw);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid bandwidth\n");
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_tc_min_bw = {
+	.f = cmd_tc_min_bw_parsed,
+	.data = NULL,
+	.help_str = "set tc tx min-bandwidth <port_id> <bw1, bw2, ...>",
+	.tokens = {
+		(void *)&cmd_vf_tc_bw_set,
+		(void *)&cmd_vf_tc_bw_tc,
+		(void *)&cmd_vf_tc_bw_tx,
+		(void *)&cmd_vf_tc_bw_min_bw,
+		(void *)&cmd_vf_tc_bw_port_id,
+		(void *)&cmd_vf_tc_bw_bw_list,
+		NULL,
+	},
+};
+
+/* TC max bandwidth setting */
+static void
+cmd_vf_tc_max_bw_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_vf_tc_bw_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_set_vf_tc_max_bw(res->port_id, res->vf_id,
+					    res->tc_no, res->bw);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid vf_id %d, tc_no %d or bandwidth %d\n",
+		       res->vf_id, res->tc_no, res->bw);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_vf_tc_max_bw = {
+	.f = cmd_vf_tc_max_bw_parsed,
+	.data = NULL,
+	.help_str = "set vf tc tx max-bandwidth <port_id> <vf_id> <tc_no>"
+		    " <bandwidth>",
+	.tokens = {
+		(void *)&cmd_vf_tc_bw_set,
+		(void *)&cmd_vf_tc_bw_vf,
+		(void *)&cmd_vf_tc_bw_tc,
+		(void *)&cmd_vf_tc_bw_tx,
+		(void *)&cmd_vf_tc_bw_max_bw,
+		(void *)&cmd_vf_tc_bw_port_id,
+		(void *)&cmd_vf_tc_bw_vf_id,
+		(void *)&cmd_vf_tc_bw_tc_no,
+		(void *)&cmd_vf_tc_bw_bw,
+		NULL,
+	},
+};
+
+
+#if defined RTE_LIBRTE_PMD_SOFTNIC && defined RTE_LIBRTE_SCHED
+
+/* *** Set Port default Traffic Management Hierarchy *** */
+struct cmd_set_port_tm_hierarchy_default_result {
+	cmdline_fixed_string_t set;
+	cmdline_fixed_string_t port;
+	cmdline_fixed_string_t tm;
+	cmdline_fixed_string_t hierarchy;
+	cmdline_fixed_string_t def;
+	portid_t port_id;
+};
+
+cmdline_parse_token_string_t cmd_set_port_tm_hierarchy_default_set =
+	TOKEN_STRING_INITIALIZER(
+		struct cmd_set_port_tm_hierarchy_default_result, set, "set");
+cmdline_parse_token_string_t cmd_set_port_tm_hierarchy_default_port =
+	TOKEN_STRING_INITIALIZER(
+		struct cmd_set_port_tm_hierarchy_default_result, port, "port");
+cmdline_parse_token_string_t cmd_set_port_tm_hierarchy_default_tm =
+	TOKEN_STRING_INITIALIZER(
+		struct cmd_set_port_tm_hierarchy_default_result, tm, "tm");
+cmdline_parse_token_string_t cmd_set_port_tm_hierarchy_default_hierarchy =
+	TOKEN_STRING_INITIALIZER(
+		struct cmd_set_port_tm_hierarchy_default_result,
+			hierarchy, "hierarchy");
+cmdline_parse_token_string_t cmd_set_port_tm_hierarchy_default_default =
+	TOKEN_STRING_INITIALIZER(
+		struct cmd_set_port_tm_hierarchy_default_result,
+			def, "default");
+cmdline_parse_token_num_t cmd_set_port_tm_hierarchy_default_port_id =
+	TOKEN_NUM_INITIALIZER(
+		struct cmd_set_port_tm_hierarchy_default_result,
+			port_id, UINT16);
+
+static void cmd_set_port_tm_hierarchy_default_parsed(void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_set_port_tm_hierarchy_default_result *res = parsed_result;
+	struct rte_port *p;
+	portid_t port_id = res->port_id;
+
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+
+	p = &ports[port_id];
+
+	/* Forward mode: tm */
+	if (strcmp(cur_fwd_config.fwd_eng->fwd_mode_name, "softnic")) {
+		printf("  softnicfwd mode not enabled(error)\n");
+		return;
+	}
+
+	/* Set the default tm hierarchy */
+	p->softport.default_tm_hierarchy_enable = 1;
+}
+
+cmdline_parse_inst_t cmd_set_port_tm_hierarchy_default = {
+	.f = cmd_set_port_tm_hierarchy_default_parsed,
+	.data = NULL,
+	.help_str = "set port tm hierarchy default <port_id>",
+	.tokens = {
+		(void *)&cmd_set_port_tm_hierarchy_default_set,
+		(void *)&cmd_set_port_tm_hierarchy_default_port,
+		(void *)&cmd_set_port_tm_hierarchy_default_tm,
+		(void *)&cmd_set_port_tm_hierarchy_default_hierarchy,
+		(void *)&cmd_set_port_tm_hierarchy_default_default,
+		(void *)&cmd_set_port_tm_hierarchy_default_port_id,
+		NULL,
+	},
+};
+#endif
+
 /** Set VXLAN encapsulation details */
 struct cmd_set_vxlan_result {
 	cmdline_fixed_string_t set;
@@ -9232,76 +15353,76 @@
 	struct rte_ether_addr eth_dst;
 };
 
-static cmdline_parse_token_string_t cmd_set_vxlan_set =
+cmdline_parse_token_string_t cmd_set_vxlan_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_vxlan_vxlan =
+cmdline_parse_token_string_t cmd_set_vxlan_vxlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, vxlan, "vxlan");
-static cmdline_parse_token_string_t cmd_set_vxlan_vxlan_tos_ttl =
+cmdline_parse_token_string_t cmd_set_vxlan_vxlan_tos_ttl =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, vxlan,
 				 "vxlan-tos-ttl");
-static cmdline_parse_token_string_t cmd_set_vxlan_vxlan_with_vlan =
+cmdline_parse_token_string_t cmd_set_vxlan_vxlan_with_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, vxlan,
 				 "vxlan-with-vlan");
-static cmdline_parse_token_string_t cmd_set_vxlan_ip_version =
+cmdline_parse_token_string_t cmd_set_vxlan_ip_version =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "ip-version");
-static cmdline_parse_token_string_t cmd_set_vxlan_ip_version_value =
+cmdline_parse_token_string_t cmd_set_vxlan_ip_version_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, ip_version,
 				 "ipv4#ipv6");
-static cmdline_parse_token_string_t cmd_set_vxlan_vni =
+cmdline_parse_token_string_t cmd_set_vxlan_vni =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "vni");
-static cmdline_parse_token_num_t cmd_set_vxlan_vni_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, vni, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_vxlan_udp_src =
+cmdline_parse_token_num_t cmd_set_vxlan_vni_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, vni, UINT32);
+cmdline_parse_token_string_t cmd_set_vxlan_udp_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "udp-src");
-static cmdline_parse_token_num_t cmd_set_vxlan_udp_src_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, udp_src, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_vxlan_udp_dst =
+cmdline_parse_token_num_t cmd_set_vxlan_udp_src_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, udp_src, UINT16);
+cmdline_parse_token_string_t cmd_set_vxlan_udp_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "udp-dst");
-static cmdline_parse_token_num_t cmd_set_vxlan_udp_dst_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, udp_dst, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_vxlan_ip_tos =
+cmdline_parse_token_num_t cmd_set_vxlan_udp_dst_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, udp_dst, UINT16);
+cmdline_parse_token_string_t cmd_set_vxlan_ip_tos =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "ip-tos");
-static cmdline_parse_token_num_t cmd_set_vxlan_ip_tos_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, tos, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_set_vxlan_ip_ttl =
+cmdline_parse_token_num_t cmd_set_vxlan_ip_tos_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, tos, UINT8);
+cmdline_parse_token_string_t cmd_set_vxlan_ip_ttl =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "ip-ttl");
-static cmdline_parse_token_num_t cmd_set_vxlan_ip_ttl_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, ttl, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_set_vxlan_ip_src =
+cmdline_parse_token_num_t cmd_set_vxlan_ip_ttl_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, ttl, UINT8);
+cmdline_parse_token_string_t cmd_set_vxlan_ip_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "ip-src");
-static cmdline_parse_token_ipaddr_t cmd_set_vxlan_ip_src_value =
+cmdline_parse_token_ipaddr_t cmd_set_vxlan_ip_src_value =
 	TOKEN_IPADDR_INITIALIZER(struct cmd_set_vxlan_result, ip_src);
-static cmdline_parse_token_string_t cmd_set_vxlan_ip_dst =
+cmdline_parse_token_string_t cmd_set_vxlan_ip_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "ip-dst");
-static cmdline_parse_token_ipaddr_t cmd_set_vxlan_ip_dst_value =
+cmdline_parse_token_ipaddr_t cmd_set_vxlan_ip_dst_value =
 	TOKEN_IPADDR_INITIALIZER(struct cmd_set_vxlan_result, ip_dst);
-static cmdline_parse_token_string_t cmd_set_vxlan_vlan =
+cmdline_parse_token_string_t cmd_set_vxlan_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "vlan-tci");
-static cmdline_parse_token_num_t cmd_set_vxlan_vlan_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, tci, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_vxlan_eth_src =
+cmdline_parse_token_num_t cmd_set_vxlan_vlan_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_vxlan_result, tci, UINT16);
+cmdline_parse_token_string_t cmd_set_vxlan_eth_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "eth-src");
-static cmdline_parse_token_etheraddr_t cmd_set_vxlan_eth_src_value =
+cmdline_parse_token_etheraddr_t cmd_set_vxlan_eth_src_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_vxlan_result, eth_src);
-static cmdline_parse_token_string_t cmd_set_vxlan_eth_dst =
+cmdline_parse_token_string_t cmd_set_vxlan_eth_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_vxlan_result, pos_token,
 				 "eth-dst");
-static cmdline_parse_token_etheraddr_t cmd_set_vxlan_eth_dst_value =
+cmdline_parse_token_etheraddr_t cmd_set_vxlan_eth_dst_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_vxlan_result, eth_dst);
 
 static void cmd_set_vxlan_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_vxlan_result *res = parsed_result;
 	union {
@@ -9346,7 +15467,7 @@
 		   RTE_ETHER_ADDR_LEN);
 }
 
-static cmdline_parse_inst_t cmd_set_vxlan = {
+cmdline_parse_inst_t cmd_set_vxlan = {
 	.f = cmd_set_vxlan_parsed,
 	.data = NULL,
 	.help_str = "set vxlan ip-version ipv4|ipv6 vni <vni> udp-src"
@@ -9375,7 +15496,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_vxlan_tos_ttl = {
+cmdline_parse_inst_t cmd_set_vxlan_tos_ttl = {
 	.f = cmd_set_vxlan_parsed,
 	.data = NULL,
 	.help_str = "set vxlan-tos-ttl ip-version ipv4|ipv6 vni <vni> udp-src"
@@ -9409,7 +15530,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_vxlan_with_vlan = {
+cmdline_parse_inst_t cmd_set_vxlan_with_vlan = {
 	.f = cmd_set_vxlan_parsed,
 	.data = NULL,
 	.help_str = "set vxlan-with-vlan ip-version ipv4|ipv6 vni <vni>"
@@ -9455,53 +15576,53 @@
 	struct rte_ether_addr eth_dst;
 };
 
-static cmdline_parse_token_string_t cmd_set_nvgre_set =
+cmdline_parse_token_string_t cmd_set_nvgre_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_nvgre_nvgre =
+cmdline_parse_token_string_t cmd_set_nvgre_nvgre =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, nvgre, "nvgre");
-static cmdline_parse_token_string_t cmd_set_nvgre_nvgre_with_vlan =
+cmdline_parse_token_string_t cmd_set_nvgre_nvgre_with_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, nvgre,
 				 "nvgre-with-vlan");
-static cmdline_parse_token_string_t cmd_set_nvgre_ip_version =
+cmdline_parse_token_string_t cmd_set_nvgre_ip_version =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, pos_token,
 				 "ip-version");
-static cmdline_parse_token_string_t cmd_set_nvgre_ip_version_value =
+cmdline_parse_token_string_t cmd_set_nvgre_ip_version_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, ip_version,
 				 "ipv4#ipv6");
-static cmdline_parse_token_string_t cmd_set_nvgre_tni =
+cmdline_parse_token_string_t cmd_set_nvgre_tni =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, pos_token,
 				 "tni");
-static cmdline_parse_token_num_t cmd_set_nvgre_tni_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_nvgre_result, tni, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_nvgre_ip_src =
+cmdline_parse_token_num_t cmd_set_nvgre_tni_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_nvgre_result, tni, UINT32);
+cmdline_parse_token_string_t cmd_set_nvgre_ip_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, pos_token,
 				 "ip-src");
-static cmdline_parse_token_num_t cmd_set_nvgre_ip_src_value =
+cmdline_parse_token_num_t cmd_set_nvgre_ip_src_value =
 	TOKEN_IPADDR_INITIALIZER(struct cmd_set_nvgre_result, ip_src);
-static cmdline_parse_token_string_t cmd_set_nvgre_ip_dst =
+cmdline_parse_token_string_t cmd_set_nvgre_ip_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, pos_token,
 				 "ip-dst");
-static cmdline_parse_token_ipaddr_t cmd_set_nvgre_ip_dst_value =
+cmdline_parse_token_ipaddr_t cmd_set_nvgre_ip_dst_value =
 	TOKEN_IPADDR_INITIALIZER(struct cmd_set_nvgre_result, ip_dst);
-static cmdline_parse_token_string_t cmd_set_nvgre_vlan =
+cmdline_parse_token_string_t cmd_set_nvgre_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, pos_token,
 				 "vlan-tci");
-static cmdline_parse_token_num_t cmd_set_nvgre_vlan_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_nvgre_result, tci, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_nvgre_eth_src =
+cmdline_parse_token_num_t cmd_set_nvgre_vlan_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_nvgre_result, tci, UINT16);
+cmdline_parse_token_string_t cmd_set_nvgre_eth_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, pos_token,
 				 "eth-src");
-static cmdline_parse_token_etheraddr_t cmd_set_nvgre_eth_src_value =
+cmdline_parse_token_etheraddr_t cmd_set_nvgre_eth_src_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_nvgre_result, eth_src);
-static cmdline_parse_token_string_t cmd_set_nvgre_eth_dst =
+cmdline_parse_token_string_t cmd_set_nvgre_eth_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_nvgre_result, pos_token,
 				 "eth-dst");
-static cmdline_parse_token_etheraddr_t cmd_set_nvgre_eth_dst_value =
+cmdline_parse_token_etheraddr_t cmd_set_nvgre_eth_dst_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_nvgre_result, eth_dst);
 
 static void cmd_set_nvgre_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_nvgre_result *res = parsed_result;
 	union {
@@ -9537,7 +15658,7 @@
 		   RTE_ETHER_ADDR_LEN);
 }
 
-static cmdline_parse_inst_t cmd_set_nvgre = {
+cmdline_parse_inst_t cmd_set_nvgre = {
 	.f = cmd_set_nvgre_parsed,
 	.data = NULL,
 	.help_str = "set nvgre ip-version <ipv4|ipv6> tni <tni> ip-src"
@@ -9562,7 +15683,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_nvgre_with_vlan = {
+cmdline_parse_inst_t cmd_set_nvgre_with_vlan = {
 	.f = cmd_set_nvgre_parsed,
 	.data = NULL,
 	.help_str = "set nvgre-with-vlan ip-version <ipv4|ipv6> tni <tni>"
@@ -9601,38 +15722,38 @@
 	struct rte_ether_addr eth_dst;
 };
 
-static cmdline_parse_token_string_t cmd_set_l2_encap_set =
+cmdline_parse_token_string_t cmd_set_l2_encap_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_encap_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_l2_encap_l2_encap =
+cmdline_parse_token_string_t cmd_set_l2_encap_l2_encap =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_encap_result, l2_encap, "l2_encap");
-static cmdline_parse_token_string_t cmd_set_l2_encap_l2_encap_with_vlan =
+cmdline_parse_token_string_t cmd_set_l2_encap_l2_encap_with_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_encap_result, l2_encap,
 				 "l2_encap-with-vlan");
-static cmdline_parse_token_string_t cmd_set_l2_encap_ip_version =
+cmdline_parse_token_string_t cmd_set_l2_encap_ip_version =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_encap_result, pos_token,
 				 "ip-version");
-static cmdline_parse_token_string_t cmd_set_l2_encap_ip_version_value =
+cmdline_parse_token_string_t cmd_set_l2_encap_ip_version_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_encap_result, ip_version,
 				 "ipv4#ipv6");
-static cmdline_parse_token_string_t cmd_set_l2_encap_vlan =
+cmdline_parse_token_string_t cmd_set_l2_encap_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_encap_result, pos_token,
 				 "vlan-tci");
-static cmdline_parse_token_num_t cmd_set_l2_encap_vlan_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_l2_encap_result, tci, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_l2_encap_eth_src =
+cmdline_parse_token_num_t cmd_set_l2_encap_vlan_value =
+	TOKEN_NUM_INITIALIZER(struct cmd_set_l2_encap_result, tci, UINT16);
+cmdline_parse_token_string_t cmd_set_l2_encap_eth_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_encap_result, pos_token,
 				 "eth-src");
-static cmdline_parse_token_etheraddr_t cmd_set_l2_encap_eth_src_value =
+cmdline_parse_token_etheraddr_t cmd_set_l2_encap_eth_src_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_l2_encap_result, eth_src);
-static cmdline_parse_token_string_t cmd_set_l2_encap_eth_dst =
+cmdline_parse_token_string_t cmd_set_l2_encap_eth_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_encap_result, pos_token,
 				 "eth-dst");
-static cmdline_parse_token_etheraddr_t cmd_set_l2_encap_eth_dst_value =
+cmdline_parse_token_etheraddr_t cmd_set_l2_encap_eth_dst_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_l2_encap_result, eth_dst);
 
 static void cmd_set_l2_encap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_l2_encap_result *res = parsed_result;
 
@@ -9654,7 +15775,7 @@
 		   RTE_ETHER_ADDR_LEN);
 }
 
-static cmdline_parse_inst_t cmd_set_l2_encap = {
+cmdline_parse_inst_t cmd_set_l2_encap = {
 	.f = cmd_set_l2_encap_parsed,
 	.data = NULL,
 	.help_str = "set l2_encap ip-version ipv4|ipv6"
@@ -9672,7 +15793,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_l2_encap_with_vlan = {
+cmdline_parse_inst_t cmd_set_l2_encap_with_vlan = {
 	.f = cmd_set_l2_encap_parsed,
 	.data = NULL,
 	.help_str = "set l2_encap-with-vlan ip-version ipv4|ipv6"
@@ -9700,18 +15821,18 @@
 	uint32_t vlan_present:1;
 };
 
-static cmdline_parse_token_string_t cmd_set_l2_decap_set =
+cmdline_parse_token_string_t cmd_set_l2_decap_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_decap_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_l2_decap_l2_decap =
+cmdline_parse_token_string_t cmd_set_l2_decap_l2_decap =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_decap_result, l2_decap,
 				 "l2_decap");
-static cmdline_parse_token_string_t cmd_set_l2_decap_l2_decap_with_vlan =
+cmdline_parse_token_string_t cmd_set_l2_decap_l2_decap_with_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_l2_decap_result, l2_decap,
 				 "l2_decap-with-vlan");
 
 static void cmd_set_l2_decap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_l2_decap_result *res = parsed_result;
 
@@ -9721,7 +15842,7 @@
 		l2_decap_conf.select_vlan = 1;
 }
 
-static cmdline_parse_inst_t cmd_set_l2_decap = {
+cmdline_parse_inst_t cmd_set_l2_decap = {
 	.f = cmd_set_l2_decap_parsed,
 	.data = NULL,
 	.help_str = "set l2_decap",
@@ -9732,7 +15853,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_l2_decap_with_vlan = {
+cmdline_parse_inst_t cmd_set_l2_decap_with_vlan = {
 	.f = cmd_set_l2_decap_parsed,
 	.data = NULL,
 	.help_str = "set l2_decap-with-vlan",
@@ -9758,59 +15879,59 @@
 	struct rte_ether_addr eth_dst;
 };
 
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_set =
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result, set,
 				 "set");
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_mplsogre_encap =
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_mplsogre_encap =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result, mplsogre,
 				 "mplsogre_encap");
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_mplsogre_encap_with_vlan =
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_mplsogre_encap_with_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				 mplsogre, "mplsogre_encap-with-vlan");
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_ip_version =
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_ip_version =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				 pos_token, "ip-version");
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_ip_version_value =
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_ip_version_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				 ip_version, "ipv4#ipv6");
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_label =
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_label =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				 pos_token, "label");
-static cmdline_parse_token_num_t cmd_set_mplsogre_encap_label_value =
+cmdline_parse_token_num_t cmd_set_mplsogre_encap_label_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_mplsogre_encap_result, label,
-			      RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_ip_src =
+			      UINT32);
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_ip_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				 pos_token, "ip-src");
-static cmdline_parse_token_ipaddr_t cmd_set_mplsogre_encap_ip_src_value =
+cmdline_parse_token_ipaddr_t cmd_set_mplsogre_encap_ip_src_value =
 	TOKEN_IPADDR_INITIALIZER(struct cmd_set_mplsogre_encap_result, ip_src);
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_ip_dst =
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_ip_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				 pos_token, "ip-dst");
-static cmdline_parse_token_ipaddr_t cmd_set_mplsogre_encap_ip_dst_value =
+cmdline_parse_token_ipaddr_t cmd_set_mplsogre_encap_ip_dst_value =
 	TOKEN_IPADDR_INITIALIZER(struct cmd_set_mplsogre_encap_result, ip_dst);
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_vlan =
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				 pos_token, "vlan-tci");
-static cmdline_parse_token_num_t cmd_set_mplsogre_encap_vlan_value =
+cmdline_parse_token_num_t cmd_set_mplsogre_encap_vlan_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_mplsogre_encap_result, tci,
-			      RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_eth_src =
+			      UINT16);
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_eth_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				 pos_token, "eth-src");
-static cmdline_parse_token_etheraddr_t cmd_set_mplsogre_encap_eth_src_value =
+cmdline_parse_token_etheraddr_t cmd_set_mplsogre_encap_eth_src_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				    eth_src);
-static cmdline_parse_token_string_t cmd_set_mplsogre_encap_eth_dst =
+cmdline_parse_token_string_t cmd_set_mplsogre_encap_eth_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				 pos_token, "eth-dst");
-static cmdline_parse_token_etheraddr_t cmd_set_mplsogre_encap_eth_dst_value =
+cmdline_parse_token_etheraddr_t cmd_set_mplsogre_encap_eth_dst_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_mplsogre_encap_result,
 				    eth_dst);
 
 static void cmd_set_mplsogre_encap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_mplsogre_encap_result *res = parsed_result;
 	union {
@@ -9846,7 +15967,7 @@
 		   RTE_ETHER_ADDR_LEN);
 }
 
-static cmdline_parse_inst_t cmd_set_mplsogre_encap = {
+cmdline_parse_inst_t cmd_set_mplsogre_encap = {
 	.f = cmd_set_mplsogre_encap_parsed,
 	.data = NULL,
 	.help_str = "set mplsogre_encap ip-version ipv4|ipv6 label <label>"
@@ -9871,7 +15992,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_mplsogre_encap_with_vlan = {
+cmdline_parse_inst_t cmd_set_mplsogre_encap_with_vlan = {
 	.f = cmd_set_mplsogre_encap_parsed,
 	.data = NULL,
 	.help_str = "set mplsogre_encap-with-vlan ip-version ipv4|ipv6"
@@ -9907,25 +16028,25 @@
 	uint32_t vlan_present:1;
 };
 
-static cmdline_parse_token_string_t cmd_set_mplsogre_decap_set =
+cmdline_parse_token_string_t cmd_set_mplsogre_decap_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_decap_result, set,
 				 "set");
-static cmdline_parse_token_string_t cmd_set_mplsogre_decap_mplsogre_decap =
+cmdline_parse_token_string_t cmd_set_mplsogre_decap_mplsogre_decap =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_decap_result, mplsogre,
 				 "mplsogre_decap");
-static cmdline_parse_token_string_t cmd_set_mplsogre_decap_mplsogre_decap_with_vlan =
+cmdline_parse_token_string_t cmd_set_mplsogre_decap_mplsogre_decap_with_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_decap_result,
 				 mplsogre, "mplsogre_decap-with-vlan");
-static cmdline_parse_token_string_t cmd_set_mplsogre_decap_ip_version =
+cmdline_parse_token_string_t cmd_set_mplsogre_decap_ip_version =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_decap_result,
 				 pos_token, "ip-version");
-static cmdline_parse_token_string_t cmd_set_mplsogre_decap_ip_version_value =
+cmdline_parse_token_string_t cmd_set_mplsogre_decap_ip_version_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsogre_decap_result,
 				 ip_version, "ipv4#ipv6");
 
 static void cmd_set_mplsogre_decap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_mplsogre_decap_result *res = parsed_result;
 
@@ -9939,7 +16060,7 @@
 		mplsogre_decap_conf.select_ipv4 = 0;
 }
 
-static cmdline_parse_inst_t cmd_set_mplsogre_decap = {
+cmdline_parse_inst_t cmd_set_mplsogre_decap = {
 	.f = cmd_set_mplsogre_decap_parsed,
 	.data = NULL,
 	.help_str = "set mplsogre_decap ip-version ipv4|ipv6",
@@ -9952,7 +16073,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_mplsogre_decap_with_vlan = {
+cmdline_parse_inst_t cmd_set_mplsogre_decap_with_vlan = {
 	.f = cmd_set_mplsogre_decap_parsed,
 	.data = NULL,
 	.help_str = "set mplsogre_decap-with-vlan ip-version ipv4|ipv6",
@@ -9982,71 +16103,71 @@
 	struct rte_ether_addr eth_dst;
 };
 
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_set =
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result, set,
 				 "set");
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_mplsoudp_encap =
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_mplsoudp_encap =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result, mplsoudp,
 				 "mplsoudp_encap");
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_mplsoudp_encap_with_vlan =
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_mplsoudp_encap_with_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 mplsoudp, "mplsoudp_encap-with-vlan");
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_ip_version =
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_ip_version =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 pos_token, "ip-version");
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_ip_version_value =
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_ip_version_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 ip_version, "ipv4#ipv6");
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_label =
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_label =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 pos_token, "label");
-static cmdline_parse_token_num_t cmd_set_mplsoudp_encap_label_value =
+cmdline_parse_token_num_t cmd_set_mplsoudp_encap_label_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_mplsoudp_encap_result, label,
-			      RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_udp_src =
+			      UINT32);
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_udp_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 pos_token, "udp-src");
-static cmdline_parse_token_num_t cmd_set_mplsoudp_encap_udp_src_value =
+cmdline_parse_token_num_t cmd_set_mplsoudp_encap_udp_src_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_mplsoudp_encap_result, udp_src,
-			      RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_udp_dst =
+			      UINT16);
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_udp_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 pos_token, "udp-dst");
-static cmdline_parse_token_num_t cmd_set_mplsoudp_encap_udp_dst_value =
+cmdline_parse_token_num_t cmd_set_mplsoudp_encap_udp_dst_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_mplsoudp_encap_result, udp_dst,
-			      RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_ip_src =
+			      UINT16);
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_ip_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 pos_token, "ip-src");
-static cmdline_parse_token_ipaddr_t cmd_set_mplsoudp_encap_ip_src_value =
+cmdline_parse_token_ipaddr_t cmd_set_mplsoudp_encap_ip_src_value =
 	TOKEN_IPADDR_INITIALIZER(struct cmd_set_mplsoudp_encap_result, ip_src);
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_ip_dst =
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_ip_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 pos_token, "ip-dst");
-static cmdline_parse_token_ipaddr_t cmd_set_mplsoudp_encap_ip_dst_value =
+cmdline_parse_token_ipaddr_t cmd_set_mplsoudp_encap_ip_dst_value =
 	TOKEN_IPADDR_INITIALIZER(struct cmd_set_mplsoudp_encap_result, ip_dst);
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_vlan =
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 pos_token, "vlan-tci");
-static cmdline_parse_token_num_t cmd_set_mplsoudp_encap_vlan_value =
+cmdline_parse_token_num_t cmd_set_mplsoudp_encap_vlan_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_mplsoudp_encap_result, tci,
-			      RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_eth_src =
+			      UINT16);
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_eth_src =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 pos_token, "eth-src");
-static cmdline_parse_token_etheraddr_t cmd_set_mplsoudp_encap_eth_src_value =
+cmdline_parse_token_etheraddr_t cmd_set_mplsoudp_encap_eth_src_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				    eth_src);
-static cmdline_parse_token_string_t cmd_set_mplsoudp_encap_eth_dst =
+cmdline_parse_token_string_t cmd_set_mplsoudp_encap_eth_dst =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				 pos_token, "eth-dst");
-static cmdline_parse_token_etheraddr_t cmd_set_mplsoudp_encap_eth_dst_value =
+cmdline_parse_token_etheraddr_t cmd_set_mplsoudp_encap_eth_dst_value =
 	TOKEN_ETHERADDR_INITIALIZER(struct cmd_set_mplsoudp_encap_result,
 				    eth_dst);
 
 static void cmd_set_mplsoudp_encap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_mplsoudp_encap_result *res = parsed_result;
 	union {
@@ -10084,7 +16205,7 @@
 		   RTE_ETHER_ADDR_LEN);
 }
 
-static cmdline_parse_inst_t cmd_set_mplsoudp_encap = {
+cmdline_parse_inst_t cmd_set_mplsoudp_encap = {
 	.f = cmd_set_mplsoudp_encap_parsed,
 	.data = NULL,
 	.help_str = "set mplsoudp_encap ip-version ipv4|ipv6 label <label>"
@@ -10113,7 +16234,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_mplsoudp_encap_with_vlan = {
+cmdline_parse_inst_t cmd_set_mplsoudp_encap_with_vlan = {
 	.f = cmd_set_mplsoudp_encap_parsed,
 	.data = NULL,
 	.help_str = "set mplsoudp_encap-with-vlan ip-version ipv4|ipv6"
@@ -10154,25 +16275,25 @@
 	uint32_t vlan_present:1;
 };
 
-static cmdline_parse_token_string_t cmd_set_mplsoudp_decap_set =
+cmdline_parse_token_string_t cmd_set_mplsoudp_decap_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_decap_result, set,
 				 "set");
-static cmdline_parse_token_string_t cmd_set_mplsoudp_decap_mplsoudp_decap =
+cmdline_parse_token_string_t cmd_set_mplsoudp_decap_mplsoudp_decap =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_decap_result, mplsoudp,
 				 "mplsoudp_decap");
-static cmdline_parse_token_string_t cmd_set_mplsoudp_decap_mplsoudp_decap_with_vlan =
+cmdline_parse_token_string_t cmd_set_mplsoudp_decap_mplsoudp_decap_with_vlan =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_decap_result,
 				 mplsoudp, "mplsoudp_decap-with-vlan");
-static cmdline_parse_token_string_t cmd_set_mplsoudp_decap_ip_version =
+cmdline_parse_token_string_t cmd_set_mplsoudp_decap_ip_version =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_decap_result,
 				 pos_token, "ip-version");
-static cmdline_parse_token_string_t cmd_set_mplsoudp_decap_ip_version_value =
+cmdline_parse_token_string_t cmd_set_mplsoudp_decap_ip_version_value =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_mplsoudp_decap_result,
 				 ip_version, "ipv4#ipv6");
 
 static void cmd_set_mplsoudp_decap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_mplsoudp_decap_result *res = parsed_result;
 
@@ -10186,7 +16307,7 @@
 		mplsoudp_decap_conf.select_ipv4 = 0;
 }
 
-static cmdline_parse_inst_t cmd_set_mplsoudp_decap = {
+cmdline_parse_inst_t cmd_set_mplsoudp_decap = {
 	.f = cmd_set_mplsoudp_decap_parsed,
 	.data = NULL,
 	.help_str = "set mplsoudp_decap ip-version ipv4|ipv6",
@@ -10199,7 +16320,7 @@
 	},
 };
 
-static cmdline_parse_inst_t cmd_set_mplsoudp_decap_with_vlan = {
+cmdline_parse_inst_t cmd_set_mplsoudp_decap_with_vlan = {
 	.f = cmd_set_mplsoudp_decap_parsed,
 	.data = NULL,
 	.help_str = "set mplsoudp_decap-with-vlan ip-version ipv4|ipv6",
@@ -10212,349 +16333,736 @@
 	},
 };
 
-/** Set connection tracking object common details */
-struct cmd_set_conntrack_common_result {
-	cmdline_fixed_string_t set;
-	cmdline_fixed_string_t conntrack;
-	cmdline_fixed_string_t common;
-	cmdline_fixed_string_t peer;
-	cmdline_fixed_string_t is_orig;
-	cmdline_fixed_string_t enable;
-	cmdline_fixed_string_t live;
-	cmdline_fixed_string_t sack;
-	cmdline_fixed_string_t cack;
-	cmdline_fixed_string_t last_dir;
-	cmdline_fixed_string_t liberal;
-	cmdline_fixed_string_t state;
-	cmdline_fixed_string_t max_ack_win;
-	cmdline_fixed_string_t retrans;
-	cmdline_fixed_string_t last_win;
-	cmdline_fixed_string_t last_seq;
-	cmdline_fixed_string_t last_ack;
-	cmdline_fixed_string_t last_end;
-	cmdline_fixed_string_t last_index;
-	uint8_t stat;
-	uint8_t factor;
-	uint16_t peer_port;
-	uint32_t is_original;
-	uint32_t en;
-	uint32_t is_live;
-	uint32_t s_ack;
-	uint32_t c_ack;
-	uint32_t ld;
-	uint32_t lb;
-	uint8_t re_num;
-	uint8_t li;
-	uint16_t lw;
-	uint32_t ls;
-	uint32_t la;
-	uint32_t le;
+/* Strict link priority scheduling mode setting */
+static void
+cmd_strict_link_prio_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_vf_tc_bw_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_set_tc_strict_prio(res->port_id, res->tc_map);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid tc_bitmap 0x%x\n", res->tc_map);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_strict_link_prio = {
+	.f = cmd_strict_link_prio_parsed,
+	.data = NULL,
+	.help_str = "set tx strict-link-priority <port_id> <tc_bitmap>",
+	.tokens = {
+		(void *)&cmd_vf_tc_bw_set,
+		(void *)&cmd_vf_tc_bw_tx,
+		(void *)&cmd_vf_tc_bw_strict_link_prio,
+		(void *)&cmd_vf_tc_bw_port_id,
+		(void *)&cmd_vf_tc_bw_tc_map,
+		NULL,
+	},
 };
 
-static cmdline_parse_token_string_t cmd_set_conntrack_set =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 set, "set");
-static cmdline_parse_token_string_t cmd_set_conntrack_conntrack =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 conntrack, "conntrack");
-static cmdline_parse_token_string_t cmd_set_conntrack_common_com =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 common, "com");
-static cmdline_parse_token_string_t cmd_set_conntrack_common_peer =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 peer, "peer");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_peer_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      peer_port, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_is_orig =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 is_orig, "is_orig");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_is_orig_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      is_original, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_enable =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 enable, "enable");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_enable_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      en, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_live =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 live, "live");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_live_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      is_live, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_sack =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 sack, "sack");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_sack_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      s_ack, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_cack =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 cack, "cack");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_cack_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      c_ack, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_last_dir =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 last_dir, "last_dir");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_last_dir_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      ld, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_liberal =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 liberal, "liberal");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_liberal_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      lb, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_state =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 state, "state");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_state_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      stat, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_max_ackwin =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 max_ack_win, "max_ack_win");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_max_ackwin_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      factor, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_retrans =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 retrans, "r_lim");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_retrans_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      re_num, RTE_UINT8);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_last_win =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 last_win, "last_win");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_last_win_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      lw, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_last_seq =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 last_seq, "last_seq");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_last_seq_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      ls, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_last_ack =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 last_ack, "last_ack");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_last_ack_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      la, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_last_end =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 last_end, "last_end");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_last_end_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      le, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_common_last_index =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_common_result,
-				 last_index, "last_index");
-static cmdline_parse_token_num_t cmd_set_conntrack_common_last_index_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_common_result,
-			      li, RTE_UINT8);
+/* Load dynamic device personalization*/
+struct cmd_ddp_add_result {
+	cmdline_fixed_string_t ddp;
+	cmdline_fixed_string_t add;
+	portid_t port_id;
+	char filepath[];
+};
 
-static void cmd_set_conntrack_common_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+cmdline_parse_token_string_t cmd_ddp_add_ddp =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_add_result, ddp, "ddp");
+cmdline_parse_token_string_t cmd_ddp_add_add =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_add_result, add, "add");
+cmdline_parse_token_num_t cmd_ddp_add_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_ddp_add_result, port_id, UINT16);
+cmdline_parse_token_string_t cmd_ddp_add_filepath =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_add_result, filepath, NULL);
+
+static void
+cmd_ddp_add_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
-	struct cmd_set_conntrack_common_result *res = parsed_result;
+	struct cmd_ddp_add_result *res = parsed_result;
+	uint8_t *buff;
+	uint32_t size;
+	char *filepath;
+	char *file_fld[2];
+	int file_num;
+	int ret = -ENOTSUP;
+
+	if (!all_ports_stopped()) {
+		printf("Please stop all ports first\n");
+		return;
+	}
 
-	/* No need to swap to big endian. */
-	conntrack_context.peer_port = res->peer_port;
-	conntrack_context.is_original_dir = res->is_original;
-	conntrack_context.enable = res->en;
-	conntrack_context.live_connection = res->is_live;
-	conntrack_context.selective_ack = res->s_ack;
-	conntrack_context.challenge_ack_passed = res->c_ack;
-	conntrack_context.last_direction = res->ld;
-	conntrack_context.liberal_mode = res->lb;
-	conntrack_context.state = (enum rte_flow_conntrack_state)res->stat;
-	conntrack_context.max_ack_window = res->factor;
-	conntrack_context.retransmission_limit = res->re_num;
-	conntrack_context.last_window = res->lw;
-	conntrack_context.last_index =
-		(enum rte_flow_conntrack_tcp_last_index)res->li;
-	conntrack_context.last_seq = res->ls;
-	conntrack_context.last_ack = res->la;
-	conntrack_context.last_end = res->le;
-}
-
-static cmdline_parse_inst_t cmd_set_conntrack_common = {
-	.f = cmd_set_conntrack_common_parsed,
-	.data = NULL,
-	.help_str = "set conntrack com peer <port_id> is_orig <dir> enable <en>"
-		" live <ack_seen> sack <en> cack <passed> last_dir <dir>"
-		" liberal <en> state <s> max_ack_win <factor> r_lim <num>"
-		" last_win <win> last_seq <seq> last_ack <ack> last_end <end>"
-		" last_index <flag>",
-	.tokens = {
-		(void *)&cmd_set_conntrack_set,
-		(void *)&cmd_set_conntrack_conntrack,
-		(void *)&cmd_set_conntrack_common_com,
-		(void *)&cmd_set_conntrack_common_peer,
-		(void *)&cmd_set_conntrack_common_peer_value,
-		(void *)&cmd_set_conntrack_common_is_orig,
-		(void *)&cmd_set_conntrack_common_is_orig_value,
-		(void *)&cmd_set_conntrack_common_enable,
-		(void *)&cmd_set_conntrack_common_enable_value,
-		(void *)&cmd_set_conntrack_common_live,
-		(void *)&cmd_set_conntrack_common_live_value,
-		(void *)&cmd_set_conntrack_common_sack,
-		(void *)&cmd_set_conntrack_common_sack_value,
-		(void *)&cmd_set_conntrack_common_cack,
-		(void *)&cmd_set_conntrack_common_cack_value,
-		(void *)&cmd_set_conntrack_common_last_dir,
-		(void *)&cmd_set_conntrack_common_last_dir_value,
-		(void *)&cmd_set_conntrack_common_liberal,
-		(void *)&cmd_set_conntrack_common_liberal_value,
-		(void *)&cmd_set_conntrack_common_state,
-		(void *)&cmd_set_conntrack_common_state_value,
-		(void *)&cmd_set_conntrack_common_max_ackwin,
-		(void *)&cmd_set_conntrack_common_max_ackwin_value,
-		(void *)&cmd_set_conntrack_common_retrans,
-		(void *)&cmd_set_conntrack_common_retrans_value,
-		(void *)&cmd_set_conntrack_common_last_win,
-		(void *)&cmd_set_conntrack_common_last_win_value,
-		(void *)&cmd_set_conntrack_common_last_seq,
-		(void *)&cmd_set_conntrack_common_last_seq_value,
-		(void *)&cmd_set_conntrack_common_last_ack,
-		(void *)&cmd_set_conntrack_common_last_ack_value,
-		(void *)&cmd_set_conntrack_common_last_end,
-		(void *)&cmd_set_conntrack_common_last_end_value,
-		(void *)&cmd_set_conntrack_common_last_index,
-		(void *)&cmd_set_conntrack_common_last_index_value,
-		NULL,
-	},
-};
-
-/** Set connection tracking object both directions' details */
-struct cmd_set_conntrack_dir_result {
-	cmdline_fixed_string_t set;
-	cmdline_fixed_string_t conntrack;
-	cmdline_fixed_string_t dir;
-	cmdline_fixed_string_t scale;
-	cmdline_fixed_string_t fin;
-	cmdline_fixed_string_t ack_seen;
-	cmdline_fixed_string_t unack;
-	cmdline_fixed_string_t sent_end;
-	cmdline_fixed_string_t reply_end;
-	cmdline_fixed_string_t max_win;
-	cmdline_fixed_string_t max_ack;
-	uint32_t factor;
-	uint32_t f;
-	uint32_t as;
-	uint32_t un;
-	uint32_t se;
-	uint32_t re;
-	uint32_t mw;
-	uint32_t ma;
-};
-
-static cmdline_parse_token_string_t cmd_set_conntrack_dir_dir =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_dir_result,
-				 dir, "orig#rply");
-static cmdline_parse_token_string_t cmd_set_conntrack_dir_scale =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_dir_result,
-				 scale, "scale");
-static cmdline_parse_token_num_t cmd_set_conntrack_dir_scale_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_dir_result,
-			      factor, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_dir_fin =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_dir_result,
-				 fin, "fin");
-static cmdline_parse_token_num_t cmd_set_conntrack_dir_fin_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_dir_result,
-			      f, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_dir_ack =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_dir_result,
-				 ack_seen, "acked");
-static cmdline_parse_token_num_t cmd_set_conntrack_dir_ack_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_dir_result,
-			      as, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_dir_unack_data =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_dir_result,
-				 unack, "unack_data");
-static cmdline_parse_token_num_t cmd_set_conntrack_dir_unack_data_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_dir_result,
-			      un, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_dir_sent_end =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_dir_result,
-				 sent_end, "sent_end");
-static cmdline_parse_token_num_t cmd_set_conntrack_dir_sent_end_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_dir_result,
-			      se, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_dir_reply_end =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_dir_result,
-				 reply_end, "reply_end");
-static cmdline_parse_token_num_t cmd_set_conntrack_dir_reply_end_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_dir_result,
-			      re, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_dir_max_win =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_dir_result,
-				 max_win, "max_win");
-static cmdline_parse_token_num_t cmd_set_conntrack_dir_max_win_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_dir_result,
-			      mw, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_set_conntrack_dir_max_ack =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_conntrack_dir_result,
-				 max_ack, "max_ack");
-static cmdline_parse_token_num_t cmd_set_conntrack_dir_max_ack_value =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_conntrack_dir_result,
-			      ma, RTE_UINT32);
+	filepath = strdup(res->filepath);
+	if (filepath == NULL) {
+		printf("Failed to allocate memory\n");
+		return;
+	}
+	file_num = rte_strsplit(filepath, strlen(filepath), file_fld, 2, ',');
 
-static void cmd_set_conntrack_dir_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	buff = open_file(file_fld[0], &size);
+	if (!buff) {
+		free((void *)filepath);
+		return;
+	}
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	if (ret == -ENOTSUP)
+		ret = rte_pmd_i40e_process_ddp_package(res->port_id,
+					       buff, size,
+					       RTE_PMD_I40E_PKG_OP_WR_ADD);
+#endif
+
+	if (ret == -EEXIST)
+		printf("Profile has already existed.\n");
+	else if (ret < 0)
+		printf("Failed to load profile.\n");
+	else if (file_num == 2)
+		save_file(file_fld[1], buff, size);
+
+	close_file(buff);
+	free((void *)filepath);
+}
+
+cmdline_parse_inst_t cmd_ddp_add = {
+	.f = cmd_ddp_add_parsed,
+	.data = NULL,
+	.help_str = "ddp add <port_id> <profile_path[,backup_profile_path]>",
+	.tokens = {
+		(void *)&cmd_ddp_add_ddp,
+		(void *)&cmd_ddp_add_add,
+		(void *)&cmd_ddp_add_port_id,
+		(void *)&cmd_ddp_add_filepath,
+		NULL,
+	},
+};
+
+/* Delete dynamic device personalization*/
+struct cmd_ddp_del_result {
+	cmdline_fixed_string_t ddp;
+	cmdline_fixed_string_t del;
+	portid_t port_id;
+	char filepath[];
+};
+
+cmdline_parse_token_string_t cmd_ddp_del_ddp =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_del_result, ddp, "ddp");
+cmdline_parse_token_string_t cmd_ddp_del_del =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_del_result, del, "del");
+cmdline_parse_token_num_t cmd_ddp_del_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_ddp_del_result, port_id, UINT16);
+cmdline_parse_token_string_t cmd_ddp_del_filepath =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_del_result, filepath, NULL);
+
+static void
+cmd_ddp_del_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_ddp_del_result *res = parsed_result;
+	uint8_t *buff;
+	uint32_t size;
+	int ret = -ENOTSUP;
+
+	if (!all_ports_stopped()) {
+		printf("Please stop all ports first\n");
+		return;
+	}
+
+	buff = open_file(res->filepath, &size);
+	if (!buff)
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	if (ret == -ENOTSUP)
+		ret = rte_pmd_i40e_process_ddp_package(res->port_id,
+					       buff, size,
+					       RTE_PMD_I40E_PKG_OP_WR_DEL);
+#endif
+
+	if (ret == -EACCES)
+		printf("Profile does not exist.\n");
+	else if (ret < 0)
+		printf("Failed to delete profile.\n");
+
+	close_file(buff);
+}
+
+cmdline_parse_inst_t cmd_ddp_del = {
+	.f = cmd_ddp_del_parsed,
+	.data = NULL,
+	.help_str = "ddp del <port_id> <backup_profile_path>",
+	.tokens = {
+		(void *)&cmd_ddp_del_ddp,
+		(void *)&cmd_ddp_del_del,
+		(void *)&cmd_ddp_del_port_id,
+		(void *)&cmd_ddp_del_filepath,
+		NULL,
+	},
+};
+
+/* Get dynamic device personalization profile info */
+struct cmd_ddp_info_result {
+	cmdline_fixed_string_t ddp;
+	cmdline_fixed_string_t get;
+	cmdline_fixed_string_t info;
+	char filepath[];
+};
+
+cmdline_parse_token_string_t cmd_ddp_info_ddp =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_info_result, ddp, "ddp");
+cmdline_parse_token_string_t cmd_ddp_info_get =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_info_result, get, "get");
+cmdline_parse_token_string_t cmd_ddp_info_info =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_info_result, info, "info");
+cmdline_parse_token_string_t cmd_ddp_info_filepath =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_info_result, filepath, NULL);
+
+static void
+cmd_ddp_info_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
-	struct cmd_set_conntrack_dir_result *res = parsed_result;
-	struct rte_flow_tcp_dir_param *dir = NULL;
+	struct cmd_ddp_info_result *res = parsed_result;
+	uint8_t *pkg;
+	uint32_t pkg_size;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	uint32_t i, j, n;
+	uint8_t *buff;
+	uint32_t buff_size = 0;
+	struct rte_pmd_i40e_profile_info info;
+	uint32_t dev_num = 0;
+	struct rte_pmd_i40e_ddp_device_id *devs;
+	uint32_t proto_num = 0;
+	struct rte_pmd_i40e_proto_info *proto = NULL;
+	uint32_t pctype_num = 0;
+	struct rte_pmd_i40e_ptype_info *pctype;
+	uint32_t ptype_num = 0;
+	struct rte_pmd_i40e_ptype_info *ptype;
+	uint8_t proto_id;
+
+#endif
+
+	pkg = open_file(res->filepath, &pkg_size);
+	if (!pkg)
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size,
+				(uint8_t *)&info, sizeof(info),
+				RTE_PMD_I40E_PKG_INFO_GLOBAL_HEADER);
+	if (!ret) {
+		printf("Global Track id:       0x%x\n", info.track_id);
+		printf("Global Version:        %d.%d.%d.%d\n",
+			info.version.major,
+			info.version.minor,
+			info.version.update,
+			info.version.draft);
+		printf("Global Package name:   %s\n\n", info.name);
+	}
+
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size,
+				(uint8_t *)&info, sizeof(info),
+				RTE_PMD_I40E_PKG_INFO_HEADER);
+	if (!ret) {
+		printf("i40e Profile Track id: 0x%x\n", info.track_id);
+		printf("i40e Profile Version:  %d.%d.%d.%d\n",
+			info.version.major,
+			info.version.minor,
+			info.version.update,
+			info.version.draft);
+		printf("i40e Profile name:     %s\n\n", info.name);
+	}
+
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size,
+				(uint8_t *)&buff_size, sizeof(buff_size),
+				RTE_PMD_I40E_PKG_INFO_GLOBAL_NOTES_SIZE);
+	if (!ret && buff_size) {
+		buff = (uint8_t *)malloc(buff_size);
+		if (buff) {
+			ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size,
+						buff, buff_size,
+						RTE_PMD_I40E_PKG_INFO_GLOBAL_NOTES);
+			if (!ret)
+				printf("Package Notes:\n%s\n\n", buff);
+			free(buff);
+		}
+	}
+
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size,
+				(uint8_t *)&dev_num, sizeof(dev_num),
+				RTE_PMD_I40E_PKG_INFO_DEVID_NUM);
+	if (!ret && dev_num) {
+		buff_size = dev_num * sizeof(struct rte_pmd_i40e_ddp_device_id);
+		devs = (struct rte_pmd_i40e_ddp_device_id *)malloc(buff_size);
+		if (devs) {
+			ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size,
+						(uint8_t *)devs, buff_size,
+						RTE_PMD_I40E_PKG_INFO_DEVID_LIST);
+			if (!ret) {
+				printf("List of supported devices:\n");
+				for (i = 0; i < dev_num; i++) {
+					printf("  %04X:%04X %04X:%04X\n",
+						devs[i].vendor_dev_id >> 16,
+						devs[i].vendor_dev_id & 0xFFFF,
+						devs[i].sub_vendor_dev_id >> 16,
+						devs[i].sub_vendor_dev_id & 0xFFFF);
+				}
+				printf("\n");
+			}
+			free(devs);
+		}
+	}
+
+	/* get information about protocols and packet types */
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size,
+		(uint8_t *)&proto_num, sizeof(proto_num),
+		RTE_PMD_I40E_PKG_INFO_PROTOCOL_NUM);
+	if (ret || !proto_num)
+		goto no_print_return;
+
+	buff_size = proto_num * sizeof(struct rte_pmd_i40e_proto_info);
+	proto = (struct rte_pmd_i40e_proto_info *)malloc(buff_size);
+	if (!proto)
+		goto no_print_return;
+
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size, (uint8_t *)proto,
+					buff_size,
+					RTE_PMD_I40E_PKG_INFO_PROTOCOL_LIST);
+	if (!ret) {
+		printf("List of used protocols:\n");
+		for (i = 0; i < proto_num; i++)
+			printf("  %2u: %s\n", proto[i].proto_id,
+			       proto[i].name);
+		printf("\n");
+	}
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size,
+		(uint8_t *)&pctype_num, sizeof(pctype_num),
+		RTE_PMD_I40E_PKG_INFO_PCTYPE_NUM);
+	if (ret || !pctype_num)
+		goto no_print_pctypes;
+
+	buff_size = pctype_num * sizeof(struct rte_pmd_i40e_ptype_info);
+	pctype = (struct rte_pmd_i40e_ptype_info *)malloc(buff_size);
+	if (!pctype)
+		goto no_print_pctypes;
+
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size, (uint8_t *)pctype,
+					buff_size,
+					RTE_PMD_I40E_PKG_INFO_PCTYPE_LIST);
+	if (ret) {
+		free(pctype);
+		goto no_print_pctypes;
+	}
+
+	printf("List of defined packet classification types:\n");
+	for (i = 0; i < pctype_num; i++) {
+		printf("  %2u:", pctype[i].ptype_id);
+		for (j = 0; j < RTE_PMD_I40E_PROTO_NUM; j++) {
+			proto_id = pctype[i].protocols[j];
+			if (proto_id != RTE_PMD_I40E_PROTO_UNUSED) {
+				for (n = 0; n < proto_num; n++) {
+					if (proto[n].proto_id == proto_id) {
+						printf(" %s", proto[n].name);
+						break;
+					}
+				}
+			}
+		}
+		printf("\n");
+	}
+	printf("\n");
+	free(pctype);
+
+no_print_pctypes:
+
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size, (uint8_t *)&ptype_num,
+					sizeof(ptype_num),
+					RTE_PMD_I40E_PKG_INFO_PTYPE_NUM);
+	if (ret || !ptype_num)
+		goto no_print_return;
+
+	buff_size = ptype_num * sizeof(struct rte_pmd_i40e_ptype_info);
+	ptype = (struct rte_pmd_i40e_ptype_info *)malloc(buff_size);
+	if (!ptype)
+		goto no_print_return;
+
+	ret = rte_pmd_i40e_get_ddp_info(pkg, pkg_size, (uint8_t *)ptype,
+					buff_size,
+					RTE_PMD_I40E_PKG_INFO_PTYPE_LIST);
+	if (ret) {
+		free(ptype);
+		goto no_print_return;
+	}
+	printf("List of defined packet types:\n");
+	for (i = 0; i < ptype_num; i++) {
+		printf("  %2u:", ptype[i].ptype_id);
+		for (j = 0; j < RTE_PMD_I40E_PROTO_NUM; j++) {
+			proto_id = ptype[i].protocols[j];
+			if (proto_id != RTE_PMD_I40E_PROTO_UNUSED) {
+				for (n = 0; n < proto_num; n++) {
+					if (proto[n].proto_id == proto_id) {
+						printf(" %s", proto[n].name);
+						break;
+					}
+				}
+			}
+		}
+		printf("\n");
+	}
+	free(ptype);
+	printf("\n");
+
+	ret = 0;
+no_print_return:
+	if (proto)
+		free(proto);
+#endif
+	if (ret == -ENOTSUP)
+		printf("Function not supported in PMD driver\n");
+	close_file(pkg);
+}
+
+cmdline_parse_inst_t cmd_ddp_get_info = {
+	.f = cmd_ddp_info_parsed,
+	.data = NULL,
+	.help_str = "ddp get info <profile_path>",
+	.tokens = {
+		(void *)&cmd_ddp_info_ddp,
+		(void *)&cmd_ddp_info_get,
+		(void *)&cmd_ddp_info_info,
+		(void *)&cmd_ddp_info_filepath,
+		NULL,
+	},
+};
+
+/* Get dynamic device personalization profile info list*/
+#define PROFILE_INFO_SIZE 48
+#define MAX_PROFILE_NUM 16
+
+struct cmd_ddp_get_list_result {
+	cmdline_fixed_string_t ddp;
+	cmdline_fixed_string_t get;
+	cmdline_fixed_string_t list;
+	portid_t port_id;
+};
+
+cmdline_parse_token_string_t cmd_ddp_get_list_ddp =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_get_list_result, ddp, "ddp");
+cmdline_parse_token_string_t cmd_ddp_get_list_get =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_get_list_result, get, "get");
+cmdline_parse_token_string_t cmd_ddp_get_list_list =
+	TOKEN_STRING_INITIALIZER(struct cmd_ddp_get_list_result, list, "list");
+cmdline_parse_token_num_t cmd_ddp_get_list_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_ddp_get_list_result, port_id, UINT16);
+
+static void
+cmd_ddp_get_list_parsed(
+	__attribute__((unused)) void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct cmd_ddp_get_list_result *res = parsed_result;
+	struct rte_pmd_i40e_profile_list *p_list;
+	struct rte_pmd_i40e_profile_info *p_info;
+	uint32_t p_num;
+	uint32_t size;
+	uint32_t i;
+#endif
+	int ret = -ENOTSUP;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	size = PROFILE_INFO_SIZE * MAX_PROFILE_NUM + 4;
+	p_list = (struct rte_pmd_i40e_profile_list *)malloc(size);
+	if (!p_list)
+		printf("%s: Failed to malloc buffer\n", __func__);
+
+	if (ret == -ENOTSUP)
+		ret = rte_pmd_i40e_get_ddp_list(res->port_id,
+						(uint8_t *)p_list, size);
+
+	if (!ret) {
+		p_num = p_list->p_count;
+		printf("Profile number is: %d\n\n", p_num);
+
+		for (i = 0; i < p_num; i++) {
+			p_info = &p_list->p_info[i];
+			printf("Profile %d:\n", i);
+			printf("Track id:     0x%x\n", p_info->track_id);
+			printf("Version:      %d.%d.%d.%d\n",
+			       p_info->version.major,
+			       p_info->version.minor,
+			       p_info->version.update,
+			       p_info->version.draft);
+			printf("Profile name: %s\n\n", p_info->name);
+		}
+	}
+
+	free(p_list);
+#endif
+
+	if (ret < 0)
+		printf("Failed to get ddp list\n");
+}
+
+cmdline_parse_inst_t cmd_ddp_get_list = {
+	.f = cmd_ddp_get_list_parsed,
+	.data = NULL,
+	.help_str = "ddp get list <port_id>",
+	.tokens = {
+		(void *)&cmd_ddp_get_list_ddp,
+		(void *)&cmd_ddp_get_list_get,
+		(void *)&cmd_ddp_get_list_list,
+		(void *)&cmd_ddp_get_list_port_id,
+		NULL,
+	},
+};
+
+/* Configure input set */
+struct cmd_cfg_input_set_result {
+	cmdline_fixed_string_t port;
+	cmdline_fixed_string_t cfg;
+	portid_t port_id;
+	cmdline_fixed_string_t pctype;
+	uint8_t pctype_id;
+	cmdline_fixed_string_t inset_type;
+	cmdline_fixed_string_t opt;
+	cmdline_fixed_string_t field;
+	uint8_t field_idx;
+};
+
+static void
+cmd_cfg_input_set_parsed(
+	__attribute__((unused)) void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct cmd_cfg_input_set_result *res = parsed_result;
+	enum rte_pmd_i40e_inset_type inset_type = INSET_NONE;
+	struct rte_pmd_i40e_inset inset;
+#endif
+	int ret = -ENOTSUP;
+
+	if (!all_ports_stopped()) {
+		printf("Please stop all ports first\n");
+		return;
+	}
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	if (!strcmp(res->inset_type, "hash_inset"))
+		inset_type = INSET_HASH;
+	else if (!strcmp(res->inset_type, "fdir_inset"))
+		inset_type = INSET_FDIR;
+	else if (!strcmp(res->inset_type, "fdir_flx_inset"))
+		inset_type = INSET_FDIR_FLX;
+	ret = rte_pmd_i40e_inset_get(res->port_id, res->pctype_id,
+				     &inset, inset_type);
+	if (ret) {
+		printf("Failed to get input set.\n");
+		return;
+	}
+
+	if (!strcmp(res->opt, "get")) {
+		ret = rte_pmd_i40e_inset_field_get(inset.inset,
+						   res->field_idx);
+		if (ret)
+			printf("Field index %d is enabled.\n", res->field_idx);
+		else
+			printf("Field index %d is disabled.\n", res->field_idx);
+		return;
+	} else if (!strcmp(res->opt, "set"))
+		ret = rte_pmd_i40e_inset_field_set(&inset.inset,
+						   res->field_idx);
+	else if (!strcmp(res->opt, "clear"))
+		ret = rte_pmd_i40e_inset_field_clear(&inset.inset,
+						     res->field_idx);
+	if (ret) {
+		printf("Failed to configure input set field.\n");
+		return;
+	}
+
+	ret = rte_pmd_i40e_inset_set(res->port_id, res->pctype_id,
+				     &inset, inset_type);
+	if (ret) {
+		printf("Failed to set input set.\n");
+		return;
+	}
+#endif
+
+	if (ret == -ENOTSUP)
+		printf("Function not supported\n");
+}
+
+cmdline_parse_token_string_t cmd_cfg_input_set_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_cfg_input_set_result,
+				 port, "port");
+cmdline_parse_token_string_t cmd_cfg_input_set_cfg =
+	TOKEN_STRING_INITIALIZER(struct cmd_cfg_input_set_result,
+				 cfg, "config");
+cmdline_parse_token_num_t cmd_cfg_input_set_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_cfg_input_set_result,
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_cfg_input_set_pctype =
+	TOKEN_STRING_INITIALIZER(struct cmd_cfg_input_set_result,
+				 pctype, "pctype");
+cmdline_parse_token_num_t cmd_cfg_input_set_pctype_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_cfg_input_set_result,
+			      pctype_id, UINT8);
+cmdline_parse_token_string_t cmd_cfg_input_set_inset_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_cfg_input_set_result,
+				 inset_type,
+				 "hash_inset#fdir_inset#fdir_flx_inset");
+cmdline_parse_token_string_t cmd_cfg_input_set_opt =
+	TOKEN_STRING_INITIALIZER(struct cmd_cfg_input_set_result,
+				 opt, "get#set#clear");
+cmdline_parse_token_string_t cmd_cfg_input_set_field =
+	TOKEN_STRING_INITIALIZER(struct cmd_cfg_input_set_result,
+				 field, "field");
+cmdline_parse_token_num_t cmd_cfg_input_set_field_idx =
+	TOKEN_NUM_INITIALIZER(struct cmd_cfg_input_set_result,
+			      field_idx, UINT8);
+
+cmdline_parse_inst_t cmd_cfg_input_set = {
+	.f = cmd_cfg_input_set_parsed,
+	.data = NULL,
+	.help_str = "port config <port_id> pctype <pctype_id> hash_inset|"
+		    "fdir_inset|fdir_flx_inset get|set|clear field <field_idx>",
+	.tokens = {
+		(void *)&cmd_cfg_input_set_port,
+		(void *)&cmd_cfg_input_set_cfg,
+		(void *)&cmd_cfg_input_set_port_id,
+		(void *)&cmd_cfg_input_set_pctype,
+		(void *)&cmd_cfg_input_set_pctype_id,
+		(void *)&cmd_cfg_input_set_inset_type,
+		(void *)&cmd_cfg_input_set_opt,
+		(void *)&cmd_cfg_input_set_field,
+		(void *)&cmd_cfg_input_set_field_idx,
+		NULL,
+	},
+};
+
+/* Clear input set */
+struct cmd_clear_input_set_result {
+	cmdline_fixed_string_t port;
+	cmdline_fixed_string_t cfg;
+	portid_t port_id;
+	cmdline_fixed_string_t pctype;
+	uint8_t pctype_id;
+	cmdline_fixed_string_t inset_type;
+	cmdline_fixed_string_t clear;
+	cmdline_fixed_string_t all;
+};
+
+static void
+cmd_clear_input_set_parsed(
+	__attribute__((unused)) void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct cmd_clear_input_set_result *res = parsed_result;
+	enum rte_pmd_i40e_inset_type inset_type = INSET_NONE;
+	struct rte_pmd_i40e_inset inset;
+#endif
+	int ret = -ENOTSUP;
+
+	if (!all_ports_stopped()) {
+		printf("Please stop all ports first\n");
+		return;
+	}
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	if (!strcmp(res->inset_type, "hash_inset"))
+		inset_type = INSET_HASH;
+	else if (!strcmp(res->inset_type, "fdir_inset"))
+		inset_type = INSET_FDIR;
+	else if (!strcmp(res->inset_type, "fdir_flx_inset"))
+		inset_type = INSET_FDIR_FLX;
+
+	memset(&inset, 0, sizeof(inset));
+
+	ret = rte_pmd_i40e_inset_set(res->port_id, res->pctype_id,
+				     &inset, inset_type);
+	if (ret) {
+		printf("Failed to clear input set.\n");
+		return;
+	}
+
+#endif
+
+	if (ret == -ENOTSUP)
+		printf("Function not supported\n");
+}
 
-	if (strcmp(res->dir, "orig") == 0)
-		dir = &conntrack_context.original_dir;
-	else if (strcmp(res->dir, "rply") == 0)
-		dir = &conntrack_context.reply_dir;
-	else
-		return;
-	dir->scale = res->factor;
-	dir->close_initiated = res->f;
-	dir->last_ack_seen = res->as;
-	dir->data_unacked = res->un;
-	dir->sent_end = res->se;
-	dir->reply_end = res->re;
-	dir->max_ack = res->ma;
-	dir->max_win = res->mw;
-}
-
-static cmdline_parse_inst_t cmd_set_conntrack_dir = {
-	.f = cmd_set_conntrack_dir_parsed,
-	.data = NULL,
-	.help_str = "set conntrack orig|rply scale <factor> fin <sent>"
-		    " acked <seen> unack_data <unack> sent_end <sent>"
-		    " reply_end <reply> max_win <win> max_ack <ack>",
-	.tokens = {
-		(void *)&cmd_set_conntrack_set,
-		(void *)&cmd_set_conntrack_conntrack,
-		(void *)&cmd_set_conntrack_dir_dir,
-		(void *)&cmd_set_conntrack_dir_scale,
-		(void *)&cmd_set_conntrack_dir_scale_value,
-		(void *)&cmd_set_conntrack_dir_fin,
-		(void *)&cmd_set_conntrack_dir_fin_value,
-		(void *)&cmd_set_conntrack_dir_ack,
-		(void *)&cmd_set_conntrack_dir_ack_value,
-		(void *)&cmd_set_conntrack_dir_unack_data,
-		(void *)&cmd_set_conntrack_dir_unack_data_value,
-		(void *)&cmd_set_conntrack_dir_sent_end,
-		(void *)&cmd_set_conntrack_dir_sent_end_value,
-		(void *)&cmd_set_conntrack_dir_reply_end,
-		(void *)&cmd_set_conntrack_dir_reply_end_value,
-		(void *)&cmd_set_conntrack_dir_max_win,
-		(void *)&cmd_set_conntrack_dir_max_win_value,
-		(void *)&cmd_set_conntrack_dir_max_ack,
-		(void *)&cmd_set_conntrack_dir_max_ack_value,
+cmdline_parse_token_string_t cmd_clear_input_set_port =
+	TOKEN_STRING_INITIALIZER(struct cmd_clear_input_set_result,
+				 port, "port");
+cmdline_parse_token_string_t cmd_clear_input_set_cfg =
+	TOKEN_STRING_INITIALIZER(struct cmd_clear_input_set_result,
+				 cfg, "config");
+cmdline_parse_token_num_t cmd_clear_input_set_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_clear_input_set_result,
+			      port_id, UINT16);
+cmdline_parse_token_string_t cmd_clear_input_set_pctype =
+	TOKEN_STRING_INITIALIZER(struct cmd_clear_input_set_result,
+				 pctype, "pctype");
+cmdline_parse_token_num_t cmd_clear_input_set_pctype_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_clear_input_set_result,
+			      pctype_id, UINT8);
+cmdline_parse_token_string_t cmd_clear_input_set_inset_type =
+	TOKEN_STRING_INITIALIZER(struct cmd_clear_input_set_result,
+				 inset_type,
+				 "hash_inset#fdir_inset#fdir_flx_inset");
+cmdline_parse_token_string_t cmd_clear_input_set_clear =
+	TOKEN_STRING_INITIALIZER(struct cmd_clear_input_set_result,
+				 clear, "clear");
+cmdline_parse_token_string_t cmd_clear_input_set_all =
+	TOKEN_STRING_INITIALIZER(struct cmd_clear_input_set_result,
+				 all, "all");
+
+cmdline_parse_inst_t cmd_clear_input_set = {
+	.f = cmd_clear_input_set_parsed,
+	.data = NULL,
+	.help_str = "port config <port_id> pctype <pctype_id> hash_inset|"
+		    "fdir_inset|fdir_flx_inset clear all",
+	.tokens = {
+		(void *)&cmd_clear_input_set_port,
+		(void *)&cmd_clear_input_set_cfg,
+		(void *)&cmd_clear_input_set_port_id,
+		(void *)&cmd_clear_input_set_pctype,
+		(void *)&cmd_clear_input_set_pctype_id,
+		(void *)&cmd_clear_input_set_inset_type,
+		(void *)&cmd_clear_input_set_clear,
+		(void *)&cmd_clear_input_set_all,
 		NULL,
 	},
 };
@@ -10571,32 +17079,32 @@
 };
 
 /* Common CLI fields show vf stats*/
-static cmdline_parse_token_string_t cmd_show_vf_stats_show =
+cmdline_parse_token_string_t cmd_show_vf_stats_show =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_show_vf_stats_result,
 		 show, "show");
-static cmdline_parse_token_string_t cmd_show_vf_stats_vf =
+cmdline_parse_token_string_t cmd_show_vf_stats_vf =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_show_vf_stats_result,
 		 vf, "vf");
-static cmdline_parse_token_string_t cmd_show_vf_stats_stats =
+cmdline_parse_token_string_t cmd_show_vf_stats_stats =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_show_vf_stats_result,
 		 stats, "stats");
-static cmdline_parse_token_num_t cmd_show_vf_stats_port_id =
+cmdline_parse_token_num_t cmd_show_vf_stats_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_show_vf_stats_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_show_vf_stats_vf_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_show_vf_stats_vf_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_show_vf_stats_result,
-		 vf_id, RTE_UINT16);
+		 vf_id, UINT16);
 
 static void
 cmd_show_vf_stats_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_show_vf_stats_result *res = parsed_result;
 	struct rte_eth_stats stats;
@@ -10608,13 +17116,13 @@
 
 	memset(&stats, 0, sizeof(stats));
 
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_get_vf_stats(res->port_id,
 						res->vf_id,
 						&stats);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_get_vf_stats(res->port_id,
 						res->vf_id,
@@ -10625,16 +17133,16 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid vf_id %d\n", res->vf_id);
+		printf("invalid vf_id %d\n", res->vf_id);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented\n");
+		printf("function not implemented\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 
 	printf("\n  %s NIC statistics for port %-2d vf %-2d %s\n",
@@ -10654,7 +17162,7 @@
 			       nic_stats_border, nic_stats_border);
 }
 
-static cmdline_parse_inst_t cmd_show_vf_stats = {
+cmdline_parse_inst_t cmd_show_vf_stats = {
 	.f = cmd_show_vf_stats_parsed,
 	.data = NULL,
 	.help_str = "show vf stats <port_id> <vf_id>",
@@ -10680,32 +17188,32 @@
 };
 
 /* Common CLI fields clear vf stats*/
-static cmdline_parse_token_string_t cmd_clear_vf_stats_clear =
+cmdline_parse_token_string_t cmd_clear_vf_stats_clear =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_clear_vf_stats_result,
 		 clear, "clear");
-static cmdline_parse_token_string_t cmd_clear_vf_stats_vf =
+cmdline_parse_token_string_t cmd_clear_vf_stats_vf =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_clear_vf_stats_result,
 		 vf, "vf");
-static cmdline_parse_token_string_t cmd_clear_vf_stats_stats =
+cmdline_parse_token_string_t cmd_clear_vf_stats_stats =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_clear_vf_stats_result,
 		 stats, "stats");
-static cmdline_parse_token_num_t cmd_clear_vf_stats_port_id =
+cmdline_parse_token_num_t cmd_clear_vf_stats_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_clear_vf_stats_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_clear_vf_stats_vf_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_clear_vf_stats_vf_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_clear_vf_stats_result,
-		 vf_id, RTE_UINT16);
+		 vf_id, UINT16);
 
 static void
 cmd_clear_vf_stats_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_clear_vf_stats_result *res = parsed_result;
 	int ret = -ENOTSUP;
@@ -10713,12 +17221,12 @@
 	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
 		return;
 
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_i40e_reset_vf_stats(res->port_id,
 						  res->vf_id);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (ret == -ENOTSUP)
 		ret = rte_pmd_bnxt_reset_vf_stats(res->port_id,
 						  res->vf_id);
@@ -10728,20 +17236,20 @@
 	case 0:
 		break;
 	case -EINVAL:
-		fprintf(stderr, "invalid vf_id %d\n", res->vf_id);
+		printf("invalid vf_id %d\n", res->vf_id);
 		break;
 	case -ENODEV:
-		fprintf(stderr, "invalid port_id %d\n", res->port_id);
+		printf("invalid port_id %d\n", res->port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "function not implemented\n");
+		printf("function not implemented\n");
 		break;
 	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
+		printf("programming error: (%s)\n", strerror(-ret));
 	}
 }
 
-static cmdline_parse_inst_t cmd_clear_vf_stats = {
+cmdline_parse_inst_t cmd_clear_vf_stats = {
 	.f = cmd_clear_vf_stats_parsed,
 	.data = NULL,
 	.help_str = "clear vf stats <port_id> <vf_id>",
@@ -10755,6 +17263,659 @@
 	},
 };
 
+/* port config pctype mapping reset */
+
+/* Common result structure for port config pctype mapping reset */
+struct cmd_pctype_mapping_reset_result {
+	cmdline_fixed_string_t port;
+	cmdline_fixed_string_t config;
+	portid_t port_id;
+	cmdline_fixed_string_t pctype;
+	cmdline_fixed_string_t mapping;
+	cmdline_fixed_string_t reset;
+};
+
+/* Common CLI fields for port config pctype mapping reset*/
+cmdline_parse_token_string_t cmd_pctype_mapping_reset_port =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_reset_result,
+		 port, "port");
+cmdline_parse_token_string_t cmd_pctype_mapping_reset_config =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_reset_result,
+		 config, "config");
+cmdline_parse_token_num_t cmd_pctype_mapping_reset_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_pctype_mapping_reset_result,
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_pctype_mapping_reset_pctype =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_reset_result,
+		 pctype, "pctype");
+cmdline_parse_token_string_t cmd_pctype_mapping_reset_mapping =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_reset_result,
+		 mapping, "mapping");
+cmdline_parse_token_string_t cmd_pctype_mapping_reset_reset =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_reset_result,
+		 reset, "reset");
+
+static void
+cmd_pctype_mapping_reset_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_pctype_mapping_reset_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_flow_type_mapping_reset(res->port_id);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_pctype_mapping_reset = {
+	.f = cmd_pctype_mapping_reset_parsed,
+	.data = NULL,
+	.help_str = "port config <port_id> pctype mapping reset",
+	.tokens = {
+		(void *)&cmd_pctype_mapping_reset_port,
+		(void *)&cmd_pctype_mapping_reset_config,
+		(void *)&cmd_pctype_mapping_reset_port_id,
+		(void *)&cmd_pctype_mapping_reset_pctype,
+		(void *)&cmd_pctype_mapping_reset_mapping,
+		(void *)&cmd_pctype_mapping_reset_reset,
+		NULL,
+	},
+};
+
+/* show port pctype mapping */
+
+/* Common result structure for show port pctype mapping */
+struct cmd_pctype_mapping_get_result {
+	cmdline_fixed_string_t show;
+	cmdline_fixed_string_t port;
+	portid_t port_id;
+	cmdline_fixed_string_t pctype;
+	cmdline_fixed_string_t mapping;
+};
+
+/* Common CLI fields for pctype mapping get */
+cmdline_parse_token_string_t cmd_pctype_mapping_get_show =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_get_result,
+		 show, "show");
+cmdline_parse_token_string_t cmd_pctype_mapping_get_port =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_get_result,
+		 port, "port");
+cmdline_parse_token_num_t cmd_pctype_mapping_get_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_pctype_mapping_get_result,
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_pctype_mapping_get_pctype =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_get_result,
+		 pctype, "pctype");
+cmdline_parse_token_string_t cmd_pctype_mapping_get_mapping =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_get_result,
+		 mapping, "mapping");
+
+static void
+cmd_pctype_mapping_get_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_pctype_mapping_get_result *res = parsed_result;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct rte_pmd_i40e_flow_type_mapping
+				mapping[RTE_PMD_I40E_FLOW_TYPE_MAX];
+	int i, j, first_pctype;
+#endif
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_flow_type_mapping_get(res->port_id, mapping);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		return;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		return;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+		return;
+	}
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	for (i = 0; i < RTE_PMD_I40E_FLOW_TYPE_MAX; i++) {
+		if (mapping[i].pctype != 0ULL) {
+			first_pctype = 1;
+
+			printf("pctype: ");
+			for (j = 0; j < RTE_PMD_I40E_PCTYPE_MAX; j++) {
+				if (mapping[i].pctype & (1ULL << j)) {
+					printf(first_pctype ?
+					       "%02d" : ",%02d", j);
+					first_pctype = 0;
+				}
+			}
+			printf("  ->  flowtype: %02d\n", mapping[i].flow_type);
+		}
+	}
+#endif
+}
+
+cmdline_parse_inst_t cmd_pctype_mapping_get = {
+	.f = cmd_pctype_mapping_get_parsed,
+	.data = NULL,
+	.help_str = "show port <port_id> pctype mapping",
+	.tokens = {
+		(void *)&cmd_pctype_mapping_get_show,
+		(void *)&cmd_pctype_mapping_get_port,
+		(void *)&cmd_pctype_mapping_get_port_id,
+		(void *)&cmd_pctype_mapping_get_pctype,
+		(void *)&cmd_pctype_mapping_get_mapping,
+		NULL,
+	},
+};
+
+/* port config pctype mapping update */
+
+/* Common result structure for port config pctype mapping update */
+struct cmd_pctype_mapping_update_result {
+	cmdline_fixed_string_t port;
+	cmdline_fixed_string_t config;
+	portid_t port_id;
+	cmdline_fixed_string_t pctype;
+	cmdline_fixed_string_t mapping;
+	cmdline_fixed_string_t update;
+	cmdline_fixed_string_t pctype_list;
+	uint16_t flow_type;
+};
+
+/* Common CLI fields for pctype mapping update*/
+cmdline_parse_token_string_t cmd_pctype_mapping_update_port =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_update_result,
+		 port, "port");
+cmdline_parse_token_string_t cmd_pctype_mapping_update_config =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_update_result,
+		 config, "config");
+cmdline_parse_token_num_t cmd_pctype_mapping_update_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_pctype_mapping_update_result,
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_pctype_mapping_update_pctype =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_update_result,
+		 pctype, "pctype");
+cmdline_parse_token_string_t cmd_pctype_mapping_update_mapping =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_update_result,
+		 mapping, "mapping");
+cmdline_parse_token_string_t cmd_pctype_mapping_update_update =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_update_result,
+		 update, "update");
+cmdline_parse_token_string_t cmd_pctype_mapping_update_pc_type =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_pctype_mapping_update_result,
+		 pctype_list, NULL);
+cmdline_parse_token_num_t cmd_pctype_mapping_update_flow_type =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_pctype_mapping_update_result,
+		 flow_type, UINT16);
+
+static void
+cmd_pctype_mapping_update_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_pctype_mapping_update_result *res = parsed_result;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct rte_pmd_i40e_flow_type_mapping mapping;
+	unsigned int i;
+	unsigned int nb_item;
+	unsigned int pctype_list[RTE_PMD_I40E_PCTYPE_MAX];
+#endif
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	nb_item = parse_item_list(res->pctype_list, "pctypes",
+				  RTE_PMD_I40E_PCTYPE_MAX, pctype_list, 1);
+	mapping.flow_type = res->flow_type;
+	for (i = 0, mapping.pctype = 0ULL; i < nb_item; i++)
+		mapping.pctype |= (1ULL << pctype_list[i]);
+	ret = rte_pmd_i40e_flow_type_mapping_update(res->port_id,
+						&mapping,
+						1,
+						0);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid pctype or flow type\n");
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_pctype_mapping_update = {
+	.f = cmd_pctype_mapping_update_parsed,
+	.data = NULL,
+	.help_str = "port config <port_id> pctype mapping update"
+	" <pctype_id_0,[pctype_id_1]*> <flowtype_id>",
+	.tokens = {
+		(void *)&cmd_pctype_mapping_update_port,
+		(void *)&cmd_pctype_mapping_update_config,
+		(void *)&cmd_pctype_mapping_update_port_id,
+		(void *)&cmd_pctype_mapping_update_pctype,
+		(void *)&cmd_pctype_mapping_update_mapping,
+		(void *)&cmd_pctype_mapping_update_update,
+		(void *)&cmd_pctype_mapping_update_pc_type,
+		(void *)&cmd_pctype_mapping_update_flow_type,
+		NULL,
+	},
+};
+
+/* ptype mapping get */
+
+/* Common result structure for ptype mapping get */
+struct cmd_ptype_mapping_get_result {
+	cmdline_fixed_string_t ptype;
+	cmdline_fixed_string_t mapping;
+	cmdline_fixed_string_t get;
+	portid_t port_id;
+	uint8_t valid_only;
+};
+
+/* Common CLI fields for ptype mapping get */
+cmdline_parse_token_string_t cmd_ptype_mapping_get_ptype =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_get_result,
+		 ptype, "ptype");
+cmdline_parse_token_string_t cmd_ptype_mapping_get_mapping =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_get_result,
+		 mapping, "mapping");
+cmdline_parse_token_string_t cmd_ptype_mapping_get_get =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_get_result,
+		 get, "get");
+cmdline_parse_token_num_t cmd_ptype_mapping_get_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_get_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_ptype_mapping_get_valid_only =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_get_result,
+		 valid_only, UINT8);
+
+static void
+cmd_ptype_mapping_get_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_ptype_mapping_get_result *res = parsed_result;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	int max_ptype_num = 256;
+	struct rte_pmd_i40e_ptype_mapping mapping[max_ptype_num];
+	uint16_t count;
+	int i;
+#endif
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_ptype_mapping_get(res->port_id,
+					mapping,
+					max_ptype_num,
+					&count,
+					res->valid_only);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	if (!ret) {
+		for (i = 0; i < count; i++)
+			printf("%3d\t0x%08x\n",
+				mapping[i].hw_ptype, mapping[i].sw_ptype);
+	}
+#endif
+}
+
+cmdline_parse_inst_t cmd_ptype_mapping_get = {
+	.f = cmd_ptype_mapping_get_parsed,
+	.data = NULL,
+	.help_str = "ptype mapping get <port_id> <valid_only>",
+	.tokens = {
+		(void *)&cmd_ptype_mapping_get_ptype,
+		(void *)&cmd_ptype_mapping_get_mapping,
+		(void *)&cmd_ptype_mapping_get_get,
+		(void *)&cmd_ptype_mapping_get_port_id,
+		(void *)&cmd_ptype_mapping_get_valid_only,
+		NULL,
+	},
+};
+
+/* ptype mapping replace */
+
+/* Common result structure for ptype mapping replace */
+struct cmd_ptype_mapping_replace_result {
+	cmdline_fixed_string_t ptype;
+	cmdline_fixed_string_t mapping;
+	cmdline_fixed_string_t replace;
+	portid_t port_id;
+	uint32_t target;
+	uint8_t mask;
+	uint32_t pkt_type;
+};
+
+/* Common CLI fields for ptype mapping replace */
+cmdline_parse_token_string_t cmd_ptype_mapping_replace_ptype =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_replace_result,
+		 ptype, "ptype");
+cmdline_parse_token_string_t cmd_ptype_mapping_replace_mapping =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_replace_result,
+		 mapping, "mapping");
+cmdline_parse_token_string_t cmd_ptype_mapping_replace_replace =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_replace_result,
+		 replace, "replace");
+cmdline_parse_token_num_t cmd_ptype_mapping_replace_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_replace_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_ptype_mapping_replace_target =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_replace_result,
+		 target, UINT32);
+cmdline_parse_token_num_t cmd_ptype_mapping_replace_mask =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_replace_result,
+		 mask, UINT8);
+cmdline_parse_token_num_t cmd_ptype_mapping_replace_pkt_type =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_replace_result,
+		 pkt_type, UINT32);
+
+static void
+cmd_ptype_mapping_replace_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_ptype_mapping_replace_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_ptype_mapping_replace(res->port_id,
+					res->target,
+					res->mask,
+					res->pkt_type);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid ptype 0x%8x or 0x%8x\n",
+				res->target, res->pkt_type);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_ptype_mapping_replace = {
+	.f = cmd_ptype_mapping_replace_parsed,
+	.data = NULL,
+	.help_str =
+		"ptype mapping replace <port_id> <target> <mask> <pkt_type>",
+	.tokens = {
+		(void *)&cmd_ptype_mapping_replace_ptype,
+		(void *)&cmd_ptype_mapping_replace_mapping,
+		(void *)&cmd_ptype_mapping_replace_replace,
+		(void *)&cmd_ptype_mapping_replace_port_id,
+		(void *)&cmd_ptype_mapping_replace_target,
+		(void *)&cmd_ptype_mapping_replace_mask,
+		(void *)&cmd_ptype_mapping_replace_pkt_type,
+		NULL,
+	},
+};
+
+/* ptype mapping reset */
+
+/* Common result structure for ptype mapping reset */
+struct cmd_ptype_mapping_reset_result {
+	cmdline_fixed_string_t ptype;
+	cmdline_fixed_string_t mapping;
+	cmdline_fixed_string_t reset;
+	portid_t port_id;
+};
+
+/* Common CLI fields for ptype mapping reset*/
+cmdline_parse_token_string_t cmd_ptype_mapping_reset_ptype =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_reset_result,
+		 ptype, "ptype");
+cmdline_parse_token_string_t cmd_ptype_mapping_reset_mapping =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_reset_result,
+		 mapping, "mapping");
+cmdline_parse_token_string_t cmd_ptype_mapping_reset_reset =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_reset_result,
+		 reset, "reset");
+cmdline_parse_token_num_t cmd_ptype_mapping_reset_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_reset_result,
+		 port_id, UINT16);
+
+static void
+cmd_ptype_mapping_reset_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_ptype_mapping_reset_result *res = parsed_result;
+	int ret = -ENOTSUP;
+
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	ret = rte_pmd_i40e_ptype_mapping_reset(res->port_id);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_ptype_mapping_reset = {
+	.f = cmd_ptype_mapping_reset_parsed,
+	.data = NULL,
+	.help_str = "ptype mapping reset <port_id>",
+	.tokens = {
+		(void *)&cmd_ptype_mapping_reset_ptype,
+		(void *)&cmd_ptype_mapping_reset_mapping,
+		(void *)&cmd_ptype_mapping_reset_reset,
+		(void *)&cmd_ptype_mapping_reset_port_id,
+		NULL,
+	},
+};
+
+/* ptype mapping update */
+
+/* Common result structure for ptype mapping update */
+struct cmd_ptype_mapping_update_result {
+	cmdline_fixed_string_t ptype;
+	cmdline_fixed_string_t mapping;
+	cmdline_fixed_string_t reset;
+	portid_t port_id;
+	uint8_t hw_ptype;
+	uint32_t sw_ptype;
+};
+
+/* Common CLI fields for ptype mapping update*/
+cmdline_parse_token_string_t cmd_ptype_mapping_update_ptype =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_update_result,
+		 ptype, "ptype");
+cmdline_parse_token_string_t cmd_ptype_mapping_update_mapping =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_update_result,
+		 mapping, "mapping");
+cmdline_parse_token_string_t cmd_ptype_mapping_update_update =
+	TOKEN_STRING_INITIALIZER
+		(struct cmd_ptype_mapping_update_result,
+		 reset, "update");
+cmdline_parse_token_num_t cmd_ptype_mapping_update_port_id =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_update_result,
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_ptype_mapping_update_hw_ptype =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_update_result,
+		 hw_ptype, UINT8);
+cmdline_parse_token_num_t cmd_ptype_mapping_update_sw_ptype =
+	TOKEN_NUM_INITIALIZER
+		(struct cmd_ptype_mapping_update_result,
+		 sw_ptype, UINT32);
+
+static void
+cmd_ptype_mapping_update_parsed(
+	void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
+{
+	struct cmd_ptype_mapping_update_result *res = parsed_result;
+	int ret = -ENOTSUP;
+#ifdef RTE_LIBRTE_I40E_PMD
+	struct rte_pmd_i40e_ptype_mapping mapping;
+#endif
+	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+		return;
+
+#ifdef RTE_LIBRTE_I40E_PMD
+	mapping.hw_ptype = res->hw_ptype;
+	mapping.sw_ptype = res->sw_ptype;
+	ret = rte_pmd_i40e_ptype_mapping_update(res->port_id,
+						&mapping,
+						1,
+						0);
+#endif
+
+	switch (ret) {
+	case 0:
+		break;
+	case -EINVAL:
+		printf("invalid ptype 0x%8x\n", res->sw_ptype);
+		break;
+	case -ENODEV:
+		printf("invalid port_id %d\n", res->port_id);
+		break;
+	case -ENOTSUP:
+		printf("function not implemented\n");
+		break;
+	default:
+		printf("programming error: (%s)\n", strerror(-ret));
+	}
+}
+
+cmdline_parse_inst_t cmd_ptype_mapping_update = {
+	.f = cmd_ptype_mapping_update_parsed,
+	.data = NULL,
+	.help_str = "ptype mapping update <port_id> <hw_ptype> <sw_ptype>",
+	.tokens = {
+		(void *)&cmd_ptype_mapping_update_ptype,
+		(void *)&cmd_ptype_mapping_update_mapping,
+		(void *)&cmd_ptype_mapping_update_update,
+		(void *)&cmd_ptype_mapping_update_port_id,
+		(void *)&cmd_ptype_mapping_update_hw_ptype,
+		(void *)&cmd_ptype_mapping_update_sw_ptype,
+		NULL,
+	},
+};
+
 /* Common result structure for file commands */
 struct cmd_cmdfile_result {
 	cmdline_fixed_string_t load;
@@ -10762,23 +17923,23 @@
 };
 
 /* Common CLI fields for file commands */
-static cmdline_parse_token_string_t cmd_load_cmdfile =
+cmdline_parse_token_string_t cmd_load_cmdfile =
 	TOKEN_STRING_INITIALIZER(struct cmd_cmdfile_result, load, "load");
-static cmdline_parse_token_string_t cmd_load_cmdfile_filename =
+cmdline_parse_token_string_t cmd_load_cmdfile_filename =
 	TOKEN_STRING_INITIALIZER(struct cmd_cmdfile_result, filename, NULL);
 
 static void
 cmd_load_from_file_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_cmdfile_result *res = parsed_result;
 
 	cmdline_read_from_file(res->filename);
 }
 
-static cmdline_parse_inst_t cmd_load_from_file = {
+cmdline_parse_inst_t cmd_load_from_file = {
 	.f = cmd_load_from_file_parsed,
 	.data = NULL,
 	.help_str = "load <filename>",
@@ -10798,23 +17959,23 @@
 	cmdline_fixed_string_t capabilities;
 };
 
-static cmdline_parse_token_string_t cmd_rx_offload_get_capa_show =
+cmdline_parse_token_string_t cmd_rx_offload_get_capa_show =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_rx_offload_get_capa_result,
 		 show, "show");
-static cmdline_parse_token_string_t cmd_rx_offload_get_capa_port =
+cmdline_parse_token_string_t cmd_rx_offload_get_capa_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_rx_offload_get_capa_result,
 		 port, "port");
-static cmdline_parse_token_num_t cmd_rx_offload_get_capa_port_id =
+cmdline_parse_token_num_t cmd_rx_offload_get_capa_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_rx_offload_get_capa_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_rx_offload_get_capa_rx_offload =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_rx_offload_get_capa_rx_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_rx_offload_get_capa_result,
 		 rx_offload, "rx_offload");
-static cmdline_parse_token_string_t cmd_rx_offload_get_capa_capabilities =
+cmdline_parse_token_string_t cmd_rx_offload_get_capa_capabilities =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_rx_offload_get_capa_result,
 		 capabilities, "capabilities");
@@ -10845,8 +18006,8 @@
 static void
 cmd_rx_offload_get_capa_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_rx_offload_get_capa_result *res = parsed_result;
 	struct rte_eth_dev_info dev_info;
@@ -10872,7 +18033,7 @@
 	printf("\n\n");
 }
 
-static cmdline_parse_inst_t cmd_rx_offload_get_capa = {
+cmdline_parse_inst_t cmd_rx_offload_get_capa = {
 	.f = cmd_rx_offload_get_capa_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> rx_offload capabilities",
@@ -10895,23 +18056,23 @@
 	cmdline_fixed_string_t configuration;
 };
 
-static cmdline_parse_token_string_t cmd_rx_offload_get_configuration_show =
+cmdline_parse_token_string_t cmd_rx_offload_get_configuration_show =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_rx_offload_get_configuration_result,
 		 show, "show");
-static cmdline_parse_token_string_t cmd_rx_offload_get_configuration_port =
+cmdline_parse_token_string_t cmd_rx_offload_get_configuration_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_rx_offload_get_configuration_result,
 		 port, "port");
-static cmdline_parse_token_num_t cmd_rx_offload_get_configuration_port_id =
+cmdline_parse_token_num_t cmd_rx_offload_get_configuration_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_rx_offload_get_configuration_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_rx_offload_get_configuration_rx_offload =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_rx_offload_get_configuration_rx_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_rx_offload_get_configuration_result,
 		 rx_offload, "rx_offload");
-static cmdline_parse_token_string_t cmd_rx_offload_get_configuration_configuration =
+cmdline_parse_token_string_t cmd_rx_offload_get_configuration_configuration =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_rx_offload_get_configuration_result,
 		 configuration, "configuration");
@@ -10919,14 +18080,13 @@
 static void
 cmd_rx_offload_get_configuration_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_rx_offload_get_configuration_result *res = parsed_result;
 	struct rte_eth_dev_info dev_info;
 	portid_t port_id = res->port_id;
 	struct rte_port *port = &ports[port_id];
-	struct rte_eth_conf dev_conf;
 	uint64_t port_offloads;
 	uint64_t queue_offloads;
 	uint16_t nb_rx_queues;
@@ -10935,11 +18095,7 @@
 
 	printf("Rx Offloading Configuration of port %d :\n", port_id);
 
-	ret = eth_dev_conf_get_print_err(port_id, &dev_conf);
-	if (ret != 0)
-		return;
-
-	port_offloads = dev_conf.rxmode.offloads;
+	port_offloads = port->dev_conf.rxmode.offloads;
 	printf("  Port :");
 	print_rx_offloads(port_offloads);
 	printf("\n");
@@ -10950,7 +18106,7 @@
 
 	nb_rx_queues = dev_info.nb_rx_queues;
 	for (q = 0; q < nb_rx_queues; q++) {
-		queue_offloads = port->rxq[q].conf.offloads;
+		queue_offloads = port->rx_conf[q].offloads;
 		printf("  Queue[%2d] :", q);
 		print_rx_offloads(queue_offloads);
 		printf("\n");
@@ -10958,7 +18114,7 @@
 	printf("\n");
 }
 
-static cmdline_parse_inst_t cmd_rx_offload_get_configuration = {
+cmdline_parse_inst_t cmd_rx_offload_get_configuration = {
 	.f = cmd_rx_offload_get_configuration_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> rx_offload configuration",
@@ -10982,31 +18138,30 @@
 	cmdline_fixed_string_t on_off;
 };
 
-static cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_port =
+cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_rx_offload_result,
 		 port, "port");
-static cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_config =
+cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_config =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_rx_offload_result,
 		 config, "config");
-static cmdline_parse_token_num_t cmd_config_per_port_rx_offload_result_port_id =
+cmdline_parse_token_num_t cmd_config_per_port_rx_offload_result_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_config_per_port_rx_offload_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_rx_offload =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_rx_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_rx_offload_result,
 		 rx_offload, "rx_offload");
-static cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_offload =
+cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_rx_offload_result,
 		 offload, "vlan_strip#ipv4_cksum#udp_cksum#tcp_cksum#tcp_lro#"
 			   "qinq_strip#outer_ipv4_cksum#macsec_strip#"
-			   "vlan_filter#vlan_extend#"
-			   "scatter#buffer_split#timestamp#security#"
-			   "keep_crc#rss_hash");
-static cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_on_off =
+			   "header_split#vlan_filter#vlan_extend#jumbo_frame#"
+			   "scatter#timestamp#security#keep_crc#rss_hash");
+cmdline_parse_token_string_t cmd_config_per_port_rx_offload_result_on_off =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_rx_offload_result,
 		 on_off, "on#off");
@@ -11037,8 +18192,8 @@
 
 static void
 cmd_config_per_port_rx_offload_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_per_port_rx_offload_result *res = parsed_result;
 	portid_t port_id = res->port_id;
@@ -11050,15 +18205,14 @@
 	int ret;
 
 	if (port->port_status != RTE_PORT_STOPPED) {
-		fprintf(stderr,
-			"Error: Can't config offload when Port %d is not stopped\n",
-			port_id);
+		printf("Error: Can't config offload when Port %d "
+		       "is not stopped\n", port_id);
 		return;
 	}
 
 	single_offload = search_rx_offload(res->offload);
 	if (single_offload == 0) {
-		fprintf(stderr, "Unknown offload name: %s\n", res->offload);
+		printf("Unknown offload name: %s\n", res->offload);
 		return;
 	}
 
@@ -11070,24 +18224,24 @@
 	if (!strcmp(res->on_off, "on")) {
 		port->dev_conf.rxmode.offloads |= single_offload;
 		for (q = 0; q < nb_rx_queues; q++)
-			port->rxq[q].conf.offloads |= single_offload;
+			port->rx_conf[q].offloads |= single_offload;
 	} else {
 		port->dev_conf.rxmode.offloads &= ~single_offload;
 		for (q = 0; q < nb_rx_queues; q++)
-			port->rxq[q].conf.offloads &= ~single_offload;
+			port->rx_conf[q].offloads &= ~single_offload;
 	}
 
 	cmd_reconfig_device_queue(port_id, 1, 1);
 }
 
-static cmdline_parse_inst_t cmd_config_per_port_rx_offload = {
+cmdline_parse_inst_t cmd_config_per_port_rx_offload = {
 	.f = cmd_config_per_port_rx_offload_parsed,
 	.data = NULL,
 	.help_str = "port config <port_id> rx_offload vlan_strip|ipv4_cksum|"
 		    "udp_cksum|tcp_cksum|tcp_lro|qinq_strip|outer_ipv4_cksum|"
-		    "macsec_strip|vlan_filter|vlan_extend|"
-		    "scatter|buffer_split|timestamp|security|"
-		    "keep_crc|rss_hash on|off",
+		    "macsec_strip|header_split|vlan_filter|vlan_extend|"
+		    "jumbo_frame|scatter|timestamp|security|keep_crc|rss_hash "
+		    "on|off",
 	.tokens = {
 		(void *)&cmd_config_per_port_rx_offload_result_port,
 		(void *)&cmd_config_per_port_rx_offload_result_config,
@@ -11110,42 +18264,42 @@
 	cmdline_fixed_string_t on_off;
 };
 
-static cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_port =
+cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_rx_offload_result,
 		 port, "port");
-static cmdline_parse_token_num_t cmd_config_per_queue_rx_offload_result_port_id =
+cmdline_parse_token_num_t cmd_config_per_queue_rx_offload_result_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_config_per_queue_rx_offload_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_rxq =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_rxq =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_rx_offload_result,
 		 rxq, "rxq");
-static cmdline_parse_token_num_t cmd_config_per_queue_rx_offload_result_queue_id =
+cmdline_parse_token_num_t cmd_config_per_queue_rx_offload_result_queue_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_config_per_queue_rx_offload_result,
-		 queue_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_rxoffload =
+		 queue_id, UINT16);
+cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_rxoffload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_rx_offload_result,
 		 rx_offload, "rx_offload");
-static cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_offload =
+cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_rx_offload_result,
 		 offload, "vlan_strip#ipv4_cksum#udp_cksum#tcp_cksum#tcp_lro#"
 			   "qinq_strip#outer_ipv4_cksum#macsec_strip#"
-			   "vlan_filter#vlan_extend#"
-			   "scatter#buffer_split#timestamp#security#keep_crc");
-static cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_on_off =
+			   "header_split#vlan_filter#vlan_extend#jumbo_frame#"
+			   "scatter#timestamp#security#keep_crc");
+cmdline_parse_token_string_t cmd_config_per_queue_rx_offload_result_on_off =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_rx_offload_result,
 		 on_off, "on#off");
 
 static void
 cmd_config_per_queue_rx_offload_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_per_queue_rx_offload_result *res = parsed_result;
 	struct rte_eth_dev_info dev_info;
@@ -11156,9 +18310,8 @@
 	int ret;
 
 	if (port->port_status != RTE_PORT_STOPPED) {
-		fprintf(stderr,
-			"Error: Can't config offload when Port %d is not stopped\n",
-			port_id);
+		printf("Error: Can't config offload when Port %d "
+		       "is not stopped\n", port_id);
 		return;
 	}
 
@@ -11167,35 +18320,34 @@
 		return;
 
 	if (queue_id >= dev_info.nb_rx_queues) {
-		fprintf(stderr,
-			"Error: input queue_id should be 0 ... %d\n",
-			dev_info.nb_rx_queues - 1);
+		printf("Error: input queue_id should be 0 ... "
+		       "%d\n", dev_info.nb_rx_queues - 1);
 		return;
 	}
 
 	single_offload = search_rx_offload(res->offload);
 	if (single_offload == 0) {
-		fprintf(stderr, "Unknown offload name: %s\n", res->offload);
+		printf("Unknown offload name: %s\n", res->offload);
 		return;
 	}
 
 	if (!strcmp(res->on_off, "on"))
-		port->rxq[queue_id].conf.offloads |= single_offload;
+		port->rx_conf[queue_id].offloads |= single_offload;
 	else
-		port->rxq[queue_id].conf.offloads &= ~single_offload;
+		port->rx_conf[queue_id].offloads &= ~single_offload;
 
 	cmd_reconfig_device_queue(port_id, 1, 1);
 }
 
-static cmdline_parse_inst_t cmd_config_per_queue_rx_offload = {
+cmdline_parse_inst_t cmd_config_per_queue_rx_offload = {
 	.f = cmd_config_per_queue_rx_offload_parsed,
 	.data = NULL,
 	.help_str = "port <port_id> rxq <queue_id> rx_offload "
 		    "vlan_strip|ipv4_cksum|"
 		    "udp_cksum|tcp_cksum|tcp_lro|qinq_strip|outer_ipv4_cksum|"
-		    "macsec_strip|vlan_filter|vlan_extend|"
-		    "scatter|buffer_split|timestamp|security|"
-		    "keep_crc on|off",
+		    "macsec_strip|header_split|vlan_filter|vlan_extend|"
+		    "jumbo_frame|scatter|timestamp|security|keep_crc "
+		    "on|off",
 	.tokens = {
 		(void *)&cmd_config_per_queue_rx_offload_result_port,
 		(void *)&cmd_config_per_queue_rx_offload_result_port_id,
@@ -11217,23 +18369,23 @@
 	cmdline_fixed_string_t capabilities;
 };
 
-static cmdline_parse_token_string_t cmd_tx_offload_get_capa_show =
+cmdline_parse_token_string_t cmd_tx_offload_get_capa_show =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_offload_get_capa_result,
 		 show, "show");
-static cmdline_parse_token_string_t cmd_tx_offload_get_capa_port =
+cmdline_parse_token_string_t cmd_tx_offload_get_capa_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_offload_get_capa_result,
 		 port, "port");
-static cmdline_parse_token_num_t cmd_tx_offload_get_capa_port_id =
+cmdline_parse_token_num_t cmd_tx_offload_get_capa_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_tx_offload_get_capa_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_tx_offload_get_capa_tx_offload =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_tx_offload_get_capa_tx_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_offload_get_capa_result,
 		 tx_offload, "tx_offload");
-static cmdline_parse_token_string_t cmd_tx_offload_get_capa_capabilities =
+cmdline_parse_token_string_t cmd_tx_offload_get_capa_capabilities =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_offload_get_capa_result,
 		 capabilities, "capabilities");
@@ -11264,8 +18416,8 @@
 static void
 cmd_tx_offload_get_capa_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_tx_offload_get_capa_result *res = parsed_result;
 	struct rte_eth_dev_info dev_info;
@@ -11291,7 +18443,7 @@
 	printf("\n\n");
 }
 
-static cmdline_parse_inst_t cmd_tx_offload_get_capa = {
+cmdline_parse_inst_t cmd_tx_offload_get_capa = {
 	.f = cmd_tx_offload_get_capa_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> tx_offload capabilities",
@@ -11314,23 +18466,23 @@
 	cmdline_fixed_string_t configuration;
 };
 
-static cmdline_parse_token_string_t cmd_tx_offload_get_configuration_show =
+cmdline_parse_token_string_t cmd_tx_offload_get_configuration_show =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_offload_get_configuration_result,
 		 show, "show");
-static cmdline_parse_token_string_t cmd_tx_offload_get_configuration_port =
+cmdline_parse_token_string_t cmd_tx_offload_get_configuration_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_offload_get_configuration_result,
 		 port, "port");
-static cmdline_parse_token_num_t cmd_tx_offload_get_configuration_port_id =
+cmdline_parse_token_num_t cmd_tx_offload_get_configuration_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_tx_offload_get_configuration_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_tx_offload_get_configuration_tx_offload =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_tx_offload_get_configuration_tx_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_offload_get_configuration_result,
 		 tx_offload, "tx_offload");
-static cmdline_parse_token_string_t cmd_tx_offload_get_configuration_configuration =
+cmdline_parse_token_string_t cmd_tx_offload_get_configuration_configuration =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_tx_offload_get_configuration_result,
 		 configuration, "configuration");
@@ -11338,14 +18490,13 @@
 static void
 cmd_tx_offload_get_configuration_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_tx_offload_get_configuration_result *res = parsed_result;
 	struct rte_eth_dev_info dev_info;
 	portid_t port_id = res->port_id;
 	struct rte_port *port = &ports[port_id];
-	struct rte_eth_conf dev_conf;
 	uint64_t port_offloads;
 	uint64_t queue_offloads;
 	uint16_t nb_tx_queues;
@@ -11354,11 +18505,7 @@
 
 	printf("Tx Offloading Configuration of port %d :\n", port_id);
 
-	ret = eth_dev_conf_get_print_err(port_id, &dev_conf);
-	if (ret != 0)
-		return;
-
-	port_offloads = dev_conf.txmode.offloads;
+	port_offloads = port->dev_conf.txmode.offloads;
 	printf("  Port :");
 	print_tx_offloads(port_offloads);
 	printf("\n");
@@ -11369,7 +18516,7 @@
 
 	nb_tx_queues = dev_info.nb_tx_queues;
 	for (q = 0; q < nb_tx_queues; q++) {
-		queue_offloads = port->txq[q].conf.offloads;
+		queue_offloads = port->tx_conf[q].offloads;
 		printf("  Queue[%2d] :", q);
 		print_tx_offloads(queue_offloads);
 		printf("\n");
@@ -11377,7 +18524,7 @@
 	printf("\n");
 }
 
-static cmdline_parse_inst_t cmd_tx_offload_get_configuration = {
+cmdline_parse_inst_t cmd_tx_offload_get_configuration = {
 	.f = cmd_tx_offload_get_configuration_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> tx_offload configuration",
@@ -11401,32 +18548,31 @@
 	cmdline_fixed_string_t on_off;
 };
 
-static cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_port =
+cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_tx_offload_result,
 		 port, "port");
-static cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_config =
+cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_config =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_tx_offload_result,
 		 config, "config");
-static cmdline_parse_token_num_t cmd_config_per_port_tx_offload_result_port_id =
+cmdline_parse_token_num_t cmd_config_per_port_tx_offload_result_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_config_per_port_tx_offload_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_tx_offload =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_tx_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_tx_offload_result,
 		 tx_offload, "tx_offload");
-static cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_offload =
+cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_tx_offload_result,
 		 offload, "vlan_insert#ipv4_cksum#udp_cksum#tcp_cksum#"
 			  "sctp_cksum#tcp_tso#udp_tso#outer_ipv4_cksum#"
 			  "qinq_insert#vxlan_tnl_tso#gre_tnl_tso#"
 			  "ipip_tnl_tso#geneve_tnl_tso#macsec_insert#"
-			  "mt_lockfree#multi_segs#mbuf_fast_free#security#"
-			  "send_on_timestamp");
-static cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_on_off =
+			  "mt_lockfree#multi_segs#mbuf_fast_free#security");
+cmdline_parse_token_string_t cmd_config_per_port_tx_offload_result_on_off =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_port_tx_offload_result,
 		 on_off, "on#off");
@@ -11460,8 +18606,8 @@
 
 static void
 cmd_config_per_port_tx_offload_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_per_port_tx_offload_result *res = parsed_result;
 	portid_t port_id = res->port_id;
@@ -11473,15 +18619,14 @@
 	int ret;
 
 	if (port->port_status != RTE_PORT_STOPPED) {
-		fprintf(stderr,
-			"Error: Can't config offload when Port %d is not stopped\n",
-			port_id);
+		printf("Error: Can't config offload when Port %d "
+		       "is not stopped\n", port_id);
 		return;
 	}
 
 	single_offload = search_tx_offload(res->offload);
 	if (single_offload == 0) {
-		fprintf(stderr, "Unknown offload name: %s\n", res->offload);
+		printf("Unknown offload name: %s\n", res->offload);
 		return;
 	}
 
@@ -11493,17 +18638,17 @@
 	if (!strcmp(res->on_off, "on")) {
 		port->dev_conf.txmode.offloads |= single_offload;
 		for (q = 0; q < nb_tx_queues; q++)
-			port->txq[q].conf.offloads |= single_offload;
+			port->tx_conf[q].offloads |= single_offload;
 	} else {
 		port->dev_conf.txmode.offloads &= ~single_offload;
 		for (q = 0; q < nb_tx_queues; q++)
-			port->txq[q].conf.offloads &= ~single_offload;
+			port->tx_conf[q].offloads &= ~single_offload;
 	}
 
 	cmd_reconfig_device_queue(port_id, 1, 1);
 }
 
-static cmdline_parse_inst_t cmd_config_per_port_tx_offload = {
+cmdline_parse_inst_t cmd_config_per_port_tx_offload = {
 	.f = cmd_config_per_port_tx_offload_parsed,
 	.data = NULL,
 	.help_str = "port config <port_id> tx_offload "
@@ -11511,8 +18656,7 @@
 		    "sctp_cksum|tcp_tso|udp_tso|outer_ipv4_cksum|"
 		    "qinq_insert|vxlan_tnl_tso|gre_tnl_tso|"
 		    "ipip_tnl_tso|geneve_tnl_tso|macsec_insert|"
-		    "mt_lockfree|multi_segs|mbuf_fast_free|security|"
-		    "send_on_timestamp on|off",
+		    "mt_lockfree|multi_segs|mbuf_fast_free|security on|off",
 	.tokens = {
 		(void *)&cmd_config_per_port_tx_offload_result_port,
 		(void *)&cmd_config_per_port_tx_offload_result_config,
@@ -11535,27 +18679,27 @@
 	cmdline_fixed_string_t on_off;
 };
 
-static cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_port =
+cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_tx_offload_result,
 		 port, "port");
-static cmdline_parse_token_num_t cmd_config_per_queue_tx_offload_result_port_id =
+cmdline_parse_token_num_t cmd_config_per_queue_tx_offload_result_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_config_per_queue_tx_offload_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_txq =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_txq =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_tx_offload_result,
 		 txq, "txq");
-static cmdline_parse_token_num_t cmd_config_per_queue_tx_offload_result_queue_id =
+cmdline_parse_token_num_t cmd_config_per_queue_tx_offload_result_queue_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_config_per_queue_tx_offload_result,
-		 queue_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_txoffload =
+		 queue_id, UINT16);
+cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_txoffload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_tx_offload_result,
 		 tx_offload, "tx_offload");
-static cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_offload =
+cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_offload =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_tx_offload_result,
 		 offload, "vlan_insert#ipv4_cksum#udp_cksum#tcp_cksum#"
@@ -11563,15 +18707,15 @@
 			  "qinq_insert#vxlan_tnl_tso#gre_tnl_tso#"
 			  "ipip_tnl_tso#geneve_tnl_tso#macsec_insert#"
 			  "mt_lockfree#multi_segs#mbuf_fast_free#security");
-static cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_on_off =
+cmdline_parse_token_string_t cmd_config_per_queue_tx_offload_result_on_off =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_config_per_queue_tx_offload_result,
 		 on_off, "on#off");
 
 static void
 cmd_config_per_queue_tx_offload_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_per_queue_tx_offload_result *res = parsed_result;
 	struct rte_eth_dev_info dev_info;
@@ -11582,9 +18726,8 @@
 	int ret;
 
 	if (port->port_status != RTE_PORT_STOPPED) {
-		fprintf(stderr,
-			"Error: Can't config offload when Port %d is not stopped\n",
-			port_id);
+		printf("Error: Can't config offload when Port %d "
+		       "is not stopped\n", port_id);
 		return;
 	}
 
@@ -11593,27 +18736,26 @@
 		return;
 
 	if (queue_id >= dev_info.nb_tx_queues) {
-		fprintf(stderr,
-			"Error: input queue_id should be 0 ... %d\n",
-			dev_info.nb_tx_queues - 1);
+		printf("Error: input queue_id should be 0 ... "
+		       "%d\n", dev_info.nb_tx_queues - 1);
 		return;
 	}
 
 	single_offload = search_tx_offload(res->offload);
 	if (single_offload == 0) {
-		fprintf(stderr, "Unknown offload name: %s\n", res->offload);
+		printf("Unknown offload name: %s\n", res->offload);
 		return;
 	}
 
 	if (!strcmp(res->on_off, "on"))
-		port->txq[queue_id].conf.offloads |= single_offload;
+		port->tx_conf[queue_id].offloads |= single_offload;
 	else
-		port->txq[queue_id].conf.offloads &= ~single_offload;
+		port->tx_conf[queue_id].offloads &= ~single_offload;
 
 	cmd_reconfig_device_queue(port_id, 1, 1);
 }
 
-static cmdline_parse_inst_t cmd_config_per_queue_tx_offload = {
+cmdline_parse_inst_t cmd_config_per_queue_tx_offload = {
 	.f = cmd_config_per_queue_tx_offload_parsed,
 	.data = NULL,
 	.help_str = "port <port_id> txq <queue_id> tx_offload "
@@ -11646,8 +18788,8 @@
 
 static void
 cmd_config_tx_metadata_specific_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
+				__attribute__((unused)) struct cmdline *cl,
+				__attribute__((unused)) void *data)
 {
 	struct cmd_config_tx_metadata_specific_result *res = parsed_result;
 
@@ -11662,23 +18804,23 @@
 	rte_flow_dynf_metadata_register();
 }
 
-static cmdline_parse_token_string_t cmd_config_tx_metadata_specific_port =
+cmdline_parse_token_string_t cmd_config_tx_metadata_specific_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_tx_metadata_specific_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_config_tx_metadata_specific_keyword =
+cmdline_parse_token_string_t cmd_config_tx_metadata_specific_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_tx_metadata_specific_result,
 			keyword, "config");
-static cmdline_parse_token_num_t cmd_config_tx_metadata_specific_id =
+cmdline_parse_token_num_t cmd_config_tx_metadata_specific_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_tx_metadata_specific_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_tx_metadata_specific_item =
+			port_id, UINT16);
+cmdline_parse_token_string_t cmd_config_tx_metadata_specific_item =
 	TOKEN_STRING_INITIALIZER(struct cmd_config_tx_metadata_specific_result,
 			item, "tx_metadata");
-static cmdline_parse_token_num_t cmd_config_tx_metadata_specific_value =
+cmdline_parse_token_num_t cmd_config_tx_metadata_specific_value =
 	TOKEN_NUM_INITIALIZER(struct cmd_config_tx_metadata_specific_result,
-			value, RTE_UINT32);
+			value, UINT32);
 
-static cmdline_parse_inst_t cmd_config_tx_metadata_specific = {
+cmdline_parse_inst_t cmd_config_tx_metadata_specific = {
 	.f = cmd_config_tx_metadata_specific_parsed,
 	.data = NULL,
 	.help_str = "port config <port_id> tx_metadata <value>",
@@ -11692,89 +18834,6 @@
 	},
 };
 
-/* *** set dynf *** */
-struct cmd_config_tx_dynf_specific_result {
-	cmdline_fixed_string_t port;
-	cmdline_fixed_string_t keyword;
-	uint16_t port_id;
-	cmdline_fixed_string_t item;
-	cmdline_fixed_string_t name;
-	cmdline_fixed_string_t value;
-};
-
-static void
-cmd_config_dynf_specific_parsed(void *parsed_result,
-				__rte_unused struct cmdline *cl,
-				__rte_unused void *data)
-{
-	struct cmd_config_tx_dynf_specific_result *res = parsed_result;
-	struct rte_mbuf_dynflag desc_flag;
-	int flag;
-	uint64_t old_port_flags;
-
-	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
-		return;
-	flag = rte_mbuf_dynflag_lookup(res->name, NULL);
-	if (flag <= 0) {
-		if (strlcpy(desc_flag.name, res->name,
-			    RTE_MBUF_DYN_NAMESIZE) >= RTE_MBUF_DYN_NAMESIZE) {
-			fprintf(stderr, "Flag name too long\n");
-			return;
-		}
-		desc_flag.flags = 0;
-		flag = rte_mbuf_dynflag_register(&desc_flag);
-		if (flag < 0) {
-			fprintf(stderr, "Can't register flag\n");
-			return;
-		}
-		strcpy(dynf_names[flag], desc_flag.name);
-	}
-	old_port_flags = ports[res->port_id].mbuf_dynf;
-	if (!strcmp(res->value, "set")) {
-		ports[res->port_id].mbuf_dynf |= 1UL << flag;
-		if (old_port_flags == 0)
-			add_tx_dynf_callback(res->port_id);
-	} else {
-		ports[res->port_id].mbuf_dynf &= ~(1UL << flag);
-		if (ports[res->port_id].mbuf_dynf == 0)
-			remove_tx_dynf_callback(res->port_id);
-	}
-}
-
-static cmdline_parse_token_string_t cmd_config_tx_dynf_specific_port =
-	TOKEN_STRING_INITIALIZER(struct cmd_config_tx_dynf_specific_result,
-			keyword, "port");
-static cmdline_parse_token_string_t cmd_config_tx_dynf_specific_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_config_tx_dynf_specific_result,
-			keyword, "config");
-static cmdline_parse_token_num_t cmd_config_tx_dynf_specific_port_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_config_tx_dynf_specific_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_config_tx_dynf_specific_item =
-	TOKEN_STRING_INITIALIZER(struct cmd_config_tx_dynf_specific_result,
-			item, "dynf");
-static cmdline_parse_token_string_t cmd_config_tx_dynf_specific_name =
-	TOKEN_STRING_INITIALIZER(struct cmd_config_tx_dynf_specific_result,
-			name, NULL);
-static cmdline_parse_token_string_t cmd_config_tx_dynf_specific_value =
-	TOKEN_STRING_INITIALIZER(struct cmd_config_tx_dynf_specific_result,
-			value, "set#clear");
-
-static cmdline_parse_inst_t cmd_config_tx_dynf_specific = {
-	.f = cmd_config_dynf_specific_parsed,
-	.data = NULL,
-	.help_str = "port config <port id> dynf <name> set|clear",
-	.tokens = {
-		(void *)&cmd_config_tx_dynf_specific_port,
-		(void *)&cmd_config_tx_dynf_specific_keyword,
-		(void *)&cmd_config_tx_dynf_specific_port_id,
-		(void *)&cmd_config_tx_dynf_specific_item,
-		(void *)&cmd_config_tx_dynf_specific_name,
-		(void *)&cmd_config_tx_dynf_specific_value,
-		NULL,
-	},
-};
-
 /* *** display tx_metadata per port configuration *** */
 struct cmd_show_tx_metadata_result {
 	cmdline_fixed_string_t cmd_show;
@@ -11785,13 +18844,13 @@
 
 static void
 cmd_show_tx_metadata_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_show_tx_metadata_result *res = parsed_result;
 
 	if (!rte_eth_dev_is_valid_port(res->cmd_pid)) {
-		fprintf(stderr, "invalid port id %u\n", res->cmd_pid);
+		printf("invalid port id %u\n", res->cmd_pid);
 		return;
 	}
 	if (!strcmp(res->cmd_keyword, "tx_metadata")) {
@@ -11800,20 +18859,20 @@
 	}
 }
 
-static cmdline_parse_token_string_t cmd_show_tx_metadata_show =
+cmdline_parse_token_string_t cmd_show_tx_metadata_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_tx_metadata_result,
 			cmd_show, "show");
-static cmdline_parse_token_string_t cmd_show_tx_metadata_port =
+cmdline_parse_token_string_t cmd_show_tx_metadata_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_tx_metadata_result,
 			cmd_port, "port");
-static cmdline_parse_token_num_t cmd_show_tx_metadata_pid =
+cmdline_parse_token_num_t cmd_show_tx_metadata_pid =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_tx_metadata_result,
-			cmd_pid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_tx_metadata_keyword =
+			cmd_pid, UINT16);
+cmdline_parse_token_string_t cmd_show_tx_metadata_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_tx_metadata_result,
 			cmd_keyword, "tx_metadata");
 
-static cmdline_parse_inst_t cmd_show_tx_metadata = {
+cmdline_parse_inst_t cmd_show_tx_metadata = {
 	.f = cmd_show_tx_metadata_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> tx_metadata",
@@ -11826,306 +18885,6 @@
 	},
 };
 
-/* *** show fec capability per port configuration *** */
-struct cmd_show_fec_capability_result {
-	cmdline_fixed_string_t cmd_show;
-	cmdline_fixed_string_t cmd_port;
-	cmdline_fixed_string_t cmd_fec;
-	cmdline_fixed_string_t cmd_keyword;
-	portid_t cmd_pid;
-};
-
-static void
-cmd_show_fec_capability_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
-{
-	struct cmd_show_fec_capability_result *res = parsed_result;
-	struct rte_eth_fec_capa *speed_fec_capa;
-	unsigned int num;
-	int ret;
-
-	if (!rte_eth_dev_is_valid_port(res->cmd_pid)) {
-		fprintf(stderr, "Invalid port id %u\n", res->cmd_pid);
-		return;
-	}
-
-	ret = rte_eth_fec_get_capability(res->cmd_pid, NULL, 0);
-	if (ret == -ENOTSUP) {
-		fprintf(stderr, "Function not implemented\n");
-		return;
-	} else if (ret < 0) {
-		fprintf(stderr, "Get FEC capability failed: %d\n", ret);
-		return;
-	}
-
-	num = (unsigned int)ret;
-	speed_fec_capa = calloc(num, sizeof(*speed_fec_capa));
-	if (speed_fec_capa == NULL) {
-		fprintf(stderr, "Failed to alloc FEC capability buffer\n");
-		return;
-	}
-
-	ret = rte_eth_fec_get_capability(res->cmd_pid, speed_fec_capa, num);
-	if (ret < 0) {
-		fprintf(stderr, "Error getting FEC capability: %d\n", ret);
-		goto out;
-	}
-
-	show_fec_capability(num, speed_fec_capa);
-out:
-	free(speed_fec_capa);
-}
-
-static cmdline_parse_token_string_t cmd_show_fec_capability_show =
-	TOKEN_STRING_INITIALIZER(struct cmd_show_fec_capability_result,
-			cmd_show, "show");
-static cmdline_parse_token_string_t cmd_show_fec_capability_port =
-	TOKEN_STRING_INITIALIZER(struct cmd_show_fec_capability_result,
-			cmd_port, "port");
-static cmdline_parse_token_num_t cmd_show_fec_capability_pid =
-	TOKEN_NUM_INITIALIZER(struct cmd_show_fec_capability_result,
-			cmd_pid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_fec_capability_fec =
-	TOKEN_STRING_INITIALIZER(struct cmd_show_fec_capability_result,
-			cmd_fec, "fec");
-static cmdline_parse_token_string_t cmd_show_fec_capability_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_show_fec_capability_result,
-			cmd_keyword, "capabilities");
-
-static cmdline_parse_inst_t cmd_show_capability = {
-	.f = cmd_show_fec_capability_parsed,
-	.data = NULL,
-	.help_str = "show port <port_id> fec capabilities",
-	.tokens = {
-		(void *)&cmd_show_fec_capability_show,
-		(void *)&cmd_show_fec_capability_port,
-		(void *)&cmd_show_fec_capability_pid,
-		(void *)&cmd_show_fec_capability_fec,
-		(void *)&cmd_show_fec_capability_keyword,
-		NULL,
-	},
-};
-
-/* *** show fec mode per port configuration *** */
-struct cmd_show_fec_metadata_result {
-	cmdline_fixed_string_t cmd_show;
-	cmdline_fixed_string_t cmd_port;
-	cmdline_fixed_string_t cmd_keyword;
-	portid_t cmd_pid;
-};
-
-static void
-cmd_show_fec_mode_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
-{
-#define FEC_NAME_SIZE 16
-	struct cmd_show_fec_metadata_result *res = parsed_result;
-	uint32_t mode;
-	char buf[FEC_NAME_SIZE];
-	int ret;
-
-	if (!rte_eth_dev_is_valid_port(res->cmd_pid)) {
-		fprintf(stderr, "Invalid port id %u\n", res->cmd_pid);
-		return;
-	}
-	ret = rte_eth_fec_get(res->cmd_pid, &mode);
-	if (ret == -ENOTSUP) {
-		fprintf(stderr, "Function not implemented\n");
-		return;
-	} else if (ret < 0) {
-		fprintf(stderr, "Get FEC mode failed\n");
-		return;
-	}
-
-	switch (mode) {
-	case RTE_ETH_FEC_MODE_CAPA_MASK(NOFEC):
-		strlcpy(buf, "off", sizeof(buf));
-		break;
-	case RTE_ETH_FEC_MODE_CAPA_MASK(AUTO):
-		strlcpy(buf, "auto", sizeof(buf));
-		break;
-	case RTE_ETH_FEC_MODE_CAPA_MASK(BASER):
-		strlcpy(buf, "baser", sizeof(buf));
-		break;
-	case RTE_ETH_FEC_MODE_CAPA_MASK(RS):
-		strlcpy(buf, "rs", sizeof(buf));
-		break;
-	default:
-		return;
-	}
-
-	printf("%s\n", buf);
-}
-
-static cmdline_parse_token_string_t cmd_show_fec_mode_show =
-	TOKEN_STRING_INITIALIZER(struct cmd_show_fec_metadata_result,
-			cmd_show, "show");
-static cmdline_parse_token_string_t cmd_show_fec_mode_port =
-	TOKEN_STRING_INITIALIZER(struct cmd_show_fec_metadata_result,
-			cmd_port, "port");
-static cmdline_parse_token_num_t cmd_show_fec_mode_pid =
-	TOKEN_NUM_INITIALIZER(struct cmd_show_fec_metadata_result,
-			cmd_pid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_fec_mode_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_show_fec_metadata_result,
-			cmd_keyword, "fec_mode");
-
-static cmdline_parse_inst_t cmd_show_fec_mode = {
-	.f = cmd_show_fec_mode_parsed,
-	.data = NULL,
-	.help_str = "show port <port_id> fec_mode",
-	.tokens = {
-		(void *)&cmd_show_fec_mode_show,
-		(void *)&cmd_show_fec_mode_port,
-		(void *)&cmd_show_fec_mode_pid,
-		(void *)&cmd_show_fec_mode_keyword,
-		NULL,
-	},
-};
-
-/* *** set fec mode per port configuration *** */
-struct cmd_set_port_fec_mode {
-	cmdline_fixed_string_t set;
-	cmdline_fixed_string_t port;
-	portid_t port_id;
-	cmdline_fixed_string_t fec_mode;
-	cmdline_fixed_string_t fec_value;
-};
-
-/* Common CLI fields for set fec mode */
-static cmdline_parse_token_string_t cmd_set_port_fec_mode_set =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_set_port_fec_mode,
-		 set, "set");
-static cmdline_parse_token_string_t cmd_set_port_fec_mode_port =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_set_port_fec_mode,
-		 port, "port");
-static cmdline_parse_token_num_t cmd_set_port_fec_mode_port_id =
-	TOKEN_NUM_INITIALIZER
-		(struct cmd_set_port_fec_mode,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_port_fec_mode_str =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_set_port_fec_mode,
-		 fec_mode, "fec_mode");
-static cmdline_parse_token_string_t cmd_set_port_fec_mode_value =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_set_port_fec_mode,
-		 fec_value, NULL);
-
-static void
-cmd_set_port_fec_mode_parsed(
-	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
-{
-	struct cmd_set_port_fec_mode *res = parsed_result;
-	uint16_t port_id = res->port_id;
-	uint32_t fec_capa;
-	int ret;
-
-	ret = parse_fec_mode(res->fec_value, &fec_capa);
-	if (ret < 0) {
-		fprintf(stderr, "Unknown fec mode: %s for port %d\n",
-				res->fec_value,	port_id);
-		return;
-	}
-
-	ret = rte_eth_fec_set(port_id, fec_capa);
-	if (ret == -ENOTSUP) {
-		fprintf(stderr, "Function not implemented\n");
-		return;
-	} else if (ret < 0) {
-		fprintf(stderr, "Set FEC mode failed\n");
-		return;
-	}
-}
-
-static cmdline_parse_inst_t cmd_set_fec_mode = {
-	.f = cmd_set_port_fec_mode_parsed,
-	.data = NULL,
-	.help_str = "set port <port_id> fec_mode auto|off|rs|baser",
-	.tokens = {
-		(void *)&cmd_set_port_fec_mode_set,
-		(void *)&cmd_set_port_fec_mode_port,
-		(void *)&cmd_set_port_fec_mode_port_id,
-		(void *)&cmd_set_port_fec_mode_str,
-		(void *)&cmd_set_port_fec_mode_value,
-		NULL,
-	},
-};
-
-/* *** set available descriptors threshold for an RxQ of a port *** */
-struct cmd_set_rxq_avail_thresh_result {
-	cmdline_fixed_string_t set;
-	cmdline_fixed_string_t port;
-	uint16_t port_num;
-	cmdline_fixed_string_t rxq;
-	uint16_t rxq_num;
-	cmdline_fixed_string_t avail_thresh;
-	uint8_t avail_thresh_num;
-};
-
-static void cmd_set_rxq_avail_thresh_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
-{
-	struct cmd_set_rxq_avail_thresh_result *res = parsed_result;
-	int ret = 0;
-
-	if ((strcmp(res->set, "set") == 0) && (strcmp(res->port, "port") == 0)
-	    && (strcmp(res->rxq, "rxq") == 0)
-	    && (strcmp(res->avail_thresh, "avail_thresh") == 0))
-		ret = set_rxq_avail_thresh(res->port_num, res->rxq_num,
-				  res->avail_thresh_num);
-	if (ret < 0)
-		printf("rxq_avail_thresh_cmd error: (%s)\n", strerror(-ret));
-
-}
-
-static cmdline_parse_token_string_t cmd_set_rxq_avail_thresh_set =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxq_avail_thresh_result,
-				set, "set");
-static cmdline_parse_token_string_t cmd_set_rxq_avail_thresh_port =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxq_avail_thresh_result,
-				port, "port");
-static cmdline_parse_token_num_t cmd_set_rxq_avail_thresh_portnum =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_rxq_avail_thresh_result,
-				port_num, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_rxq_avail_thresh_rxq =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxq_avail_thresh_result,
-				rxq, "rxq");
-static cmdline_parse_token_num_t cmd_set_rxq_avail_thresh_rxqnum =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_rxq_avail_thresh_result,
-				rxq_num, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_rxq_avail_thresh_avail_thresh =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_rxq_avail_thresh_result,
-				avail_thresh, "avail_thresh");
-static cmdline_parse_token_num_t cmd_set_rxq_avail_thresh_avail_threshnum =
-	TOKEN_NUM_INITIALIZER(struct cmd_set_rxq_avail_thresh_result,
-				avail_thresh_num, RTE_UINT8);
-
-static cmdline_parse_inst_t cmd_set_rxq_avail_thresh = {
-	.f = cmd_set_rxq_avail_thresh_parsed,
-	.data = (void *)0,
-	.help_str =
-		"set port <port_id> rxq <queue_id> avail_thresh <0..99>: "
-		"Set available descriptors threshold for Rx queue",
-	.tokens = {
-		(void *)&cmd_set_rxq_avail_thresh_set,
-		(void *)&cmd_set_rxq_avail_thresh_port,
-		(void *)&cmd_set_rxq_avail_thresh_portnum,
-		(void *)&cmd_set_rxq_avail_thresh_rxq,
-		(void *)&cmd_set_rxq_avail_thresh_rxqnum,
-		(void *)&cmd_set_rxq_avail_thresh_avail_thresh,
-		(void *)&cmd_set_rxq_avail_thresh_avail_threshnum,
-		NULL,
-	},
-};
-
 /* show port supported ptypes */
 
 /* Common result structure for show port ptypes */
@@ -12137,19 +18896,19 @@
 };
 
 /* Common CLI fields for show port ptypes */
-static cmdline_parse_token_string_t cmd_show_port_supported_ptypes_show =
+cmdline_parse_token_string_t cmd_show_port_supported_ptypes_show =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_show_port_supported_ptypes_result,
 		 show, "show");
-static cmdline_parse_token_string_t cmd_show_port_supported_ptypes_port =
+cmdline_parse_token_string_t cmd_show_port_supported_ptypes_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_show_port_supported_ptypes_result,
 		 port, "port");
-static cmdline_parse_token_num_t cmd_show_port_supported_ptypes_port_id =
+cmdline_parse_token_num_t cmd_show_port_supported_ptypes_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_show_port_supported_ptypes_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_port_supported_ptypes_ptypes =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_show_port_supported_ptypes_ptypes =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_show_port_supported_ptypes_result,
 		 ptypes, "ptypes");
@@ -12157,8 +18916,8 @@
 static void
 cmd_show_port_supported_ptypes_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 #define RSVD_PTYPE_MASK       0xf0000000
 #define MAX_PTYPES_PER_LAYER  16
@@ -12221,7 +18980,7 @@
 	}
 }
 
-static cmdline_parse_inst_t cmd_show_port_supported_ptypes = {
+cmdline_parse_inst_t cmd_show_port_supported_ptypes = {
 	.f = cmd_show_port_supported_ptypes_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> ptypes",
@@ -12248,14 +19007,14 @@
 
 static void
 cmd_show_rx_tx_desc_status_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
 {
 	struct cmd_show_rx_tx_desc_status_result *res = parsed_result;
 	int rc;
 
 	if (!rte_eth_dev_is_valid_port(res->cmd_pid)) {
-		fprintf(stderr, "invalid port id %u\n", res->cmd_pid);
+		printf("invalid port id %u\n", res->cmd_pid);
 		return;
 	}
 
@@ -12263,9 +19022,7 @@
 		rc = rte_eth_rx_descriptor_status(res->cmd_pid, res->cmd_qid,
 					     res->cmd_did);
 		if (rc < 0) {
-			fprintf(stderr,
-				"Invalid input: queue id = %d, desc id = %d\n",
-				res->cmd_qid, res->cmd_did);
+			printf("Invalid queueid = %d\n", res->cmd_qid);
 			return;
 		}
 		if (rc == RTE_ETH_RX_DESC_AVAIL)
@@ -12278,9 +19035,7 @@
 		rc = rte_eth_tx_descriptor_status(res->cmd_pid, res->cmd_qid,
 					     res->cmd_did);
 		if (rc < 0) {
-			fprintf(stderr,
-				"Invalid input: queue id = %d, desc id = %d\n",
-				res->cmd_qid, res->cmd_did);
+			printf("Invalid queueid = %d\n", res->cmd_qid);
 			return;
 		}
 		if (rc == RTE_ETH_TX_DESC_FULL)
@@ -12292,31 +19047,31 @@
 	}
 }
 
-static cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_show =
+cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_rx_tx_desc_status_result,
 			cmd_show, "show");
-static cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_port =
+cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_rx_tx_desc_status_result,
 			cmd_port, "port");
-static cmdline_parse_token_num_t cmd_show_rx_tx_desc_status_pid =
+cmdline_parse_token_num_t cmd_show_rx_tx_desc_status_pid =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_rx_tx_desc_status_result,
-			cmd_pid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_keyword =
+			cmd_pid, UINT16);
+cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_keyword =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_rx_tx_desc_status_result,
 			cmd_keyword, "rxq#txq");
-static cmdline_parse_token_num_t cmd_show_rx_tx_desc_status_qid =
+cmdline_parse_token_num_t cmd_show_rx_tx_desc_status_qid =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_rx_tx_desc_status_result,
-			cmd_qid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_desc =
+			cmd_qid, UINT16);
+cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_desc =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_rx_tx_desc_status_result,
 			cmd_desc, "desc");
-static cmdline_parse_token_num_t cmd_show_rx_tx_desc_status_did =
+cmdline_parse_token_num_t cmd_show_rx_tx_desc_status_did =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_rx_tx_desc_status_result,
-			cmd_did, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_status =
+			cmd_did, UINT16);
+cmdline_parse_token_string_t cmd_show_rx_tx_desc_status_status =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_rx_tx_desc_status_result,
 			cmd_status, "status");
-static cmdline_parse_inst_t cmd_show_rx_tx_desc_status = {
+cmdline_parse_inst_t cmd_show_rx_tx_desc_status = {
 	.f = cmd_show_rx_tx_desc_status_parsed,
 	.data = NULL,
 	.help_str = "show port <port_id> rxq|txq <queue_id> desc <desc_id> "
@@ -12334,88 +19089,6 @@
 	},
 };
 
-/* *** display rx queue desc used count *** */
-struct cmd_show_rx_queue_desc_used_count_result {
-	cmdline_fixed_string_t cmd_show;
-	cmdline_fixed_string_t cmd_port;
-	cmdline_fixed_string_t cmd_rxq;
-	cmdline_fixed_string_t cmd_desc;
-	cmdline_fixed_string_t cmd_used;
-	cmdline_fixed_string_t cmd_count;
-	portid_t cmd_pid;
-	portid_t cmd_qid;
-};
-
-static void
-cmd_show_rx_queue_desc_used_count_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
-{
-	struct cmd_show_rx_queue_desc_used_count_result *res = parsed_result;
-	int rc;
-
-	if (!rte_eth_dev_is_valid_port(res->cmd_pid)) {
-		fprintf(stderr, "invalid port id %u\n", res->cmd_pid);
-		return;
-	}
-
-	rc = rte_eth_rx_queue_count(res->cmd_pid, res->cmd_qid);
-	if (rc < 0) {
-		fprintf(stderr, "Invalid queueid = %d\n", res->cmd_qid);
-		return;
-	}
-	printf("Used desc count = %d\n", rc);
-}
-
-static cmdline_parse_token_string_t cmd_show_rx_queue_desc_used_count_show =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_rx_queue_desc_used_count_result,
-		 cmd_show, "show");
-static cmdline_parse_token_string_t cmd_show_rx_queue_desc_used_count_port =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_rx_queue_desc_used_count_result,
-		 cmd_port, "port");
-static cmdline_parse_token_num_t cmd_show_rx_queue_desc_used_count_pid =
-	TOKEN_NUM_INITIALIZER
-		(struct cmd_show_rx_queue_desc_used_count_result,
-		 cmd_pid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_rx_queue_desc_used_count_rxq =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_rx_queue_desc_used_count_result,
-		 cmd_rxq, "rxq");
-static cmdline_parse_token_num_t cmd_show_rx_queue_desc_used_count_qid =
-	TOKEN_NUM_INITIALIZER
-		(struct cmd_show_rx_queue_desc_used_count_result,
-		 cmd_qid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_rx_queue_desc_used_count_desc =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_rx_queue_desc_used_count_result,
-		 cmd_count, "desc");
-static cmdline_parse_token_string_t cmd_show_rx_queue_desc_used_count_used =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_rx_queue_desc_used_count_result,
-		 cmd_count, "used");
-static cmdline_parse_token_string_t cmd_show_rx_queue_desc_used_count_count =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_rx_queue_desc_used_count_result,
-		 cmd_count, "count");
-static cmdline_parse_inst_t cmd_show_rx_queue_desc_used_count = {
-	.f = cmd_show_rx_queue_desc_used_count_parsed,
-	.data = NULL,
-	.help_str = "show port <port_id> rxq <queue_id> desc used count",
-	.tokens = {
-		(void *)&cmd_show_rx_queue_desc_used_count_show,
-		(void *)&cmd_show_rx_queue_desc_used_count_port,
-		(void *)&cmd_show_rx_queue_desc_used_count_pid,
-		(void *)&cmd_show_rx_queue_desc_used_count_rxq,
-		(void *)&cmd_show_rx_queue_desc_used_count_qid,
-		(void *)&cmd_show_rx_queue_desc_used_count_desc,
-		(void *)&cmd_show_rx_queue_desc_used_count_used,
-		(void *)&cmd_show_rx_queue_desc_used_count_count,
-		NULL,
-	},
-};
-
 /* Common result structure for set port ptypes */
 struct cmd_set_port_ptypes_result {
 	cmdline_fixed_string_t set;
@@ -12426,32 +19099,32 @@
 };
 
 /* Common CLI fields for set port ptypes */
-static cmdline_parse_token_string_t cmd_set_port_ptypes_set =
+cmdline_parse_token_string_t cmd_set_port_ptypes_set =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_set_port_ptypes_result,
 		 set, "set");
-static cmdline_parse_token_string_t cmd_set_port_ptypes_port =
+cmdline_parse_token_string_t cmd_set_port_ptypes_port =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_set_port_ptypes_result,
 		 port, "port");
-static cmdline_parse_token_num_t cmd_set_port_ptypes_port_id =
+cmdline_parse_token_num_t cmd_set_port_ptypes_port_id =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_set_port_ptypes_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_set_port_ptypes_mask_str =
+		 port_id, UINT16);
+cmdline_parse_token_string_t cmd_set_port_ptypes_mask_str =
 	TOKEN_STRING_INITIALIZER
 		(struct cmd_set_port_ptypes_result,
 		 ptype_mask, "ptype_mask");
-static cmdline_parse_token_num_t cmd_set_port_ptypes_mask_u32 =
+cmdline_parse_token_num_t cmd_set_port_ptypes_mask_u32 =
 	TOKEN_NUM_INITIALIZER
 		(struct cmd_set_port_ptypes_result,
-		 mask, RTE_UINT32);
+		 mask, UINT32);
 
 static void
 cmd_set_port_ptypes_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_port_ptypes_result *res = parsed_result;
 #define PTYPE_NAMESIZE        256
@@ -12463,8 +19136,7 @@
 	ret = rte_eth_dev_get_supported_ptypes(port_id, RTE_PTYPE_ALL_MASK,
 					       NULL, 0);
 	if (ret <= 0) {
-		fprintf(stderr, "Port %d doesn't support any ptypes.\n",
-			port_id);
+		printf("Port %d doesn't support any ptypes.\n", port_id);
 		return;
 	}
 
@@ -12472,8 +19144,7 @@
 
 	ret = rte_eth_dev_set_ptypes(port_id, ptype_mask, ptypes, ret);
 	if (ret < 0) {
-		fprintf(stderr, "Unable to set requested ptypes for Port %d\n",
-			port_id);
+		printf("Unable to set requested ptypes for Port %d\n", port_id);
 		return;
 	}
 
@@ -12486,7 +19157,7 @@
 	clear_ptypes = false;
 }
 
-static cmdline_parse_inst_t cmd_set_port_ptypes = {
+cmdline_parse_inst_t cmd_set_port_ptypes = {
 	.f = cmd_set_port_ptypes_parsed,
 	.data = NULL,
 	.help_str = "set port <port_id> ptype_mask <mask>",
@@ -12500,140 +19171,17 @@
 	},
 };
 
-/* *** display mac addresses added to a port *** */
-struct cmd_showport_macs_result {
-	cmdline_fixed_string_t cmd_show;
-	cmdline_fixed_string_t cmd_port;
-	cmdline_fixed_string_t cmd_keyword;
-	portid_t cmd_pid;
-};
-
-static void
-cmd_showport_macs_parsed(void *parsed_result,
-		__rte_unused struct cmdline *cl,
-		__rte_unused void *data)
-{
-	struct cmd_showport_macs_result *res = parsed_result;
-
-	if (port_id_is_invalid(res->cmd_pid, ENABLED_WARN))
-		return;
-
-	if (!strcmp(res->cmd_keyword, "macs"))
-		show_macs(res->cmd_pid);
-	else if (!strcmp(res->cmd_keyword, "mcast_macs"))
-		show_mcast_macs(res->cmd_pid);
-}
-
-static cmdline_parse_token_string_t cmd_showport_macs_show =
-	TOKEN_STRING_INITIALIZER(struct cmd_showport_macs_result,
-			cmd_show, "show");
-static cmdline_parse_token_string_t cmd_showport_macs_port =
-	TOKEN_STRING_INITIALIZER(struct cmd_showport_macs_result,
-			cmd_port, "port");
-static cmdline_parse_token_num_t cmd_showport_macs_pid =
-	TOKEN_NUM_INITIALIZER(struct cmd_showport_macs_result,
-			cmd_pid, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_showport_macs_keyword =
-	TOKEN_STRING_INITIALIZER(struct cmd_showport_macs_result,
-			cmd_keyword, "macs#mcast_macs");
-
-static cmdline_parse_inst_t cmd_showport_macs = {
-	.f = cmd_showport_macs_parsed,
-	.data = NULL,
-	.help_str = "show port <port_id> macs|mcast_macs",
-	.tokens = {
-		(void *)&cmd_showport_macs_show,
-		(void *)&cmd_showport_macs_port,
-		(void *)&cmd_showport_macs_pid,
-		(void *)&cmd_showport_macs_keyword,
-		NULL,
-	},
-};
-
-/* *** show flow transfer proxy port ID for the given port *** */
-struct cmd_show_port_flow_transfer_proxy_result {
-	cmdline_fixed_string_t show;
-	cmdline_fixed_string_t port;
-	portid_t port_id;
-	cmdline_fixed_string_t flow;
-	cmdline_fixed_string_t transfer;
-	cmdline_fixed_string_t proxy;
-};
-
-static cmdline_parse_token_string_t cmd_show_port_flow_transfer_proxy_show =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_port_flow_transfer_proxy_result,
-		 show, "show");
-static cmdline_parse_token_string_t cmd_show_port_flow_transfer_proxy_port =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_port_flow_transfer_proxy_result,
-		 port, "port");
-static cmdline_parse_token_num_t cmd_show_port_flow_transfer_proxy_port_id =
-	TOKEN_NUM_INITIALIZER
-		(struct cmd_show_port_flow_transfer_proxy_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_port_flow_transfer_proxy_flow =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_port_flow_transfer_proxy_result,
-		 flow, "flow");
-static cmdline_parse_token_string_t cmd_show_port_flow_transfer_proxy_transfer =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_port_flow_transfer_proxy_result,
-		 transfer, "transfer");
-static cmdline_parse_token_string_t cmd_show_port_flow_transfer_proxy_proxy =
-	TOKEN_STRING_INITIALIZER
-		(struct cmd_show_port_flow_transfer_proxy_result,
-		 proxy, "proxy");
-
-static void
-cmd_show_port_flow_transfer_proxy_parsed(void *parsed_result,
-					 __rte_unused struct cmdline *cl,
-					 __rte_unused void *data)
-{
-	struct cmd_show_port_flow_transfer_proxy_result *res = parsed_result;
-	portid_t proxy_port_id;
-	int ret;
-
-	printf("\n");
-
-	ret = rte_flow_pick_transfer_proxy(res->port_id, &proxy_port_id, NULL);
-	if (ret != 0) {
-		fprintf(stderr, "Failed to pick transfer proxy: %s\n",
-			rte_strerror(-ret));
-		return;
-	}
-
-	printf("Transfer proxy port ID: %u\n\n", proxy_port_id);
-}
-
-static cmdline_parse_inst_t cmd_show_port_flow_transfer_proxy = {
-	.f = cmd_show_port_flow_transfer_proxy_parsed,
-	.data = NULL,
-	.help_str = "show port <port_id> flow transfer proxy",
-	.tokens = {
-		(void *)&cmd_show_port_flow_transfer_proxy_show,
-		(void *)&cmd_show_port_flow_transfer_proxy_port,
-		(void *)&cmd_show_port_flow_transfer_proxy_port_id,
-		(void *)&cmd_show_port_flow_transfer_proxy_flow,
-		(void *)&cmd_show_port_flow_transfer_proxy_transfer,
-		(void *)&cmd_show_port_flow_transfer_proxy_proxy,
-		NULL,
-	}
-};
-
 /* ******************************************************************************** */
 
 /* list of instructions */
-static cmdline_parse_ctx_t builtin_ctx[] = {
+cmdline_parse_ctx_t main_ctx[] = {
 	(cmdline_parse_inst_t *)&cmd_help_brief,
 	(cmdline_parse_inst_t *)&cmd_help_long,
 	(cmdline_parse_inst_t *)&cmd_quit,
 	(cmdline_parse_inst_t *)&cmd_load_from_file,
 	(cmdline_parse_inst_t *)&cmd_showport,
 	(cmdline_parse_inst_t *)&cmd_showqueue,
-	(cmdline_parse_inst_t *)&cmd_showeeprom,
 	(cmdline_parse_inst_t *)&cmd_showportall,
-	(cmdline_parse_inst_t *)&cmd_representor_info,
 	(cmdline_parse_inst_t *)&cmd_showdevice,
 	(cmdline_parse_inst_t *)&cmd_showcfg,
 	(cmdline_parse_inst_t *)&cmd_showfwdall,
@@ -12645,12 +19193,8 @@
 	(cmdline_parse_inst_t *)&cmd_reset,
 	(cmdline_parse_inst_t *)&cmd_set_numbers,
 	(cmdline_parse_inst_t *)&cmd_set_log,
-	(cmdline_parse_inst_t *)&cmd_set_rxoffs,
-	(cmdline_parse_inst_t *)&cmd_set_rxpkts,
-	(cmdline_parse_inst_t *)&cmd_set_rxhdrs,
 	(cmdline_parse_inst_t *)&cmd_set_txpkts,
 	(cmdline_parse_inst_t *)&cmd_set_txsplit,
-	(cmdline_parse_inst_t *)&cmd_set_txtimes,
 	(cmdline_parse_inst_t *)&cmd_set_fwd_list,
 	(cmdline_parse_inst_t *)&cmd_set_fwd_mask,
 	(cmdline_parse_inst_t *)&cmd_set_fwd_mode,
@@ -12662,6 +19206,23 @@
 	(cmdline_parse_inst_t *)&cmd_set_allmulti_mode_all,
 	(cmdline_parse_inst_t *)&cmd_set_flush_rx,
 	(cmdline_parse_inst_t *)&cmd_set_link_check,
+	(cmdline_parse_inst_t *)&cmd_set_bypass_mode,
+	(cmdline_parse_inst_t *)&cmd_set_bypass_event,
+	(cmdline_parse_inst_t *)&cmd_set_bypass_timeout,
+	(cmdline_parse_inst_t *)&cmd_show_bypass_config,
+#ifdef RTE_LIBRTE_PMD_BOND
+	(cmdline_parse_inst_t *) &cmd_set_bonding_mode,
+	(cmdline_parse_inst_t *) &cmd_show_bonding_config,
+	(cmdline_parse_inst_t *) &cmd_set_bonding_primary,
+	(cmdline_parse_inst_t *) &cmd_add_bonding_slave,
+	(cmdline_parse_inst_t *) &cmd_remove_bonding_slave,
+	(cmdline_parse_inst_t *) &cmd_create_bonded_device,
+	(cmdline_parse_inst_t *) &cmd_set_bond_mac_addr,
+	(cmdline_parse_inst_t *) &cmd_set_balance_xmit_policy,
+	(cmdline_parse_inst_t *) &cmd_set_bond_mon_period,
+	(cmdline_parse_inst_t *) &cmd_set_lacp_dedicated_queues,
+	(cmdline_parse_inst_t *) &cmd_set_bonding_agg_mode_policy,
+#endif
 	(cmdline_parse_inst_t *)&cmd_vlan_offload,
 	(cmdline_parse_inst_t *)&cmd_vlan_tpid,
 	(cmdline_parse_inst_t *)&cmd_rx_vlan_filter_all,
@@ -12673,21 +19234,16 @@
 	(cmdline_parse_inst_t *)&cmd_csum_set,
 	(cmdline_parse_inst_t *)&cmd_csum_show,
 	(cmdline_parse_inst_t *)&cmd_csum_tunnel,
-	(cmdline_parse_inst_t *)&cmd_csum_mac_swap,
 	(cmdline_parse_inst_t *)&cmd_tso_set,
 	(cmdline_parse_inst_t *)&cmd_tso_show,
 	(cmdline_parse_inst_t *)&cmd_tunnel_tso_set,
 	(cmdline_parse_inst_t *)&cmd_tunnel_tso_show,
-#ifdef RTE_LIB_GRO
 	(cmdline_parse_inst_t *)&cmd_gro_enable,
 	(cmdline_parse_inst_t *)&cmd_gro_flush,
 	(cmdline_parse_inst_t *)&cmd_gro_show,
-#endif
-#ifdef RTE_LIB_GSO
 	(cmdline_parse_inst_t *)&cmd_gso_enable,
 	(cmdline_parse_inst_t *)&cmd_gso_size,
 	(cmdline_parse_inst_t *)&cmd_gso_show,
-#endif
 	(cmdline_parse_inst_t *)&cmd_link_flow_control_set,
 	(cmdline_parse_inst_t *)&cmd_link_flow_control_set_rx,
 	(cmdline_parse_inst_t *)&cmd_link_flow_control_set_tx,
@@ -12697,18 +19253,20 @@
 	(cmdline_parse_inst_t *)&cmd_link_flow_control_set_xon,
 	(cmdline_parse_inst_t *)&cmd_link_flow_control_set_macfwd,
 	(cmdline_parse_inst_t *)&cmd_link_flow_control_set_autoneg,
-	(cmdline_parse_inst_t *)&cmd_link_flow_control_show,
 	(cmdline_parse_inst_t *)&cmd_priority_flow_control_set,
-	(cmdline_parse_inst_t *)&cmd_queue_priority_flow_control_set,
 	(cmdline_parse_inst_t *)&cmd_config_dcb,
+	(cmdline_parse_inst_t *)&cmd_read_reg,
+	(cmdline_parse_inst_t *)&cmd_read_reg_bit_field,
+	(cmdline_parse_inst_t *)&cmd_read_reg_bit,
+	(cmdline_parse_inst_t *)&cmd_write_reg,
+	(cmdline_parse_inst_t *)&cmd_write_reg_bit_field,
+	(cmdline_parse_inst_t *)&cmd_write_reg_bit,
 	(cmdline_parse_inst_t *)&cmd_read_rxd_txd,
 	(cmdline_parse_inst_t *)&cmd_stop,
 	(cmdline_parse_inst_t *)&cmd_mac_addr,
 	(cmdline_parse_inst_t *)&cmd_set_fwd_eth_peer,
 	(cmdline_parse_inst_t *)&cmd_set_qmap,
 	(cmdline_parse_inst_t *)&cmd_set_xstats_hide_zero,
-	(cmdline_parse_inst_t *)&cmd_set_record_core_cycles,
-	(cmdline_parse_inst_t *)&cmd_set_record_burst_stats,
 	(cmdline_parse_inst_t *)&cmd_operate_port,
 	(cmdline_parse_inst_t *)&cmd_operate_specific_port,
 	(cmdline_parse_inst_t *)&cmd_operate_attach_port,
@@ -12731,53 +19289,102 @@
 	(cmdline_parse_inst_t *)&cmd_setup_rxtx_queue,
 	(cmdline_parse_inst_t *)&cmd_config_rss_reta,
 	(cmdline_parse_inst_t *)&cmd_showport_reta,
-	(cmdline_parse_inst_t *)&cmd_showport_macs,
-	(cmdline_parse_inst_t *)&cmd_show_port_flow_transfer_proxy,
 	(cmdline_parse_inst_t *)&cmd_config_burst,
 	(cmdline_parse_inst_t *)&cmd_config_thresh,
 	(cmdline_parse_inst_t *)&cmd_config_threshold,
 	(cmdline_parse_inst_t *)&cmd_set_uc_hash_filter,
 	(cmdline_parse_inst_t *)&cmd_set_uc_all_hash_filter,
 	(cmdline_parse_inst_t *)&cmd_vf_mac_addr_filter,
+	(cmdline_parse_inst_t *)&cmd_set_vf_macvlan_filter,
 	(cmdline_parse_inst_t *)&cmd_queue_rate_limit,
+	(cmdline_parse_inst_t *)&cmd_tunnel_filter,
 	(cmdline_parse_inst_t *)&cmd_tunnel_udp_config,
+	(cmdline_parse_inst_t *)&cmd_global_config,
+	(cmdline_parse_inst_t *)&cmd_set_mirror_mask,
+	(cmdline_parse_inst_t *)&cmd_set_mirror_link,
+	(cmdline_parse_inst_t *)&cmd_reset_mirror_rule,
 	(cmdline_parse_inst_t *)&cmd_showport_rss_hash,
 	(cmdline_parse_inst_t *)&cmd_showport_rss_hash_key,
 	(cmdline_parse_inst_t *)&cmd_config_rss_hash_key,
-	(cmdline_parse_inst_t *)&cmd_cleanup_txq_mbufs,
 	(cmdline_parse_inst_t *)&cmd_dump,
 	(cmdline_parse_inst_t *)&cmd_dump_one,
+	(cmdline_parse_inst_t *)&cmd_ethertype_filter,
+	(cmdline_parse_inst_t *)&cmd_syn_filter,
+	(cmdline_parse_inst_t *)&cmd_2tuple_filter,
+	(cmdline_parse_inst_t *)&cmd_5tuple_filter,
+	(cmdline_parse_inst_t *)&cmd_flex_filter,
+	(cmdline_parse_inst_t *)&cmd_add_del_ip_flow_director,
+	(cmdline_parse_inst_t *)&cmd_add_del_udp_flow_director,
+	(cmdline_parse_inst_t *)&cmd_add_del_sctp_flow_director,
+	(cmdline_parse_inst_t *)&cmd_add_del_l2_flow_director,
+	(cmdline_parse_inst_t *)&cmd_add_del_mac_vlan_flow_director,
+	(cmdline_parse_inst_t *)&cmd_add_del_tunnel_flow_director,
+	(cmdline_parse_inst_t *)&cmd_add_del_raw_flow_director,
+	(cmdline_parse_inst_t *)&cmd_flush_flow_director,
+	(cmdline_parse_inst_t *)&cmd_set_flow_director_ip_mask,
+	(cmdline_parse_inst_t *)&cmd_set_flow_director_mac_vlan_mask,
+	(cmdline_parse_inst_t *)&cmd_set_flow_director_tunnel_mask,
+	(cmdline_parse_inst_t *)&cmd_set_flow_director_flex_mask,
+	(cmdline_parse_inst_t *)&cmd_set_flow_director_flex_payload,
+	(cmdline_parse_inst_t *)&cmd_get_sym_hash_ena_per_port,
+	(cmdline_parse_inst_t *)&cmd_set_sym_hash_ena_per_port,
+	(cmdline_parse_inst_t *)&cmd_get_hash_global_config,
+	(cmdline_parse_inst_t *)&cmd_set_hash_global_config,
+	(cmdline_parse_inst_t *)&cmd_set_hash_input_set,
+	(cmdline_parse_inst_t *)&cmd_set_fdir_input_set,
 	(cmdline_parse_inst_t *)&cmd_flow,
 	(cmdline_parse_inst_t *)&cmd_show_port_meter_cap,
 	(cmdline_parse_inst_t *)&cmd_add_port_meter_profile_srtcm,
 	(cmdline_parse_inst_t *)&cmd_add_port_meter_profile_trtcm,
-	(cmdline_parse_inst_t *)&cmd_add_port_meter_profile_trtcm_rfc4115,
 	(cmdline_parse_inst_t *)&cmd_del_port_meter_profile,
 	(cmdline_parse_inst_t *)&cmd_create_port_meter,
 	(cmdline_parse_inst_t *)&cmd_enable_port_meter,
 	(cmdline_parse_inst_t *)&cmd_disable_port_meter,
 	(cmdline_parse_inst_t *)&cmd_del_port_meter,
-	(cmdline_parse_inst_t *)&cmd_del_port_meter_policy,
 	(cmdline_parse_inst_t *)&cmd_set_port_meter_profile,
 	(cmdline_parse_inst_t *)&cmd_set_port_meter_dscp_table,
-	(cmdline_parse_inst_t *)&cmd_set_port_meter_vlan_table,
-	(cmdline_parse_inst_t *)&cmd_set_port_meter_in_proto,
-	(cmdline_parse_inst_t *)&cmd_get_port_meter_in_proto,
-	(cmdline_parse_inst_t *)&cmd_get_port_meter_in_proto_prio,
+	(cmdline_parse_inst_t *)&cmd_set_port_meter_policer_action,
 	(cmdline_parse_inst_t *)&cmd_set_port_meter_stats_mask,
 	(cmdline_parse_inst_t *)&cmd_show_port_meter_stats,
 	(cmdline_parse_inst_t *)&cmd_mcast_addr,
+	(cmdline_parse_inst_t *)&cmd_config_l2_tunnel_eth_type_all,
+	(cmdline_parse_inst_t *)&cmd_config_l2_tunnel_eth_type_specific,
+	(cmdline_parse_inst_t *)&cmd_config_l2_tunnel_en_dis_all,
+	(cmdline_parse_inst_t *)&cmd_config_l2_tunnel_en_dis_specific,
+	(cmdline_parse_inst_t *)&cmd_config_e_tag_insertion_en,
+	(cmdline_parse_inst_t *)&cmd_config_e_tag_insertion_dis,
+	(cmdline_parse_inst_t *)&cmd_config_e_tag_stripping_en_dis,
+	(cmdline_parse_inst_t *)&cmd_config_e_tag_forwarding_en_dis,
+	(cmdline_parse_inst_t *)&cmd_config_e_tag_filter_add,
+	(cmdline_parse_inst_t *)&cmd_config_e_tag_filter_del,
 	(cmdline_parse_inst_t *)&cmd_set_vf_vlan_anti_spoof,
 	(cmdline_parse_inst_t *)&cmd_set_vf_mac_anti_spoof,
 	(cmdline_parse_inst_t *)&cmd_set_vf_vlan_stripq,
 	(cmdline_parse_inst_t *)&cmd_set_vf_vlan_insert,
 	(cmdline_parse_inst_t *)&cmd_set_tx_loopback,
 	(cmdline_parse_inst_t *)&cmd_set_all_queues_drop_en,
+	(cmdline_parse_inst_t *)&cmd_set_vf_split_drop_en,
+	(cmdline_parse_inst_t *)&cmd_set_macsec_offload_on,
+	(cmdline_parse_inst_t *)&cmd_set_macsec_offload_off,
+	(cmdline_parse_inst_t *)&cmd_set_macsec_sc,
+	(cmdline_parse_inst_t *)&cmd_set_macsec_sa,
 	(cmdline_parse_inst_t *)&cmd_set_vf_traffic,
 	(cmdline_parse_inst_t *)&cmd_set_vf_rxmode,
 	(cmdline_parse_inst_t *)&cmd_vf_rate_limit,
 	(cmdline_parse_inst_t *)&cmd_vf_rxvlan_filter,
 	(cmdline_parse_inst_t *)&cmd_set_vf_mac_addr,
+	(cmdline_parse_inst_t *)&cmd_set_vf_promisc,
+	(cmdline_parse_inst_t *)&cmd_set_vf_allmulti,
+	(cmdline_parse_inst_t *)&cmd_set_vf_broadcast,
+	(cmdline_parse_inst_t *)&cmd_set_vf_vlan_tag,
+	(cmdline_parse_inst_t *)&cmd_vf_max_bw,
+	(cmdline_parse_inst_t *)&cmd_vf_tc_min_bw,
+	(cmdline_parse_inst_t *)&cmd_vf_tc_max_bw,
+	(cmdline_parse_inst_t *)&cmd_strict_link_prio,
+	(cmdline_parse_inst_t *)&cmd_tc_min_bw,
+#if defined RTE_LIBRTE_PMD_SOFTNIC && defined RTE_LIBRTE_SCHED
+	(cmdline_parse_inst_t *)&cmd_set_port_tm_hierarchy_default,
+#endif
 	(cmdline_parse_inst_t *)&cmd_set_vxlan,
 	(cmdline_parse_inst_t *)&cmd_set_vxlan_tos_ttl,
 	(cmdline_parse_inst_t *)&cmd_set_vxlan_with_vlan,
@@ -12795,12 +19402,29 @@
 	(cmdline_parse_inst_t *)&cmd_set_mplsoudp_encap_with_vlan,
 	(cmdline_parse_inst_t *)&cmd_set_mplsoudp_decap,
 	(cmdline_parse_inst_t *)&cmd_set_mplsoudp_decap_with_vlan,
-	(cmdline_parse_inst_t *)&cmd_set_conntrack_common,
-	(cmdline_parse_inst_t *)&cmd_set_conntrack_dir,
+	(cmdline_parse_inst_t *)&cmd_ddp_add,
+	(cmdline_parse_inst_t *)&cmd_ddp_del,
+	(cmdline_parse_inst_t *)&cmd_ddp_get_list,
+	(cmdline_parse_inst_t *)&cmd_ddp_get_info,
+	(cmdline_parse_inst_t *)&cmd_cfg_input_set,
+	(cmdline_parse_inst_t *)&cmd_clear_input_set,
 	(cmdline_parse_inst_t *)&cmd_show_vf_stats,
 	(cmdline_parse_inst_t *)&cmd_clear_vf_stats,
 	(cmdline_parse_inst_t *)&cmd_show_port_supported_ptypes,
 	(cmdline_parse_inst_t *)&cmd_set_port_ptypes,
+	(cmdline_parse_inst_t *)&cmd_ptype_mapping_get,
+	(cmdline_parse_inst_t *)&cmd_ptype_mapping_replace,
+	(cmdline_parse_inst_t *)&cmd_ptype_mapping_reset,
+	(cmdline_parse_inst_t *)&cmd_ptype_mapping_update,
+
+	(cmdline_parse_inst_t *)&cmd_pctype_mapping_get,
+	(cmdline_parse_inst_t *)&cmd_pctype_mapping_reset,
+	(cmdline_parse_inst_t *)&cmd_pctype_mapping_update,
+	(cmdline_parse_inst_t *)&cmd_queue_region,
+	(cmdline_parse_inst_t *)&cmd_region_flowtype,
+	(cmdline_parse_inst_t *)&cmd_user_priority_region,
+	(cmdline_parse_inst_t *)&cmd_flush_queue_region,
+	(cmdline_parse_inst_t *)&cmd_show_queue_region_info_all,
 	(cmdline_parse_inst_t *)&cmd_show_port_tm_cap,
 	(cmdline_parse_inst_t *)&cmd_show_port_tm_level_cap,
 	(cmdline_parse_inst_t *)&cmd_show_port_tm_node_cap,
@@ -12814,7 +19438,6 @@
 	(cmdline_parse_inst_t *)&cmd_del_port_tm_node_wred_profile,
 	(cmdline_parse_inst_t *)&cmd_set_port_tm_node_shaper_profile,
 	(cmdline_parse_inst_t *)&cmd_add_port_tm_nonleaf_node,
-	(cmdline_parse_inst_t *)&cmd_add_port_tm_nonleaf_node_pmode,
 	(cmdline_parse_inst_t *)&cmd_add_port_tm_leaf_node,
 	(cmdline_parse_inst_t *)&cmd_del_port_tm_node,
 	(cmdline_parse_inst_t *)&cmd_set_port_tm_node_parent,
@@ -12833,68 +19456,19 @@
 	(cmdline_parse_inst_t *)&cmd_tx_offload_get_configuration,
 	(cmdline_parse_inst_t *)&cmd_config_per_port_tx_offload,
 	(cmdline_parse_inst_t *)&cmd_config_per_queue_tx_offload,
-#ifdef RTE_LIB_BPF
+#ifdef RTE_LIBRTE_BPF
 	(cmdline_parse_inst_t *)&cmd_operate_bpf_ld_parse,
 	(cmdline_parse_inst_t *)&cmd_operate_bpf_unld_parse,
 #endif
 	(cmdline_parse_inst_t *)&cmd_config_tx_metadata_specific,
 	(cmdline_parse_inst_t *)&cmd_show_tx_metadata,
 	(cmdline_parse_inst_t *)&cmd_show_rx_tx_desc_status,
-	(cmdline_parse_inst_t *)&cmd_show_rx_queue_desc_used_count,
 	(cmdline_parse_inst_t *)&cmd_set_raw,
 	(cmdline_parse_inst_t *)&cmd_show_set_raw,
 	(cmdline_parse_inst_t *)&cmd_show_set_raw_all,
-	(cmdline_parse_inst_t *)&cmd_config_tx_dynf_specific,
-	(cmdline_parse_inst_t *)&cmd_show_fec_mode,
-	(cmdline_parse_inst_t *)&cmd_set_fec_mode,
-	(cmdline_parse_inst_t *)&cmd_set_rxq_avail_thresh,
-	(cmdline_parse_inst_t *)&cmd_show_capability,
-	(cmdline_parse_inst_t *)&cmd_set_flex_is_pattern,
-	(cmdline_parse_inst_t *)&cmd_set_flex_spec_pattern,
 	NULL,
 };
 
-void
-testpmd_add_driver_commands(struct testpmd_driver_commands *c)
-{
-	TAILQ_INSERT_TAIL(&driver_commands_head, c, next);
-}
-
-int
-init_cmdline(void)
-{
-	struct testpmd_driver_commands *c;
-	unsigned int count;
-	unsigned int i;
-
-	/* initialize non-constant commands */
-	cmd_set_fwd_mode_init();
-	cmd_set_fwd_retry_mode_init();
-
-	count = 0;
-	for (i = 0; builtin_ctx[i] != NULL; i++)
-		count++;
-	TAILQ_FOREACH(c, &driver_commands_head, next) {
-		for (i = 0; c->commands[i].ctx != NULL; i++)
-			count++;
-	}
-
-	/* cmdline expects a NULL terminated array */
-	main_ctx = calloc(count + 1, sizeof(main_ctx[0]));
-	if (main_ctx == NULL)
-		return -1;
-
-	count = 0;
-	for (i = 0; builtin_ctx[i] != NULL; i++, count++)
-		main_ctx[count] = builtin_ctx[i];
-	TAILQ_FOREACH(c, &driver_commands_head, next) {
-		for (i = 0; c->commands[i].ctx != NULL; i++, count++)
-			main_ctx[count] = c->commands[i].ctx;
-	}
-
-	return 0;
-}
-
 /* read cmdline commands from file */
 void
 cmdline_read_from_file(const char *filename)
@@ -12903,9 +19477,8 @@
 
 	cl = cmdline_file_new(main_ctx, "testpmd> ", filename);
 	if (cl == NULL) {
-		fprintf(stderr,
-			"Failed to create file based cmdline context: %s\n",
-			filename);
+		printf("Failed to create file based cmdline context: %s\n",
+		       filename);
 		return;
 	}
 
@@ -12917,28 +19490,29 @@
 	printf("Read CLI commands from %s\n", filename);
 }
 
-void
-prompt_exit(void)
-{
-	cmdline_quit(testpmd_cl);
-}
-
-/* prompt function, called from main on MAIN lcore */
+/* prompt function, called from main on MASTER lcore */
 void
 prompt(void)
 {
+	/* initialize non-constant commands */
+	cmd_set_fwd_mode_init();
+	cmd_set_fwd_retry_mode_init();
+
 	testpmd_cl = cmdline_stdin_new(main_ctx, "testpmd> ");
-	if (testpmd_cl == NULL) {
-		fprintf(stderr,
-			"Failed to create stdin based cmdline context\n");
+	if (testpmd_cl == NULL)
 		return;
-	}
-
 	cmdline_interact(testpmd_cl);
 	cmdline_stdin_exit(testpmd_cl);
 }
 
 void
+prompt_exit(void)
+{
+	if (testpmd_cl != NULL)
+		cmdline_quit(testpmd_cl);
+}
+
+static void
 cmd_reconfig_device_queue(portid_t id, uint8_t dev, uint8_t queue)
 {
 	if (id == (portid_t)RTE_PORT_ALL) {
diff -urN dpdk/app/test-pmd/cmdline_flow.c testpmd-as-load-balancer/v19.11/test-pmd/cmdline_flow.c
--- dpdk/app/test-pmd/cmdline_flow.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/cmdline_flow.c	2023-12-15 15:26:37.089199123 +0100
@@ -6,11 +6,12 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <stdio.h>
-#include <stdlib.h>
 #include <inttypes.h>
 #include <errno.h>
 #include <ctype.h>
 #include <string.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
 
 #include <rte_string_fns.h>
 #include <rte_common.h>
@@ -22,11 +23,6 @@
 #include <cmdline_parse_num.h>
 #include <rte_flow.h>
 #include <rte_hexdump.h>
-#include <rte_vxlan.h>
-#include <rte_gre.h>
-#include <rte_mpls.h>
-#include <rte_gtp.h>
-#include <rte_geneve.h>
 
 #include "testpmd.h"
 
@@ -39,32 +35,19 @@
 	END_SET,
 
 	/* Common tokens. */
-	COMMON_INTEGER,
-	COMMON_UNSIGNED,
-	COMMON_PREFIX,
-	COMMON_BOOLEAN,
-	COMMON_STRING,
-	COMMON_HEX,
-	COMMON_FILE_PATH,
-	COMMON_MAC_ADDR,
-	COMMON_IPV4_ADDR,
-	COMMON_IPV6_ADDR,
-	COMMON_RULE_ID,
-	COMMON_PORT_ID,
-	COMMON_GROUP_ID,
-	COMMON_PRIORITY_LEVEL,
-	COMMON_INDIRECT_ACTION_ID,
-	COMMON_PROFILE_ID,
-	COMMON_POLICY_ID,
-	COMMON_FLEX_HANDLE,
-	COMMON_FLEX_TOKEN,
-	COMMON_PATTERN_TEMPLATE_ID,
-	COMMON_ACTIONS_TEMPLATE_ID,
-	COMMON_TABLE_ID,
-	COMMON_QUEUE_ID,
-
-	/* TOP-level command. */
-	ADD,
+	INTEGER,
+	UNSIGNED,
+	PREFIX,
+	BOOLEAN,
+	STRING,
+	HEX,
+	MAC_ADDR,
+	IPV4_ADDR,
+	IPV6_ADDR,
+	RULE_ID,
+	PORT_ID,
+	GROUP_ID,
+	PRIORITY_LEVEL,
 
 	/* Top-level command. */
 	SET,
@@ -72,128 +55,17 @@
 	SET_RAW_ENCAP,
 	SET_RAW_DECAP,
 	SET_RAW_INDEX,
-	SET_SAMPLE_ACTIONS,
-	SET_SAMPLE_INDEX,
 
 	/* Top-level command. */
 	FLOW,
 	/* Sub-level commands. */
-	INFO,
-	CONFIGURE,
-	PATTERN_TEMPLATE,
-	ACTIONS_TEMPLATE,
-	TABLE,
-	INDIRECT_ACTION,
 	VALIDATE,
 	CREATE,
 	DESTROY,
 	FLUSH,
-	DUMP,
 	QUERY,
 	LIST,
-	AGED,
 	ISOLATE,
-	TUNNEL,
-	FLEX,
-	QUEUE,
-	PUSH,
-	PULL,
-
-	/* Flex arguments */
-	FLEX_ITEM_INIT,
-	FLEX_ITEM_CREATE,
-	FLEX_ITEM_DESTROY,
-
-	/* Pattern template arguments. */
-	PATTERN_TEMPLATE_CREATE,
-	PATTERN_TEMPLATE_DESTROY,
-	PATTERN_TEMPLATE_CREATE_ID,
-	PATTERN_TEMPLATE_DESTROY_ID,
-	PATTERN_TEMPLATE_RELAXED_MATCHING,
-	PATTERN_TEMPLATE_INGRESS,
-	PATTERN_TEMPLATE_EGRESS,
-	PATTERN_TEMPLATE_TRANSFER,
-	PATTERN_TEMPLATE_SPEC,
-
-	/* Actions template arguments. */
-	ACTIONS_TEMPLATE_CREATE,
-	ACTIONS_TEMPLATE_DESTROY,
-	ACTIONS_TEMPLATE_CREATE_ID,
-	ACTIONS_TEMPLATE_DESTROY_ID,
-	ACTIONS_TEMPLATE_INGRESS,
-	ACTIONS_TEMPLATE_EGRESS,
-	ACTIONS_TEMPLATE_TRANSFER,
-	ACTIONS_TEMPLATE_SPEC,
-	ACTIONS_TEMPLATE_MASK,
-
-	/* Queue arguments. */
-	QUEUE_CREATE,
-	QUEUE_DESTROY,
-	QUEUE_AGED,
-	QUEUE_INDIRECT_ACTION,
-
-	/* Queue create arguments. */
-	QUEUE_CREATE_ID,
-	QUEUE_CREATE_POSTPONE,
-	QUEUE_TEMPLATE_TABLE,
-	QUEUE_PATTERN_TEMPLATE,
-	QUEUE_ACTIONS_TEMPLATE,
-	QUEUE_SPEC,
-
-	/* Queue destroy arguments. */
-	QUEUE_DESTROY_ID,
-	QUEUE_DESTROY_POSTPONE,
-
-	/* Queue indirect action arguments */
-	QUEUE_INDIRECT_ACTION_CREATE,
-	QUEUE_INDIRECT_ACTION_UPDATE,
-	QUEUE_INDIRECT_ACTION_DESTROY,
-	QUEUE_INDIRECT_ACTION_QUERY,
-
-	/* Queue indirect action create arguments */
-	QUEUE_INDIRECT_ACTION_CREATE_ID,
-	QUEUE_INDIRECT_ACTION_INGRESS,
-	QUEUE_INDIRECT_ACTION_EGRESS,
-	QUEUE_INDIRECT_ACTION_TRANSFER,
-	QUEUE_INDIRECT_ACTION_CREATE_POSTPONE,
-	QUEUE_INDIRECT_ACTION_SPEC,
-
-	/* Queue indirect action update arguments */
-	QUEUE_INDIRECT_ACTION_UPDATE_POSTPONE,
-
-	/* Queue indirect action destroy arguments */
-	QUEUE_INDIRECT_ACTION_DESTROY_ID,
-	QUEUE_INDIRECT_ACTION_DESTROY_POSTPONE,
-
-	/* Queue indirect action query arguments */
-	QUEUE_INDIRECT_ACTION_QUERY_POSTPONE,
-
-	/* Push arguments. */
-	PUSH_QUEUE,
-
-	/* Pull arguments. */
-	PULL_QUEUE,
-
-	/* Table arguments. */
-	TABLE_CREATE,
-	TABLE_DESTROY,
-	TABLE_CREATE_ID,
-	TABLE_DESTROY_ID,
-	TABLE_GROUP,
-	TABLE_PRIORITY,
-	TABLE_INGRESS,
-	TABLE_EGRESS,
-	TABLE_TRANSFER,
-	TABLE_RULES_NUMBER,
-	TABLE_PATTERN_TEMPLATE,
-	TABLE_ACTIONS_TEMPLATE,
-
-	/* Tunnel arguments. */
-	TUNNEL_CREATE,
-	TUNNEL_CREATE_TYPE,
-	TUNNEL_LIST,
-	TUNNEL_DESTROY,
-	TUNNEL_DESTROY_ID,
 
 	/* Destroy arguments. */
 	DESTROY_RULE,
@@ -204,49 +76,15 @@
 	/* List arguments. */
 	LIST_GROUP,
 
-	/* Destroy aged flow arguments. */
-	AGED_DESTROY,
-
 	/* Validate/create arguments. */
-	VC_GROUP,
-	VC_PRIORITY,
-	VC_INGRESS,
-	VC_EGRESS,
-	VC_TRANSFER,
-	VC_TUNNEL_SET,
-	VC_TUNNEL_MATCH,
-
-	/* Dump arguments */
-	DUMP_ALL,
-	DUMP_ONE,
-
-	/* Configure arguments */
-	CONFIG_QUEUES_NUMBER,
-	CONFIG_QUEUES_SIZE,
-	CONFIG_COUNTERS_NUMBER,
-	CONFIG_AGING_OBJECTS_NUMBER,
-	CONFIG_METERS_NUMBER,
-	CONFIG_CONN_TRACK_NUMBER,
-	CONFIG_FLAGS,
-
-	/* Indirect action arguments */
-	INDIRECT_ACTION_CREATE,
-	INDIRECT_ACTION_UPDATE,
-	INDIRECT_ACTION_DESTROY,
-	INDIRECT_ACTION_QUERY,
-
-	/* Indirect action create arguments */
-	INDIRECT_ACTION_CREATE_ID,
-	INDIRECT_ACTION_INGRESS,
-	INDIRECT_ACTION_EGRESS,
-	INDIRECT_ACTION_TRANSFER,
-	INDIRECT_ACTION_SPEC,
-
-	/* Indirect action destroy arguments */
-	INDIRECT_ACTION_DESTROY_ID,
+	GROUP,
+	PRIORITY,
+	INGRESS,
+	EGRESS,
+	TRANSFER,
 
 	/* Validate/create pattern. */
-	ITEM_PATTERN,
+	PATTERN,
 	ITEM_PARAM_IS,
 	ITEM_PARAM_SPEC,
 	ITEM_PARAM_LAST,
@@ -258,6 +96,11 @@
 	ITEM_INVERT,
 	ITEM_ANY,
 	ITEM_ANY_NUM,
+	ITEM_PF,
+	ITEM_VF,
+	ITEM_VF_ID,
+	ITEM_PHY_PORT,
+	ITEM_PHY_PORT_INDEX,
 	ITEM_PORT_ID,
 	ITEM_PORT_ID_ID,
 	ITEM_MARK,
@@ -268,24 +111,18 @@
 	ITEM_RAW_OFFSET,
 	ITEM_RAW_LIMIT,
 	ITEM_RAW_PATTERN,
-	ITEM_RAW_PATTERN_HEX,
 	ITEM_ETH,
 	ITEM_ETH_DST,
 	ITEM_ETH_SRC,
 	ITEM_ETH_TYPE,
-	ITEM_ETH_HAS_VLAN,
 	ITEM_VLAN,
 	ITEM_VLAN_TCI,
 	ITEM_VLAN_PCP,
 	ITEM_VLAN_DEI,
 	ITEM_VLAN_VID,
 	ITEM_VLAN_INNER_TYPE,
-	ITEM_VLAN_HAS_MORE_VLAN,
 	ITEM_IPV4,
-	ITEM_IPV4_VER_IHL,
 	ITEM_IPV4_TOS,
-	ITEM_IPV4_ID,
-	ITEM_IPV4_FRAGMENT_OFFSET,
 	ITEM_IPV4_TTL,
 	ITEM_IPV4_PROTO,
 	ITEM_IPV4_SRC,
@@ -297,12 +134,9 @@
 	ITEM_IPV6_HOP,
 	ITEM_IPV6_SRC,
 	ITEM_IPV6_DST,
-	ITEM_IPV6_HAS_FRAG_EXT,
 	ITEM_ICMP,
 	ITEM_ICMP_TYPE,
 	ITEM_ICMP_CODE,
-	ITEM_ICMP_IDENT,
-	ITEM_ICMP_SEQ,
 	ITEM_UDP,
 	ITEM_UDP_SRC,
 	ITEM_UDP_DST,
@@ -317,7 +151,6 @@
 	ITEM_SCTP_CKSUM,
 	ITEM_VXLAN,
 	ITEM_VXLAN_VNI,
-	ITEM_VXLAN_LAST_RSVD,
 	ITEM_E_TAG,
 	ITEM_E_TAG_GRP_ECID_B,
 	ITEM_NVGRE,
@@ -335,15 +168,12 @@
 	ITEM_FUZZY,
 	ITEM_FUZZY_THRESH,
 	ITEM_GTP,
-	ITEM_GTP_FLAGS,
-	ITEM_GTP_MSG_TYPE,
 	ITEM_GTP_TEID,
 	ITEM_GTPC,
 	ITEM_GTPU,
 	ITEM_GENEVE,
 	ITEM_GENEVE_VNI,
 	ITEM_GENEVE_PROTO,
-	ITEM_GENEVE_OPTLEN,
 	ITEM_VXLAN_GPE,
 	ITEM_VXLAN_GPE_VNI,
 	ITEM_ARP_ETH_IPV4,
@@ -353,10 +183,6 @@
 	ITEM_ARP_ETH_IPV4_TPA,
 	ITEM_IPV6_EXT,
 	ITEM_IPV6_EXT_NEXT_HDR,
-	ITEM_IPV6_FRAG_EXT,
-	ITEM_IPV6_FRAG_EXT_NEXT_HDR,
-	ITEM_IPV6_FRAG_EXT_FRAG_DATA,
-	ITEM_IPV6_FRAG_EXT_ID,
 	ITEM_ICMP6,
 	ITEM_ICMP6_TYPE,
 	ITEM_ICMP6_CODE,
@@ -374,10 +200,6 @@
 	ITEM_META_DATA,
 	ITEM_GRE_KEY,
 	ITEM_GRE_KEY_VALUE,
-	ITEM_GRE_OPTION,
-	ITEM_GRE_OPTION_CHECKSUM,
-	ITEM_GRE_OPTION_KEY,
-	ITEM_GRE_OPTION_SEQUENCE,
 	ITEM_GTP_PSC,
 	ITEM_GTP_PSC_QFI,
 	ITEM_GTP_PSC_PDU_T,
@@ -391,80 +213,6 @@
 	ITEM_TAG,
 	ITEM_TAG_DATA,
 	ITEM_TAG_INDEX,
-	ITEM_L2TPV3OIP,
-	ITEM_L2TPV3OIP_SESSION_ID,
-	ITEM_ESP,
-	ITEM_ESP_SPI,
-	ITEM_AH,
-	ITEM_AH_SPI,
-	ITEM_PFCP,
-	ITEM_PFCP_S_FIELD,
-	ITEM_PFCP_SEID,
-	ITEM_ECPRI,
-	ITEM_ECPRI_COMMON,
-	ITEM_ECPRI_COMMON_TYPE,
-	ITEM_ECPRI_COMMON_TYPE_IQ_DATA,
-	ITEM_ECPRI_COMMON_TYPE_RTC_CTRL,
-	ITEM_ECPRI_COMMON_TYPE_DLY_MSR,
-	ITEM_ECPRI_MSG_IQ_DATA_PCID,
-	ITEM_ECPRI_MSG_RTC_CTRL_RTCID,
-	ITEM_ECPRI_MSG_DLY_MSR_MSRID,
-	ITEM_GENEVE_OPT,
-	ITEM_GENEVE_OPT_CLASS,
-	ITEM_GENEVE_OPT_TYPE,
-	ITEM_GENEVE_OPT_LENGTH,
-	ITEM_GENEVE_OPT_DATA,
-	ITEM_INTEGRITY,
-	ITEM_INTEGRITY_LEVEL,
-	ITEM_INTEGRITY_VALUE,
-	ITEM_CONNTRACK,
-	ITEM_POL_PORT,
-	ITEM_POL_METER,
-	ITEM_POL_POLICY,
-	ITEM_PORT_REPRESENTOR,
-	ITEM_PORT_REPRESENTOR_PORT_ID,
-	ITEM_REPRESENTED_PORT,
-	ITEM_REPRESENTED_PORT_ETHDEV_PORT_ID,
-	ITEM_FLEX,
-	ITEM_FLEX_ITEM_HANDLE,
-	ITEM_FLEX_PATTERN_HANDLE,
-	ITEM_L2TPV2,
-	ITEM_L2TPV2_TYPE,
-	ITEM_L2TPV2_TYPE_DATA,
-	ITEM_L2TPV2_TYPE_DATA_L,
-	ITEM_L2TPV2_TYPE_DATA_S,
-	ITEM_L2TPV2_TYPE_DATA_O,
-	ITEM_L2TPV2_TYPE_DATA_L_S,
-	ITEM_L2TPV2_TYPE_CTRL,
-	ITEM_L2TPV2_MSG_DATA_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_SESSION_ID,
-	ITEM_L2TPV2_MSG_DATA_L_LENGTH,
-	ITEM_L2TPV2_MSG_DATA_L_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_L_SESSION_ID,
-	ITEM_L2TPV2_MSG_DATA_S_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_S_SESSION_ID,
-	ITEM_L2TPV2_MSG_DATA_S_NS,
-	ITEM_L2TPV2_MSG_DATA_S_NR,
-	ITEM_L2TPV2_MSG_DATA_O_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_O_SESSION_ID,
-	ITEM_L2TPV2_MSG_DATA_O_OFFSET,
-	ITEM_L2TPV2_MSG_DATA_L_S_LENGTH,
-	ITEM_L2TPV2_MSG_DATA_L_S_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_L_S_SESSION_ID,
-	ITEM_L2TPV2_MSG_DATA_L_S_NS,
-	ITEM_L2TPV2_MSG_DATA_L_S_NR,
-	ITEM_L2TPV2_MSG_CTRL_LENGTH,
-	ITEM_L2TPV2_MSG_CTRL_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_CTRL_SESSION_ID,
-	ITEM_L2TPV2_MSG_CTRL_NS,
-	ITEM_L2TPV2_MSG_CTRL_NR,
-	ITEM_PPP,
-	ITEM_PPP_ADDR,
-	ITEM_PPP_CTRL,
-	ITEM_PPP_PROTO_ID,
-	ITEM_METER,
-	ITEM_METER_COLOR,
-	ITEM_METER_COLOR_NAME,
 
 	/* Validate/create actions. */
 	ACTIONS,
@@ -481,6 +229,7 @@
 	ACTION_QUEUE_INDEX,
 	ACTION_DROP,
 	ACTION_COUNT,
+	ACTION_COUNT_SHARED,
 	ACTION_COUNT_ID,
 	ACTION_RSS,
 	ACTION_RSS_FUNC,
@@ -499,25 +248,22 @@
 	ACTION_VF,
 	ACTION_VF_ORIGINAL,
 	ACTION_VF_ID,
+	ACTION_PHY_PORT,
+	ACTION_PHY_PORT_ORIGINAL,
+	ACTION_PHY_PORT_INDEX,
 	ACTION_PORT_ID,
 	ACTION_PORT_ID_ORIGINAL,
 	ACTION_PORT_ID_ID,
 	ACTION_METER,
-	ACTION_METER_COLOR,
-	ACTION_METER_COLOR_TYPE,
-	ACTION_METER_COLOR_GREEN,
-	ACTION_METER_COLOR_YELLOW,
-	ACTION_METER_COLOR_RED,
 	ACTION_METER_ID,
-	ACTION_METER_MARK,
-	ACTION_METER_PROFILE,
-	ACTION_METER_PROFILE_ID2PTR,
-	ACTION_METER_POLICY,
-	ACTION_METER_POLICY_ID2PTR,
-	ACTION_METER_COLOR_MODE,
-	ACTION_METER_INIT_COLOR,
-	ACTION_METER_STATE,
+	ACTION_OF_SET_MPLS_TTL,
+	ACTION_OF_SET_MPLS_TTL_MPLS_TTL,
+	ACTION_OF_DEC_MPLS_TTL,
+	ACTION_OF_SET_NW_TTL,
+	ACTION_OF_SET_NW_TTL_NW_TTL,
 	ACTION_OF_DEC_NW_TTL,
+	ACTION_OF_COPY_TTL_OUT,
+	ACTION_OF_COPY_TTL_IN,
 	ACTION_OF_POP_VLAN,
 	ACTION_OF_PUSH_VLAN,
 	ACTION_OF_PUSH_VLAN_ETHERTYPE,
@@ -580,67 +326,15 @@
 	ACTION_SET_META,
 	ACTION_SET_META_DATA,
 	ACTION_SET_META_MASK,
-	ACTION_SET_IPV4_DSCP,
-	ACTION_SET_IPV4_DSCP_VALUE,
-	ACTION_SET_IPV6_DSCP,
-	ACTION_SET_IPV6_DSCP_VALUE,
-	ACTION_AGE,
-	ACTION_AGE_TIMEOUT,
-	ACTION_AGE_UPDATE,
-	ACTION_AGE_UPDATE_TIMEOUT,
-	ACTION_AGE_UPDATE_TOUCH,
-	ACTION_SAMPLE,
-	ACTION_SAMPLE_RATIO,
-	ACTION_SAMPLE_INDEX,
-	ACTION_SAMPLE_INDEX_VALUE,
-	ACTION_INDIRECT,
-	INDIRECT_ACTION_ID2PTR,
-	ACTION_MODIFY_FIELD,
-	ACTION_MODIFY_FIELD_OP,
-	ACTION_MODIFY_FIELD_OP_VALUE,
-	ACTION_MODIFY_FIELD_DST_TYPE,
-	ACTION_MODIFY_FIELD_DST_TYPE_VALUE,
-	ACTION_MODIFY_FIELD_DST_LEVEL,
-	ACTION_MODIFY_FIELD_DST_OFFSET,
-	ACTION_MODIFY_FIELD_SRC_TYPE,
-	ACTION_MODIFY_FIELD_SRC_TYPE_VALUE,
-	ACTION_MODIFY_FIELD_SRC_LEVEL,
-	ACTION_MODIFY_FIELD_SRC_OFFSET,
-	ACTION_MODIFY_FIELD_SRC_VALUE,
-	ACTION_MODIFY_FIELD_SRC_POINTER,
-	ACTION_MODIFY_FIELD_WIDTH,
-	ACTION_CONNTRACK,
-	ACTION_CONNTRACK_UPDATE,
-	ACTION_CONNTRACK_UPDATE_DIR,
-	ACTION_CONNTRACK_UPDATE_CTX,
-	ACTION_POL_G,
-	ACTION_POL_Y,
-	ACTION_POL_R,
-	ACTION_PORT_REPRESENTOR,
-	ACTION_PORT_REPRESENTOR_PORT_ID,
-	ACTION_REPRESENTED_PORT,
-	ACTION_REPRESENTED_PORT_ETHDEV_PORT_ID,
-	ACTION_SEND_TO_KERNEL,
 };
 
 /** Maximum size for pattern in struct rte_flow_item_raw. */
-#define ITEM_RAW_PATTERN_SIZE 512
-
-/** Maximum size for GENEVE option data pattern in bytes. */
-#define ITEM_GENEVE_OPT_DATA_SIZE 124
+#define ITEM_RAW_PATTERN_SIZE 40
 
 /** Storage size for struct rte_flow_item_raw including pattern. */
 #define ITEM_RAW_SIZE \
 	(sizeof(struct rte_flow_item_raw) + ITEM_RAW_PATTERN_SIZE)
 
-/** Maximum size for external pattern in struct rte_flow_action_modify_data. */
-#define ACTION_MODIFY_PATTERN_SIZE 32
-
-/** Storage size for struct rte_flow_action_modify_field including pattern. */
-#define ACTION_MODIFY_SIZE \
-	(sizeof(struct rte_flow_action_modify_field) + \
-	ACTION_MODIFY_PATTERN_SIZE)
-
 /** Maximum number of queue indices in struct rte_flow_action_rss. */
 #define ACTION_RSS_QUEUE_NUM 128
 
@@ -652,7 +346,7 @@
 };
 
 /** Maximum data size in struct rte_flow_action_raw_encap. */
-#define ACTION_RAW_ENCAP_MAX_DATA 512
+#define ACTION_RAW_ENCAP_MAX_DATA 128
 #define RAW_ENCAP_CONFS_MAX_NUM 8
 
 /** Storage for struct rte_flow_action_raw_encap. */
@@ -693,7 +387,7 @@
 	.select_tos_ttl = 0,
 	.vni = "\x00\x00\x00",
 	.udp_src = 0,
-	.udp_dst = RTE_BE16(RTE_VXLAN_DEFAULT_PORT),
+	.udp_dst = RTE_BE16(4789),
 	.ipv4_src = RTE_IPV4(127, 0, 0, 1),
 	.ipv4_dst = RTE_IPV4(255, 255, 255, 255),
 	.ipv6_src = "\x00\x00\x00\x00\x00\x00\x00\x00"
@@ -767,53 +461,6 @@
 
 struct mplsoudp_decap_conf mplsoudp_decap_conf;
 
-struct rte_flow_action_conntrack conntrack_context;
-
-#define ACTION_SAMPLE_ACTIONS_NUM 10
-#define RAW_SAMPLE_CONFS_MAX_NUM 8
-/** Storage for struct rte_flow_action_sample including external data. */
-struct action_sample_data {
-	struct rte_flow_action_sample conf;
-	uint32_t idx;
-};
-/** Storage for struct rte_flow_action_sample. */
-struct raw_sample_conf {
-	struct rte_flow_action data[ACTION_SAMPLE_ACTIONS_NUM];
-};
-struct raw_sample_conf raw_sample_confs[RAW_SAMPLE_CONFS_MAX_NUM];
-struct rte_flow_action_mark sample_mark[RAW_SAMPLE_CONFS_MAX_NUM];
-struct rte_flow_action_queue sample_queue[RAW_SAMPLE_CONFS_MAX_NUM];
-struct rte_flow_action_count sample_count[RAW_SAMPLE_CONFS_MAX_NUM];
-struct rte_flow_action_port_id sample_port_id[RAW_SAMPLE_CONFS_MAX_NUM];
-struct rte_flow_action_raw_encap sample_encap[RAW_SAMPLE_CONFS_MAX_NUM];
-struct action_vxlan_encap_data sample_vxlan_encap[RAW_SAMPLE_CONFS_MAX_NUM];
-struct action_nvgre_encap_data sample_nvgre_encap[RAW_SAMPLE_CONFS_MAX_NUM];
-struct action_rss_data sample_rss_data[RAW_SAMPLE_CONFS_MAX_NUM];
-struct rte_flow_action_vf sample_vf[RAW_SAMPLE_CONFS_MAX_NUM];
-struct rte_flow_action_ethdev sample_port_representor[RAW_SAMPLE_CONFS_MAX_NUM];
-struct rte_flow_action_ethdev sample_represented_port[RAW_SAMPLE_CONFS_MAX_NUM];
-
-static const char *const modify_field_ops[] = {
-	"set", "add", "sub", NULL
-};
-
-static const char *const modify_field_ids[] = {
-	"start", "mac_dst", "mac_src",
-	"vlan_type", "vlan_id", "mac_type",
-	"ipv4_dscp", "ipv4_ttl", "ipv4_src", "ipv4_dst",
-	"ipv6_dscp", "ipv6_hoplimit", "ipv6_src", "ipv6_dst",
-	"tcp_port_src", "tcp_port_dst",
-	"tcp_seq_num", "tcp_ack_num", "tcp_flags",
-	"udp_port_src", "udp_port_dst",
-	"vxlan_vni", "geneve_vni", "gtp_teid",
-	"tag", "mark", "meta", "pointer", "value",
-	"ipv4_ecn", "ipv6_ecn", "gtp_psc_qfi", "meter_color", NULL
-};
-
-static const char *const meter_colors[] = {
-	"green", "yellow", "red", "all", NULL
-};
-
 /** Maximum number of subsequent tokens and arguments on the stack. */
 #define CTX_STACK_SIZE 16
 
@@ -911,16 +558,6 @@
 		.mask = (const void *)&(const s){ .f = (1 << (b)) - 1 }, \
 	})
 
-/** Static initializer for ARGS() to target a field with limits. */
-#define ARGS_ENTRY_BOUNDED(s, f, i, a) \
-	(&(const struct arg){ \
-		.bounded = 1, \
-		.min = (i), \
-		.max = (a), \
-		.offset = offsetof(s, f), \
-		.size = sizeof(((s *)0)->f), \
-	})
-
 /** Static initializer for ARGS() to target an arbitrary bit-mask. */
 #define ARGS_ENTRY_MASK(s, f, m) \
 	(&(const struct arg){ \
@@ -981,46 +618,11 @@
 struct buffer {
 	enum index command; /**< Flow command. */
 	portid_t port; /**< Affected port ID. */
-	queueid_t queue; /** Async queue ID. */
-	bool postpone; /** Postpone async operation */
 	union {
 		struct {
-			struct rte_flow_port_attr port_attr;
-			uint32_t nb_queue;
-			struct rte_flow_queue_attr queue_attr;
-		} configure; /**< Configuration arguments. */
-		struct {
-			uint32_t *template_id;
-			uint32_t template_id_n;
-		} templ_destroy; /**< Template destroy arguments. */
-		struct {
-			uint32_t id;
-			struct rte_flow_template_table_attr attr;
-			uint32_t *pat_templ_id;
-			uint32_t pat_templ_id_n;
-			uint32_t *act_templ_id;
-			uint32_t act_templ_id_n;
-		} table; /**< Table arguments. */
-		struct {
-			uint32_t *table_id;
-			uint32_t table_id_n;
-		} table_destroy; /**< Template destroy arguments. */
-		struct {
-			uint32_t *action_id;
-			uint32_t action_id_n;
-		} ia_destroy; /**< Indirect action destroy arguments. */
-		struct {
-			uint32_t action_id;
-		} ia; /* Indirect action query arguments */
-		struct {
-			uint32_t table_id;
-			uint32_t pat_templ_id;
-			uint32_t act_templ_id;
 			struct rte_flow_attr attr;
-			struct tunnel_ops tunnel_ops;
 			struct rte_flow_item *pattern;
 			struct rte_flow_action *actions;
-			struct rte_flow_action *masks;
 			uint32_t pattern_n;
 			uint32_t actions_n;
 			uint8_t *data;
@@ -1030,11 +632,6 @@
 			uint32_t rule_n;
 		} destroy; /**< Destroy arguments. */
 		struct {
-			char file[128];
-			bool mode;
-			uint32_t rule;
-		} dump; /**< Dump arguments. */
-		struct {
 			uint32_t rule;
 			struct rte_flow_action action;
 		} query; /**< Query arguments. */
@@ -1045,17 +642,6 @@
 		struct {
 			int set;
 		} isolate; /**< Isolated mode arguments. */
-		struct {
-			int destroy;
-		} aged; /**< Aged arguments. */
-		struct {
-			uint32_t policy_id;
-		} policy;/**< Policy arguments. */
-		struct {
-			uint16_t token;
-			uintptr_t uintptr;
-			char filename[128];
-		} flex; /**< Flex arguments*/
 	} args; /**< Command arguments. */
 };
 
@@ -1083,177 +669,13 @@
 		.size = s, \
 	})
 
-static const enum index next_flex_item[] = {
-	FLEX_ITEM_INIT,
-	FLEX_ITEM_CREATE,
-	FLEX_ITEM_DESTROY,
-	ZERO,
-};
-
-static const enum index next_config_attr[] = {
-	CONFIG_QUEUES_NUMBER,
-	CONFIG_QUEUES_SIZE,
-	CONFIG_COUNTERS_NUMBER,
-	CONFIG_AGING_OBJECTS_NUMBER,
-	CONFIG_METERS_NUMBER,
-	CONFIG_CONN_TRACK_NUMBER,
-	CONFIG_FLAGS,
-	END,
-	ZERO,
-};
-
-static const enum index next_pt_subcmd[] = {
-	PATTERN_TEMPLATE_CREATE,
-	PATTERN_TEMPLATE_DESTROY,
-	ZERO,
-};
-
-static const enum index next_pt_attr[] = {
-	PATTERN_TEMPLATE_CREATE_ID,
-	PATTERN_TEMPLATE_RELAXED_MATCHING,
-	PATTERN_TEMPLATE_INGRESS,
-	PATTERN_TEMPLATE_EGRESS,
-	PATTERN_TEMPLATE_TRANSFER,
-	PATTERN_TEMPLATE_SPEC,
-	ZERO,
-};
-
-static const enum index next_pt_destroy_attr[] = {
-	PATTERN_TEMPLATE_DESTROY_ID,
-	END,
-	ZERO,
-};
-
-static const enum index next_at_subcmd[] = {
-	ACTIONS_TEMPLATE_CREATE,
-	ACTIONS_TEMPLATE_DESTROY,
-	ZERO,
-};
-
-static const enum index next_at_attr[] = {
-	ACTIONS_TEMPLATE_CREATE_ID,
-	ACTIONS_TEMPLATE_INGRESS,
-	ACTIONS_TEMPLATE_EGRESS,
-	ACTIONS_TEMPLATE_TRANSFER,
-	ACTIONS_TEMPLATE_SPEC,
-	ZERO,
-};
-
-static const enum index next_at_destroy_attr[] = {
-	ACTIONS_TEMPLATE_DESTROY_ID,
-	END,
-	ZERO,
-};
-
-static const enum index next_table_subcmd[] = {
-	TABLE_CREATE,
-	TABLE_DESTROY,
-	ZERO,
-};
-
-static const enum index next_table_attr[] = {
-	TABLE_CREATE_ID,
-	TABLE_GROUP,
-	TABLE_PRIORITY,
-	TABLE_INGRESS,
-	TABLE_EGRESS,
-	TABLE_TRANSFER,
-	TABLE_RULES_NUMBER,
-	TABLE_PATTERN_TEMPLATE,
-	TABLE_ACTIONS_TEMPLATE,
-	END,
-	ZERO,
-};
-
-static const enum index next_table_destroy_attr[] = {
-	TABLE_DESTROY_ID,
-	END,
-	ZERO,
-};
-
-static const enum index next_queue_subcmd[] = {
-	QUEUE_CREATE,
-	QUEUE_DESTROY,
-	QUEUE_AGED,
-	QUEUE_INDIRECT_ACTION,
-	ZERO,
-};
-
-static const enum index next_queue_destroy_attr[] = {
-	QUEUE_DESTROY_ID,
-	END,
-	ZERO,
-};
-
-static const enum index next_qia_subcmd[] = {
-	QUEUE_INDIRECT_ACTION_CREATE,
-	QUEUE_INDIRECT_ACTION_UPDATE,
-	QUEUE_INDIRECT_ACTION_DESTROY,
-	QUEUE_INDIRECT_ACTION_QUERY,
-	ZERO,
-};
-
-static const enum index next_qia_create_attr[] = {
-	QUEUE_INDIRECT_ACTION_CREATE_ID,
-	QUEUE_INDIRECT_ACTION_INGRESS,
-	QUEUE_INDIRECT_ACTION_EGRESS,
-	QUEUE_INDIRECT_ACTION_TRANSFER,
-	QUEUE_INDIRECT_ACTION_CREATE_POSTPONE,
-	QUEUE_INDIRECT_ACTION_SPEC,
-	ZERO,
-};
-
-static const enum index next_qia_update_attr[] = {
-	QUEUE_INDIRECT_ACTION_UPDATE_POSTPONE,
-	QUEUE_INDIRECT_ACTION_SPEC,
-	ZERO,
-};
-
-static const enum index next_qia_destroy_attr[] = {
-	QUEUE_INDIRECT_ACTION_DESTROY_POSTPONE,
-	QUEUE_INDIRECT_ACTION_DESTROY_ID,
-	END,
-	ZERO,
-};
-
-static const enum index next_qia_query_attr[] = {
-	QUEUE_INDIRECT_ACTION_QUERY_POSTPONE,
-	END,
-	ZERO,
-};
-
-static const enum index next_ia_create_attr[] = {
-	INDIRECT_ACTION_CREATE_ID,
-	INDIRECT_ACTION_INGRESS,
-	INDIRECT_ACTION_EGRESS,
-	INDIRECT_ACTION_TRANSFER,
-	INDIRECT_ACTION_SPEC,
-	ZERO,
-};
-
-static const enum index next_dump_subcmd[] = {
-	DUMP_ALL,
-	DUMP_ONE,
-	ZERO,
-};
-
-static const enum index next_ia_subcmd[] = {
-	INDIRECT_ACTION_CREATE,
-	INDIRECT_ACTION_UPDATE,
-	INDIRECT_ACTION_DESTROY,
-	INDIRECT_ACTION_QUERY,
-	ZERO,
-};
-
 static const enum index next_vc_attr[] = {
-	VC_GROUP,
-	VC_PRIORITY,
-	VC_INGRESS,
-	VC_EGRESS,
-	VC_TRANSFER,
-	VC_TUNNEL_SET,
-	VC_TUNNEL_MATCH,
-	ITEM_PATTERN,
+	GROUP,
+	PRIORITY,
+	INGRESS,
+	EGRESS,
+	TRANSFER,
+	PATTERN,
 	ZERO,
 };
 
@@ -1263,30 +685,12 @@
 	ZERO,
 };
 
-static const enum index next_dump_attr[] = {
-	COMMON_FILE_PATH,
-	END,
-	ZERO,
-};
-
 static const enum index next_list_attr[] = {
 	LIST_GROUP,
 	END,
 	ZERO,
 };
 
-static const enum index next_aged_attr[] = {
-	AGED_DESTROY,
-	END,
-	ZERO,
-};
-
-static const enum index next_ia_destroy_attr[] = {
-	INDIRECT_ACTION_DESTROY_ID,
-	END,
-	ZERO,
-};
-
 static const enum index item_param[] = {
 	ITEM_PARAM_IS,
 	ITEM_PARAM_SPEC,
@@ -1301,6 +705,9 @@
 	ITEM_VOID,
 	ITEM_INVERT,
 	ITEM_ANY,
+	ITEM_PF,
+	ITEM_VF,
+	ITEM_PHY_PORT,
 	ITEM_PORT_ID,
 	ITEM_MARK,
 	ITEM_RAW,
@@ -1325,7 +732,6 @@
 	ITEM_VXLAN_GPE,
 	ITEM_ARP_ETH_IPV4,
 	ITEM_IPV6_EXT,
-	ITEM_IPV6_FRAG_EXT,
 	ITEM_ICMP6,
 	ITEM_ICMP6_ND_NS,
 	ITEM_ICMP6_ND_NA,
@@ -1334,27 +740,12 @@
 	ITEM_ICMP6_ND_OPT_TLA_ETH,
 	ITEM_META,
 	ITEM_GRE_KEY,
-	ITEM_GRE_OPTION,
 	ITEM_GTP_PSC,
 	ITEM_PPPOES,
 	ITEM_PPPOED,
 	ITEM_PPPOE_PROTO_ID,
 	ITEM_HIGIG2,
 	ITEM_TAG,
-	ITEM_L2TPV3OIP,
-	ITEM_ESP,
-	ITEM_AH,
-	ITEM_PFCP,
-	ITEM_ECPRI,
-	ITEM_GENEVE_OPT,
-	ITEM_INTEGRITY,
-	ITEM_CONNTRACK,
-	ITEM_PORT_REPRESENTOR,
-	ITEM_REPRESENTED_PORT,
-	ITEM_FLEX,
-	ITEM_L2TPV2,
-	ITEM_PPP,
-	ITEM_METER,
 	END_SET,
 	ZERO,
 };
@@ -1371,6 +762,18 @@
 	ZERO,
 };
 
+static const enum index item_vf[] = {
+	ITEM_VF_ID,
+	ITEM_NEXT,
+	ZERO,
+};
+
+static const enum index item_phy_port[] = {
+	ITEM_PHY_PORT_INDEX,
+	ITEM_NEXT,
+	ZERO,
+};
+
 static const enum index item_port_id[] = {
 	ITEM_PORT_ID_ID,
 	ITEM_NEXT,
@@ -1389,7 +792,6 @@
 	ITEM_RAW_OFFSET,
 	ITEM_RAW_LIMIT,
 	ITEM_RAW_PATTERN,
-	ITEM_RAW_PATTERN_HEX,
 	ITEM_NEXT,
 	ZERO,
 };
@@ -1398,7 +800,6 @@
 	ITEM_ETH_DST,
 	ITEM_ETH_SRC,
 	ITEM_ETH_TYPE,
-	ITEM_ETH_HAS_VLAN,
 	ITEM_NEXT,
 	ZERO,
 };
@@ -1409,16 +810,12 @@
 	ITEM_VLAN_DEI,
 	ITEM_VLAN_VID,
 	ITEM_VLAN_INNER_TYPE,
-	ITEM_VLAN_HAS_MORE_VLAN,
 	ITEM_NEXT,
 	ZERO,
 };
 
 static const enum index item_ipv4[] = {
-	ITEM_IPV4_VER_IHL,
 	ITEM_IPV4_TOS,
-	ITEM_IPV4_ID,
-	ITEM_IPV4_FRAGMENT_OFFSET,
 	ITEM_IPV4_TTL,
 	ITEM_IPV4_PROTO,
 	ITEM_IPV4_SRC,
@@ -1434,7 +831,6 @@
 	ITEM_IPV6_HOP,
 	ITEM_IPV6_SRC,
 	ITEM_IPV6_DST,
-	ITEM_IPV6_HAS_FRAG_EXT,
 	ITEM_NEXT,
 	ZERO,
 };
@@ -1442,8 +838,6 @@
 static const enum index item_icmp[] = {
 	ITEM_ICMP_TYPE,
 	ITEM_ICMP_CODE,
-	ITEM_ICMP_IDENT,
-	ITEM_ICMP_SEQ,
 	ITEM_NEXT,
 	ZERO,
 };
@@ -1474,7 +868,6 @@
 
 static const enum index item_vxlan[] = {
 	ITEM_VXLAN_VNI,
-	ITEM_VXLAN_LAST_RSVD,
 	ITEM_NEXT,
 	ZERO,
 };
@@ -1515,17 +908,7 @@
 	ZERO,
 };
 
-static const enum index item_gre_option[] = {
-	ITEM_GRE_OPTION_CHECKSUM,
-	ITEM_GRE_OPTION_KEY,
-	ITEM_GRE_OPTION_SEQUENCE,
-	ITEM_NEXT,
-	ZERO,
-};
-
 static const enum index item_gtp[] = {
-	ITEM_GTP_FLAGS,
-	ITEM_GTP_MSG_TYPE,
 	ITEM_GTP_TEID,
 	ITEM_NEXT,
 	ZERO,
@@ -1534,7 +917,6 @@
 static const enum index item_geneve[] = {
 	ITEM_GENEVE_VNI,
 	ITEM_GENEVE_PROTO,
-	ITEM_GENEVE_OPTLEN,
 	ITEM_NEXT,
 	ZERO,
 };
@@ -1560,14 +942,6 @@
 	ZERO,
 };
 
-static const enum index item_ipv6_frag_ext[] = {
-	ITEM_IPV6_FRAG_EXT_NEXT_HDR,
-	ITEM_IPV6_FRAG_EXT_FRAG_DATA,
-	ITEM_IPV6_FRAG_EXT_ID,
-	ITEM_NEXT,
-	ZERO,
-};
-
 static const enum index item_icmp6[] = {
 	ITEM_ICMP6_TYPE,
 	ITEM_ICMP6_CODE,
@@ -1631,6 +1005,7 @@
 };
 
 static const enum index item_pppoe_proto_id[] = {
+	ITEM_PPPOE_PROTO_ID,
 	ITEM_NEXT,
 	ZERO,
 };
@@ -1642,25 +1017,6 @@
 	ZERO,
 };
 
-static const enum index item_esp[] = {
-	ITEM_ESP_SPI,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_ah[] = {
-	ITEM_AH_SPI,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_pfcp[] = {
-	ITEM_PFCP_S_FIELD,
-	ITEM_PFCP_SEID,
-	ITEM_NEXT,
-	ZERO,
-};
-
 static const enum index next_set_raw[] = {
 	SET_RAW_INDEX,
 	ITEM_ETH,
@@ -1674,153 +1030,6 @@
 	ZERO,
 };
 
-static const enum index item_l2tpv3oip[] = {
-	ITEM_L2TPV3OIP_SESSION_ID,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_ecpri[] = {
-	ITEM_ECPRI_COMMON,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_ecpri_common[] = {
-	ITEM_ECPRI_COMMON_TYPE,
-	ZERO,
-};
-
-static const enum index item_ecpri_common_type[] = {
-	ITEM_ECPRI_COMMON_TYPE_IQ_DATA,
-	ITEM_ECPRI_COMMON_TYPE_RTC_CTRL,
-	ITEM_ECPRI_COMMON_TYPE_DLY_MSR,
-	ZERO,
-};
-
-static const enum index item_geneve_opt[] = {
-	ITEM_GENEVE_OPT_CLASS,
-	ITEM_GENEVE_OPT_TYPE,
-	ITEM_GENEVE_OPT_LENGTH,
-	ITEM_GENEVE_OPT_DATA,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_integrity[] = {
-	ITEM_INTEGRITY_LEVEL,
-	ITEM_INTEGRITY_VALUE,
-	ZERO,
-};
-
-static const enum index item_integrity_lv[] = {
-	ITEM_INTEGRITY_LEVEL,
-	ITEM_INTEGRITY_VALUE,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_port_representor[] = {
-	ITEM_PORT_REPRESENTOR_PORT_ID,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_represented_port[] = {
-	ITEM_REPRESENTED_PORT_ETHDEV_PORT_ID,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_flex[] = {
-	ITEM_FLEX_PATTERN_HANDLE,
-	ITEM_FLEX_ITEM_HANDLE,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_l2tpv2[] = {
-	ITEM_L2TPV2_TYPE,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_l2tpv2_type[] = {
-	ITEM_L2TPV2_TYPE_DATA,
-	ITEM_L2TPV2_TYPE_DATA_L,
-	ITEM_L2TPV2_TYPE_DATA_S,
-	ITEM_L2TPV2_TYPE_DATA_O,
-	ITEM_L2TPV2_TYPE_DATA_L_S,
-	ITEM_L2TPV2_TYPE_CTRL,
-	ZERO,
-};
-
-static const enum index item_l2tpv2_type_data[] = {
-	ITEM_L2TPV2_MSG_DATA_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_SESSION_ID,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_l2tpv2_type_data_l[] = {
-	ITEM_L2TPV2_MSG_DATA_L_LENGTH,
-	ITEM_L2TPV2_MSG_DATA_L_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_L_SESSION_ID,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_l2tpv2_type_data_s[] = {
-	ITEM_L2TPV2_MSG_DATA_S_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_S_SESSION_ID,
-	ITEM_L2TPV2_MSG_DATA_S_NS,
-	ITEM_L2TPV2_MSG_DATA_S_NR,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_l2tpv2_type_data_o[] = {
-	ITEM_L2TPV2_MSG_DATA_O_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_O_SESSION_ID,
-	ITEM_L2TPV2_MSG_DATA_O_OFFSET,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_l2tpv2_type_data_l_s[] = {
-	ITEM_L2TPV2_MSG_DATA_L_S_LENGTH,
-	ITEM_L2TPV2_MSG_DATA_L_S_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_DATA_L_S_SESSION_ID,
-	ITEM_L2TPV2_MSG_DATA_L_S_NS,
-	ITEM_L2TPV2_MSG_DATA_L_S_NR,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_l2tpv2_type_ctrl[] = {
-	ITEM_L2TPV2_MSG_CTRL_LENGTH,
-	ITEM_L2TPV2_MSG_CTRL_TUNNEL_ID,
-	ITEM_L2TPV2_MSG_CTRL_SESSION_ID,
-	ITEM_L2TPV2_MSG_CTRL_NS,
-	ITEM_L2TPV2_MSG_CTRL_NR,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_ppp[] = {
-	ITEM_PPP_ADDR,
-	ITEM_PPP_CTRL,
-	ITEM_PPP_PROTO_ID,
-	ITEM_NEXT,
-	ZERO,
-};
-
-static const enum index item_meter[] = {
-	ITEM_METER_COLOR,
-	ITEM_NEXT,
-	ZERO,
-};
-
 static const enum index next_action[] = {
 	ACTION_END,
 	ACTION_VOID,
@@ -1834,11 +1043,15 @@
 	ACTION_RSS,
 	ACTION_PF,
 	ACTION_VF,
+	ACTION_PHY_PORT,
 	ACTION_PORT_ID,
 	ACTION_METER,
-	ACTION_METER_COLOR,
-	ACTION_METER_MARK,
+	ACTION_OF_SET_MPLS_TTL,
+	ACTION_OF_DEC_MPLS_TTL,
+	ACTION_OF_SET_NW_TTL,
 	ACTION_OF_DEC_NW_TTL,
+	ACTION_OF_COPY_TTL_OUT,
+	ACTION_OF_COPY_TTL_IN,
 	ACTION_OF_POP_VLAN,
 	ACTION_OF_PUSH_VLAN,
 	ACTION_OF_SET_VLAN_VID,
@@ -1874,18 +1087,6 @@
 	ACTION_RAW_DECAP,
 	ACTION_SET_TAG,
 	ACTION_SET_META,
-	ACTION_SET_IPV4_DSCP,
-	ACTION_SET_IPV6_DSCP,
-	ACTION_AGE,
-	ACTION_AGE_UPDATE,
-	ACTION_SAMPLE,
-	ACTION_INDIRECT,
-	ACTION_MODIFY_FIELD,
-	ACTION_CONNTRACK,
-	ACTION_CONNTRACK_UPDATE,
-	ACTION_PORT_REPRESENTOR,
-	ACTION_REPRESENTED_PORT,
-	ACTION_SEND_TO_KERNEL,
 	ZERO,
 };
 
@@ -1903,6 +1104,7 @@
 
 static const enum index action_count[] = {
 	ACTION_COUNT_ID,
+	ACTION_COUNT_SHARED,
 	ACTION_NEXT,
 	ZERO,
 };
@@ -1925,6 +1127,13 @@
 	ZERO,
 };
 
+static const enum index action_phy_port[] = {
+	ACTION_PHY_PORT_ORIGINAL,
+	ACTION_PHY_PORT_INDEX,
+	ACTION_NEXT,
+	ZERO,
+};
+
 static const enum index action_port_id[] = {
 	ACTION_PORT_ID_ORIGINAL,
 	ACTION_PORT_ID_ID,
@@ -1938,18 +1147,14 @@
 	ZERO,
 };
 
-static const enum index action_meter_color[] = {
-	ACTION_METER_COLOR_TYPE,
+static const enum index action_of_set_mpls_ttl[] = {
+	ACTION_OF_SET_MPLS_TTL_MPLS_TTL,
 	ACTION_NEXT,
 	ZERO,
 };
 
-static const enum index action_meter_mark[] = {
-	ACTION_METER_PROFILE,
-	ACTION_METER_POLICY,
-	ACTION_METER_COLOR_MODE,
-	ACTION_METER_INIT_COLOR,
-	ACTION_METER_STATE,
+static const enum index action_of_set_nw_ttl[] = {
+	ACTION_OF_SET_NW_TTL_NW_TTL,
 	ACTION_NEXT,
 	ZERO,
 };
@@ -2095,101 +1300,12 @@
 	ZERO,
 };
 
-static const enum index action_set_ipv4_dscp[] = {
-	ACTION_SET_IPV4_DSCP_VALUE,
-	ACTION_NEXT,
-	ZERO,
-};
-
-static const enum index action_set_ipv6_dscp[] = {
-	ACTION_SET_IPV6_DSCP_VALUE,
-	ACTION_NEXT,
-	ZERO,
-};
-
-static const enum index action_age[] = {
-	ACTION_AGE,
-	ACTION_AGE_TIMEOUT,
-	ACTION_NEXT,
-	ZERO,
-};
-
-static const enum index action_age_update[] = {
-	ACTION_AGE_UPDATE,
-	ACTION_AGE_UPDATE_TIMEOUT,
-	ACTION_AGE_UPDATE_TOUCH,
-	ACTION_NEXT,
-	ZERO,
-};
-
-static const enum index action_sample[] = {
-	ACTION_SAMPLE,
-	ACTION_SAMPLE_RATIO,
-	ACTION_SAMPLE_INDEX,
-	ACTION_NEXT,
-	ZERO,
-};
-
-static const enum index next_action_sample[] = {
-	ACTION_QUEUE,
-	ACTION_RSS,
-	ACTION_MARK,
-	ACTION_COUNT,
-	ACTION_PORT_ID,
-	ACTION_RAW_ENCAP,
-	ACTION_VXLAN_ENCAP,
-	ACTION_NVGRE_ENCAP,
-	ACTION_NEXT,
-	ZERO,
-};
-
-static const enum index action_modify_field_dst[] = {
-	ACTION_MODIFY_FIELD_DST_LEVEL,
-	ACTION_MODIFY_FIELD_DST_OFFSET,
-	ACTION_MODIFY_FIELD_SRC_TYPE,
-	ZERO,
-};
-
-static const enum index action_modify_field_src[] = {
-	ACTION_MODIFY_FIELD_SRC_LEVEL,
-	ACTION_MODIFY_FIELD_SRC_OFFSET,
-	ACTION_MODIFY_FIELD_SRC_VALUE,
-	ACTION_MODIFY_FIELD_SRC_POINTER,
-	ACTION_MODIFY_FIELD_WIDTH,
-	ZERO,
-};
-
-static const enum index action_update_conntrack[] = {
-	ACTION_CONNTRACK_UPDATE_DIR,
-	ACTION_CONNTRACK_UPDATE_CTX,
-	ACTION_NEXT,
-	ZERO,
-};
-
-static const enum index action_port_representor[] = {
-	ACTION_PORT_REPRESENTOR_PORT_ID,
-	ACTION_NEXT,
-	ZERO,
-};
-
-static const enum index action_represented_port[] = {
-	ACTION_REPRESENTED_PORT_ETHDEV_PORT_ID,
-	ACTION_NEXT,
-	ZERO,
-};
-
 static int parse_set_raw_encap_decap(struct context *, const struct token *,
 				     const char *, unsigned int,
 				     void *, unsigned int);
-static int parse_set_sample_action(struct context *, const struct token *,
-				   const char *, unsigned int,
-				   void *, unsigned int);
 static int parse_set_init(struct context *, const struct token *,
 			  const char *, unsigned int,
 			  void *, unsigned int);
-static int
-parse_flex_handle(struct context *, const struct token *,
-		  const char *, unsigned int, void *, unsigned int);
 static int parse_init(struct context *, const struct token *,
 		      const char *, unsigned int,
 		      void *, unsigned int);
@@ -2200,19 +1316,6 @@
 			 const char *, unsigned int, void *, unsigned int);
 static int parse_vc_conf(struct context *, const struct token *,
 			 const char *, unsigned int, void *, unsigned int);
-static int parse_vc_conf_timeout(struct context *, const struct token *,
-				 const char *, unsigned int, void *,
-				 unsigned int);
-static int parse_vc_item_ecpri_type(struct context *, const struct token *,
-				    const char *, unsigned int,
-				    void *, unsigned int);
-static int parse_vc_item_l2tpv2_type(struct context *, const struct token *,
-				    const char *, unsigned int,
-				    void *, unsigned int);
-static int parse_vc_action_meter_color_type(struct context *,
-					const struct token *,
-					const char *, unsigned int, void *,
-					unsigned int);
 static int parse_vc_action_rss(struct context *, const struct token *,
 			       const char *, unsigned int, void *,
 			       unsigned int);
@@ -2264,36 +1367,13 @@
 static int parse_vc_action_set_meta(struct context *ctx,
 				    const struct token *token, const char *str,
 				    unsigned int len, void *buf,
-					unsigned int size);
-static int parse_vc_action_sample(struct context *ctx,
-				    const struct token *token, const char *str,
-				    unsigned int len, void *buf,
 				    unsigned int size);
-static int
-parse_vc_action_sample_index(struct context *ctx, const struct token *token,
-				const char *str, unsigned int len, void *buf,
-				unsigned int size);
-static int
-parse_vc_modify_field_op(struct context *ctx, const struct token *token,
-				const char *str, unsigned int len, void *buf,
-				unsigned int size);
-static int
-parse_vc_modify_field_id(struct context *ctx, const struct token *token,
-				const char *str, unsigned int len, void *buf,
-				unsigned int size);
-static int
-parse_vc_action_conntrack_update(struct context *ctx, const struct token *token,
-			 const char *str, unsigned int len, void *buf,
-			 unsigned int size);
 static int parse_destroy(struct context *, const struct token *,
 			 const char *, unsigned int,
 			 void *, unsigned int);
 static int parse_flush(struct context *, const struct token *,
 		       const char *, unsigned int,
 		       void *, unsigned int);
-static int parse_dump(struct context *, const struct token *,
-		      const char *, unsigned int,
-		      void *, unsigned int);
 static int parse_query(struct context *, const struct token *,
 		       const char *, unsigned int,
 		       void *, unsigned int);
@@ -2303,49 +1383,9 @@
 static int parse_list(struct context *, const struct token *,
 		      const char *, unsigned int,
 		      void *, unsigned int);
-static int parse_aged(struct context *, const struct token *,
-		      const char *, unsigned int,
-		      void *, unsigned int);
 static int parse_isolate(struct context *, const struct token *,
 			 const char *, unsigned int,
 			 void *, unsigned int);
-static int parse_configure(struct context *, const struct token *,
-			   const char *, unsigned int,
-			   void *, unsigned int);
-static int parse_template(struct context *, const struct token *,
-			  const char *, unsigned int,
-			  void *, unsigned int);
-static int parse_template_destroy(struct context *, const struct token *,
-				  const char *, unsigned int,
-				  void *, unsigned int);
-static int parse_table(struct context *, const struct token *,
-		       const char *, unsigned int, void *, unsigned int);
-static int parse_table_destroy(struct context *, const struct token *,
-			       const char *, unsigned int,
-			       void *, unsigned int);
-static int parse_qo(struct context *, const struct token *,
-		    const char *, unsigned int,
-		    void *, unsigned int);
-static int parse_qo_destroy(struct context *, const struct token *,
-			    const char *, unsigned int,
-			    void *, unsigned int);
-static int parse_qia(struct context *, const struct token *,
-		     const char *, unsigned int,
-		     void *, unsigned int);
-static int parse_qia_destroy(struct context *, const struct token *,
-			     const char *, unsigned int,
-			     void *, unsigned int);
-static int parse_push(struct context *, const struct token *,
-		      const char *, unsigned int,
-		      void *, unsigned int);
-static int parse_pull(struct context *, const struct token *,
-		      const char *, unsigned int,
-		      void *, unsigned int);
-static int parse_tunnel(struct context *, const struct token *,
-			const char *, unsigned int,
-			void *, unsigned int);
-static int parse_flex(struct context *, const struct token *,
-		      const char *, unsigned int, void *, unsigned int);
 static int parse_int(struct context *, const struct token *,
 		     const char *, unsigned int,
 		     void *, unsigned int);
@@ -2361,9 +1401,6 @@
 static int parse_hex(struct context *ctx, const struct token *token,
 			const char *str, unsigned int len,
 			void *buf, unsigned int size);
-static int parse_string0(struct context *, const struct token *,
-			const char *, unsigned int,
-			void *, unsigned int);
 static int parse_mac_addr(struct context *, const struct token *,
 			  const char *, unsigned int,
 			  void *, unsigned int);
@@ -2376,29 +1413,6 @@
 static int parse_port(struct context *, const struct token *,
 		      const char *, unsigned int,
 		      void *, unsigned int);
-static int parse_ia(struct context *, const struct token *,
-		    const char *, unsigned int,
-		    void *, unsigned int);
-static int parse_ia_destroy(struct context *ctx, const struct token *token,
-			    const char *str, unsigned int len,
-			    void *buf, unsigned int size);
-static int parse_ia_id2ptr(struct context *ctx, const struct token *token,
-			   const char *str, unsigned int len, void *buf,
-			   unsigned int size);
-static int parse_mp(struct context *, const struct token *,
-		    const char *, unsigned int,
-		    void *, unsigned int);
-static int parse_meter_profile_id2ptr(struct context *ctx,
-				      const struct token *token,
-				      const char *str, unsigned int len,
-				      void *buf, unsigned int size);
-static int parse_meter_policy_id2ptr(struct context *ctx,
-				     const struct token *token,
-				     const char *str, unsigned int len,
-				     void *buf, unsigned int size);
-static int parse_meter_color(struct context *ctx, const struct token *token,
-			     const char *str, unsigned int len, void *buf,
-			     unsigned int size);
 static int comp_none(struct context *, const struct token *,
 		     unsigned int, char *, unsigned int);
 static int comp_boolean(struct context *, const struct token *,
@@ -2415,22 +1429,6 @@
 				    unsigned int, char *, unsigned int);
 static int comp_set_raw_index(struct context *, const struct token *,
 			      unsigned int, char *, unsigned int);
-static int comp_set_sample_index(struct context *, const struct token *,
-			      unsigned int, char *, unsigned int);
-static int comp_set_modify_field_op(struct context *, const struct token *,
-			      unsigned int, char *, unsigned int);
-static int comp_set_modify_field_id(struct context *, const struct token *,
-			      unsigned int, char *, unsigned int);
-static int comp_pattern_template_id(struct context *, const struct token *,
-				    unsigned int, char *, unsigned int);
-static int comp_actions_template_id(struct context *, const struct token *,
-				    unsigned int, char *, unsigned int);
-static int comp_table_id(struct context *, const struct token *,
-			 unsigned int, char *, unsigned int);
-static int comp_queue_id(struct context *, const struct token *,
-			 unsigned int, char *, unsigned int);
-static int comp_meter_color(struct context *, const struct token *,
-			    unsigned int, char *, unsigned int);
 
 /** Token definitions. */
 static const struct token token_list[] = {
@@ -2438,7 +1436,7 @@
 	[ZERO] = {
 		.name = "ZERO",
 		.help = "null entry, abused as the entry point",
-		.next = NEXT(NEXT_ENTRY(FLOW, ADD)),
+		.next = NEXT(NEXT_ENTRY(FLOW)),
 	},
 	[END] = {
 		.name = "",
@@ -2456,813 +1454,147 @@
 		.help = "set command may end here",
 	},
 	/* Common tokens. */
-	[COMMON_INTEGER] = {
+	[INTEGER] = {
 		.name = "{int}",
 		.type = "INTEGER",
 		.help = "integer value",
 		.call = parse_int,
 		.comp = comp_none,
 	},
-	[COMMON_UNSIGNED] = {
+	[UNSIGNED] = {
 		.name = "{unsigned}",
 		.type = "UNSIGNED",
 		.help = "unsigned integer value",
 		.call = parse_int,
 		.comp = comp_none,
 	},
-	[COMMON_PREFIX] = {
+	[PREFIX] = {
 		.name = "{prefix}",
 		.type = "PREFIX",
 		.help = "prefix length for bit-mask",
 		.call = parse_prefix,
 		.comp = comp_none,
 	},
-	[COMMON_BOOLEAN] = {
+	[BOOLEAN] = {
 		.name = "{boolean}",
 		.type = "BOOLEAN",
 		.help = "any boolean value",
 		.call = parse_boolean,
 		.comp = comp_boolean,
 	},
-	[COMMON_STRING] = {
+	[STRING] = {
 		.name = "{string}",
 		.type = "STRING",
 		.help = "fixed string",
 		.call = parse_string,
 		.comp = comp_none,
 	},
-	[COMMON_HEX] = {
+	[HEX] = {
 		.name = "{hex}",
 		.type = "HEX",
 		.help = "fixed string",
 		.call = parse_hex,
-	},
-	[COMMON_FILE_PATH] = {
-		.name = "{file path}",
-		.type = "STRING",
-		.help = "file path",
-		.call = parse_string0,
 		.comp = comp_none,
 	},
-	[COMMON_MAC_ADDR] = {
+	[MAC_ADDR] = {
 		.name = "{MAC address}",
 		.type = "MAC-48",
 		.help = "standard MAC address notation",
 		.call = parse_mac_addr,
 		.comp = comp_none,
 	},
-	[COMMON_IPV4_ADDR] = {
+	[IPV4_ADDR] = {
 		.name = "{IPv4 address}",
 		.type = "IPV4 ADDRESS",
 		.help = "standard IPv4 address notation",
 		.call = parse_ipv4_addr,
 		.comp = comp_none,
 	},
-	[COMMON_IPV6_ADDR] = {
+	[IPV6_ADDR] = {
 		.name = "{IPv6 address}",
 		.type = "IPV6 ADDRESS",
 		.help = "standard IPv6 address notation",
 		.call = parse_ipv6_addr,
 		.comp = comp_none,
 	},
-	[COMMON_RULE_ID] = {
+	[RULE_ID] = {
 		.name = "{rule id}",
 		.type = "RULE ID",
 		.help = "rule identifier",
 		.call = parse_int,
 		.comp = comp_rule_id,
 	},
-	[COMMON_PORT_ID] = {
+	[PORT_ID] = {
 		.name = "{port_id}",
 		.type = "PORT ID",
 		.help = "port identifier",
 		.call = parse_port,
 		.comp = comp_port,
 	},
-	[COMMON_GROUP_ID] = {
+	[GROUP_ID] = {
 		.name = "{group_id}",
 		.type = "GROUP ID",
 		.help = "group identifier",
 		.call = parse_int,
 		.comp = comp_none,
 	},
-	[COMMON_PRIORITY_LEVEL] = {
+	[PRIORITY_LEVEL] = {
 		.name = "{level}",
 		.type = "PRIORITY",
 		.help = "priority level",
 		.call = parse_int,
 		.comp = comp_none,
 	},
-	[COMMON_INDIRECT_ACTION_ID] = {
-		.name = "{indirect_action_id}",
-		.type = "INDIRECT_ACTION_ID",
-		.help = "indirect action id",
-		.call = parse_int,
-		.comp = comp_none,
-	},
-	[COMMON_PROFILE_ID] = {
-		.name = "{profile_id}",
-		.type = "PROFILE_ID",
-		.help = "profile id",
-		.call = parse_int,
-		.comp = comp_none,
-	},
-	[COMMON_POLICY_ID] = {
-		.name = "{policy_id}",
-		.type = "POLICY_ID",
-		.help = "policy id",
-		.call = parse_int,
-		.comp = comp_none,
-	},
-	[COMMON_FLEX_TOKEN] = {
-		.name = "{flex token}",
-		.type = "flex token",
-		.help = "flex token",
-		.call = parse_int,
-		.comp = comp_none,
-	},
-	[COMMON_FLEX_HANDLE] = {
-		.name = "{flex handle}",
-		.type = "FLEX HANDLE",
-		.help = "fill flex item data",
-		.call = parse_flex_handle,
-		.comp = comp_none,
-	},
-	[COMMON_PATTERN_TEMPLATE_ID] = {
-		.name = "{pattern_template_id}",
-		.type = "PATTERN_TEMPLATE_ID",
-		.help = "pattern template id",
-		.call = parse_int,
-		.comp = comp_pattern_template_id,
-	},
-	[COMMON_ACTIONS_TEMPLATE_ID] = {
-		.name = "{actions_template_id}",
-		.type = "ACTIONS_TEMPLATE_ID",
-		.help = "actions template id",
-		.call = parse_int,
-		.comp = comp_actions_template_id,
-	},
-	[COMMON_TABLE_ID] = {
-		.name = "{table_id}",
-		.type = "TABLE_ID",
-		.help = "table id",
-		.call = parse_int,
-		.comp = comp_table_id,
-	},
-	[COMMON_QUEUE_ID] = {
-		.name = "{queue_id}",
-		.type = "QUEUE_ID",
-		.help = "queue id",
-		.call = parse_int,
-		.comp = comp_queue_id,
-	},
 	/* Top-level command. */
 	[FLOW] = {
 		.name = "flow",
 		.type = "{command} {port_id} [{arg} [...]]",
 		.help = "manage ingress/egress flow rules",
 		.next = NEXT(NEXT_ENTRY
-			     (INFO,
-			      CONFIGURE,
-			      PATTERN_TEMPLATE,
-			      ACTIONS_TEMPLATE,
-			      TABLE,
-			      INDIRECT_ACTION,
-			      VALIDATE,
+			     (VALIDATE,
 			      CREATE,
 			      DESTROY,
 			      FLUSH,
-			      DUMP,
 			      LIST,
-			      AGED,
 			      QUERY,
-			      ISOLATE,
-			      TUNNEL,
-			      FLEX,
-			      QUEUE,
-			      PUSH,
-			      PULL)),
+			      ISOLATE)),
 		.call = parse_init,
 	},
-	/* Top-level command. */
-	[INFO] = {
-		.name = "info",
-		.help = "get information about flow engine",
-		.next = NEXT(NEXT_ENTRY(END),
-			     NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_configure,
-	},
-	/* Top-level command. */
-	[CONFIGURE] = {
-		.name = "configure",
-		.help = "configure flow engine",
-		.next = NEXT(next_config_attr,
-			     NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_configure,
-	},
-	/* Configure arguments. */
-	[CONFIG_QUEUES_NUMBER] = {
-		.name = "queues_number",
-		.help = "number of queues",
-		.next = NEXT(next_config_attr,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.configure.nb_queue)),
-	},
-	[CONFIG_QUEUES_SIZE] = {
-		.name = "queues_size",
-		.help = "number of elements in queues",
-		.next = NEXT(next_config_attr,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.configure.queue_attr.size)),
-	},
-	[CONFIG_COUNTERS_NUMBER] = {
-		.name = "counters_number",
-		.help = "number of counters",
-		.next = NEXT(next_config_attr,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.configure.port_attr.nb_counters)),
-	},
-	[CONFIG_AGING_OBJECTS_NUMBER] = {
-		.name = "aging_counters_number",
-		.help = "number of aging objects",
-		.next = NEXT(next_config_attr,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.configure.port_attr.nb_aging_objects)),
-	},
-	[CONFIG_METERS_NUMBER] = {
-		.name = "meters_number",
-		.help = "number of meters",
-		.next = NEXT(next_config_attr,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.configure.port_attr.nb_meters)),
-	},
-	[CONFIG_CONN_TRACK_NUMBER] = {
-		.name = "conn_tracks_number",
-		.help = "number of connection trackings",
-		.next = NEXT(next_config_attr,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.configure.port_attr.nb_conn_tracks)),
-	},
-	[CONFIG_FLAGS] = {
-		.name = "flags",
-		.help = "configuration flags",
-		.next = NEXT(next_config_attr,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.configure.port_attr.flags)),
-	},
-	/* Top-level command. */
-	[PATTERN_TEMPLATE] = {
-		.name = "pattern_template",
-		.type = "{command} {port_id} [{arg} [...]]",
-		.help = "manage pattern templates",
-		.next = NEXT(next_pt_subcmd, NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_template,
-	},
-	/* Sub-level commands. */
-	[PATTERN_TEMPLATE_CREATE] = {
-		.name = "create",
-		.help = "create pattern template",
-		.next = NEXT(next_pt_attr),
-		.call = parse_template,
-	},
-	[PATTERN_TEMPLATE_DESTROY] = {
-		.name = "destroy",
-		.help = "destroy pattern template",
-		.next = NEXT(NEXT_ENTRY(PATTERN_TEMPLATE_DESTROY_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_template_destroy,
-	},
-	/* Pattern template arguments. */
-	[PATTERN_TEMPLATE_CREATE_ID] = {
-		.name = "pattern_template_id",
-		.help = "specify a pattern template id to create",
-		.next = NEXT(next_pt_attr,
-			     NEXT_ENTRY(COMMON_PATTERN_TEMPLATE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.vc.pat_templ_id)),
-	},
-	[PATTERN_TEMPLATE_DESTROY_ID] = {
-		.name = "pattern_template",
-		.help = "specify a pattern template id to destroy",
-		.next = NEXT(next_pt_destroy_attr,
-			     NEXT_ENTRY(COMMON_PATTERN_TEMPLATE_ID)),
-		.args = ARGS(ARGS_ENTRY_PTR(struct buffer,
-					    args.templ_destroy.template_id)),
-		.call = parse_template_destroy,
-	},
-	[PATTERN_TEMPLATE_RELAXED_MATCHING] = {
-		.name = "relaxed",
-		.help = "is matching relaxed",
-		.next = NEXT(next_pt_attr,
-			     NEXT_ENTRY(COMMON_BOOLEAN)),
-		.args = ARGS(ARGS_ENTRY_BF(struct buffer,
-			     args.vc.attr.reserved, 1)),
-	},
-	[PATTERN_TEMPLATE_INGRESS] = {
-		.name = "ingress",
-		.help = "attribute pattern to ingress",
-		.next = NEXT(next_pt_attr),
-		.call = parse_template,
-	},
-	[PATTERN_TEMPLATE_EGRESS] = {
-		.name = "egress",
-		.help = "attribute pattern to egress",
-		.next = NEXT(next_pt_attr),
-		.call = parse_template,
-	},
-	[PATTERN_TEMPLATE_TRANSFER] = {
-		.name = "transfer",
-		.help = "attribute pattern to transfer",
-		.next = NEXT(next_pt_attr),
-		.call = parse_template,
-	},
-	[PATTERN_TEMPLATE_SPEC] = {
-		.name = "template",
-		.help = "specify item to create pattern template",
-		.next = NEXT(next_item),
-	},
-	/* Top-level command. */
-	[ACTIONS_TEMPLATE] = {
-		.name = "actions_template",
-		.type = "{command} {port_id} [{arg} [...]]",
-		.help = "manage actions templates",
-		.next = NEXT(next_at_subcmd, NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_template,
-	},
-	/* Sub-level commands. */
-	[ACTIONS_TEMPLATE_CREATE] = {
-		.name = "create",
-		.help = "create actions template",
-		.next = NEXT(next_at_attr),
-		.call = parse_template,
-	},
-	[ACTIONS_TEMPLATE_DESTROY] = {
-		.name = "destroy",
-		.help = "destroy actions template",
-		.next = NEXT(NEXT_ENTRY(ACTIONS_TEMPLATE_DESTROY_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_template_destroy,
-	},
-	/* Actions template arguments. */
-	[ACTIONS_TEMPLATE_CREATE_ID] = {
-		.name = "actions_template_id",
-		.help = "specify an actions template id to create",
-		.next = NEXT(NEXT_ENTRY(ACTIONS_TEMPLATE_MASK),
-			     NEXT_ENTRY(ACTIONS_TEMPLATE_SPEC),
-			     NEXT_ENTRY(COMMON_ACTIONS_TEMPLATE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.vc.act_templ_id)),
-	},
-	[ACTIONS_TEMPLATE_DESTROY_ID] = {
-		.name = "actions_template",
-		.help = "specify an actions template id to destroy",
-		.next = NEXT(next_at_destroy_attr,
-			     NEXT_ENTRY(COMMON_ACTIONS_TEMPLATE_ID)),
-		.args = ARGS(ARGS_ENTRY_PTR(struct buffer,
-					    args.templ_destroy.template_id)),
-		.call = parse_template_destroy,
-	},
-	[ACTIONS_TEMPLATE_INGRESS] = {
-		.name = "ingress",
-		.help = "attribute actions to ingress",
-		.next = NEXT(next_at_attr),
-		.call = parse_template,
-	},
-	[ACTIONS_TEMPLATE_EGRESS] = {
-		.name = "egress",
-		.help = "attribute actions to egress",
-		.next = NEXT(next_at_attr),
-		.call = parse_template,
-	},
-	[ACTIONS_TEMPLATE_TRANSFER] = {
-		.name = "transfer",
-		.help = "attribute actions to transfer",
-		.next = NEXT(next_at_attr),
-		.call = parse_template,
-	},
-	[ACTIONS_TEMPLATE_SPEC] = {
-		.name = "template",
-		.help = "specify action to create actions template",
-		.next = NEXT(next_action),
-		.call = parse_template,
-	},
-	[ACTIONS_TEMPLATE_MASK] = {
-		.name = "mask",
-		.help = "specify action mask to create actions template",
-		.next = NEXT(next_action),
-		.call = parse_template,
-	},
-	/* Top-level command. */
-	[TABLE] = {
-		.name = "template_table",
-		.type = "{command} {port_id} [{arg} [...]]",
-		.help = "manage template tables",
-		.next = NEXT(next_table_subcmd, NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_table,
-	},
-	/* Sub-level commands. */
-	[TABLE_CREATE] = {
-		.name = "create",
-		.help = "create template table",
-		.next = NEXT(next_table_attr),
-		.call = parse_table,
-	},
-	[TABLE_DESTROY] = {
-		.name = "destroy",
-		.help = "destroy template table",
-		.next = NEXT(NEXT_ENTRY(TABLE_DESTROY_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_table_destroy,
-	},
-	/* Table  arguments. */
-	[TABLE_CREATE_ID] = {
-		.name = "table_id",
-		.help = "specify table id to create",
-		.next = NEXT(next_table_attr,
-			     NEXT_ENTRY(COMMON_TABLE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.table.id)),
-	},
-	[TABLE_DESTROY_ID] = {
-		.name = "table",
-		.help = "specify table id to destroy",
-		.next = NEXT(next_table_destroy_attr,
-			     NEXT_ENTRY(COMMON_TABLE_ID)),
-		.args = ARGS(ARGS_ENTRY_PTR(struct buffer,
-					    args.table_destroy.table_id)),
-		.call = parse_table_destroy,
-	},
-	[TABLE_GROUP] = {
-		.name = "group",
-		.help = "specify a group",
-		.next = NEXT(next_table_attr, NEXT_ENTRY(COMMON_GROUP_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.table.attr.flow_attr.group)),
-	},
-	[TABLE_PRIORITY] = {
-		.name = "priority",
-		.help = "specify a priority level",
-		.next = NEXT(next_table_attr, NEXT_ENTRY(COMMON_PRIORITY_LEVEL)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.table.attr.flow_attr.priority)),
-	},
-	[TABLE_EGRESS] = {
-		.name = "egress",
-		.help = "affect rule to egress",
-		.next = NEXT(next_table_attr),
-		.call = parse_table,
-	},
-	[TABLE_INGRESS] = {
-		.name = "ingress",
-		.help = "affect rule to ingress",
-		.next = NEXT(next_table_attr),
-		.call = parse_table,
-	},
-	[TABLE_TRANSFER] = {
-		.name = "transfer",
-		.help = "affect rule to transfer",
-		.next = NEXT(next_table_attr),
-		.call = parse_table,
-	},
-	[TABLE_RULES_NUMBER] = {
-		.name = "rules_number",
-		.help = "number of rules in table",
-		.next = NEXT(next_table_attr,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.table.attr.nb_flows)),
-		.call = parse_table,
-	},
-	[TABLE_PATTERN_TEMPLATE] = {
-		.name = "pattern_template",
-		.help = "specify pattern template id",
-		.next = NEXT(next_table_attr,
-			     NEXT_ENTRY(COMMON_PATTERN_TEMPLATE_ID)),
-		.args = ARGS(ARGS_ENTRY_PTR(struct buffer,
-					    args.table.pat_templ_id)),
-		.call = parse_table,
-	},
-	[TABLE_ACTIONS_TEMPLATE] = {
-		.name = "actions_template",
-		.help = "specify actions template id",
-		.next = NEXT(next_table_attr,
-			     NEXT_ENTRY(COMMON_ACTIONS_TEMPLATE_ID)),
-		.args = ARGS(ARGS_ENTRY_PTR(struct buffer,
-					    args.table.act_templ_id)),
-		.call = parse_table,
-	},
-	/* Top-level command. */
-	[QUEUE] = {
-		.name = "queue",
-		.help = "queue a flow rule operation",
-		.next = NEXT(next_queue_subcmd, NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_qo,
-	},
 	/* Sub-level commands. */
-	[QUEUE_CREATE] = {
-		.name = "create",
-		.help = "create a flow rule",
-		.next = NEXT(NEXT_ENTRY(QUEUE_TEMPLATE_TABLE),
-			     NEXT_ENTRY(COMMON_QUEUE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, queue)),
-		.call = parse_qo,
-	},
-	[QUEUE_DESTROY] = {
-		.name = "destroy",
-		.help = "destroy a flow rule",
-		.next = NEXT(NEXT_ENTRY(QUEUE_DESTROY_ID),
-			     NEXT_ENTRY(COMMON_QUEUE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, queue)),
-		.call = parse_qo_destroy,
-	},
-	[QUEUE_AGED] = {
-		.name = "aged",
-		.help = "list and destroy aged flows",
-		.next = NEXT(next_aged_attr, NEXT_ENTRY(COMMON_QUEUE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, queue)),
-		.call = parse_aged,
-	},
-	[QUEUE_INDIRECT_ACTION] = {
-		.name = "indirect_action",
-		.help = "queue indirect actions",
-		.next = NEXT(next_qia_subcmd, NEXT_ENTRY(COMMON_QUEUE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, queue)),
-		.call = parse_qia,
-	},
-	/* Queue  arguments. */
-	[QUEUE_TEMPLATE_TABLE] = {
-		.name = "template_table",
-		.help = "specify table id",
-		.next = NEXT(NEXT_ENTRY(QUEUE_PATTERN_TEMPLATE),
-			     NEXT_ENTRY(COMMON_TABLE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.vc.table_id)),
-		.call = parse_qo,
-	},
-	[QUEUE_PATTERN_TEMPLATE] = {
-		.name = "pattern_template",
-		.help = "specify pattern template index",
-		.next = NEXT(NEXT_ENTRY(QUEUE_ACTIONS_TEMPLATE),
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.vc.pat_templ_id)),
-		.call = parse_qo,
-	},
-	[QUEUE_ACTIONS_TEMPLATE] = {
-		.name = "actions_template",
-		.help = "specify actions template index",
-		.next = NEXT(NEXT_ENTRY(QUEUE_CREATE_POSTPONE),
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct buffer,
-					args.vc.act_templ_id)),
-		.call = parse_qo,
-	},
-	[QUEUE_CREATE_POSTPONE] = {
-		.name = "postpone",
-		.help = "postpone create operation",
-		.next = NEXT(NEXT_ENTRY(ITEM_PATTERN),
-			     NEXT_ENTRY(COMMON_BOOLEAN)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, postpone)),
-		.call = parse_qo,
-	},
-	[QUEUE_DESTROY_POSTPONE] = {
-		.name = "postpone",
-		.help = "postpone destroy operation",
-		.next = NEXT(NEXT_ENTRY(QUEUE_DESTROY_ID),
-			     NEXT_ENTRY(COMMON_BOOLEAN)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, postpone)),
-		.call = parse_qo_destroy,
-	},
-	[QUEUE_DESTROY_ID] = {
-		.name = "rule",
-		.help = "specify rule id to destroy",
-		.next = NEXT(next_queue_destroy_attr,
-			NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY_PTR(struct buffer,
-					    args.destroy.rule)),
-		.call = parse_qo_destroy,
-	},
-	/* Queue indirect action arguments */
-	[QUEUE_INDIRECT_ACTION_CREATE] = {
-		.name = "create",
-		.help = "create indirect action",
-		.next = NEXT(next_qia_create_attr),
-		.call = parse_qia,
-	},
-	[QUEUE_INDIRECT_ACTION_UPDATE] = {
-		.name = "update",
-		.help = "update indirect action",
-		.next = NEXT(next_qia_update_attr,
-			     NEXT_ENTRY(COMMON_INDIRECT_ACTION_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.vc.attr.group)),
-		.call = parse_qia,
-	},
-	[QUEUE_INDIRECT_ACTION_DESTROY] = {
-		.name = "destroy",
-		.help = "destroy indirect action",
-		.next = NEXT(next_qia_destroy_attr),
-		.call = parse_qia_destroy,
-	},
-	[QUEUE_INDIRECT_ACTION_QUERY] = {
-		.name = "query",
-		.help = "query indirect action",
-		.next = NEXT(next_qia_query_attr,
-			     NEXT_ENTRY(COMMON_INDIRECT_ACTION_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.vc.attr.group)),
-		.call = parse_qia,
-	},
-	/* Indirect action destroy arguments. */
-	[QUEUE_INDIRECT_ACTION_DESTROY_POSTPONE] = {
-		.name = "postpone",
-		.help = "postpone destroy operation",
-		.next = NEXT(next_qia_destroy_attr,
-			     NEXT_ENTRY(COMMON_BOOLEAN)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, postpone)),
-	},
-	[QUEUE_INDIRECT_ACTION_DESTROY_ID] = {
-		.name = "action_id",
-		.help = "specify a indirect action id to destroy",
-		.next = NEXT(next_qia_destroy_attr,
-			     NEXT_ENTRY(COMMON_INDIRECT_ACTION_ID)),
-		.args = ARGS(ARGS_ENTRY_PTR(struct buffer,
-					    args.ia_destroy.action_id)),
-		.call = parse_qia_destroy,
-	},
-	/* Indirect action update arguments. */
-	[QUEUE_INDIRECT_ACTION_UPDATE_POSTPONE] = {
-		.name = "postpone",
-		.help = "postpone update operation",
-		.next = NEXT(next_qia_update_attr,
-			     NEXT_ENTRY(COMMON_BOOLEAN)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, postpone)),
-	},
-	/* Indirect action update arguments. */
-	[QUEUE_INDIRECT_ACTION_QUERY_POSTPONE] = {
-		.name = "postpone",
-		.help = "postpone query operation",
-		.next = NEXT(next_qia_query_attr,
-			     NEXT_ENTRY(COMMON_BOOLEAN)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, postpone)),
-	},
-	/* Indirect action create arguments. */
-	[QUEUE_INDIRECT_ACTION_CREATE_ID] = {
-		.name = "action_id",
-		.help = "specify a indirect action id to create",
-		.next = NEXT(next_qia_create_attr,
-			     NEXT_ENTRY(COMMON_INDIRECT_ACTION_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.vc.attr.group)),
-	},
-	[QUEUE_INDIRECT_ACTION_INGRESS] = {
-		.name = "ingress",
-		.help = "affect rule to ingress",
-		.next = NEXT(next_qia_create_attr),
-		.call = parse_qia,
-	},
-	[QUEUE_INDIRECT_ACTION_EGRESS] = {
-		.name = "egress",
-		.help = "affect rule to egress",
-		.next = NEXT(next_qia_create_attr),
-		.call = parse_qia,
-	},
-	[QUEUE_INDIRECT_ACTION_TRANSFER] = {
-		.name = "transfer",
-		.help = "affect rule to transfer",
-		.next = NEXT(next_qia_create_attr),
-		.call = parse_qia,
-	},
-	[QUEUE_INDIRECT_ACTION_CREATE_POSTPONE] = {
-		.name = "postpone",
-		.help = "postpone create operation",
-		.next = NEXT(next_qia_create_attr,
-			     NEXT_ENTRY(COMMON_BOOLEAN)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, postpone)),
-	},
-	[QUEUE_INDIRECT_ACTION_SPEC] = {
-		.name = "action",
-		.help = "specify action to create indirect handle",
-		.next = NEXT(next_action),
-	},
-	/* Top-level command. */
-	[PUSH] = {
-		.name = "push",
-		.help = "push enqueued operations",
-		.next = NEXT(NEXT_ENTRY(PUSH_QUEUE), NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_push,
-	},
-	/* Sub-level commands. */
-	[PUSH_QUEUE] = {
-		.name = "queue",
-		.help = "specify queue id",
-		.next = NEXT(NEXT_ENTRY(END), NEXT_ENTRY(COMMON_QUEUE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, queue)),
-	},
-	/* Top-level command. */
-	[PULL] = {
-		.name = "pull",
-		.help = "pull flow operations results",
-		.next = NEXT(NEXT_ENTRY(PULL_QUEUE), NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_pull,
-	},
-	/* Sub-level commands. */
-	[PULL_QUEUE] = {
-		.name = "queue",
-		.help = "specify queue id",
-		.next = NEXT(NEXT_ENTRY(END), NEXT_ENTRY(COMMON_QUEUE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, queue)),
-	},
-	/* Top-level command. */
-	[INDIRECT_ACTION] = {
-		.name = "indirect_action",
-		.type = "{command} {port_id} [{arg} [...]]",
-		.help = "manage indirect actions",
-		.next = NEXT(next_ia_subcmd, NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_ia,
-	},
-	/* Sub-level commands. */
-	[INDIRECT_ACTION_CREATE] = {
-		.name = "create",
-		.help = "create indirect action",
-		.next = NEXT(next_ia_create_attr),
-		.call = parse_ia,
-	},
-	[INDIRECT_ACTION_UPDATE] = {
-		.name = "update",
-		.help = "update indirect action",
-		.next = NEXT(NEXT_ENTRY(INDIRECT_ACTION_SPEC),
-			     NEXT_ENTRY(COMMON_INDIRECT_ACTION_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.vc.attr.group)),
-		.call = parse_ia,
-	},
-	[INDIRECT_ACTION_DESTROY] = {
-		.name = "destroy",
-		.help = "destroy indirect action",
-		.next = NEXT(NEXT_ENTRY(INDIRECT_ACTION_DESTROY_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_ia_destroy,
-	},
-	[INDIRECT_ACTION_QUERY] = {
-		.name = "query",
-		.help = "query indirect action",
-		.next = NEXT(NEXT_ENTRY(END),
-			     NEXT_ENTRY(COMMON_INDIRECT_ACTION_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.ia.action_id)),
-		.call = parse_ia,
-	},
 	[VALIDATE] = {
 		.name = "validate",
 		.help = "check whether a flow rule can be created",
-		.next = NEXT(next_vc_attr, NEXT_ENTRY(COMMON_PORT_ID)),
+		.next = NEXT(next_vc_attr, NEXT_ENTRY(PORT_ID)),
 		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
 		.call = parse_vc,
 	},
 	[CREATE] = {
 		.name = "create",
 		.help = "create a flow rule",
-		.next = NEXT(next_vc_attr, NEXT_ENTRY(COMMON_PORT_ID)),
+		.next = NEXT(next_vc_attr, NEXT_ENTRY(PORT_ID)),
 		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
 		.call = parse_vc,
 	},
 	[DESTROY] = {
 		.name = "destroy",
 		.help = "destroy specific flow rules",
-		.next = NEXT(NEXT_ENTRY(DESTROY_RULE),
-			     NEXT_ENTRY(COMMON_PORT_ID)),
+		.next = NEXT(NEXT_ENTRY(DESTROY_RULE), NEXT_ENTRY(PORT_ID)),
 		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
 		.call = parse_destroy,
 	},
 	[FLUSH] = {
 		.name = "flush",
 		.help = "destroy all flow rules",
-		.next = NEXT(NEXT_ENTRY(COMMON_PORT_ID)),
+		.next = NEXT(NEXT_ENTRY(PORT_ID)),
 		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
 		.call = parse_flush,
 	},
-	[DUMP] = {
-		.name = "dump",
-		.help = "dump single/all flow rules to file",
-		.next = NEXT(next_dump_subcmd, NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_dump,
-	},
 	[QUERY] = {
 		.name = "query",
 		.help = "query an existing flow rule",
 		.next = NEXT(NEXT_ENTRY(QUERY_ACTION),
-			     NEXT_ENTRY(COMMON_RULE_ID),
-			     NEXT_ENTRY(COMMON_PORT_ID)),
+			     NEXT_ENTRY(RULE_ID),
+			     NEXT_ENTRY(PORT_ID)),
 		.args = ARGS(ARGS_ENTRY(struct buffer, args.query.action.type),
 			     ARGS_ENTRY(struct buffer, args.query.rule),
 			     ARGS_ENTRY(struct buffer, port)),
@@ -3271,130 +1603,27 @@
 	[LIST] = {
 		.name = "list",
 		.help = "list existing flow rules",
-		.next = NEXT(next_list_attr, NEXT_ENTRY(COMMON_PORT_ID)),
+		.next = NEXT(next_list_attr, NEXT_ENTRY(PORT_ID)),
 		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
 		.call = parse_list,
 	},
-	[AGED] = {
-		.name = "aged",
-		.help = "list and destroy aged flows",
-		.next = NEXT(next_aged_attr, NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_aged,
-	},
 	[ISOLATE] = {
 		.name = "isolate",
 		.help = "restrict ingress traffic to the defined flow rules",
-		.next = NEXT(NEXT_ENTRY(COMMON_BOOLEAN),
-			     NEXT_ENTRY(COMMON_PORT_ID)),
+		.next = NEXT(NEXT_ENTRY(BOOLEAN),
+			     NEXT_ENTRY(PORT_ID)),
 		.args = ARGS(ARGS_ENTRY(struct buffer, args.isolate.set),
 			     ARGS_ENTRY(struct buffer, port)),
 		.call = parse_isolate,
 	},
-	[FLEX] = {
-		.name = "flex_item",
-		.help = "flex item API",
-		.next = NEXT(next_flex_item),
-		.call = parse_flex,
-	},
-	[FLEX_ITEM_INIT] = {
-		.name = "init",
-		.help = "flex item init",
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.flex.token),
-			     ARGS_ENTRY(struct buffer, port)),
-		.next = NEXT(NEXT_ENTRY(COMMON_FLEX_TOKEN),
-			     NEXT_ENTRY(COMMON_PORT_ID)),
-		.call = parse_flex
-	},
-	[FLEX_ITEM_CREATE] = {
-		.name = "create",
-		.help = "flex item create",
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.flex.filename),
-			     ARGS_ENTRY(struct buffer, args.flex.token),
-			     ARGS_ENTRY(struct buffer, port)),
-		.next = NEXT(NEXT_ENTRY(COMMON_FILE_PATH),
-			     NEXT_ENTRY(COMMON_FLEX_TOKEN),
-			     NEXT_ENTRY(COMMON_PORT_ID)),
-		.call = parse_flex
-	},
-	[FLEX_ITEM_DESTROY] = {
-		.name = "destroy",
-		.help = "flex item destroy",
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.flex.token),
-			     ARGS_ENTRY(struct buffer, port)),
-		.next = NEXT(NEXT_ENTRY(COMMON_FLEX_TOKEN),
-			     NEXT_ENTRY(COMMON_PORT_ID)),
-		.call = parse_flex
-	},
-	[TUNNEL] = {
-		.name = "tunnel",
-		.help = "new tunnel API",
-		.next = NEXT(NEXT_ENTRY
-			     (TUNNEL_CREATE, TUNNEL_LIST, TUNNEL_DESTROY)),
-		.call = parse_tunnel,
-	},
-	/* Tunnel arguments. */
-	[TUNNEL_CREATE] = {
-		.name = "create",
-		.help = "create new tunnel object",
-		.next = NEXT(NEXT_ENTRY(TUNNEL_CREATE_TYPE),
-			     NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_tunnel,
-	},
-	[TUNNEL_CREATE_TYPE] = {
-		.name = "type",
-		.help = "create new tunnel",
-		.next = NEXT(NEXT_ENTRY(COMMON_FILE_PATH)),
-		.args = ARGS(ARGS_ENTRY(struct tunnel_ops, type)),
-		.call = parse_tunnel,
-	},
-	[TUNNEL_DESTROY] = {
-		.name = "destroy",
-		.help = "destroy tunnel",
-		.next = NEXT(NEXT_ENTRY(TUNNEL_DESTROY_ID),
-			     NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_tunnel,
-	},
-	[TUNNEL_DESTROY_ID] = {
-		.name = "id",
-		.help = "tunnel identifier to destroy",
-		.next = NEXT(NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct tunnel_ops, id)),
-		.call = parse_tunnel,
-	},
-	[TUNNEL_LIST] = {
-		.name = "list",
-		.help = "list existing tunnels",
-		.next = NEXT(NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, port)),
-		.call = parse_tunnel,
-	},
 	/* Destroy arguments. */
 	[DESTROY_RULE] = {
 		.name = "rule",
 		.help = "specify a rule identifier",
-		.next = NEXT(next_destroy_attr, NEXT_ENTRY(COMMON_RULE_ID)),
+		.next = NEXT(next_destroy_attr, NEXT_ENTRY(RULE_ID)),
 		.args = ARGS(ARGS_ENTRY_PTR(struct buffer, args.destroy.rule)),
 		.call = parse_destroy,
 	},
-	/* Dump arguments. */
-	[DUMP_ALL] = {
-		.name = "all",
-		.help = "dump all",
-		.next = NEXT(next_dump_attr),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.dump.file)),
-		.call = parse_dump,
-	},
-	[DUMP_ONE] = {
-		.name = "rule",
-		.help = "dump one rule",
-		.next = NEXT(next_dump_attr, NEXT_ENTRY(COMMON_RULE_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.dump.file),
-				ARGS_ENTRY(struct buffer, args.dump.rule)),
-		.call = parse_dump,
-	},
 	/* Query arguments. */
 	[QUERY_ACTION] = {
 		.name = "{action}",
@@ -3407,65 +1636,45 @@
 	[LIST_GROUP] = {
 		.name = "group",
 		.help = "specify a group",
-		.next = NEXT(next_list_attr, NEXT_ENTRY(COMMON_GROUP_ID)),
+		.next = NEXT(next_list_attr, NEXT_ENTRY(GROUP_ID)),
 		.args = ARGS(ARGS_ENTRY_PTR(struct buffer, args.list.group)),
 		.call = parse_list,
 	},
-	[AGED_DESTROY] = {
-		.name = "destroy",
-		.help = "specify aged flows need be destroyed",
-		.call = parse_aged,
-		.comp = comp_none,
-	},
 	/* Validate/create attributes. */
-	[VC_GROUP] = {
+	[GROUP] = {
 		.name = "group",
 		.help = "specify a group",
-		.next = NEXT(next_vc_attr, NEXT_ENTRY(COMMON_GROUP_ID)),
+		.next = NEXT(next_vc_attr, NEXT_ENTRY(GROUP_ID)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_attr, group)),
 		.call = parse_vc,
 	},
-	[VC_PRIORITY] = {
+	[PRIORITY] = {
 		.name = "priority",
 		.help = "specify a priority level",
-		.next = NEXT(next_vc_attr, NEXT_ENTRY(COMMON_PRIORITY_LEVEL)),
+		.next = NEXT(next_vc_attr, NEXT_ENTRY(PRIORITY_LEVEL)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_attr, priority)),
 		.call = parse_vc,
 	},
-	[VC_INGRESS] = {
+	[INGRESS] = {
 		.name = "ingress",
 		.help = "affect rule to ingress",
 		.next = NEXT(next_vc_attr),
 		.call = parse_vc,
 	},
-	[VC_EGRESS] = {
+	[EGRESS] = {
 		.name = "egress",
 		.help = "affect rule to egress",
 		.next = NEXT(next_vc_attr),
 		.call = parse_vc,
 	},
-	[VC_TRANSFER] = {
+	[TRANSFER] = {
 		.name = "transfer",
 		.help = "apply rule directly to endpoints found in pattern",
 		.next = NEXT(next_vc_attr),
 		.call = parse_vc,
 	},
-	[VC_TUNNEL_SET] = {
-		.name = "tunnel_set",
-		.help = "tunnel steer rule",
-		.next = NEXT(next_vc_attr, NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct tunnel_ops, id)),
-		.call = parse_vc,
-	},
-	[VC_TUNNEL_MATCH] = {
-		.name = "tunnel_match",
-		.help = "tunnel match rule",
-		.next = NEXT(next_vc_attr, NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct tunnel_ops, id)),
-		.call = parse_vc,
-	},
 	/* Validate/create pattern. */
-	[ITEM_PATTERN] = {
+	[PATTERN] = {
 		.name = "pattern",
 		.help = "submit a list of pattern items",
 		.next = NEXT(next_item),
@@ -3505,7 +1714,7 @@
 		.name = "end",
 		.help = "end list of pattern items",
 		.priv = PRIV_ITEM(END, 0),
-		.next = NEXT(NEXT_ENTRY(ACTIONS, END)),
+		.next = NEXT(NEXT_ENTRY(ACTIONS)),
 		.call = parse_vc,
 	},
 	[ITEM_VOID] = {
@@ -3532,9 +1741,43 @@
 	[ITEM_ANY_NUM] = {
 		.name = "num",
 		.help = "number of layers covered",
-		.next = NEXT(item_any, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
+		.next = NEXT(item_any, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_any, num)),
 	},
+	[ITEM_PF] = {
+		.name = "pf",
+		.help = "match traffic from/to the physical function",
+		.priv = PRIV_ITEM(PF, 0),
+		.next = NEXT(NEXT_ENTRY(ITEM_NEXT)),
+		.call = parse_vc,
+	},
+	[ITEM_VF] = {
+		.name = "vf",
+		.help = "match traffic from/to a virtual function ID",
+		.priv = PRIV_ITEM(VF, sizeof(struct rte_flow_item_vf)),
+		.next = NEXT(item_vf),
+		.call = parse_vc,
+	},
+	[ITEM_VF_ID] = {
+		.name = "id",
+		.help = "VF ID",
+		.next = NEXT(item_vf, NEXT_ENTRY(UNSIGNED), item_param),
+		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_vf, id)),
+	},
+	[ITEM_PHY_PORT] = {
+		.name = "phy_port",
+		.help = "match traffic from/to a specific physical port",
+		.priv = PRIV_ITEM(PHY_PORT,
+				  sizeof(struct rte_flow_item_phy_port)),
+		.next = NEXT(item_phy_port),
+		.call = parse_vc,
+	},
+	[ITEM_PHY_PORT_INDEX] = {
+		.name = "index",
+		.help = "physical port index",
+		.next = NEXT(item_phy_port, NEXT_ENTRY(UNSIGNED), item_param),
+		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_phy_port, index)),
+	},
 	[ITEM_PORT_ID] = {
 		.name = "port_id",
 		.help = "match traffic from/to a given DPDK port ID",
@@ -3546,8 +1789,7 @@
 	[ITEM_PORT_ID_ID] = {
 		.name = "id",
 		.help = "DPDK port ID",
-		.next = NEXT(item_port_id, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_port_id, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_port_id, id)),
 	},
 	[ITEM_MARK] = {
@@ -3560,8 +1802,7 @@
 	[ITEM_MARK_ID] = {
 		.name = "id",
 		.help = "Integer value to match against",
-		.next = NEXT(item_mark, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_mark, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_mark, id)),
 	},
 	[ITEM_RAW] = {
@@ -3574,47 +1815,34 @@
 	[ITEM_RAW_RELATIVE] = {
 		.name = "relative",
 		.help = "look for pattern after the previous item",
-		.next = NEXT(item_raw, NEXT_ENTRY(COMMON_BOOLEAN), item_param),
+		.next = NEXT(item_raw, NEXT_ENTRY(BOOLEAN), item_param),
 		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_item_raw,
 					   relative, 1)),
 	},
 	[ITEM_RAW_SEARCH] = {
 		.name = "search",
 		.help = "search pattern from offset (see also limit)",
-		.next = NEXT(item_raw, NEXT_ENTRY(COMMON_BOOLEAN), item_param),
+		.next = NEXT(item_raw, NEXT_ENTRY(BOOLEAN), item_param),
 		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_item_raw,
 					   search, 1)),
 	},
 	[ITEM_RAW_OFFSET] = {
 		.name = "offset",
 		.help = "absolute or relative offset for pattern",
-		.next = NEXT(item_raw, NEXT_ENTRY(COMMON_INTEGER), item_param),
+		.next = NEXT(item_raw, NEXT_ENTRY(INTEGER), item_param),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_raw, offset)),
 	},
 	[ITEM_RAW_LIMIT] = {
 		.name = "limit",
 		.help = "search area limit for start of pattern",
-		.next = NEXT(item_raw, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
+		.next = NEXT(item_raw, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_raw, limit)),
 	},
 	[ITEM_RAW_PATTERN] = {
 		.name = "pattern",
 		.help = "byte string to look for",
 		.next = NEXT(item_raw,
-			     NEXT_ENTRY(COMMON_STRING),
-			     NEXT_ENTRY(ITEM_PARAM_IS,
-					ITEM_PARAM_SPEC,
-					ITEM_PARAM_MASK)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_raw, pattern),
-			     ARGS_ENTRY(struct rte_flow_item_raw, length),
-			     ARGS_ENTRY_ARB(sizeof(struct rte_flow_item_raw),
-					    ITEM_RAW_PATTERN_SIZE)),
-	},
-	[ITEM_RAW_PATTERN_HEX] = {
-		.name = "pattern_hex",
-		.help = "hex string to look for",
-		.next = NEXT(item_raw,
-			     NEXT_ENTRY(COMMON_HEX),
+			     NEXT_ENTRY(STRING),
 			     NEXT_ENTRY(ITEM_PARAM_IS,
 					ITEM_PARAM_SPEC,
 					ITEM_PARAM_MASK)),
@@ -3633,28 +1861,21 @@
 	[ITEM_ETH_DST] = {
 		.name = "dst",
 		.help = "destination MAC",
-		.next = NEXT(item_eth, NEXT_ENTRY(COMMON_MAC_ADDR), item_param),
+		.next = NEXT(item_eth, NEXT_ENTRY(MAC_ADDR), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_eth, dst)),
 	},
 	[ITEM_ETH_SRC] = {
 		.name = "src",
 		.help = "source MAC",
-		.next = NEXT(item_eth, NEXT_ENTRY(COMMON_MAC_ADDR), item_param),
+		.next = NEXT(item_eth, NEXT_ENTRY(MAC_ADDR), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_eth, src)),
 	},
 	[ITEM_ETH_TYPE] = {
 		.name = "type",
 		.help = "EtherType",
-		.next = NEXT(item_eth, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
+		.next = NEXT(item_eth, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_eth, type)),
 	},
-	[ITEM_ETH_HAS_VLAN] = {
-		.name = "has_vlan",
-		.help = "packet header contains VLAN",
-		.next = NEXT(item_eth, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
-		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_item_eth,
-					   has_vlan, 1)),
-	},
 	[ITEM_VLAN] = {
 		.name = "vlan",
 		.help = "match 802.1Q/ad VLAN tag",
@@ -3665,50 +1886,37 @@
 	[ITEM_VLAN_TCI] = {
 		.name = "tci",
 		.help = "tag control information",
-		.next = NEXT(item_vlan, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_vlan, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_vlan, tci)),
 	},
 	[ITEM_VLAN_PCP] = {
 		.name = "pcp",
 		.help = "priority code point",
-		.next = NEXT(item_vlan, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_vlan, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_vlan,
 						  tci, "\xe0\x00")),
 	},
 	[ITEM_VLAN_DEI] = {
 		.name = "dei",
 		.help = "drop eligible indicator",
-		.next = NEXT(item_vlan, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_vlan, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_vlan,
 						  tci, "\x10\x00")),
 	},
 	[ITEM_VLAN_VID] = {
 		.name = "vid",
 		.help = "VLAN identifier",
-		.next = NEXT(item_vlan, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_vlan, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_vlan,
 						  tci, "\x0f\xff")),
 	},
 	[ITEM_VLAN_INNER_TYPE] = {
 		.name = "inner_type",
 		.help = "inner EtherType",
-		.next = NEXT(item_vlan, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_vlan, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_vlan,
 					     inner_type)),
 	},
-	[ITEM_VLAN_HAS_MORE_VLAN] = {
-		.name = "has_more_vlan",
-		.help = "packet header contains another VLAN",
-		.next = NEXT(item_vlan, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_item_vlan,
-					   has_more_vlan, 1)),
-	},
 	[ITEM_IPV4] = {
 		.name = "ipv4",
 		.help = "match IPv4 header",
@@ -3716,67 +1924,38 @@
 		.next = NEXT(item_ipv4),
 		.call = parse_vc,
 	},
-	[ITEM_IPV4_VER_IHL] = {
-		.name = "version_ihl",
-		.help = "match header length",
-		.next = NEXT(item_ipv4, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_ipv4,
-				     hdr.version_ihl)),
-	},
 	[ITEM_IPV4_TOS] = {
 		.name = "tos",
 		.help = "type of service",
-		.next = NEXT(item_ipv4, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_ipv4, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv4,
 					     hdr.type_of_service)),
 	},
-	[ITEM_IPV4_ID] = {
-		.name = "packet_id",
-		.help = "fragment packet id",
-		.next = NEXT(item_ipv4, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv4,
-					     hdr.packet_id)),
-	},
-	[ITEM_IPV4_FRAGMENT_OFFSET] = {
-		.name = "fragment_offset",
-		.help = "fragmentation flags and fragment offset",
-		.next = NEXT(item_ipv4, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv4,
-					     hdr.fragment_offset)),
-	},
 	[ITEM_IPV4_TTL] = {
 		.name = "ttl",
 		.help = "time to live",
-		.next = NEXT(item_ipv4, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_ipv4, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv4,
 					     hdr.time_to_live)),
 	},
 	[ITEM_IPV4_PROTO] = {
 		.name = "proto",
 		.help = "next protocol ID",
-		.next = NEXT(item_ipv4, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_ipv4, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv4,
 					     hdr.next_proto_id)),
 	},
 	[ITEM_IPV4_SRC] = {
 		.name = "src",
 		.help = "source address",
-		.next = NEXT(item_ipv4, NEXT_ENTRY(COMMON_IPV4_ADDR),
-			     item_param),
+		.next = NEXT(item_ipv4, NEXT_ENTRY(IPV4_ADDR), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv4,
 					     hdr.src_addr)),
 	},
 	[ITEM_IPV4_DST] = {
 		.name = "dst",
 		.help = "destination address",
-		.next = NEXT(item_ipv4, NEXT_ENTRY(COMMON_IPV4_ADDR),
-			     item_param),
+		.next = NEXT(item_ipv4, NEXT_ENTRY(IPV4_ADDR), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv4,
 					     hdr.dst_addr)),
 	},
@@ -3790,8 +1969,7 @@
 	[ITEM_IPV6_TC] = {
 		.name = "tc",
 		.help = "traffic class",
-		.next = NEXT(item_ipv6, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_ipv6, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_ipv6,
 						  hdr.vtc_flow,
 						  "\x0f\xf0\x00\x00")),
@@ -3799,8 +1977,7 @@
 	[ITEM_IPV6_FLOW] = {
 		.name = "flow",
 		.help = "flow label",
-		.next = NEXT(item_ipv6, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_ipv6, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_ipv6,
 						  hdr.vtc_flow,
 						  "\x00\x0f\xff\xff")),
@@ -3808,43 +1985,31 @@
 	[ITEM_IPV6_PROTO] = {
 		.name = "proto",
 		.help = "protocol (next header)",
-		.next = NEXT(item_ipv6, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_ipv6, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv6,
 					     hdr.proto)),
 	},
 	[ITEM_IPV6_HOP] = {
 		.name = "hop",
 		.help = "hop limit",
-		.next = NEXT(item_ipv6, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_ipv6, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv6,
 					     hdr.hop_limits)),
 	},
 	[ITEM_IPV6_SRC] = {
 		.name = "src",
 		.help = "source address",
-		.next = NEXT(item_ipv6, NEXT_ENTRY(COMMON_IPV6_ADDR),
-			     item_param),
+		.next = NEXT(item_ipv6, NEXT_ENTRY(IPV6_ADDR), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv6,
 					     hdr.src_addr)),
 	},
 	[ITEM_IPV6_DST] = {
 		.name = "dst",
 		.help = "destination address",
-		.next = NEXT(item_ipv6, NEXT_ENTRY(COMMON_IPV6_ADDR),
-			     item_param),
+		.next = NEXT(item_ipv6, NEXT_ENTRY(IPV6_ADDR), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv6,
 					     hdr.dst_addr)),
 	},
-	[ITEM_IPV6_HAS_FRAG_EXT] = {
-		.name = "has_frag_ext",
-		.help = "fragment packet attribute",
-		.next = NEXT(item_ipv6, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_item_ipv6,
-					   has_frag_ext, 1)),
-	},
 	[ITEM_ICMP] = {
 		.name = "icmp",
 		.help = "match ICMP header",
@@ -3855,35 +2020,17 @@
 	[ITEM_ICMP_TYPE] = {
 		.name = "type",
 		.help = "ICMP packet type",
-		.next = NEXT(item_icmp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_icmp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_icmp,
 					     hdr.icmp_type)),
 	},
 	[ITEM_ICMP_CODE] = {
 		.name = "code",
 		.help = "ICMP packet code",
-		.next = NEXT(item_icmp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_icmp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_icmp,
 					     hdr.icmp_code)),
 	},
-	[ITEM_ICMP_IDENT] = {
-		.name = "ident",
-		.help = "ICMP packet identifier",
-		.next = NEXT(item_icmp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_icmp,
-					     hdr.icmp_ident)),
-	},
-	[ITEM_ICMP_SEQ] = {
-		.name = "seq",
-		.help = "ICMP packet sequence number",
-		.next = NEXT(item_icmp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_icmp,
-					     hdr.icmp_seq_nb)),
-	},
 	[ITEM_UDP] = {
 		.name = "udp",
 		.help = "match UDP header",
@@ -3894,15 +2041,14 @@
 	[ITEM_UDP_SRC] = {
 		.name = "src",
 		.help = "UDP source port",
-		.next = NEXT(item_udp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_udp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_udp,
 					     hdr.src_port)),
 	},
 	[ITEM_UDP_DST] = {
 		.name = "dst",
 		.help = "UDP destination port",
-		.next = NEXT(item_udp, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
+		.next = NEXT(item_udp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_udp,
 					     hdr.dst_port)),
 	},
@@ -3916,21 +2062,21 @@
 	[ITEM_TCP_SRC] = {
 		.name = "src",
 		.help = "TCP source port",
-		.next = NEXT(item_tcp, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
+		.next = NEXT(item_tcp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_tcp,
 					     hdr.src_port)),
 	},
 	[ITEM_TCP_DST] = {
 		.name = "dst",
 		.help = "TCP destination port",
-		.next = NEXT(item_tcp, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
+		.next = NEXT(item_tcp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_tcp,
 					     hdr.dst_port)),
 	},
 	[ITEM_TCP_FLAGS] = {
 		.name = "flags",
 		.help = "TCP flags",
-		.next = NEXT(item_tcp, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
+		.next = NEXT(item_tcp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_tcp,
 					     hdr.tcp_flags)),
 	},
@@ -3944,32 +2090,28 @@
 	[ITEM_SCTP_SRC] = {
 		.name = "src",
 		.help = "SCTP source port",
-		.next = NEXT(item_sctp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_sctp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_sctp,
 					     hdr.src_port)),
 	},
 	[ITEM_SCTP_DST] = {
 		.name = "dst",
 		.help = "SCTP destination port",
-		.next = NEXT(item_sctp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_sctp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_sctp,
 					     hdr.dst_port)),
 	},
 	[ITEM_SCTP_TAG] = {
 		.name = "tag",
 		.help = "validation tag",
-		.next = NEXT(item_sctp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_sctp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_sctp,
 					     hdr.tag)),
 	},
 	[ITEM_SCTP_CKSUM] = {
 		.name = "cksum",
 		.help = "checksum",
-		.next = NEXT(item_sctp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_sctp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_sctp,
 					     hdr.cksum)),
 	},
@@ -3983,18 +2125,9 @@
 	[ITEM_VXLAN_VNI] = {
 		.name = "vni",
 		.help = "VXLAN identifier",
-		.next = NEXT(item_vxlan, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_vxlan, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_vxlan, vni)),
 	},
-	[ITEM_VXLAN_LAST_RSVD] = {
-		.name = "last_rsvd",
-		.help = "VXLAN last reserved bits",
-		.next = NEXT(item_vxlan, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_vxlan,
-					     rsvd1)),
-	},
 	[ITEM_E_TAG] = {
 		.name = "e_tag",
 		.help = "match E-Tag header",
@@ -4005,8 +2138,7 @@
 	[ITEM_E_TAG_GRP_ECID_B] = {
 		.name = "grp_ecid_b",
 		.help = "GRP and E-CID base",
-		.next = NEXT(item_e_tag, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_e_tag, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_e_tag,
 						  rsvd_grp_ecid_b,
 						  "\x3f\xff")),
@@ -4021,8 +2153,7 @@
 	[ITEM_NVGRE_TNI] = {
 		.name = "tni",
 		.help = "virtual subnet ID",
-		.next = NEXT(item_nvgre, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_nvgre, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_nvgre, tni)),
 	},
 	[ITEM_MPLS] = {
@@ -4035,8 +2166,7 @@
 	[ITEM_MPLS_LABEL] = {
 		.name = "label",
 		.help = "MPLS label",
-		.next = NEXT(item_mpls, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_mpls, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_mpls,
 						  label_tc_s,
 						  "\xff\xff\xf0")),
@@ -4044,8 +2174,7 @@
 	[ITEM_MPLS_TC] = {
 		.name = "tc",
 		.help = "MPLS Traffic Class",
-		.next = NEXT(item_mpls, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_mpls, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_mpls,
 						  label_tc_s,
 						  "\x00\x00\x0e")),
@@ -4053,8 +2182,7 @@
 	[ITEM_MPLS_S] = {
 		.name = "s",
 		.help = "MPLS Bottom-of-Stack",
-		.next = NEXT(item_mpls, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_mpls, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_mpls,
 						  label_tc_s,
 						  "\x00\x00\x01")),
@@ -4069,8 +2197,7 @@
 	[ITEM_GRE_PROTO] = {
 		.name = "protocol",
 		.help = "GRE protocol type",
-		.next = NEXT(item_gre, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_gre, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_gre,
 					     protocol)),
 	},
@@ -4080,16 +2207,14 @@
 			"checksum (1b), undefined (1b), key bit (1b),"
 			" sequence number (1b), reserved 0 (9b),"
 			" version (3b)",
-		.next = NEXT(item_gre, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_gre, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_gre,
 					     c_rsvd0_ver)),
 	},
 	[ITEM_GRE_C_BIT] = {
 		.name = "c_bit",
 		.help = "checksum bit (C)",
-		.next = NEXT(item_gre, NEXT_ENTRY(COMMON_BOOLEAN),
-			     item_param),
+		.next = NEXT(item_gre, NEXT_ENTRY(BOOLEAN), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_gre,
 						  c_rsvd0_ver,
 						  "\x80\x00\x00\x00")),
@@ -4097,7 +2222,7 @@
 	[ITEM_GRE_S_BIT] = {
 		.name = "s_bit",
 		.help = "sequence number bit (S)",
-		.next = NEXT(item_gre, NEXT_ENTRY(COMMON_BOOLEAN), item_param),
+		.next = NEXT(item_gre, NEXT_ENTRY(BOOLEAN), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_gre,
 						  c_rsvd0_ver,
 						  "\x10\x00\x00\x00")),
@@ -4105,7 +2230,7 @@
 	[ITEM_GRE_K_BIT] = {
 		.name = "k_bit",
 		.help = "key bit (K)",
-		.next = NEXT(item_gre, NEXT_ENTRY(COMMON_BOOLEAN), item_param),
+		.next = NEXT(item_gre, NEXT_ENTRY(BOOLEAN), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_gre,
 						  c_rsvd0_ver,
 						  "\x20\x00\x00\x00")),
@@ -4121,8 +2246,7 @@
 	[ITEM_FUZZY_THRESH] = {
 		.name = "thresh",
 		.help = "match accuracy threshold",
-		.next = NEXT(item_fuzzy, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_fuzzy, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_fuzzy,
 					thresh)),
 	},
@@ -4133,23 +2257,10 @@
 		.next = NEXT(item_gtp),
 		.call = parse_vc,
 	},
-	[ITEM_GTP_FLAGS] = {
-		.name = "v_pt_rsv_flags",
-		.help = "GTP flags",
-		.next = NEXT(item_gtp, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_gtp,
-					v_pt_rsv_flags)),
-	},
-	[ITEM_GTP_MSG_TYPE] = {
-		.name = "msg_type",
-		.help = "GTP message type",
-		.next = NEXT(item_gtp, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_gtp, msg_type)),
-	},
 	[ITEM_GTP_TEID] = {
 		.name = "teid",
 		.help = "tunnel endpoint identifier",
-		.next = NEXT(item_gtp, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
+		.next = NEXT(item_gtp, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_gtp, teid)),
 	},
 	[ITEM_GTPC] = {
@@ -4176,27 +2287,16 @@
 	[ITEM_GENEVE_VNI] = {
 		.name = "vni",
 		.help = "virtual network identifier",
-		.next = NEXT(item_geneve, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_geneve, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_geneve, vni)),
 	},
 	[ITEM_GENEVE_PROTO] = {
 		.name = "protocol",
 		.help = "GENEVE protocol type",
-		.next = NEXT(item_geneve, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_geneve, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_geneve,
 					     protocol)),
 	},
-	[ITEM_GENEVE_OPTLEN] = {
-		.name = "optlen",
-		.help = "GENEVE options length in dwords",
-		.next = NEXT(item_geneve, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_MASK_HTON(struct rte_flow_item_geneve,
-						  ver_opt_len_o_c_rsvd0,
-						  "\x3f\x00")),
-	},
 	[ITEM_VXLAN_GPE] = {
 		.name = "vxlan-gpe",
 		.help = "match VXLAN-GPE header",
@@ -4208,8 +2308,7 @@
 	[ITEM_VXLAN_GPE_VNI] = {
 		.name = "vni",
 		.help = "VXLAN-GPE identifier",
-		.next = NEXT(item_vxlan_gpe, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_vxlan_gpe, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_vxlan_gpe,
 					     vni)),
 	},
@@ -4224,7 +2323,7 @@
 	[ITEM_ARP_ETH_IPV4_SHA] = {
 		.name = "sha",
 		.help = "sender hardware address",
-		.next = NEXT(item_arp_eth_ipv4, NEXT_ENTRY(COMMON_MAC_ADDR),
+		.next = NEXT(item_arp_eth_ipv4, NEXT_ENTRY(MAC_ADDR),
 			     item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_arp_eth_ipv4,
 					     sha)),
@@ -4232,7 +2331,7 @@
 	[ITEM_ARP_ETH_IPV4_SPA] = {
 		.name = "spa",
 		.help = "sender IPv4 address",
-		.next = NEXT(item_arp_eth_ipv4, NEXT_ENTRY(COMMON_IPV4_ADDR),
+		.next = NEXT(item_arp_eth_ipv4, NEXT_ENTRY(IPV4_ADDR),
 			     item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_arp_eth_ipv4,
 					     spa)),
@@ -4240,7 +2339,7 @@
 	[ITEM_ARP_ETH_IPV4_THA] = {
 		.name = "tha",
 		.help = "target hardware address",
-		.next = NEXT(item_arp_eth_ipv4, NEXT_ENTRY(COMMON_MAC_ADDR),
+		.next = NEXT(item_arp_eth_ipv4, NEXT_ENTRY(MAC_ADDR),
 			     item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_arp_eth_ipv4,
 					     tha)),
@@ -4248,7 +2347,7 @@
 	[ITEM_ARP_ETH_IPV4_TPA] = {
 		.name = "tpa",
 		.help = "target IPv4 address",
-		.next = NEXT(item_arp_eth_ipv4, NEXT_ENTRY(COMMON_IPV4_ADDR),
+		.next = NEXT(item_arp_eth_ipv4, NEXT_ENTRY(IPV4_ADDR),
 			     item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_arp_eth_ipv4,
 					     tpa)),
@@ -4264,43 +2363,10 @@
 	[ITEM_IPV6_EXT_NEXT_HDR] = {
 		.name = "next_hdr",
 		.help = "next header",
-		.next = NEXT(item_ipv6_ext, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_ipv6_ext, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv6_ext,
 					     next_hdr)),
 	},
-	[ITEM_IPV6_FRAG_EXT] = {
-		.name = "ipv6_frag_ext",
-		.help = "match presence of IPv6 fragment extension header",
-		.priv = PRIV_ITEM(IPV6_FRAG_EXT,
-				sizeof(struct rte_flow_item_ipv6_frag_ext)),
-		.next = NEXT(item_ipv6_frag_ext),
-		.call = parse_vc,
-	},
-	[ITEM_IPV6_FRAG_EXT_NEXT_HDR] = {
-		.name = "next_hdr",
-		.help = "next header",
-		.next = NEXT(item_ipv6_frag_ext, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_ipv6_frag_ext,
-					hdr.next_header)),
-	},
-	[ITEM_IPV6_FRAG_EXT_FRAG_DATA] = {
-		.name = "frag_data",
-		.help = "fragment flags and offset",
-		.next = NEXT(item_ipv6_frag_ext, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv6_frag_ext,
-					     hdr.frag_data)),
-	},
-	[ITEM_IPV6_FRAG_EXT_ID] = {
-		.name = "packet_id",
-		.help = "fragment packet id",
-		.next = NEXT(item_ipv6_frag_ext, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ipv6_frag_ext,
-					     hdr.id)),
-	},
 	[ITEM_ICMP6] = {
 		.name = "icmp6",
 		.help = "match any ICMPv6 header",
@@ -4311,16 +2377,14 @@
 	[ITEM_ICMP6_TYPE] = {
 		.name = "type",
 		.help = "ICMPv6 type",
-		.next = NEXT(item_icmp6, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_icmp6, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_icmp6,
 					     type)),
 	},
 	[ITEM_ICMP6_CODE] = {
 		.name = "code",
 		.help = "ICMPv6 code",
-		.next = NEXT(item_icmp6, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_icmp6, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_icmp6,
 					     code)),
 	},
@@ -4335,7 +2399,7 @@
 	[ITEM_ICMP6_ND_NS_TARGET_ADDR] = {
 		.name = "target_addr",
 		.help = "target address",
-		.next = NEXT(item_icmp6_nd_ns, NEXT_ENTRY(COMMON_IPV6_ADDR),
+		.next = NEXT(item_icmp6_nd_ns, NEXT_ENTRY(IPV6_ADDR),
 			     item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_icmp6_nd_ns,
 					     target_addr)),
@@ -4351,7 +2415,7 @@
 	[ITEM_ICMP6_ND_NA_TARGET_ADDR] = {
 		.name = "target_addr",
 		.help = "target address",
-		.next = NEXT(item_icmp6_nd_na, NEXT_ENTRY(COMMON_IPV6_ADDR),
+		.next = NEXT(item_icmp6_nd_na, NEXT_ENTRY(IPV6_ADDR),
 			     item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_icmp6_nd_na,
 					     target_addr)),
@@ -4368,7 +2432,7 @@
 	[ITEM_ICMP6_ND_OPT_TYPE] = {
 		.name = "type",
 		.help = "ND option type",
-		.next = NEXT(item_icmp6_nd_opt, NEXT_ENTRY(COMMON_UNSIGNED),
+		.next = NEXT(item_icmp6_nd_opt, NEXT_ENTRY(UNSIGNED),
 			     item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_icmp6_nd_opt,
 					     type)),
@@ -4386,8 +2450,8 @@
 	[ITEM_ICMP6_ND_OPT_SLA_ETH_SLA] = {
 		.name = "sla",
 		.help = "source Ethernet LLA",
-		.next = NEXT(item_icmp6_nd_opt_sla_eth,
-			     NEXT_ENTRY(COMMON_MAC_ADDR), item_param),
+		.next = NEXT(item_icmp6_nd_opt_sla_eth, NEXT_ENTRY(MAC_ADDR),
+			     item_param),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_item_icmp6_nd_opt_sla_eth, sla)),
 	},
@@ -4404,8 +2468,8 @@
 	[ITEM_ICMP6_ND_OPT_TLA_ETH_TLA] = {
 		.name = "tla",
 		.help = "target Ethernet LLA",
-		.next = NEXT(item_icmp6_nd_opt_tla_eth,
-			     NEXT_ENTRY(COMMON_MAC_ADDR), item_param),
+		.next = NEXT(item_icmp6_nd_opt_tla_eth, NEXT_ENTRY(MAC_ADDR),
+			     item_param),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_item_icmp6_nd_opt_tla_eth, tla)),
 	},
@@ -4419,8 +2483,7 @@
 	[ITEM_META_DATA] = {
 		.name = "data",
 		.help = "metadata value",
-		.next = NEXT(item_meta, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_meta, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_MASK(struct rte_flow_item_meta,
 					     data, "\xff\xff\xff\xff")),
 	},
@@ -4434,42 +2497,9 @@
 	[ITEM_GRE_KEY_VALUE] = {
 		.name = "value",
 		.help = "key value",
-		.next = NEXT(item_gre_key, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_gre_key, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARG_ENTRY_HTON(rte_be32_t)),
 	},
-	[ITEM_GRE_OPTION] = {
-		.name = "gre_option",
-		.help = "match GRE optional fields",
-		.priv = PRIV_ITEM(GRE_OPTION,
-				  sizeof(struct rte_flow_item_gre_opt)),
-		.next = NEXT(item_gre_option),
-		.call = parse_vc,
-	},
-	[ITEM_GRE_OPTION_CHECKSUM] = {
-		.name = "checksum",
-		.help = "match GRE checksum",
-		.next = NEXT(item_gre_option, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_gre_opt,
-					     checksum_rsvd.checksum)),
-	},
-	[ITEM_GRE_OPTION_KEY] = {
-		.name = "key",
-		.help = "match GRE key",
-		.next = NEXT(item_gre_option, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_gre_opt,
-					     key.key)),
-	},
-	[ITEM_GRE_OPTION_SEQUENCE] = {
-		.name = "sequence",
-		.help = "match GRE sequence",
-		.next = NEXT(item_gre_option, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_gre_opt,
-					     sequence.sequence)),
-	},
 	[ITEM_GTP_PSC] = {
 		.name = "gtp_psc",
 		.help = "match GTP extension header with type 0x85",
@@ -4481,18 +2511,16 @@
 	[ITEM_GTP_PSC_QFI] = {
 		.name = "qfi",
 		.help = "QoS flow identifier",
-		.next = NEXT(item_gtp_psc, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_item_gtp_psc,
-					hdr.qfi, 6)),
+		.next = NEXT(item_gtp_psc, NEXT_ENTRY(UNSIGNED), item_param),
+		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_gtp_psc,
+					qfi)),
 	},
 	[ITEM_GTP_PSC_PDU_T] = {
 		.name = "pdu_t",
 		.help = "PDU type",
-		.next = NEXT(item_gtp_psc, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_item_gtp_psc,
-					hdr.type, 4)),
+		.next = NEXT(item_gtp_psc, NEXT_ENTRY(UNSIGNED), item_param),
+		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_gtp_psc,
+					pdu_type)),
 	},
 	[ITEM_PPPOES] = {
 		.name = "pppoes",
@@ -4511,20 +2539,16 @@
 	[ITEM_PPPOE_SEID] = {
 		.name = "seid",
 		.help = "session identifier",
-		.next = NEXT(item_pppoes, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_pppoes, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_pppoe,
 					session_id)),
 	},
 	[ITEM_PPPOE_PROTO_ID] = {
-		.name = "pppoe_proto_id",
+		.name = "proto_id",
 		.help = "match PPPoE session protocol identifier",
 		.priv = PRIV_ITEM(PPPOE_PROTO_ID,
 				sizeof(struct rte_flow_item_pppoe_proto_id)),
-		.next = NEXT(item_pppoe_proto_id, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON
-			     (struct rte_flow_item_pppoe_proto_id, proto_id)),
+		.next = NEXT(item_pppoe_proto_id),
 		.call = parse_vc,
 	},
 	[ITEM_HIGIG2] = {
@@ -4538,16 +2562,14 @@
 	[ITEM_HIGIG2_CLASSIFICATION] = {
 		.name = "classification",
 		.help = "matches classification of higig2 header",
-		.next = NEXT(item_higig2, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_higig2, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_higig2_hdr,
 					hdr.ppt1.classification)),
 	},
 	[ITEM_HIGIG2_VID] = {
 		.name = "vid",
 		.help = "matches vid of higig2 header",
-		.next = NEXT(item_higig2, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
+		.next = NEXT(item_higig2, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_higig2_hdr,
 					hdr.ppt1.vid)),
 	},
@@ -4561,573 +2583,16 @@
 	[ITEM_TAG_DATA] = {
 		.name = "data",
 		.help = "tag value to match",
-		.next = NEXT(item_tag, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
+		.next = NEXT(item_tag, NEXT_ENTRY(UNSIGNED), item_param),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_tag, data)),
 	},
 	[ITEM_TAG_INDEX] = {
 		.name = "index",
 		.help = "index of tag array to match",
-		.next = NEXT(item_tag, NEXT_ENTRY(COMMON_UNSIGNED),
+		.next = NEXT(item_tag, NEXT_ENTRY(UNSIGNED),
 			     NEXT_ENTRY(ITEM_PARAM_IS)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_tag, index)),
 	},
-	[ITEM_L2TPV3OIP] = {
-		.name = "l2tpv3oip",
-		.help = "match L2TPv3 over IP header",
-		.priv = PRIV_ITEM(L2TPV3OIP,
-				  sizeof(struct rte_flow_item_l2tpv3oip)),
-		.next = NEXT(item_l2tpv3oip),
-		.call = parse_vc,
-	},
-	[ITEM_L2TPV3OIP_SESSION_ID] = {
-		.name = "session_id",
-		.help = "session identifier",
-		.next = NEXT(item_l2tpv3oip, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv3oip,
-					     session_id)),
-	},
-	[ITEM_ESP] = {
-		.name = "esp",
-		.help = "match ESP header",
-		.priv = PRIV_ITEM(ESP, sizeof(struct rte_flow_item_esp)),
-		.next = NEXT(item_esp),
-		.call = parse_vc,
-	},
-	[ITEM_ESP_SPI] = {
-		.name = "spi",
-		.help = "security policy index",
-		.next = NEXT(item_esp, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_esp,
-				hdr.spi)),
-	},
-	[ITEM_AH] = {
-		.name = "ah",
-		.help = "match AH header",
-		.priv = PRIV_ITEM(AH, sizeof(struct rte_flow_item_ah)),
-		.next = NEXT(item_ah),
-		.call = parse_vc,
-	},
-	[ITEM_AH_SPI] = {
-		.name = "spi",
-		.help = "security parameters index",
-		.next = NEXT(item_ah, NEXT_ENTRY(COMMON_UNSIGNED), item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ah, spi)),
-	},
-	[ITEM_PFCP] = {
-		.name = "pfcp",
-		.help = "match pfcp header",
-		.priv = PRIV_ITEM(PFCP, sizeof(struct rte_flow_item_pfcp)),
-		.next = NEXT(item_pfcp),
-		.call = parse_vc,
-	},
-	[ITEM_PFCP_S_FIELD] = {
-		.name = "s_field",
-		.help = "S field",
-		.next = NEXT(item_pfcp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_pfcp,
-				s_field)),
-	},
-	[ITEM_PFCP_SEID] = {
-		.name = "seid",
-		.help = "session endpoint identifier",
-		.next = NEXT(item_pfcp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_pfcp, seid)),
-	},
-	[ITEM_ECPRI] = {
-		.name = "ecpri",
-		.help = "match eCPRI header",
-		.priv = PRIV_ITEM(ECPRI, sizeof(struct rte_flow_item_ecpri)),
-		.next = NEXT(item_ecpri),
-		.call = parse_vc,
-	},
-	[ITEM_ECPRI_COMMON] = {
-		.name = "common",
-		.help = "eCPRI common header",
-		.next = NEXT(item_ecpri_common),
-	},
-	[ITEM_ECPRI_COMMON_TYPE] = {
-		.name = "type",
-		.help = "type of common header",
-		.next = NEXT(item_ecpri_common_type),
-		.args = ARGS(ARG_ENTRY_HTON(struct rte_flow_item_ecpri)),
-	},
-	[ITEM_ECPRI_COMMON_TYPE_IQ_DATA] = {
-		.name = "iq_data",
-		.help = "Type #0: IQ Data",
-		.next = NEXT(NEXT_ENTRY(ITEM_ECPRI_MSG_IQ_DATA_PCID,
-					ITEM_NEXT)),
-		.call = parse_vc_item_ecpri_type,
-	},
-	[ITEM_ECPRI_MSG_IQ_DATA_PCID] = {
-		.name = "pc_id",
-		.help = "Physical Channel ID",
-		.next = NEXT(NEXT_ENTRY(ITEM_ECPRI_MSG_IQ_DATA_PCID,
-				ITEM_ECPRI_COMMON, ITEM_NEXT),
-				NEXT_ENTRY(COMMON_UNSIGNED), item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ecpri,
-				hdr.type0.pc_id)),
-	},
-	[ITEM_ECPRI_COMMON_TYPE_RTC_CTRL] = {
-		.name = "rtc_ctrl",
-		.help = "Type #2: Real-Time Control Data",
-		.next = NEXT(NEXT_ENTRY(ITEM_ECPRI_MSG_RTC_CTRL_RTCID,
-					ITEM_NEXT)),
-		.call = parse_vc_item_ecpri_type,
-	},
-	[ITEM_ECPRI_MSG_RTC_CTRL_RTCID] = {
-		.name = "rtc_id",
-		.help = "Real-Time Control Data ID",
-		.next = NEXT(NEXT_ENTRY(ITEM_ECPRI_MSG_RTC_CTRL_RTCID,
-				ITEM_ECPRI_COMMON, ITEM_NEXT),
-				NEXT_ENTRY(COMMON_UNSIGNED), item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ecpri,
-				hdr.type2.rtc_id)),
-	},
-	[ITEM_ECPRI_COMMON_TYPE_DLY_MSR] = {
-		.name = "delay_measure",
-		.help = "Type #5: One-Way Delay Measurement",
-		.next = NEXT(NEXT_ENTRY(ITEM_ECPRI_MSG_DLY_MSR_MSRID,
-					ITEM_NEXT)),
-		.call = parse_vc_item_ecpri_type,
-	},
-	[ITEM_ECPRI_MSG_DLY_MSR_MSRID] = {
-		.name = "msr_id",
-		.help = "Measurement ID",
-		.next = NEXT(NEXT_ENTRY(ITEM_ECPRI_MSG_DLY_MSR_MSRID,
-				ITEM_ECPRI_COMMON, ITEM_NEXT),
-				NEXT_ENTRY(COMMON_UNSIGNED), item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_ecpri,
-				hdr.type5.msr_id)),
-	},
-	[ITEM_GENEVE_OPT] = {
-		.name = "geneve-opt",
-		.help = "GENEVE header option",
-		.priv = PRIV_ITEM(GENEVE_OPT,
-				  sizeof(struct rte_flow_item_geneve_opt) +
-				  ITEM_GENEVE_OPT_DATA_SIZE),
-		.next = NEXT(item_geneve_opt),
-		.call = parse_vc,
-	},
-	[ITEM_GENEVE_OPT_CLASS]	= {
-		.name = "class",
-		.help = "GENEVE option class",
-		.next = NEXT(item_geneve_opt, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_geneve_opt,
-					     option_class)),
-	},
-	[ITEM_GENEVE_OPT_TYPE] = {
-		.name = "type",
-		.help = "GENEVE option type",
-		.next = NEXT(item_geneve_opt, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_geneve_opt,
-					option_type)),
-	},
-	[ITEM_GENEVE_OPT_LENGTH] = {
-		.name = "length",
-		.help = "GENEVE option data length (in 32b words)",
-		.next = NEXT(item_geneve_opt, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_BOUNDED(
-				struct rte_flow_item_geneve_opt, option_len,
-				0, 31)),
-	},
-	[ITEM_GENEVE_OPT_DATA] = {
-		.name = "data",
-		.help = "GENEVE option data pattern",
-		.next = NEXT(item_geneve_opt, NEXT_ENTRY(COMMON_HEX),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_geneve_opt, data),
-			     ARGS_ENTRY_ARB(0, 0),
-			     ARGS_ENTRY_ARB
-				(sizeof(struct rte_flow_item_geneve_opt),
-				ITEM_GENEVE_OPT_DATA_SIZE)),
-	},
-	[ITEM_INTEGRITY] = {
-		.name = "integrity",
-		.help = "match packet integrity",
-		.priv = PRIV_ITEM(INTEGRITY,
-				  sizeof(struct rte_flow_item_integrity)),
-		.next = NEXT(item_integrity),
-		.call = parse_vc,
-	},
-	[ITEM_INTEGRITY_LEVEL] = {
-		.name = "level",
-		.help = "integrity level",
-		.next = NEXT(item_integrity_lv, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_integrity, level)),
-	},
-	[ITEM_INTEGRITY_VALUE] = {
-		.name = "value",
-		.help = "integrity value",
-		.next = NEXT(item_integrity_lv, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_integrity, value)),
-	},
-	[ITEM_CONNTRACK] = {
-		.name = "conntrack",
-		.help = "conntrack state",
-		.next = NEXT(NEXT_ENTRY(ITEM_NEXT), NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_conntrack, flags)),
-	},
-	[ITEM_PORT_REPRESENTOR] = {
-		.name = "port_representor",
-		.help = "match traffic entering the embedded switch from the given ethdev",
-		.priv = PRIV_ITEM(PORT_REPRESENTOR,
-				  sizeof(struct rte_flow_item_ethdev)),
-		.next = NEXT(item_port_representor),
-		.call = parse_vc,
-	},
-	[ITEM_PORT_REPRESENTOR_PORT_ID] = {
-		.name = "port_id",
-		.help = "ethdev port ID",
-		.next = NEXT(item_port_representor, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_ethdev, port_id)),
-	},
-	[ITEM_REPRESENTED_PORT] = {
-		.name = "represented_port",
-		.help = "match traffic entering the embedded switch from the entity represented by the given ethdev",
-		.priv = PRIV_ITEM(REPRESENTED_PORT,
-				  sizeof(struct rte_flow_item_ethdev)),
-		.next = NEXT(item_represented_port),
-		.call = parse_vc,
-	},
-	[ITEM_REPRESENTED_PORT_ETHDEV_PORT_ID] = {
-		.name = "ethdev_port_id",
-		.help = "ethdev port ID",
-		.next = NEXT(item_represented_port, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_ethdev, port_id)),
-	},
-	[ITEM_FLEX] = {
-		.name = "flex",
-		.help = "match flex header",
-		.priv = PRIV_ITEM(FLEX, sizeof(struct rte_flow_item_flex)),
-		.next = NEXT(item_flex),
-		.call = parse_vc,
-	},
-	[ITEM_FLEX_ITEM_HANDLE] = {
-		.name = "item",
-		.help = "flex item handle",
-		.next = NEXT(item_flex, NEXT_ENTRY(COMMON_FLEX_HANDLE),
-			     NEXT_ENTRY(ITEM_PARAM_IS)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_flex, handle)),
-	},
-	[ITEM_FLEX_PATTERN_HANDLE] = {
-		.name = "pattern",
-		.help = "flex pattern handle",
-		.next = NEXT(item_flex, NEXT_ENTRY(COMMON_FLEX_HANDLE),
-			     NEXT_ENTRY(ITEM_PARAM_IS)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_flex, pattern)),
-	},
-	[ITEM_L2TPV2] = {
-		.name = "l2tpv2",
-		.help = "match L2TPv2 header",
-		.priv = PRIV_ITEM(L2TPV2, sizeof(struct rte_flow_item_l2tpv2)),
-		.next = NEXT(item_l2tpv2),
-		.call = parse_vc,
-	},
-	[ITEM_L2TPV2_TYPE] = {
-		.name = "type",
-		.help = "type of l2tpv2",
-		.next = NEXT(item_l2tpv2_type),
-		.args = ARGS(ARG_ENTRY_HTON(struct rte_flow_item_l2tpv2)),
-	},
-	[ITEM_L2TPV2_TYPE_DATA] = {
-		.name = "data",
-		.help = "Type #7: data message without any options",
-		.next = NEXT(item_l2tpv2_type_data),
-		.call = parse_vc_item_l2tpv2_type,
-	},
-	[ITEM_L2TPV2_MSG_DATA_TUNNEL_ID] = {
-		.name = "tunnel_id",
-		.help = "tunnel identifier",
-		.next = NEXT(item_l2tpv2_type_data,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type7.tunnel_id)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_SESSION_ID] = {
-		.name = "session_id",
-		.help = "session identifier",
-		.next = NEXT(item_l2tpv2_type_data,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type7.session_id)),
-	},
-	[ITEM_L2TPV2_TYPE_DATA_L] = {
-		.name = "data_l",
-		.help = "Type #6: data message with length option",
-		.next = NEXT(item_l2tpv2_type_data_l),
-		.call = parse_vc_item_l2tpv2_type,
-	},
-	[ITEM_L2TPV2_MSG_DATA_L_LENGTH] = {
-		.name = "length",
-		.help = "message length",
-		.next = NEXT(item_l2tpv2_type_data_l,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type6.length)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_L_TUNNEL_ID] = {
-		.name = "tunnel_id",
-		.help = "tunnel identifier",
-		.next = NEXT(item_l2tpv2_type_data_l,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type6.tunnel_id)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_L_SESSION_ID] = {
-		.name = "session_id",
-		.help = "session identifier",
-		.next = NEXT(item_l2tpv2_type_data_l,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type6.session_id)),
-	},
-	[ITEM_L2TPV2_TYPE_DATA_S] = {
-		.name = "data_s",
-		.help = "Type #5: data message with ns, nr option",
-		.next = NEXT(item_l2tpv2_type_data_s),
-		.call = parse_vc_item_l2tpv2_type,
-	},
-	[ITEM_L2TPV2_MSG_DATA_S_TUNNEL_ID] = {
-		.name = "tunnel_id",
-		.help = "tunnel identifier",
-		.next = NEXT(item_l2tpv2_type_data_s,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type5.tunnel_id)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_S_SESSION_ID] = {
-		.name = "session_id",
-		.help = "session identifier",
-		.next = NEXT(item_l2tpv2_type_data_s,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type5.session_id)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_S_NS] = {
-		.name = "ns",
-		.help = "sequence number for message",
-		.next = NEXT(item_l2tpv2_type_data_s,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type5.ns)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_S_NR] = {
-		.name = "nr",
-		.help = "sequence number for next receive message",
-		.next = NEXT(item_l2tpv2_type_data_s,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type5.nr)),
-	},
-	[ITEM_L2TPV2_TYPE_DATA_O] = {
-		.name = "data_o",
-		.help = "Type #4: data message with offset option",
-		.next = NEXT(item_l2tpv2_type_data_o),
-		.call = parse_vc_item_l2tpv2_type,
-	},
-	[ITEM_L2TPV2_MSG_DATA_O_TUNNEL_ID] = {
-		.name = "tunnel_id",
-		.help = "tunnel identifier",
-		.next = NEXT(item_l2tpv2_type_data_o,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type4.tunnel_id)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_O_SESSION_ID] = {
-		.name = "session_id",
-		.help = "session identifier",
-		.next = NEXT(item_l2tpv2_type_data_o,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type5.session_id)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_O_OFFSET] = {
-		.name = "offset_size",
-		.help = "the size of offset padding",
-		.next = NEXT(item_l2tpv2_type_data_o,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type4.offset_size)),
-	},
-	[ITEM_L2TPV2_TYPE_DATA_L_S] = {
-		.name = "data_l_s",
-		.help = "Type #3: data message contains length, ns, nr "
-			"options",
-		.next = NEXT(item_l2tpv2_type_data_l_s),
-		.call = parse_vc_item_l2tpv2_type,
-	},
-	[ITEM_L2TPV2_MSG_DATA_L_S_LENGTH] = {
-		.name = "length",
-		.help = "message length",
-		.next = NEXT(item_l2tpv2_type_data_l_s,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.length)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_L_S_TUNNEL_ID] = {
-		.name = "tunnel_id",
-		.help = "tunnel identifier",
-		.next = NEXT(item_l2tpv2_type_data_l_s,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.tunnel_id)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_L_S_SESSION_ID] = {
-		.name = "session_id",
-		.help = "session identifier",
-		.next = NEXT(item_l2tpv2_type_data_l_s,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.session_id)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_L_S_NS] = {
-		.name = "ns",
-		.help = "sequence number for message",
-		.next = NEXT(item_l2tpv2_type_data_l_s,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.ns)),
-	},
-	[ITEM_L2TPV2_MSG_DATA_L_S_NR] = {
-		.name = "nr",
-		.help = "sequence number for next receive message",
-		.next = NEXT(item_l2tpv2_type_data_l_s,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.nr)),
-	},
-	[ITEM_L2TPV2_TYPE_CTRL] = {
-		.name = "control",
-		.help = "Type #3: conrtol message contains length, ns, nr "
-			"options",
-		.next = NEXT(item_l2tpv2_type_ctrl),
-		.call = parse_vc_item_l2tpv2_type,
-	},
-	[ITEM_L2TPV2_MSG_CTRL_LENGTH] = {
-		.name = "length",
-		.help = "message length",
-		.next = NEXT(item_l2tpv2_type_ctrl,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.length)),
-	},
-	[ITEM_L2TPV2_MSG_CTRL_TUNNEL_ID] = {
-		.name = "tunnel_id",
-		.help = "tunnel identifier",
-		.next = NEXT(item_l2tpv2_type_ctrl,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.tunnel_id)),
-	},
-	[ITEM_L2TPV2_MSG_CTRL_SESSION_ID] = {
-		.name = "session_id",
-		.help = "session identifier",
-		.next = NEXT(item_l2tpv2_type_ctrl,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.session_id)),
-	},
-	[ITEM_L2TPV2_MSG_CTRL_NS] = {
-		.name = "ns",
-		.help = "sequence number for message",
-		.next = NEXT(item_l2tpv2_type_ctrl,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.ns)),
-	},
-	[ITEM_L2TPV2_MSG_CTRL_NR] = {
-		.name = "nr",
-		.help = "sequence number for next receive message",
-		.next = NEXT(item_l2tpv2_type_ctrl,
-			     NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY_HTON(struct rte_flow_item_l2tpv2,
-					     hdr.type3.nr)),
-	},
-	[ITEM_PPP] = {
-		.name = "ppp",
-		.help = "match PPP header",
-		.priv = PRIV_ITEM(PPP, sizeof(struct rte_flow_item_ppp)),
-		.next = NEXT(item_ppp),
-		.call = parse_vc,
-	},
-	[ITEM_PPP_ADDR] = {
-		.name = "addr",
-		.help = "PPP address",
-		.next = NEXT(item_ppp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_ppp, hdr.addr)),
-	},
-	[ITEM_PPP_CTRL] = {
-		.name = "ctrl",
-		.help = "PPP control",
-		.next = NEXT(item_ppp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_ppp, hdr.ctrl)),
-	},
-	[ITEM_PPP_PROTO_ID] = {
-		.name = "proto_id",
-		.help = "PPP protocol identifier",
-		.next = NEXT(item_ppp, NEXT_ENTRY(COMMON_UNSIGNED),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_ppp,
-					hdr.proto_id)),
-	},
-	[ITEM_METER] = {
-		.name = "meter",
-		.help = "match meter color",
-		.priv = PRIV_ITEM(METER_COLOR,
-				  sizeof(struct rte_flow_item_meter_color)),
-		.next = NEXT(item_meter),
-		.call = parse_vc,
-	},
-	[ITEM_METER_COLOR] = {
-		.name = "color",
-		.help = "meter color",
-		.next = NEXT(item_meter,
-			     NEXT_ENTRY(ITEM_METER_COLOR_NAME),
-			     item_param),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_item_meter_color,
-					color)),
-	},
-	[ITEM_METER_COLOR_NAME] = {
-		.name = "color_name",
-		.help = "meter color name",
-		.call = parse_meter_color,
-		.comp = comp_meter_color,
-	},
 	/* Validate/create actions. */
 	[ACTIONS] = {
 		.name = "actions",
@@ -5170,7 +2635,7 @@
 	[ACTION_JUMP_GROUP] = {
 		.name = "group",
 		.help = "group to redirect traffic to",
-		.next = NEXT(action_jump, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_jump, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_jump, group)),
 		.call = parse_vc_conf,
 	},
@@ -5184,7 +2649,7 @@
 	[ACTION_MARK_ID] = {
 		.name = "id",
 		.help = "32 bit value to return with packets",
-		.next = NEXT(action_mark, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_mark, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_mark, id)),
 		.call = parse_vc_conf,
 	},
@@ -5206,7 +2671,7 @@
 	[ACTION_QUEUE_INDEX] = {
 		.name = "index",
 		.help = "queue index to use",
-		.next = NEXT(action_queue, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_queue, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_queue, index)),
 		.call = parse_vc_conf,
 	},
@@ -5228,10 +2693,18 @@
 	[ACTION_COUNT_ID] = {
 		.name = "identifier",
 		.help = "counter identifier to use",
-		.next = NEXT(action_count, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_count, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_count, id)),
 		.call = parse_vc_conf,
 	},
+	[ACTION_COUNT_SHARED] = {
+		.name = "shared",
+		.help = "shared counter",
+		.next = NEXT(action_count, NEXT_ENTRY(BOOLEAN)),
+		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_action_count,
+					   shared, 1)),
+		.call = parse_vc_conf,
+	},
 	[ACTION_RSS] = {
 		.name = "rss",
 		.help = "spread packets among several queues",
@@ -5271,7 +2744,7 @@
 	[ACTION_RSS_LEVEL] = {
 		.name = "level",
 		.help = "encapsulation level for \"types\"",
-		.next = NEXT(action_rss, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_rss, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_ARB
 			     (offsetof(struct action_rss_data, conf) +
 			      offsetof(struct rte_flow_action_rss, level),
@@ -5292,11 +2765,8 @@
 	[ACTION_RSS_KEY] = {
 		.name = "key",
 		.help = "RSS hash key",
-		.next = NEXT(action_rss, NEXT_ENTRY(COMMON_HEX)),
-		.args = ARGS(ARGS_ENTRY_ARB
-			     (offsetof(struct action_rss_data, conf) +
-			      offsetof(struct rte_flow_action_rss, key),
-			      sizeof(((struct rte_flow_action_rss *)0)->key)),
+		.next = NEXT(action_rss, NEXT_ENTRY(HEX)),
+		.args = ARGS(ARGS_ENTRY_ARB(0, 0),
 			     ARGS_ENTRY_ARB
 			     (offsetof(struct action_rss_data, conf) +
 			      offsetof(struct rte_flow_action_rss, key_len),
@@ -5307,7 +2777,7 @@
 	[ACTION_RSS_KEY_LEN] = {
 		.name = "key_len",
 		.help = "RSS hash key length in bytes",
-		.next = NEXT(action_rss, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_rss, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_ARB_BOUNDED
 			     (offsetof(struct action_rss_data, conf) +
 			      offsetof(struct rte_flow_action_rss, key_len),
@@ -5345,7 +2815,7 @@
 	[ACTION_VF_ORIGINAL] = {
 		.name = "original",
 		.help = "use original VF ID if possible",
-		.next = NEXT(action_vf, NEXT_ENTRY(COMMON_BOOLEAN)),
+		.next = NEXT(action_vf, NEXT_ENTRY(BOOLEAN)),
 		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_action_vf,
 					   original, 1)),
 		.call = parse_vc_conf,
@@ -5353,10 +2823,34 @@
 	[ACTION_VF_ID] = {
 		.name = "id",
 		.help = "VF ID",
-		.next = NEXT(action_vf, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_vf, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_vf, id)),
 		.call = parse_vc_conf,
 	},
+	[ACTION_PHY_PORT] = {
+		.name = "phy_port",
+		.help = "direct packets to physical port index",
+		.priv = PRIV_ACTION(PHY_PORT,
+				    sizeof(struct rte_flow_action_phy_port)),
+		.next = NEXT(action_phy_port),
+		.call = parse_vc,
+	},
+	[ACTION_PHY_PORT_ORIGINAL] = {
+		.name = "original",
+		.help = "use original port index if possible",
+		.next = NEXT(action_phy_port, NEXT_ENTRY(BOOLEAN)),
+		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_action_phy_port,
+					   original, 1)),
+		.call = parse_vc_conf,
+	},
+	[ACTION_PHY_PORT_INDEX] = {
+		.name = "index",
+		.help = "physical port index",
+		.next = NEXT(action_phy_port, NEXT_ENTRY(UNSIGNED)),
+		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_phy_port,
+					index)),
+		.call = parse_vc_conf,
+	},
 	[ACTION_PORT_ID] = {
 		.name = "port_id",
 		.help = "direct matching traffic to a given DPDK port ID",
@@ -5368,7 +2862,7 @@
 	[ACTION_PORT_ID_ORIGINAL] = {
 		.name = "original",
 		.help = "use original DPDK port ID if possible",
-		.next = NEXT(action_port_id, NEXT_ENTRY(COMMON_BOOLEAN)),
+		.next = NEXT(action_port_id, NEXT_ENTRY(BOOLEAN)),
 		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_action_port_id,
 					   original, 1)),
 		.call = parse_vc_conf,
@@ -5376,7 +2870,7 @@
 	[ACTION_PORT_ID_ID] = {
 		.name = "id",
 		.help = "DPDK port ID",
-		.next = NEXT(action_port_id, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_port_id, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_port_id, id)),
 		.call = parse_vc_conf,
 	},
@@ -5388,98 +2882,52 @@
 		.next = NEXT(action_meter),
 		.call = parse_vc,
 	},
-	[ACTION_METER_COLOR] = {
-		.name = "color",
-		.help = "meter color for the packets",
-		.priv = PRIV_ACTION(METER_COLOR,
-				sizeof(struct rte_flow_action_meter_color)),
-		.next = NEXT(action_meter_color),
-		.call = parse_vc,
-	},
-	[ACTION_METER_COLOR_TYPE] = {
-		.name = "type",
-		.help = "specific meter color",
-		.next = NEXT(NEXT_ENTRY(ACTION_NEXT),
-				NEXT_ENTRY(ACTION_METER_COLOR_GREEN,
-					ACTION_METER_COLOR_YELLOW,
-					ACTION_METER_COLOR_RED)),
-	},
-	[ACTION_METER_COLOR_GREEN] = {
-		.name = "green",
-		.help = "meter color green",
-		.call = parse_vc_action_meter_color_type,
-	},
-	[ACTION_METER_COLOR_YELLOW] = {
-		.name = "yellow",
-		.help = "meter color yellow",
-		.call = parse_vc_action_meter_color_type,
-	},
-	[ACTION_METER_COLOR_RED] = {
-		.name = "red",
-		.help = "meter color red",
-		.call = parse_vc_action_meter_color_type,
-	},
 	[ACTION_METER_ID] = {
 		.name = "mtr_id",
 		.help = "meter id to use",
-		.next = NEXT(action_meter, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_meter, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_meter, mtr_id)),
 		.call = parse_vc_conf,
 	},
-	[ACTION_METER_MARK] = {
-		.name = "meter_mark",
-		.help = "meter the directed packets using profile and policy",
-		.priv = PRIV_ACTION(METER_MARK,
-				    sizeof(struct rte_flow_action_meter_mark)),
-		.next = NEXT(action_meter_mark),
-		.call = parse_vc,
-	},
-	[ACTION_METER_PROFILE] = {
-		.name = "mtr_profile",
-		.help = "meter profile id to use",
-		.next = NEXT(NEXT_ENTRY(ACTION_METER_PROFILE_ID2PTR)),
-		.args = ARGS(ARGS_ENTRY_ARB(0, sizeof(uint32_t))),
-	},
-	[ACTION_METER_PROFILE_ID2PTR] = {
-		.name = "{mtr_profile_id}",
-		.type = "PROFILE_ID",
-		.help = "meter profile id",
-		.next = NEXT(action_meter_mark),
-		.call = parse_meter_profile_id2ptr,
-		.comp = comp_none,
-	},
-	[ACTION_METER_POLICY] = {
-		.name = "mtr_policy",
-		.help = "meter policy id to use",
-		.next = NEXT(NEXT_ENTRY(ACTION_METER_POLICY_ID2PTR)),
-		ARGS(ARGS_ENTRY_ARB(0, sizeof(uint32_t))),
-	},
-	[ACTION_METER_POLICY_ID2PTR] = {
-		.name = "{mtr_policy_id}",
-		.type = "POLICY_ID",
-		.help = "meter policy id",
-		.next = NEXT(action_meter_mark),
-		.call = parse_meter_policy_id2ptr,
-		.comp = comp_none,
+	[ACTION_OF_SET_MPLS_TTL] = {
+		.name = "of_set_mpls_ttl",
+		.help = "OpenFlow's OFPAT_SET_MPLS_TTL",
+		.priv = PRIV_ACTION
+			(OF_SET_MPLS_TTL,
+			 sizeof(struct rte_flow_action_of_set_mpls_ttl)),
+		.next = NEXT(action_of_set_mpls_ttl),
+		.call = parse_vc,
+	},
+	[ACTION_OF_SET_MPLS_TTL_MPLS_TTL] = {
+		.name = "mpls_ttl",
+		.help = "MPLS TTL",
+		.next = NEXT(action_of_set_mpls_ttl, NEXT_ENTRY(UNSIGNED)),
+		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_of_set_mpls_ttl,
+					mpls_ttl)),
+		.call = parse_vc_conf,
+	},
+	[ACTION_OF_DEC_MPLS_TTL] = {
+		.name = "of_dec_mpls_ttl",
+		.help = "OpenFlow's OFPAT_DEC_MPLS_TTL",
+		.priv = PRIV_ACTION(OF_DEC_MPLS_TTL, 0),
+		.next = NEXT(NEXT_ENTRY(ACTION_NEXT)),
+		.call = parse_vc,
 	},
-	[ACTION_METER_COLOR_MODE] = {
-		.name = "mtr_color_mode",
-		.help = "meter color awareness mode",
-		.next = NEXT(action_meter_mark, NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_meter_mark, color_mode)),
-		.call = parse_vc_conf,
+	[ACTION_OF_SET_NW_TTL] = {
+		.name = "of_set_nw_ttl",
+		.help = "OpenFlow's OFPAT_SET_NW_TTL",
+		.priv = PRIV_ACTION
+			(OF_SET_NW_TTL,
+			 sizeof(struct rte_flow_action_of_set_nw_ttl)),
+		.next = NEXT(action_of_set_nw_ttl),
+		.call = parse_vc,
 	},
-	[ACTION_METER_INIT_COLOR] = {
-		.name = "mtr_init_color",
-		.help = "meter initial color",
-		.next = NEXT(action_meter_mark, NEXT_ENTRY(ITEM_METER_COLOR_NAME)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_meter_mark, init_color)),
-	},
-	[ACTION_METER_STATE] = {
-		.name = "mtr_state",
-		.help = "meter state",
-		.next = NEXT(action_meter_mark, NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_meter_mark, state)),
+	[ACTION_OF_SET_NW_TTL_NW_TTL] = {
+		.name = "nw_ttl",
+		.help = "IP TTL",
+		.next = NEXT(action_of_set_nw_ttl, NEXT_ENTRY(UNSIGNED)),
+		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_of_set_nw_ttl,
+					nw_ttl)),
 		.call = parse_vc_conf,
 	},
 	[ACTION_OF_DEC_NW_TTL] = {
@@ -5489,6 +2937,20 @@
 		.next = NEXT(NEXT_ENTRY(ACTION_NEXT)),
 		.call = parse_vc,
 	},
+	[ACTION_OF_COPY_TTL_OUT] = {
+		.name = "of_copy_ttl_out",
+		.help = "OpenFlow's OFPAT_COPY_TTL_OUT",
+		.priv = PRIV_ACTION(OF_COPY_TTL_OUT, 0),
+		.next = NEXT(NEXT_ENTRY(ACTION_NEXT)),
+		.call = parse_vc,
+	},
+	[ACTION_OF_COPY_TTL_IN] = {
+		.name = "of_copy_ttl_in",
+		.help = "OpenFlow's OFPAT_COPY_TTL_IN",
+		.priv = PRIV_ACTION(OF_COPY_TTL_IN, 0),
+		.next = NEXT(NEXT_ENTRY(ACTION_NEXT)),
+		.call = parse_vc,
+	},
 	[ACTION_OF_POP_VLAN] = {
 		.name = "of_pop_vlan",
 		.help = "OpenFlow's OFPAT_POP_VLAN",
@@ -5508,7 +2970,7 @@
 	[ACTION_OF_PUSH_VLAN_ETHERTYPE] = {
 		.name = "ethertype",
 		.help = "EtherType",
-		.next = NEXT(action_of_push_vlan, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_of_push_vlan, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_of_push_vlan,
 			      ethertype)),
@@ -5526,8 +2988,7 @@
 	[ACTION_OF_SET_VLAN_VID_VLAN_VID] = {
 		.name = "vlan_vid",
 		.help = "VLAN id",
-		.next = NEXT(action_of_set_vlan_vid,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_of_set_vlan_vid, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_of_set_vlan_vid,
 			      vlan_vid)),
@@ -5545,8 +3006,7 @@
 	[ACTION_OF_SET_VLAN_PCP_VLAN_PCP] = {
 		.name = "vlan_pcp",
 		.help = "VLAN priority",
-		.next = NEXT(action_of_set_vlan_pcp,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_of_set_vlan_pcp, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_of_set_vlan_pcp,
 			      vlan_pcp)),
@@ -5563,7 +3023,7 @@
 	[ACTION_OF_POP_MPLS_ETHERTYPE] = {
 		.name = "ethertype",
 		.help = "EtherType",
-		.next = NEXT(action_of_pop_mpls, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_of_pop_mpls, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_of_pop_mpls,
 			      ethertype)),
@@ -5581,7 +3041,7 @@
 	[ACTION_OF_PUSH_MPLS_ETHERTYPE] = {
 		.name = "ethertype",
 		.help = "EtherType",
-		.next = NEXT(action_of_push_mpls, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_of_push_mpls, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_of_push_mpls,
 			      ethertype)),
@@ -5689,7 +3149,7 @@
 	[ACTION_SET_IPV4_SRC_IPV4_SRC] = {
 		.name = "ipv4_addr",
 		.help = "new IPv4 source address to set",
-		.next = NEXT(action_set_ipv4_src, NEXT_ENTRY(COMMON_IPV4_ADDR)),
+		.next = NEXT(action_set_ipv4_src, NEXT_ENTRY(IPV4_ADDR)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			(struct rte_flow_action_set_ipv4, ipv4_addr)),
 		.call = parse_vc_conf,
@@ -5706,7 +3166,7 @@
 	[ACTION_SET_IPV4_DST_IPV4_DST] = {
 		.name = "ipv4_addr",
 		.help = "new IPv4 destination address to set",
-		.next = NEXT(action_set_ipv4_dst, NEXT_ENTRY(COMMON_IPV4_ADDR)),
+		.next = NEXT(action_set_ipv4_dst, NEXT_ENTRY(IPV4_ADDR)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			(struct rte_flow_action_set_ipv4, ipv4_addr)),
 		.call = parse_vc_conf,
@@ -5723,7 +3183,7 @@
 	[ACTION_SET_IPV6_SRC_IPV6_SRC] = {
 		.name = "ipv6_addr",
 		.help = "new IPv6 source address to set",
-		.next = NEXT(action_set_ipv6_src, NEXT_ENTRY(COMMON_IPV6_ADDR)),
+		.next = NEXT(action_set_ipv6_src, NEXT_ENTRY(IPV6_ADDR)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			(struct rte_flow_action_set_ipv6, ipv6_addr)),
 		.call = parse_vc_conf,
@@ -5740,7 +3200,7 @@
 	[ACTION_SET_IPV6_DST_IPV6_DST] = {
 		.name = "ipv6_addr",
 		.help = "new IPv6 destination address to set",
-		.next = NEXT(action_set_ipv6_dst, NEXT_ENTRY(COMMON_IPV6_ADDR)),
+		.next = NEXT(action_set_ipv6_dst, NEXT_ENTRY(IPV6_ADDR)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			(struct rte_flow_action_set_ipv6, ipv6_addr)),
 		.call = parse_vc_conf,
@@ -5757,7 +3217,7 @@
 	[ACTION_SET_TP_SRC_TP_SRC] = {
 		.name = "port",
 		.help = "new source port number to set",
-		.next = NEXT(action_set_tp_src, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_set_tp_src, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_set_tp, port)),
 		.call = parse_vc_conf,
@@ -5774,7 +3234,7 @@
 	[ACTION_SET_TP_DST_TP_DST] = {
 		.name = "port",
 		.help = "new destination port number to set",
-		.next = NEXT(action_set_tp_dst, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_set_tp_dst, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_set_tp, port)),
 		.call = parse_vc_conf,
@@ -5805,7 +3265,7 @@
 	[ACTION_SET_TTL_TTL] = {
 		.name = "ttl_value",
 		.help = "new ttl value to set",
-		.next = NEXT(action_set_ttl, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_set_ttl, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_set_ttl, ttl_value)),
 		.call = parse_vc_conf,
@@ -5821,7 +3281,7 @@
 	[ACTION_SET_MAC_SRC_MAC_SRC] = {
 		.name = "mac_addr",
 		.help = "new source mac address",
-		.next = NEXT(action_set_mac_src, NEXT_ENTRY(COMMON_MAC_ADDR)),
+		.next = NEXT(action_set_mac_src, NEXT_ENTRY(MAC_ADDR)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_set_mac, mac_addr)),
 		.call = parse_vc_conf,
@@ -5837,7 +3297,7 @@
 	[ACTION_SET_MAC_DST_MAC_DST] = {
 		.name = "mac_addr",
 		.help = "new destination mac address to set",
-		.next = NEXT(action_set_mac_dst, NEXT_ENTRY(COMMON_MAC_ADDR)),
+		.next = NEXT(action_set_mac_dst, NEXT_ENTRY(MAC_ADDR)),
 		.args = ARGS(ARGS_ENTRY_HTON
 			     (struct rte_flow_action_set_mac, mac_addr)),
 		.call = parse_vc_conf,
@@ -5852,7 +3312,7 @@
 	[ACTION_INC_TCP_SEQ_VALUE] = {
 		.name = "value",
 		.help = "the value to increase TCP sequence number by",
-		.next = NEXT(action_inc_tcp_seq, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_inc_tcp_seq, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARG_ENTRY_HTON(rte_be32_t)),
 		.call = parse_vc_conf,
 	},
@@ -5866,7 +3326,7 @@
 	[ACTION_DEC_TCP_SEQ_VALUE] = {
 		.name = "value",
 		.help = "the value to decrease TCP sequence number by",
-		.next = NEXT(action_dec_tcp_seq, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_dec_tcp_seq, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARG_ENTRY_HTON(rte_be32_t)),
 		.call = parse_vc_conf,
 	},
@@ -5880,7 +3340,7 @@
 	[ACTION_INC_TCP_ACK_VALUE] = {
 		.name = "value",
 		.help = "the value to increase TCP acknowledgment number by",
-		.next = NEXT(action_inc_tcp_ack, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_inc_tcp_ack, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARG_ENTRY_HTON(rte_be32_t)),
 		.call = parse_vc_conf,
 	},
@@ -5894,7 +3354,7 @@
 	[ACTION_DEC_TCP_ACK_VALUE] = {
 		.name = "value",
 		.help = "the value to decrease TCP acknowledgment number by",
-		.next = NEXT(action_dec_tcp_ack, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_dec_tcp_ack, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARG_ENTRY_HTON(rte_be32_t)),
 		.call = parse_vc_conf,
 	},
@@ -5940,138 +3400,14 @@
 		.call = parse_vc_action_raw_decap_index,
 		.comp = comp_set_raw_index,
 	},
-	[ACTION_MODIFY_FIELD] = {
-		.name = "modify_field",
-		.help = "modify destination field with data from source field",
-		.priv = PRIV_ACTION(MODIFY_FIELD, ACTION_MODIFY_SIZE),
-		.next = NEXT(NEXT_ENTRY(ACTION_MODIFY_FIELD_OP)),
-		.call = parse_vc,
-	},
-	[ACTION_MODIFY_FIELD_OP] = {
-		.name = "op",
-		.help = "operation type",
-		.next = NEXT(NEXT_ENTRY(ACTION_MODIFY_FIELD_DST_TYPE),
-			NEXT_ENTRY(ACTION_MODIFY_FIELD_OP_VALUE)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_MODIFY_FIELD_OP_VALUE] = {
-		.name = "{operation}",
-		.help = "operation type value",
-		.call = parse_vc_modify_field_op,
-		.comp = comp_set_modify_field_op,
-	},
-	[ACTION_MODIFY_FIELD_DST_TYPE] = {
-		.name = "dst_type",
-		.help = "destination field type",
-		.next = NEXT(action_modify_field_dst,
-			NEXT_ENTRY(ACTION_MODIFY_FIELD_DST_TYPE_VALUE)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_MODIFY_FIELD_DST_TYPE_VALUE] = {
-		.name = "{dst_type}",
-		.help = "destination field type value",
-		.call = parse_vc_modify_field_id,
-		.comp = comp_set_modify_field_id,
-	},
-	[ACTION_MODIFY_FIELD_DST_LEVEL] = {
-		.name = "dst_level",
-		.help = "destination field level",
-		.next = NEXT(action_modify_field_dst,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_modify_field,
-					dst.level)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_MODIFY_FIELD_DST_OFFSET] = {
-		.name = "dst_offset",
-		.help = "destination field bit offset",
-		.next = NEXT(action_modify_field_dst,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_modify_field,
-					dst.offset)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_MODIFY_FIELD_SRC_TYPE] = {
-		.name = "src_type",
-		.help = "source field type",
-		.next = NEXT(action_modify_field_src,
-			NEXT_ENTRY(ACTION_MODIFY_FIELD_SRC_TYPE_VALUE)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_MODIFY_FIELD_SRC_TYPE_VALUE] = {
-		.name = "{src_type}",
-		.help = "source field type value",
-		.call = parse_vc_modify_field_id,
-		.comp = comp_set_modify_field_id,
-	},
-	[ACTION_MODIFY_FIELD_SRC_LEVEL] = {
-		.name = "src_level",
-		.help = "source field level",
-		.next = NEXT(action_modify_field_src,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_modify_field,
-					src.level)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_MODIFY_FIELD_SRC_OFFSET] = {
-		.name = "src_offset",
-		.help = "source field bit offset",
-		.next = NEXT(action_modify_field_src,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_modify_field,
-					src.offset)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_MODIFY_FIELD_SRC_VALUE] = {
-		.name = "src_value",
-		.help = "source immediate value",
-		.next = NEXT(NEXT_ENTRY(ACTION_MODIFY_FIELD_WIDTH),
-			     NEXT_ENTRY(COMMON_HEX)),
-		.args = ARGS(ARGS_ENTRY_ARB(0, 0),
-			     ARGS_ENTRY_ARB(0, 0),
-			     ARGS_ENTRY(struct rte_flow_action_modify_field,
-					src.value)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_MODIFY_FIELD_SRC_POINTER] = {
-		.name = "src_ptr",
-		.help = "pointer to source immediate value",
-		.next = NEXT(NEXT_ENTRY(ACTION_MODIFY_FIELD_WIDTH),
-			     NEXT_ENTRY(COMMON_HEX)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_modify_field,
-					src.pvalue),
-			     ARGS_ENTRY_ARB(0, 0),
-			     ARGS_ENTRY_ARB
-				(sizeof(struct rte_flow_action_modify_field),
-				 ACTION_MODIFY_PATTERN_SIZE)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_MODIFY_FIELD_WIDTH] = {
-		.name = "width",
-		.help = "number of bits to copy",
-		.next = NEXT(NEXT_ENTRY(ACTION_NEXT),
-			NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_modify_field,
-					width)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_SEND_TO_KERNEL] = {
-		.name = "send_to_kernel",
-		.help = "send packets to kernel",
-		.priv = PRIV_ACTION(SEND_TO_KERNEL, 0),
-		.next = NEXT(NEXT_ENTRY(ACTION_NEXT)),
-		.call = parse_vc,
-	},
 	/* Top level command. */
 	[SET] = {
 		.name = "set",
-		.help = "set raw encap/decap/sample data",
-		.type = "set raw_encap|raw_decap <index> <pattern>"
-				" or set sample_actions <index> <action>",
+		.help = "set raw encap/decap data",
+		.type = "set raw_encap|raw_decap <index> <pattern>",
 		.next = NEXT(NEXT_ENTRY
 			     (SET_RAW_ENCAP,
-			      SET_RAW_DECAP,
-			      SET_SAMPLE_ACTIONS)),
+			      SET_RAW_DECAP)),
 		.call = parse_set_init,
 	},
 	/* Sub-level commands. */
@@ -6097,28 +3433,11 @@
 	},
 	[SET_RAW_INDEX] = {
 		.name = "{index}",
-		.type = "COMMON_UNSIGNED",
+		.type = "UNSIGNED",
 		.help = "index of raw_encap/raw_decap data",
 		.next = NEXT(next_item),
 		.call = parse_port,
 	},
-	[SET_SAMPLE_INDEX] = {
-		.name = "{index}",
-		.type = "UNSIGNED",
-		.help = "index of sample actions",
-		.next = NEXT(next_action_sample),
-		.call = parse_port,
-	},
-	[SET_SAMPLE_ACTIONS] = {
-		.name = "sample_actions",
-		.help = "set sample actions list",
-		.next = NEXT(NEXT_ENTRY(SET_SAMPLE_INDEX)),
-		.args = ARGS(ARGS_ENTRY_ARB_BOUNDED
-				(offsetof(struct buffer, port),
-				 sizeof(((struct buffer *)0)->port),
-				 0, RAW_SAMPLE_CONFS_MAX_NUM - 1)),
-		.call = parse_set_sample_action,
-	},
 	[ACTION_SET_TAG] = {
 		.name = "set_tag",
 		.help = "set tag",
@@ -6130,14 +3449,14 @@
 	[ACTION_SET_TAG_INDEX] = {
 		.name = "index",
 		.help = "index of tag array",
-		.next = NEXT(action_set_tag, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_set_tag, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_set_tag, index)),
 		.call = parse_vc_conf,
 	},
 	[ACTION_SET_TAG_DATA] = {
 		.name = "data",
 		.help = "tag value",
-		.next = NEXT(action_set_tag, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_set_tag, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY
 			     (struct rte_flow_action_set_tag, data)),
 		.call = parse_vc_conf,
@@ -6145,7 +3464,7 @@
 	[ACTION_SET_TAG_MASK] = {
 		.name = "mask",
 		.help = "mask for tag value",
-		.next = NEXT(action_set_tag, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_set_tag, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY
 			     (struct rte_flow_action_set_tag, mask)),
 		.call = parse_vc_conf,
@@ -6161,7 +3480,7 @@
 	[ACTION_SET_META_DATA] = {
 		.name = "data",
 		.help = "metadata value",
-		.next = NEXT(action_set_meta, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_set_meta, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY
 			     (struct rte_flow_action_set_meta, data)),
 		.call = parse_vc_conf,
@@ -6169,281 +3488,11 @@
 	[ACTION_SET_META_MASK] = {
 		.name = "mask",
 		.help = "mask for metadata value",
-		.next = NEXT(action_set_meta, NEXT_ENTRY(COMMON_UNSIGNED)),
+		.next = NEXT(action_set_meta, NEXT_ENTRY(UNSIGNED)),
 		.args = ARGS(ARGS_ENTRY
 			     (struct rte_flow_action_set_meta, mask)),
 		.call = parse_vc_conf,
 	},
-	[ACTION_SET_IPV4_DSCP] = {
-		.name = "set_ipv4_dscp",
-		.help = "set DSCP value",
-		.priv = PRIV_ACTION(SET_IPV4_DSCP,
-			sizeof(struct rte_flow_action_set_dscp)),
-		.next = NEXT(action_set_ipv4_dscp),
-		.call = parse_vc,
-	},
-	[ACTION_SET_IPV4_DSCP_VALUE] = {
-		.name = "dscp_value",
-		.help = "new IPv4 DSCP value to set",
-		.next = NEXT(action_set_ipv4_dscp, NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY
-			     (struct rte_flow_action_set_dscp, dscp)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_SET_IPV6_DSCP] = {
-		.name = "set_ipv6_dscp",
-		.help = "set DSCP value",
-		.priv = PRIV_ACTION(SET_IPV6_DSCP,
-			sizeof(struct rte_flow_action_set_dscp)),
-		.next = NEXT(action_set_ipv6_dscp),
-		.call = parse_vc,
-	},
-	[ACTION_SET_IPV6_DSCP_VALUE] = {
-		.name = "dscp_value",
-		.help = "new IPv6 DSCP value to set",
-		.next = NEXT(action_set_ipv6_dscp, NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY
-			     (struct rte_flow_action_set_dscp, dscp)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_AGE] = {
-		.name = "age",
-		.help = "set a specific metadata header",
-		.next = NEXT(action_age),
-		.priv = PRIV_ACTION(AGE,
-			sizeof(struct rte_flow_action_age)),
-		.call = parse_vc,
-	},
-	[ACTION_AGE_TIMEOUT] = {
-		.name = "timeout",
-		.help = "flow age timeout value",
-		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_action_age,
-					   timeout, 24)),
-		.next = NEXT(action_age, NEXT_ENTRY(COMMON_UNSIGNED)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_AGE_UPDATE] = {
-		.name = "age_update",
-		.help = "update aging parameter",
-		.next = NEXT(action_age_update),
-		.priv = PRIV_ACTION(AGE,
-				    sizeof(struct rte_flow_update_age)),
-		.call = parse_vc,
-	},
-	[ACTION_AGE_UPDATE_TIMEOUT] = {
-		.name = "timeout",
-		.help = "age timeout update value",
-		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_update_age,
-					   timeout, 24)),
-		.next = NEXT(action_age_update, NEXT_ENTRY(COMMON_UNSIGNED)),
-		.call = parse_vc_conf_timeout,
-	},
-	[ACTION_AGE_UPDATE_TOUCH] = {
-		.name = "touch",
-		.help = "this flow is touched",
-		.next = NEXT(action_age_update, NEXT_ENTRY(COMMON_BOOLEAN)),
-		.args = ARGS(ARGS_ENTRY_BF(struct rte_flow_update_age,
-					   touch, 1)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_SAMPLE] = {
-		.name = "sample",
-		.help = "set a sample action",
-		.next = NEXT(action_sample),
-		.priv = PRIV_ACTION(SAMPLE,
-			sizeof(struct action_sample_data)),
-		.call = parse_vc_action_sample,
-	},
-	[ACTION_SAMPLE_RATIO] = {
-		.name = "ratio",
-		.help = "flow sample ratio value",
-		.next = NEXT(action_sample, NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY_ARB
-			     (offsetof(struct action_sample_data, conf) +
-			      offsetof(struct rte_flow_action_sample, ratio),
-			      sizeof(((struct rte_flow_action_sample *)0)->
-				     ratio))),
-	},
-	[ACTION_SAMPLE_INDEX] = {
-		.name = "index",
-		.help = "the index of sample actions list",
-		.next = NEXT(NEXT_ENTRY(ACTION_SAMPLE_INDEX_VALUE)),
-	},
-	[ACTION_SAMPLE_INDEX_VALUE] = {
-		.name = "{index}",
-		.type = "COMMON_UNSIGNED",
-		.help = "unsigned integer value",
-		.next = NEXT(NEXT_ENTRY(ACTION_NEXT)),
-		.call = parse_vc_action_sample_index,
-		.comp = comp_set_sample_index,
-	},
-	[ACTION_CONNTRACK] = {
-		.name = "conntrack",
-		.help = "create a conntrack object",
-		.next = NEXT(NEXT_ENTRY(ACTION_NEXT)),
-		.priv = PRIV_ACTION(CONNTRACK,
-				    sizeof(struct rte_flow_action_conntrack)),
-		.call = parse_vc,
-	},
-	[ACTION_CONNTRACK_UPDATE] = {
-		.name = "conntrack_update",
-		.help = "update a conntrack object",
-		.next = NEXT(action_update_conntrack),
-		.priv = PRIV_ACTION(CONNTRACK,
-				    sizeof(struct rte_flow_modify_conntrack)),
-		.call = parse_vc,
-	},
-	[ACTION_CONNTRACK_UPDATE_DIR] = {
-		.name = "dir",
-		.help = "update a conntrack object direction",
-		.next = NEXT(action_update_conntrack),
-		.call = parse_vc_action_conntrack_update,
-	},
-	[ACTION_CONNTRACK_UPDATE_CTX] = {
-		.name = "ctx",
-		.help = "update a conntrack object context",
-		.next = NEXT(action_update_conntrack),
-		.call = parse_vc_action_conntrack_update,
-	},
-	[ACTION_PORT_REPRESENTOR] = {
-		.name = "port_representor",
-		.help = "at embedded switch level, send matching traffic to the given ethdev",
-		.priv = PRIV_ACTION(PORT_REPRESENTOR,
-				    sizeof(struct rte_flow_action_ethdev)),
-		.next = NEXT(action_port_representor),
-		.call = parse_vc,
-	},
-	[ACTION_PORT_REPRESENTOR_PORT_ID] = {
-		.name = "port_id",
-		.help = "ethdev port ID",
-		.next = NEXT(action_port_representor,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_ethdev,
-					port_id)),
-		.call = parse_vc_conf,
-	},
-	[ACTION_REPRESENTED_PORT] = {
-		.name = "represented_port",
-		.help = "at embedded switch level, send matching traffic to the entity represented by the given ethdev",
-		.priv = PRIV_ACTION(REPRESENTED_PORT,
-				sizeof(struct rte_flow_action_ethdev)),
-		.next = NEXT(action_represented_port),
-		.call = parse_vc,
-	},
-	[ACTION_REPRESENTED_PORT_ETHDEV_PORT_ID] = {
-		.name = "ethdev_port_id",
-		.help = "ethdev port ID",
-		.next = NEXT(action_represented_port,
-			     NEXT_ENTRY(COMMON_UNSIGNED)),
-		.args = ARGS(ARGS_ENTRY(struct rte_flow_action_ethdev,
-					port_id)),
-		.call = parse_vc_conf,
-	},
-	/* Indirect action destroy arguments. */
-	[INDIRECT_ACTION_DESTROY_ID] = {
-		.name = "action_id",
-		.help = "specify a indirect action id to destroy",
-		.next = NEXT(next_ia_destroy_attr,
-			     NEXT_ENTRY(COMMON_INDIRECT_ACTION_ID)),
-		.args = ARGS(ARGS_ENTRY_PTR(struct buffer,
-					    args.ia_destroy.action_id)),
-		.call = parse_ia_destroy,
-	},
-	/* Indirect action create arguments. */
-	[INDIRECT_ACTION_CREATE_ID] = {
-		.name = "action_id",
-		.help = "specify a indirect action id to create",
-		.next = NEXT(next_ia_create_attr,
-			     NEXT_ENTRY(COMMON_INDIRECT_ACTION_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.vc.attr.group)),
-	},
-	[ACTION_INDIRECT] = {
-		.name = "indirect",
-		.help = "apply indirect action by id",
-		.priv = PRIV_ACTION(INDIRECT, 0),
-		.next = NEXT(NEXT_ENTRY(INDIRECT_ACTION_ID2PTR)),
-		.args = ARGS(ARGS_ENTRY_ARB(0, sizeof(uint32_t))),
-		.call = parse_vc,
-	},
-	[INDIRECT_ACTION_ID2PTR] = {
-		.name = "{action_id}",
-		.type = "INDIRECT_ACTION_ID",
-		.help = "indirect action id",
-		.next = NEXT(NEXT_ENTRY(ACTION_NEXT)),
-		.call = parse_ia_id2ptr,
-		.comp = comp_none,
-	},
-	[INDIRECT_ACTION_INGRESS] = {
-		.name = "ingress",
-		.help = "affect rule to ingress",
-		.next = NEXT(next_ia_create_attr),
-		.call = parse_ia,
-	},
-	[INDIRECT_ACTION_EGRESS] = {
-		.name = "egress",
-		.help = "affect rule to egress",
-		.next = NEXT(next_ia_create_attr),
-		.call = parse_ia,
-	},
-	[INDIRECT_ACTION_TRANSFER] = {
-		.name = "transfer",
-		.help = "affect rule to transfer",
-		.next = NEXT(next_ia_create_attr),
-		.call = parse_ia,
-	},
-	[INDIRECT_ACTION_SPEC] = {
-		.name = "action",
-		.help = "specify action to create indirect handle",
-		.next = NEXT(next_action),
-	},
-	[ACTION_POL_G] = {
-		.name = "g_actions",
-		.help = "submit a list of associated actions for green",
-		.next = NEXT(next_action),
-		.call = parse_mp,
-	},
-	[ACTION_POL_Y] = {
-		.name = "y_actions",
-		.help = "submit a list of associated actions for yellow",
-		.next = NEXT(next_action),
-	},
-	[ACTION_POL_R] = {
-		.name = "r_actions",
-		.help = "submit a list of associated actions for red",
-		.next = NEXT(next_action),
-	},
-
-	/* Top-level command. */
-	[ADD] = {
-		.name = "add",
-		.type = "port meter policy {port_id} {arg}",
-		.help = "add port meter policy",
-		.next = NEXT(NEXT_ENTRY(ITEM_POL_PORT)),
-		.call = parse_init,
-	},
-	/* Sub-level commands. */
-	[ITEM_POL_PORT] = {
-		.name = "port",
-		.help = "add port meter policy",
-		.next = NEXT(NEXT_ENTRY(ITEM_POL_METER)),
-	},
-	[ITEM_POL_METER] = {
-		.name = "meter",
-		.help = "add port meter policy",
-		.next = NEXT(NEXT_ENTRY(ITEM_POL_POLICY)),
-	},
-	[ITEM_POL_POLICY] = {
-		.name = "policy",
-		.help = "add port meter policy",
-		.next = NEXT(NEXT_ENTRY(ACTION_POL_R),
-				NEXT_ENTRY(ACTION_POL_Y),
-				NEXT_ENTRY(ACTION_POL_G),
-				NEXT_ENTRY(COMMON_POLICY_ID),
-				NEXT_ENTRY(COMMON_PORT_ID)),
-		.args = ARGS(ARGS_ENTRY(struct buffer, args.policy.policy_id),
-				ARGS_ENTRY(struct buffer, port)),
-		.call = parse_mp,
-	},
 };
 
 /** Remove and return last entry from argument stack. */
@@ -6628,247 +3677,6 @@
 	return len;
 }
 
-/** Parse tokens for indirect action commands. */
-static int
-parse_ia(struct context *ctx, const struct token *token,
-	 const char *str, unsigned int len,
-	 void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != INDIRECT_ACTION)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.vc.data = (uint8_t *)out + size;
-		return len;
-	}
-	switch (ctx->curr) {
-	case INDIRECT_ACTION_CREATE:
-	case INDIRECT_ACTION_UPDATE:
-		out->args.vc.actions =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		out->args.vc.attr.group = UINT32_MAX;
-		/* fallthrough */
-	case INDIRECT_ACTION_QUERY:
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	case INDIRECT_ACTION_EGRESS:
-		out->args.vc.attr.egress = 1;
-		return len;
-	case INDIRECT_ACTION_INGRESS:
-		out->args.vc.attr.ingress = 1;
-		return len;
-	case INDIRECT_ACTION_TRANSFER:
-		out->args.vc.attr.transfer = 1;
-		return len;
-	default:
-		return -1;
-	}
-}
-
-
-/** Parse tokens for indirect action destroy command. */
-static int
-parse_ia_destroy(struct context *ctx, const struct token *token,
-		 const char *str, unsigned int len,
-		 void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-	uint32_t *action_id;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command || out->command == INDIRECT_ACTION) {
-		if (ctx->curr != INDIRECT_ACTION_DESTROY)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.ia_destroy.action_id =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		return len;
-	}
-	action_id = out->args.ia_destroy.action_id
-		    + out->args.ia_destroy.action_id_n++;
-	if ((uint8_t *)action_id > (uint8_t *)out + size)
-		return -1;
-	ctx->objdata = 0;
-	ctx->object = action_id;
-	ctx->objmask = NULL;
-	return len;
-}
-
-/** Parse tokens for indirect action commands. */
-static int
-parse_qia(struct context *ctx, const struct token *token,
-	  const char *str, unsigned int len,
-	  void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != QUEUE)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->args.vc.data = (uint8_t *)out + size;
-		return len;
-	}
-	switch (ctx->curr) {
-	case QUEUE_INDIRECT_ACTION:
-		return len;
-	case QUEUE_INDIRECT_ACTION_CREATE:
-	case QUEUE_INDIRECT_ACTION_UPDATE:
-		out->args.vc.actions =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		out->args.vc.attr.group = UINT32_MAX;
-		/* fallthrough */
-	case QUEUE_INDIRECT_ACTION_QUERY:
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	case QUEUE_INDIRECT_ACTION_EGRESS:
-		out->args.vc.attr.egress = 1;
-		return len;
-	case QUEUE_INDIRECT_ACTION_INGRESS:
-		out->args.vc.attr.ingress = 1;
-		return len;
-	case QUEUE_INDIRECT_ACTION_TRANSFER:
-		out->args.vc.attr.transfer = 1;
-		return len;
-	case QUEUE_INDIRECT_ACTION_CREATE_POSTPONE:
-		return len;
-	default:
-		return -1;
-	}
-}
-
-/** Parse tokens for indirect action destroy command. */
-static int
-parse_qia_destroy(struct context *ctx, const struct token *token,
-		  const char *str, unsigned int len,
-		  void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-	uint32_t *action_id;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command || out->command == QUEUE) {
-		if (ctx->curr != QUEUE_INDIRECT_ACTION_DESTROY)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.ia_destroy.action_id =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		return len;
-	}
-	switch (ctx->curr) {
-	case QUEUE_INDIRECT_ACTION:
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	case QUEUE_INDIRECT_ACTION_DESTROY_ID:
-		action_id = out->args.ia_destroy.action_id
-				+ out->args.ia_destroy.action_id_n++;
-		if ((uint8_t *)action_id > (uint8_t *)out + size)
-			return -1;
-		ctx->objdata = 0;
-		ctx->object = action_id;
-		ctx->objmask = NULL;
-		return len;
-	case QUEUE_INDIRECT_ACTION_DESTROY_POSTPONE:
-		return len;
-	default:
-		return -1;
-	}
-}
-
-/** Parse tokens for meter policy action commands. */
-static int
-parse_mp(struct context *ctx, const struct token *token,
-	const char *str, unsigned int len,
-	void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != ITEM_POL_POLICY)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.vc.data = (uint8_t *)out + size;
-		return len;
-	}
-	switch (ctx->curr) {
-	case ACTION_POL_G:
-		out->args.vc.actions =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					sizeof(double));
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	default:
-		return -1;
-	}
-}
-
 /** Parse tokens for validate/create commands. */
 static int
 parse_vc(struct context *ctx, const struct token *token,
@@ -6886,9 +3694,7 @@
 	if (!out)
 		return len;
 	if (!out->command) {
-		if (ctx->curr != VALIDATE && ctx->curr != CREATE &&
-		    ctx->curr != PATTERN_TEMPLATE_CREATE &&
-		    ctx->curr != ACTIONS_TEMPLATE_CREATE)
+		if (ctx->curr != VALIDATE && ctx->curr != CREATE)
 			return -1;
 		if (sizeof(*out) > size)
 			return -1;
@@ -6900,52 +3706,28 @@
 		return len;
 	}
 	ctx->objdata = 0;
-	switch (ctx->curr) {
-	default:
-		ctx->object = &out->args.vc.attr;
-		break;
-	case VC_TUNNEL_SET:
-	case VC_TUNNEL_MATCH:
-		ctx->object = &out->args.vc.tunnel_ops;
-		break;
-	}
+	ctx->object = &out->args.vc.attr;
 	ctx->objmask = NULL;
 	switch (ctx->curr) {
-	case VC_GROUP:
-	case VC_PRIORITY:
-		return len;
-	case VC_TUNNEL_SET:
-		out->args.vc.tunnel_ops.enabled = 1;
-		out->args.vc.tunnel_ops.actions = 1;
-		return len;
-	case VC_TUNNEL_MATCH:
-		out->args.vc.tunnel_ops.enabled = 1;
-		out->args.vc.tunnel_ops.items = 1;
+	case GROUP:
+	case PRIORITY:
 		return len;
-	case VC_INGRESS:
+	case INGRESS:
 		out->args.vc.attr.ingress = 1;
 		return len;
-	case VC_EGRESS:
+	case EGRESS:
 		out->args.vc.attr.egress = 1;
 		return len;
-	case VC_TRANSFER:
+	case TRANSFER:
 		out->args.vc.attr.transfer = 1;
 		return len;
-	case ITEM_PATTERN:
+	case PATTERN:
 		out->args.vc.pattern =
 			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
 					       sizeof(double));
 		ctx->object = out->args.vc.pattern;
 		ctx->objmask = NULL;
 		return len;
-	case ITEM_END:
-		if ((out->command == VALIDATE || out->command == CREATE) &&
-		    ctx->last)
-			return -1;
-		if (out->command == PATTERN_TEMPLATE_CREATE &&
-		    !ctx->last)
-			return -1;
-		break;
 	case ACTIONS:
 		out->args.vc.actions =
 			(void *)RTE_ALIGN_CEIL((uintptr_t)
@@ -7020,7 +3802,7 @@
 		return -1;
 	/* Parse parameter types. */
 	switch (ctx->curr) {
-		static const enum index prefix[] = NEXT_ENTRY(COMMON_PREFIX);
+		static const enum index prefix[] = NEXT_ENTRY(PREFIX);
 
 	case ITEM_PARAM_IS:
 		index = 0;
@@ -7085,187 +3867,6 @@
 	return len;
 }
 
-/** Parse action configuration field. */
-static int
-parse_vc_conf_timeout(struct context *ctx, const struct token *token,
-		      const char *str, unsigned int len,
-		      void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-	struct rte_flow_update_age *update;
-
-	(void)size;
-	if (ctx->curr != ACTION_AGE_UPDATE_TIMEOUT)
-		return -1;
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	/* Point to selected object. */
-	ctx->object = out->args.vc.data;
-	ctx->objmask = NULL;
-	/* Update the timeout is valid. */
-	update = (struct rte_flow_update_age *)out->args.vc.data;
-	update->timeout_valid = 1;
-	return len;
-}
-
-/** Parse eCPRI common header type field. */
-static int
-parse_vc_item_ecpri_type(struct context *ctx, const struct token *token,
-			 const char *str, unsigned int len,
-			 void *buf, unsigned int size)
-{
-	struct rte_flow_item_ecpri *ecpri;
-	struct rte_flow_item_ecpri *ecpri_mask;
-	struct rte_flow_item *item;
-	uint32_t data_size;
-	uint8_t msg_type;
-	struct buffer *out = buf;
-	const struct arg *arg;
-
-	(void)size;
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	switch (ctx->curr) {
-	case ITEM_ECPRI_COMMON_TYPE_IQ_DATA:
-		msg_type = RTE_ECPRI_MSG_TYPE_IQ_DATA;
-		break;
-	case ITEM_ECPRI_COMMON_TYPE_RTC_CTRL:
-		msg_type = RTE_ECPRI_MSG_TYPE_RTC_CTRL;
-		break;
-	case ITEM_ECPRI_COMMON_TYPE_DLY_MSR:
-		msg_type = RTE_ECPRI_MSG_TYPE_DLY_MSR;
-		break;
-	default:
-		return -1;
-	}
-	if (!ctx->object)
-		return len;
-	arg = pop_args(ctx);
-	if (!arg)
-		return -1;
-	ecpri = (struct rte_flow_item_ecpri *)out->args.vc.data;
-	ecpri->hdr.common.type = msg_type;
-	data_size = ctx->objdata / 3; /* spec, last, mask */
-	ecpri_mask = (struct rte_flow_item_ecpri *)(out->args.vc.data +
-						    (data_size * 2));
-	ecpri_mask->hdr.common.type = 0xFF;
-	if (arg->hton) {
-		ecpri->hdr.common.u32 = rte_cpu_to_be_32(ecpri->hdr.common.u32);
-		ecpri_mask->hdr.common.u32 =
-				rte_cpu_to_be_32(ecpri_mask->hdr.common.u32);
-	}
-	item = &out->args.vc.pattern[out->args.vc.pattern_n - 1];
-	item->spec = ecpri;
-	item->mask = ecpri_mask;
-	return len;
-}
-
-/** Parse L2TPv2 common header type field. */
-static int
-parse_vc_item_l2tpv2_type(struct context *ctx, const struct token *token,
-			 const char *str, unsigned int len,
-			 void *buf, unsigned int size)
-{
-	struct rte_flow_item_l2tpv2 *l2tpv2;
-	struct rte_flow_item_l2tpv2 *l2tpv2_mask;
-	struct rte_flow_item *item;
-	uint32_t data_size;
-	uint16_t msg_type = 0;
-	struct buffer *out = buf;
-	const struct arg *arg;
-
-	(void)size;
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	switch (ctx->curr) {
-	case ITEM_L2TPV2_TYPE_DATA:
-		msg_type |= RTE_L2TPV2_MSG_TYPE_DATA;
-		break;
-	case ITEM_L2TPV2_TYPE_DATA_L:
-		msg_type |= RTE_L2TPV2_MSG_TYPE_DATA_L;
-		break;
-	case ITEM_L2TPV2_TYPE_DATA_S:
-		msg_type |= RTE_L2TPV2_MSG_TYPE_DATA_S;
-		break;
-	case ITEM_L2TPV2_TYPE_DATA_O:
-		msg_type |= RTE_L2TPV2_MSG_TYPE_DATA_O;
-		break;
-	case ITEM_L2TPV2_TYPE_DATA_L_S:
-		msg_type |= RTE_L2TPV2_MSG_TYPE_DATA_L_S;
-		break;
-	case ITEM_L2TPV2_TYPE_CTRL:
-		msg_type |= RTE_L2TPV2_MSG_TYPE_CONTROL;
-		break;
-	default:
-		return -1;
-	}
-	if (!ctx->object)
-		return len;
-	arg = pop_args(ctx);
-	if (!arg)
-		return -1;
-	l2tpv2 = (struct rte_flow_item_l2tpv2 *)out->args.vc.data;
-	l2tpv2->hdr.common.flags_version |= msg_type;
-	data_size = ctx->objdata / 3; /* spec, last, mask */
-	l2tpv2_mask = (struct rte_flow_item_l2tpv2 *)(out->args.vc.data +
-						    (data_size * 2));
-	l2tpv2_mask->hdr.common.flags_version = 0xFFFF;
-	if (arg->hton) {
-		l2tpv2->hdr.common.flags_version =
-			rte_cpu_to_be_16(l2tpv2->hdr.common.flags_version);
-		l2tpv2_mask->hdr.common.flags_version =
-		    rte_cpu_to_be_16(l2tpv2_mask->hdr.common.flags_version);
-	}
-	item = &out->args.vc.pattern[out->args.vc.pattern_n - 1];
-	item->spec = l2tpv2;
-	item->mask = l2tpv2_mask;
-	return len;
-}
-
-/** Parse meter color action type. */
-static int
-parse_vc_action_meter_color_type(struct context *ctx, const struct token *token,
-				const char *str, unsigned int len,
-				void *buf, unsigned int size)
-{
-	struct rte_flow_action *action_data;
-	struct rte_flow_action_meter_color *conf;
-	enum rte_color color;
-
-	(void)buf;
-	(void)size;
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	switch (ctx->curr) {
-	case ACTION_METER_COLOR_GREEN:
-		color = RTE_COLOR_GREEN;
-	break;
-	case ACTION_METER_COLOR_YELLOW:
-		color = RTE_COLOR_YELLOW;
-	break;
-	case ACTION_METER_COLOR_RED:
-		color = RTE_COLOR_RED;
-	break;
-	default:
-		return -1;
-	}
-
-	if (!ctx->object)
-		return len;
-	action_data = ctx->object;
-	conf = (struct rte_flow_action_meter_color *)
-					(uintptr_t)(action_data->conf);
-	conf->color = color;
-	return len;
-}
-
 /** Parse RSS action. */
 static int
 parse_vc_action_rss(struct context *ctx, const struct token *token,
@@ -7297,15 +3898,30 @@
 			.func = RTE_ETH_HASH_FUNCTION_DEFAULT,
 			.level = 0,
 			.types = rss_hf,
-			.key_len = 0,
+			.key_len = sizeof(action_rss_data->key),
 			.queue_num = RTE_MIN(nb_rxq, ACTION_RSS_QUEUE_NUM),
-			.key = NULL,
+			.key = action_rss_data->key,
 			.queue = action_rss_data->queue,
 		},
+		.key = "testpmd's default RSS hash key, "
+			"override it for better balancing",
 		.queue = { 0 },
 	};
 	for (i = 0; i < action_rss_data->conf.queue_num; ++i)
 		action_rss_data->queue[i] = i;
+	if (!port_id_is_invalid(ctx->port, DISABLED_WARN) &&
+	    ctx->port != (portid_t)RTE_PORT_ALL) {
+		struct rte_eth_dev_info info;
+		int ret2;
+
+		ret2 = rte_eth_dev_info_get(ctx->port, &info);
+		if (ret2 != 0)
+			return ret2;
+
+		action_rss_data->conf.key_len =
+			RTE_MIN(sizeof(action_rss_data->key),
+				info.hash_key_size);
+	}
 	action->conf = &action_rss_data->conf;
 	return ret;
 }
@@ -7449,11 +4065,31 @@
 	return len;
 }
 
-/** Setup VXLAN encap configuration. */
+/** Parse VXLAN encap action. */
 static int
-parse_setup_vxlan_encap_data(struct action_vxlan_encap_data *action_vxlan_encap_data)
+parse_vc_action_vxlan_encap(struct context *ctx, const struct token *token,
+			    const char *str, unsigned int len,
+			    void *buf, unsigned int size)
 {
+	struct buffer *out = buf;
+	struct rte_flow_action *action;
+	struct action_vxlan_encap_data *action_vxlan_encap_data;
+	int ret;
+
+	ret = parse_vc(ctx, token, str, len, buf, size);
+	if (ret < 0)
+		return ret;
+	/* Nothing else to do if there is no buffer. */
+	if (!out)
+		return ret;
+	if (!out->args.vc.actions_n)
+		return -1;
+	action = &out->args.vc.actions[out->args.vc.actions_n - 1];
+	/* Point to selected object. */
+	ctx->object = out->args.vc.data;
+	ctx->objmask = NULL;
 	/* Set up default configuration. */
+	action_vxlan_encap_data = ctx->object;
 	*action_vxlan_encap_data = (struct action_vxlan_encap_data){
 		.conf = (struct rte_flow_action_vxlan_encap){
 			.definition = action_vxlan_encap_data->items,
@@ -7557,18 +4193,19 @@
 	}
 	memcpy(action_vxlan_encap_data->item_vxlan.vni, vxlan_encap_conf.vni,
 	       RTE_DIM(vxlan_encap_conf.vni));
-	return 0;
+	action->conf = &action_vxlan_encap_data->conf;
+	return ret;
 }
 
-/** Parse VXLAN encap action. */
+/** Parse NVGRE encap action. */
 static int
-parse_vc_action_vxlan_encap(struct context *ctx, const struct token *token,
+parse_vc_action_nvgre_encap(struct context *ctx, const struct token *token,
 			    const char *str, unsigned int len,
 			    void *buf, unsigned int size)
 {
 	struct buffer *out = buf;
 	struct rte_flow_action *action;
-	struct action_vxlan_encap_data *action_vxlan_encap_data;
+	struct action_nvgre_encap_data *action_nvgre_encap_data;
 	int ret;
 
 	ret = parse_vc(ctx, token, str, len, buf, size);
@@ -7583,17 +4220,8 @@
 	/* Point to selected object. */
 	ctx->object = out->args.vc.data;
 	ctx->objmask = NULL;
-	action_vxlan_encap_data = ctx->object;
-	parse_setup_vxlan_encap_data(action_vxlan_encap_data);
-	action->conf = &action_vxlan_encap_data->conf;
-	return ret;
-}
-
-/** Setup NVGRE encap configuration. */
-static int
-parse_setup_nvgre_encap_data(struct action_nvgre_encap_data *action_nvgre_encap_data)
-{
 	/* Set up default configuration. */
+	action_nvgre_encap_data = ctx->object;
 	*action_nvgre_encap_data = (struct action_nvgre_encap_data){
 		.conf = (struct rte_flow_action_nvgre_encap){
 			.definition = action_nvgre_encap_data->items,
@@ -7632,8 +4260,6 @@
 		       .src_addr = nvgre_encap_conf.ipv4_src,
 		       .dst_addr = nvgre_encap_conf.ipv4_dst,
 		},
-		.item_nvgre.c_k_s_rsvd0_ver = RTE_BE16(0x2000),
-		.item_nvgre.protocol = RTE_BE16(RTE_ETHER_TYPE_TEB),
 		.item_nvgre.flow_id = 0,
 	};
 	memcpy(action_nvgre_encap_data->item_eth.dst.addr_bytes,
@@ -7658,34 +4284,6 @@
 			RTE_FLOW_ITEM_TYPE_VOID;
 	memcpy(action_nvgre_encap_data->item_nvgre.tni, nvgre_encap_conf.tni,
 	       RTE_DIM(nvgre_encap_conf.tni));
-	return 0;
-}
-
-/** Parse NVGRE encap action. */
-static int
-parse_vc_action_nvgre_encap(struct context *ctx, const struct token *token,
-			    const char *str, unsigned int len,
-			    void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-	struct rte_flow_action *action;
-	struct action_nvgre_encap_data *action_nvgre_encap_data;
-	int ret;
-
-	ret = parse_vc(ctx, token, str, len, buf, size);
-	if (ret < 0)
-		return ret;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return ret;
-	if (!out->args.vc.actions_n)
-		return -1;
-	action = &out->args.vc.actions[out->args.vc.actions_n - 1];
-	/* Point to selected object. */
-	ctx->object = out->args.vc.data;
-	ctx->objmask = NULL;
-	action_nvgre_encap_data = ctx->object;
-	parse_setup_nvgre_encap_data(action_nvgre_encap_data);
 	action->conf = &action_nvgre_encap_data->conf;
 	return ret;
 }
@@ -7738,15 +4336,15 @@
 	       l2_encap_conf.eth_dst, RTE_ETHER_ADDR_LEN);
 	memcpy(eth.src.addr_bytes,
 	       l2_encap_conf.eth_src, RTE_ETHER_ADDR_LEN);
-	memcpy(header, &eth.hdr, sizeof(struct rte_ether_hdr));
-	header += sizeof(struct rte_ether_hdr);
+	memcpy(header, &eth, sizeof(eth));
+	header += sizeof(eth);
 	if (l2_encap_conf.select_vlan) {
 		if (l2_encap_conf.select_ipv4)
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4);
 		else
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV6);
-		memcpy(header, &vlan.hdr, sizeof(struct rte_vlan_hdr));
-		header += sizeof(struct rte_vlan_hdr);
+		memcpy(header, &vlan, sizeof(vlan));
+		header += sizeof(vlan);
 	}
 	action_encap_data->conf.size = header -
 		action_encap_data->data;
@@ -7794,11 +4392,11 @@
 	header = action_decap_data->data;
 	if (l2_decap_conf.select_vlan)
 		eth.type = rte_cpu_to_be_16(RTE_ETHER_TYPE_VLAN);
-	memcpy(header, &eth.hdr, sizeof(struct rte_ether_hdr));
-	header += sizeof(struct rte_ether_hdr);
+	memcpy(header, &eth, sizeof(eth));
+	header += sizeof(eth);
 	if (l2_decap_conf.select_vlan) {
-		memcpy(header, &vlan.hdr, sizeof(struct rte_vlan_hdr));
-		header += sizeof(struct rte_vlan_hdr);
+		memcpy(header, &vlan, sizeof(vlan));
+		header += sizeof(vlan);
 	}
 	action_decap_data->conf.size = header -
 		action_decap_data->data;
@@ -7840,9 +4438,7 @@
 	struct rte_flow_item_gre gre = {
 		.protocol = rte_cpu_to_be_16(ETHER_TYPE_MPLS_UNICAST),
 	};
-	struct rte_flow_item_mpls mpls = {
-		.ttl = 0,
-	};
+	struct rte_flow_item_mpls mpls;
 	uint8_t *header;
 	int ret;
 
@@ -7878,15 +4474,15 @@
 	       mplsogre_encap_conf.eth_dst, RTE_ETHER_ADDR_LEN);
 	memcpy(eth.src.addr_bytes,
 	       mplsogre_encap_conf.eth_src, RTE_ETHER_ADDR_LEN);
-	memcpy(header, &eth.hdr, sizeof(struct rte_ether_hdr));
-	header += sizeof(struct rte_ether_hdr);
+	memcpy(header, &eth, sizeof(eth));
+	header += sizeof(eth);
 	if (mplsogre_encap_conf.select_vlan) {
 		if (mplsogre_encap_conf.select_ipv4)
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4);
 		else
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV6);
-		memcpy(header, &vlan.hdr, sizeof(struct rte_vlan_hdr));
-		header += sizeof(struct rte_vlan_hdr);
+		memcpy(header, &vlan, sizeof(vlan));
+		header += sizeof(vlan);
 	}
 	if (mplsogre_encap_conf.select_ipv4) {
 		memcpy(header, &ipv4, sizeof(ipv4));
@@ -7973,15 +4569,15 @@
 	       mplsogre_encap_conf.eth_dst, RTE_ETHER_ADDR_LEN);
 	memcpy(eth.src.addr_bytes,
 	       mplsogre_encap_conf.eth_src, RTE_ETHER_ADDR_LEN);
-	memcpy(header, &eth.hdr, sizeof(struct rte_ether_hdr));
-	header += sizeof(struct rte_ether_hdr);
+	memcpy(header, &eth, sizeof(eth));
+	header += sizeof(eth);
 	if (mplsogre_encap_conf.select_vlan) {
 		if (mplsogre_encap_conf.select_ipv4)
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4);
 		else
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV6);
-		memcpy(header, &vlan.hdr, sizeof(struct rte_vlan_hdr));
-		header += sizeof(struct rte_vlan_hdr);
+		memcpy(header, &vlan, sizeof(vlan));
+		header += sizeof(vlan);
 	}
 	if (mplsogre_encap_conf.select_ipv4) {
 		memcpy(header, &ipv4, sizeof(ipv4));
@@ -8072,15 +4668,15 @@
 	       mplsoudp_encap_conf.eth_dst, RTE_ETHER_ADDR_LEN);
 	memcpy(eth.src.addr_bytes,
 	       mplsoudp_encap_conf.eth_src, RTE_ETHER_ADDR_LEN);
-	memcpy(header, &eth.hdr, sizeof(struct rte_ether_hdr));
-	header += sizeof(struct rte_ether_hdr);
+	memcpy(header, &eth, sizeof(eth));
+	header += sizeof(eth);
 	if (mplsoudp_encap_conf.select_vlan) {
 		if (mplsoudp_encap_conf.select_ipv4)
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4);
 		else
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV6);
-		memcpy(header, &vlan.hdr, sizeof(struct rte_vlan_hdr));
-		header += sizeof(struct rte_vlan_hdr);
+		memcpy(header, &vlan, sizeof(vlan));
+		header += sizeof(vlan);
 	}
 	if (mplsoudp_encap_conf.select_ipv4) {
 		memcpy(header, &ipv4, sizeof(ipv4));
@@ -8169,15 +4765,15 @@
 	       mplsoudp_encap_conf.eth_dst, RTE_ETHER_ADDR_LEN);
 	memcpy(eth.src.addr_bytes,
 	       mplsoudp_encap_conf.eth_src, RTE_ETHER_ADDR_LEN);
-	memcpy(header, &eth.hdr, sizeof(struct rte_ether_hdr));
-	header += sizeof(struct rte_ether_hdr);
+	memcpy(header, &eth, sizeof(eth));
+	header += sizeof(eth);
 	if (mplsoudp_encap_conf.select_vlan) {
 		if (mplsoudp_encap_conf.select_ipv4)
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4);
 		else
 			vlan.inner_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV6);
-		memcpy(header, &vlan.hdr, sizeof(struct rte_vlan_hdr));
-		header += sizeof(struct rte_vlan_hdr);
+		memcpy(header, &vlan, sizeof(vlan));
+		header += sizeof(vlan);
 	}
 	if (mplsoudp_encap_conf.select_ipv4) {
 		memcpy(header, &ipv4, sizeof(ipv4));
@@ -8352,168 +4948,6 @@
 	return len;
 }
 
-static int
-parse_vc_action_sample(struct context *ctx, const struct token *token,
-			 const char *str, unsigned int len, void *buf,
-			 unsigned int size)
-{
-	struct buffer *out = buf;
-	struct rte_flow_action *action;
-	struct action_sample_data *action_sample_data = NULL;
-	static struct rte_flow_action end_action = {
-		RTE_FLOW_ACTION_TYPE_END, 0
-	};
-	int ret;
-
-	ret = parse_vc(ctx, token, str, len, buf, size);
-	if (ret < 0)
-		return ret;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return ret;
-	if (!out->args.vc.actions_n)
-		return -1;
-	action = &out->args.vc.actions[out->args.vc.actions_n - 1];
-	/* Point to selected object. */
-	ctx->object = out->args.vc.data;
-	ctx->objmask = NULL;
-	/* Copy the headers to the buffer. */
-	action_sample_data = ctx->object;
-	action_sample_data->conf.actions = &end_action;
-	action->conf = &action_sample_data->conf;
-	return ret;
-}
-
-static int
-parse_vc_action_sample_index(struct context *ctx, const struct token *token,
-				const char *str, unsigned int len, void *buf,
-				unsigned int size)
-{
-	struct action_sample_data *action_sample_data;
-	struct rte_flow_action *action;
-	const struct arg *arg;
-	struct buffer *out = buf;
-	int ret;
-	uint16_t idx;
-
-	RTE_SET_USED(token);
-	RTE_SET_USED(buf);
-	RTE_SET_USED(size);
-	if (ctx->curr != ACTION_SAMPLE_INDEX_VALUE)
-		return -1;
-	arg = ARGS_ENTRY_ARB_BOUNDED
-		(offsetof(struct action_sample_data, idx),
-		 sizeof(((struct action_sample_data *)0)->idx),
-		 0, RAW_SAMPLE_CONFS_MAX_NUM - 1);
-	if (push_args(ctx, arg))
-		return -1;
-	ret = parse_int(ctx, token, str, len, NULL, 0);
-	if (ret < 0) {
-		pop_args(ctx);
-		return -1;
-	}
-	if (!ctx->object)
-		return len;
-	action = &out->args.vc.actions[out->args.vc.actions_n - 1];
-	action_sample_data = ctx->object;
-	idx = action_sample_data->idx;
-	action_sample_data->conf.actions = raw_sample_confs[idx].data;
-	action->conf = &action_sample_data->conf;
-	return len;
-}
-
-/** Parse operation for modify_field command. */
-static int
-parse_vc_modify_field_op(struct context *ctx, const struct token *token,
-			 const char *str, unsigned int len, void *buf,
-			 unsigned int size)
-{
-	struct rte_flow_action_modify_field *action_modify_field;
-	unsigned int i;
-
-	(void)token;
-	(void)buf;
-	(void)size;
-	if (ctx->curr != ACTION_MODIFY_FIELD_OP_VALUE)
-		return -1;
-	for (i = 0; modify_field_ops[i]; ++i)
-		if (!strcmp_partial(modify_field_ops[i], str, len))
-			break;
-	if (!modify_field_ops[i])
-		return -1;
-	if (!ctx->object)
-		return len;
-	action_modify_field = ctx->object;
-	action_modify_field->operation = (enum rte_flow_modify_op)i;
-	return len;
-}
-
-/** Parse id for modify_field command. */
-static int
-parse_vc_modify_field_id(struct context *ctx, const struct token *token,
-			 const char *str, unsigned int len, void *buf,
-			 unsigned int size)
-{
-	struct rte_flow_action_modify_field *action_modify_field;
-	unsigned int i;
-
-	(void)token;
-	(void)buf;
-	(void)size;
-	if (ctx->curr != ACTION_MODIFY_FIELD_DST_TYPE_VALUE &&
-		ctx->curr != ACTION_MODIFY_FIELD_SRC_TYPE_VALUE)
-		return -1;
-	for (i = 0; modify_field_ids[i]; ++i)
-		if (!strcmp_partial(modify_field_ids[i], str, len))
-			break;
-	if (!modify_field_ids[i])
-		return -1;
-	if (!ctx->object)
-		return len;
-	action_modify_field = ctx->object;
-	if (ctx->curr == ACTION_MODIFY_FIELD_DST_TYPE_VALUE)
-		action_modify_field->dst.field = (enum rte_flow_field_id)i;
-	else
-		action_modify_field->src.field = (enum rte_flow_field_id)i;
-	return len;
-}
-
-/** Parse the conntrack update, not a rte_flow_action. */
-static int
-parse_vc_action_conntrack_update(struct context *ctx, const struct token *token,
-			 const char *str, unsigned int len, void *buf,
-			 unsigned int size)
-{
-	struct buffer *out = buf;
-	struct rte_flow_modify_conntrack *ct_modify = NULL;
-
-	(void)size;
-	if (ctx->curr != ACTION_CONNTRACK_UPDATE_CTX &&
-	    ctx->curr != ACTION_CONNTRACK_UPDATE_DIR)
-		return -1;
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	ct_modify = (struct rte_flow_modify_conntrack *)out->args.vc.data;
-	if (ctx->curr == ACTION_CONNTRACK_UPDATE_DIR) {
-		ct_modify->new_ct.is_original_dir =
-				conntrack_context.is_original_dir;
-		ct_modify->direction = 1;
-	} else {
-		uint32_t old_dir;
-
-		old_dir = ct_modify->new_ct.is_original_dir;
-		memcpy(&ct_modify->new_ct, &conntrack_context,
-		       sizeof(conntrack_context));
-		ct_modify->new_ct.is_original_dir = old_dir;
-		ct_modify->state = 1;
-	}
-	return len;
-}
-
 /** Parse tokens for destroy command. */
 static int
 parse_destroy(struct context *ctx, const struct token *token,
@@ -8578,45 +5012,6 @@
 	return len;
 }
 
-/** Parse tokens for dump command. */
-static int
-parse_dump(struct context *ctx, const struct token *token,
-	    const char *str, unsigned int len,
-	    void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != DUMP)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	}
-	switch (ctx->curr) {
-	case DUMP_ALL:
-	case DUMP_ONE:
-		out->args.dump.mode = (ctx->curr == DUMP_ALL) ? true : false;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	default:
-		return -1;
-	}
-}
-
 /** Parse tokens for query command. */
 static int
 parse_query(struct context *ctx, const struct token *token,
@@ -8716,35 +5111,6 @@
 	return len;
 }
 
-/** Parse tokens for list all aged flows command. */
-static int
-parse_aged(struct context *ctx, const struct token *token,
-	   const char *str, unsigned int len,
-	   void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command || out->command == QUEUE) {
-		if (ctx->curr != AGED && ctx->curr != QUEUE_AGED)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-	}
-	if (ctx->curr == AGED_DESTROY)
-		out->args.aged.destroy = 1;
-	return len;
-}
-
 /** Parse tokens for isolate command. */
 static int
 parse_isolate(struct context *ctx, const struct token *token,
@@ -8772,516 +5138,6 @@
 	return len;
 }
 
-/** Parse tokens for info/configure command. */
-static int
-parse_configure(struct context *ctx, const struct token *token,
-		const char *str, unsigned int len,
-		void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != INFO && ctx->curr != CONFIGURE)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-	}
-	return len;
-}
-
-/** Parse tokens for template create command. */
-static int
-parse_template(struct context *ctx, const struct token *token,
-	       const char *str, unsigned int len,
-	       void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != PATTERN_TEMPLATE &&
-		    ctx->curr != ACTIONS_TEMPLATE)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.vc.data = (uint8_t *)out + size;
-		return len;
-	}
-	switch (ctx->curr) {
-	case PATTERN_TEMPLATE_CREATE:
-		out->args.vc.pattern =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		out->args.vc.pat_templ_id = UINT32_MAX;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	case PATTERN_TEMPLATE_EGRESS:
-		out->args.vc.attr.egress = 1;
-		return len;
-	case PATTERN_TEMPLATE_INGRESS:
-		out->args.vc.attr.ingress = 1;
-		return len;
-	case PATTERN_TEMPLATE_TRANSFER:
-		out->args.vc.attr.transfer = 1;
-		return len;
-	case ACTIONS_TEMPLATE_CREATE:
-		out->args.vc.act_templ_id = UINT32_MAX;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	case ACTIONS_TEMPLATE_SPEC:
-		out->args.vc.actions =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		ctx->object = out->args.vc.actions;
-		ctx->objmask = NULL;
-		return len;
-	case ACTIONS_TEMPLATE_MASK:
-		out->args.vc.masks =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)
-					       (out->args.vc.actions +
-						out->args.vc.actions_n),
-					       sizeof(double));
-		ctx->object = out->args.vc.masks;
-		ctx->objmask = NULL;
-		return len;
-	case ACTIONS_TEMPLATE_EGRESS:
-		out->args.vc.attr.egress = 1;
-		return len;
-	case ACTIONS_TEMPLATE_INGRESS:
-		out->args.vc.attr.ingress = 1;
-		return len;
-	case ACTIONS_TEMPLATE_TRANSFER:
-		out->args.vc.attr.transfer = 1;
-		return len;
-	default:
-		return -1;
-	}
-}
-
-/** Parse tokens for template destroy command. */
-static int
-parse_template_destroy(struct context *ctx, const struct token *token,
-		       const char *str, unsigned int len,
-		       void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-	uint32_t *template_id;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command ||
-		out->command == PATTERN_TEMPLATE ||
-		out->command == ACTIONS_TEMPLATE) {
-		if (ctx->curr != PATTERN_TEMPLATE_DESTROY &&
-			ctx->curr != ACTIONS_TEMPLATE_DESTROY)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.templ_destroy.template_id =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		return len;
-	}
-	template_id = out->args.templ_destroy.template_id
-		    + out->args.templ_destroy.template_id_n++;
-	if ((uint8_t *)template_id > (uint8_t *)out + size)
-		return -1;
-	ctx->objdata = 0;
-	ctx->object = template_id;
-	ctx->objmask = NULL;
-	return len;
-}
-
-/** Parse tokens for table create command. */
-static int
-parse_table(struct context *ctx, const struct token *token,
-	    const char *str, unsigned int len,
-	    void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-	uint32_t *template_id;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != TABLE)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	}
-	switch (ctx->curr) {
-	case TABLE_CREATE:
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.table.id = UINT32_MAX;
-		return len;
-	case TABLE_PATTERN_TEMPLATE:
-		out->args.table.pat_templ_id =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		template_id = out->args.table.pat_templ_id
-				+ out->args.table.pat_templ_id_n++;
-		if ((uint8_t *)template_id > (uint8_t *)out + size)
-			return -1;
-		ctx->objdata = 0;
-		ctx->object = template_id;
-		ctx->objmask = NULL;
-		return len;
-	case TABLE_ACTIONS_TEMPLATE:
-		out->args.table.act_templ_id =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)
-					       (out->args.table.pat_templ_id +
-						out->args.table.pat_templ_id_n),
-					       sizeof(double));
-		template_id = out->args.table.act_templ_id
-				+ out->args.table.act_templ_id_n++;
-		if ((uint8_t *)template_id > (uint8_t *)out + size)
-			return -1;
-		ctx->objdata = 0;
-		ctx->object = template_id;
-		ctx->objmask = NULL;
-		return len;
-	case TABLE_INGRESS:
-		out->args.table.attr.flow_attr.ingress = 1;
-		return len;
-	case TABLE_EGRESS:
-		out->args.table.attr.flow_attr.egress = 1;
-		return len;
-	case TABLE_TRANSFER:
-		out->args.table.attr.flow_attr.transfer = 1;
-		return len;
-	case TABLE_RULES_NUMBER:
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	default:
-		return -1;
-	}
-}
-
-/** Parse tokens for table destroy command. */
-static int
-parse_table_destroy(struct context *ctx, const struct token *token,
-		    const char *str, unsigned int len,
-		    void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-	uint32_t *table_id;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command || out->command == TABLE) {
-		if (ctx->curr != TABLE_DESTROY)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.table_destroy.table_id =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		return len;
-	}
-	table_id = out->args.table_destroy.table_id
-		    + out->args.table_destroy.table_id_n++;
-	if ((uint8_t *)table_id > (uint8_t *)out + size)
-		return -1;
-	ctx->objdata = 0;
-	ctx->object = table_id;
-	ctx->objmask = NULL;
-	return len;
-}
-
-/** Parse tokens for queue create commands. */
-static int
-parse_qo(struct context *ctx, const struct token *token,
-	 const char *str, unsigned int len,
-	 void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != QUEUE)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.vc.data = (uint8_t *)out + size;
-		return len;
-	}
-	switch (ctx->curr) {
-	case QUEUE_CREATE:
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		return len;
-	case QUEUE_TEMPLATE_TABLE:
-	case QUEUE_PATTERN_TEMPLATE:
-	case QUEUE_ACTIONS_TEMPLATE:
-	case QUEUE_CREATE_POSTPONE:
-		return len;
-	case ITEM_PATTERN:
-		out->args.vc.pattern =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		ctx->object = out->args.vc.pattern;
-		ctx->objmask = NULL;
-		return len;
-	case ACTIONS:
-		out->args.vc.actions =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)
-					       (out->args.vc.pattern +
-						out->args.vc.pattern_n),
-					       sizeof(double));
-		ctx->object = out->args.vc.actions;
-		ctx->objmask = NULL;
-		return len;
-	default:
-		return -1;
-	}
-}
-
-/** Parse tokens for queue destroy command. */
-static int
-parse_qo_destroy(struct context *ctx, const struct token *token,
-		 const char *str, unsigned int len,
-		 void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-	uint32_t *flow_id;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command || out->command == QUEUE) {
-		if (ctx->curr != QUEUE_DESTROY)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.destroy.rule =
-			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-					       sizeof(double));
-		return len;
-	}
-	switch (ctx->curr) {
-	case QUEUE_DESTROY_ID:
-		flow_id = out->args.destroy.rule
-				+ out->args.destroy.rule_n++;
-		if ((uint8_t *)flow_id > (uint8_t *)out + size)
-			return -1;
-		ctx->objdata = 0;
-		ctx->object = flow_id;
-		ctx->objmask = NULL;
-		return len;
-	case QUEUE_DESTROY_POSTPONE:
-		return len;
-	default:
-		return -1;
-	}
-}
-
-/** Parse tokens for push queue command. */
-static int
-parse_push(struct context *ctx, const struct token *token,
-	   const char *str, unsigned int len,
-	   void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != PUSH)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.vc.data = (uint8_t *)out + size;
-	}
-	return len;
-}
-
-/** Parse tokens for pull command. */
-static int
-parse_pull(struct context *ctx, const struct token *token,
-	   const char *str, unsigned int len,
-	   void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != PULL)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-		out->args.vc.data = (uint8_t *)out + size;
-	}
-	return len;
-}
-
-static int
-parse_flex(struct context *ctx, const struct token *token,
-	     const char *str, unsigned int len,
-	     void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (out->command == ZERO) {
-		if (ctx->curr != FLEX)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-	} else {
-		switch (ctx->curr) {
-		default:
-			break;
-		case FLEX_ITEM_INIT:
-		case FLEX_ITEM_CREATE:
-		case FLEX_ITEM_DESTROY:
-			out->command = ctx->curr;
-			break;
-		}
-	}
-
-	return len;
-}
-
-static int
-parse_tunnel(struct context *ctx, const struct token *token,
-	     const char *str, unsigned int len,
-	     void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	if (!out->command) {
-		if (ctx->curr != TUNNEL)
-			return -1;
-		if (sizeof(*out) > size)
-			return -1;
-		out->command = ctx->curr;
-		ctx->objdata = 0;
-		ctx->object = out;
-		ctx->objmask = NULL;
-	} else {
-		switch (ctx->curr) {
-		default:
-			break;
-		case TUNNEL_CREATE:
-		case TUNNEL_DESTROY:
-		case TUNNEL_LIST:
-			out->command = ctx->curr;
-			break;
-		case TUNNEL_CREATE_TYPE:
-		case TUNNEL_DESTROY_ID:
-			ctx->object = &out->args.vc.tunnel_ops;
-			break;
-		}
-	}
-
-	return len;
-}
-
 /**
  * Parse signed/unsigned integers 8 to 64-bit long.
  *
@@ -9441,32 +5297,31 @@
 static int
 parse_hex_string(const char *src, uint8_t *dst, uint32_t *size)
 {
-	const uint8_t *head = dst;
-	uint32_t left;
-
-	if (*size == 0)
+	char *c = NULL;
+	uint32_t i, len;
+	char tmp[3];
+
+	/* Check input parameters */
+	if ((src == NULL) ||
+		(dst == NULL) ||
+		(size == NULL) ||
+		(*size == 0))
 		return -1;
 
-	left = *size;
-
 	/* Convert chars to bytes */
-	while (left) {
-		char tmp[3], *end = tmp;
-		uint32_t read_lim = left & 1 ? 1 : 2;
-
-		snprintf(tmp, read_lim + 1, "%s", src);
-		*dst = strtoul(tmp, &end, 16);
-		if (*end) {
-			*dst = 0;
-			*size = (uint32_t)(dst - head);
+	for (i = 0, len = 0; i < *size; i += 2) {
+		snprintf(tmp, 3, "%s", src + i);
+		dst[len++] = strtoul(tmp, &c, 16);
+		if (*c != 0) {
+			len--;
+			dst[len] = 0;
+			*size = len;
 			return -1;
 		}
-		left -= read_lim;
-		src += read_lim;
-		dst++;
 	}
-	*dst = 0;
-	*size = (uint32_t)(dst - head);
+	dst[len] = 0;
+	*size = len;
+
 	return 0;
 }
 
@@ -9510,25 +5365,19 @@
 		hexlen -= 2;
 	}
 	if (hexlen > length)
-		goto error;
+		return -1;
 	ret = parse_hex_string(str, hex_tmp, &hexlen);
 	if (ret < 0)
 		goto error;
-	/* Check the converted binary fits into data buffer. */
-	if (hexlen > size)
-		goto error;
 	/* Let parse_int() fill length information first. */
 	ret = snprintf(tmp, sizeof(tmp), "%u", hexlen);
 	if (ret < 0)
 		goto error;
-	/* Save length if requested. */
-	if (arg_len->size) {
-		push_args(ctx, arg_len);
-		ret = parse_int(ctx, token, tmp, ret, NULL, 0);
-		if (ret < 0) {
-			pop_args(ctx);
-			goto error;
-		}
+	push_args(ctx, arg_len);
+	ret = parse_int(ctx, token, tmp, ret, NULL, 0);
+	if (ret < 0) {
+		pop_args(ctx);
+		goto error;
 	}
 	buf = (uint8_t *)ctx->object + arg_data->offset;
 	/* Output buffer is not necessarily NUL-terminated. */
@@ -9561,35 +5410,6 @@
 }
 
 /**
- * Parse a zero-ended string.
- */
-static int
-parse_string0(struct context *ctx, const struct token *token __rte_unused,
-	     const char *str, unsigned int len,
-	     void *buf, unsigned int size)
-{
-	const struct arg *arg_data = pop_args(ctx);
-
-	/* Arguments are expected. */
-	if (!arg_data)
-		return -1;
-	size = arg_data->size;
-	/* Bit-mask fill is not supported. */
-	if (arg_data->mask || size < len + 1)
-		goto error;
-	if (!ctx->object)
-		return len;
-	buf = (uint8_t *)ctx->object + arg_data->offset;
-	strncpy(buf, str, len);
-	if (ctx->objmask)
-		memset((uint8_t *)ctx->objmask + arg_data->offset, 0xff, len);
-	return len;
-error:
-	push_args(ctx, arg_data);
-	return -1;
-}
-
-/**
  * Parse a MAC address.
  *
  * Last argument (ctx->args) is retrieved to determine storage size and
@@ -9784,94 +5604,6 @@
 	return ret;
 }
 
-static int
-parse_ia_id2ptr(struct context *ctx, const struct token *token,
-		const char *str, unsigned int len,
-		void *buf, unsigned int size)
-{
-	struct rte_flow_action *action = ctx->object;
-	uint32_t id;
-	int ret;
-
-	(void)buf;
-	(void)size;
-	ctx->objdata = 0;
-	ctx->object = &id;
-	ctx->objmask = NULL;
-	ret = parse_int(ctx, token, str, len, ctx->object, sizeof(id));
-	ctx->object = action;
-	if (ret != (int)len)
-		return ret;
-	/* set indirect action */
-	if (action) {
-		action->conf = port_action_handle_get_by_id(ctx->port, id);
-		ret = (action->conf) ? ret : -1;
-	}
-	return ret;
-}
-
-static int
-parse_meter_profile_id2ptr(struct context *ctx, const struct token *token,
-		const char *str, unsigned int len,
-		void *buf, unsigned int size)
-{
-	struct rte_flow_action *action = ctx->object;
-	struct rte_flow_action_meter_mark *meter;
-	struct rte_flow_meter_profile *profile = NULL;
-	uint32_t id = 0;
-	int ret;
-
-	(void)buf;
-	(void)size;
-	ctx->objdata = 0;
-	ctx->object = &id;
-	ctx->objmask = NULL;
-	ret = parse_int(ctx, token, str, len, ctx->object, sizeof(id));
-	ctx->object = action;
-	if (ret != (int)len)
-		return ret;
-	/* set meter profile */
-	if (action) {
-		meter = (struct rte_flow_action_meter_mark *)
-			(uintptr_t)(action->conf);
-		profile = port_meter_profile_get_by_id(ctx->port, id);
-		meter->profile = profile;
-		ret = (profile) ? ret : -1;
-	}
-	return ret;
-}
-
-static int
-parse_meter_policy_id2ptr(struct context *ctx, const struct token *token,
-		const char *str, unsigned int len,
-		void *buf, unsigned int size)
-{
-	struct rte_flow_action *action = ctx->object;
-	struct rte_flow_action_meter_mark *meter;
-	struct rte_flow_meter_policy *policy = NULL;
-	uint32_t id = 0;
-	int ret;
-
-	(void)buf;
-	(void)size;
-	ctx->objdata = 0;
-	ctx->object = &id;
-	ctx->objmask = NULL;
-	ret = parse_int(ctx, token, str, len, ctx->object, sizeof(id));
-	ctx->object = action;
-	if (ret != (int)len)
-		return ret;
-	/* set meter policy */
-	if (action) {
-		meter = (struct rte_flow_action_meter_mark *)
-			(uintptr_t)(action->conf);
-		policy = port_meter_policy_get_by_id(ctx->port, id);
-		meter->policy = policy;
-		ret = (policy) ? ret : -1;
-	}
-	return ret;
-}
-
 /** Parse set command, initialize output buffer for subsequent tokens. */
 static int
 parse_set_raw_encap_decap(struct context *ctx, const struct token *token,
@@ -9895,38 +5627,6 @@
 	if (!out->command)
 		return -1;
 	out->command = ctx->curr;
-	/* For encap/decap we need is pattern */
-	out->args.vc.pattern = (void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-						       sizeof(double));
-	return len;
-}
-
-/** Parse set command, initialize output buffer for subsequent tokens. */
-static int
-parse_set_sample_action(struct context *ctx, const struct token *token,
-			  const char *str, unsigned int len,
-			  void *buf, unsigned int size)
-{
-	struct buffer *out = buf;
-
-	/* Token name must match. */
-	if (parse_default(ctx, token, str, len, NULL, 0) < 0)
-		return -1;
-	/* Nothing else to do if there is no buffer. */
-	if (!out)
-		return len;
-	/* Make sure buffer is large enough. */
-	if (size < sizeof(*out))
-		return -1;
-	ctx->objdata = 0;
-	ctx->objmask = NULL;
-	ctx->object = out;
-	if (!out->command)
-		return -1;
-	out->command = ctx->curr;
-	/* For sampler we need is actions */
-	out->args.vc.actions = (void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-						       sizeof(double));
 	return len;
 }
 
@@ -9963,101 +5663,15 @@
 			return -1;
 		out->command = ctx->curr;
 		out->args.vc.data = (uint8_t *)out + size;
-		ctx->object  = (void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
-						       sizeof(double));
+		/* All we need is pattern */
+		out->args.vc.pattern =
+			(void *)RTE_ALIGN_CEIL((uintptr_t)(out + 1),
+					       sizeof(double));
+		ctx->object = out->args.vc.pattern;
 	}
 	return len;
 }
 
-/*
- * Replace testpmd handles in a flex flow item with real values.
- */
-static int
-parse_flex_handle(struct context *ctx, const struct token *token,
-		  const char *str, unsigned int len,
-		  void *buf, unsigned int size)
-{
-	struct rte_flow_item_flex *spec, *mask;
-	const struct rte_flow_item_flex *src_spec, *src_mask;
-	const struct arg *arg = pop_args(ctx);
-	uint32_t offset;
-	uint16_t handle;
-	int ret;
-
-	if (!arg) {
-		printf("Bad environment\n");
-		return -1;
-	}
-	offset = arg->offset;
-	push_args(ctx, arg);
-	ret = parse_int(ctx, token, str, len, buf, size);
-	if (ret <= 0 || !ctx->object)
-		return ret;
-	if (ctx->port >= RTE_MAX_ETHPORTS) {
-		printf("Bad port\n");
-		return -1;
-	}
-	if (offset == offsetof(struct rte_flow_item_flex, handle)) {
-		const struct flex_item *fp;
-		struct rte_flow_item_flex *item_flex = ctx->object;
-		handle = (uint16_t)(uintptr_t)item_flex->handle;
-		if (handle >= FLEX_MAX_PARSERS_NUM) {
-			printf("Bad flex item handle\n");
-			return -1;
-		}
-		fp = flex_items[ctx->port][handle];
-		if (!fp) {
-			printf("Bad flex item handle\n");
-			return -1;
-		}
-		item_flex->handle = fp->flex_handle;
-	} else if (offset == offsetof(struct rte_flow_item_flex, pattern)) {
-		handle = (uint16_t)(uintptr_t)
-			((struct rte_flow_item_flex *)ctx->object)->pattern;
-		if (handle >= FLEX_MAX_PATTERNS_NUM) {
-			printf("Bad pattern handle\n");
-			return -1;
-		}
-		src_spec = &flex_patterns[handle].spec;
-		src_mask = &flex_patterns[handle].mask;
-		spec = ctx->object;
-		mask = spec + 2; /* spec, last, mask */
-		/* fill flow rule spec and mask parameters */
-		spec->length = src_spec->length;
-		spec->pattern = src_spec->pattern;
-		mask->length = src_mask->length;
-		mask->pattern = src_mask->pattern;
-	} else {
-		printf("Bad arguments - unknown flex item offset\n");
-		return -1;
-	}
-	return ret;
-}
-
-/** Parse Meter color name */
-static int
-parse_meter_color(struct context *ctx, const struct token *token,
-		  const char *str, unsigned int len, void *buf,
-		  unsigned int size)
-{
-	struct rte_flow_item_meter_color *meter_color;
-	unsigned int i;
-
-	(void)token;
-	(void)buf;
-	(void)size;
-	for (i = 0; meter_colors[i]; ++i)
-		if (!strcmp_partial(meter_colors[i], str, len))
-			break;
-	if (!meter_colors[i])
-		return -1;
-	if (!ctx->object)
-		return len;
-	meter_color = ctx->object;
-	meter_color->color = (enum rte_color)i;
-	return len;
-}
-
 /** No completion. */
 static int
 comp_none(struct context *ctx, const struct token *token,
@@ -10204,165 +5818,6 @@
 	return nb;
 }
 
-/** Complete index number for set raw_encap/raw_decap commands. */
-static int
-comp_set_sample_index(struct context *ctx, const struct token *token,
-		   unsigned int ent, char *buf, unsigned int size)
-{
-	uint16_t idx = 0;
-	uint16_t nb = 0;
-
-	RTE_SET_USED(ctx);
-	RTE_SET_USED(token);
-	for (idx = 0; idx < RAW_SAMPLE_CONFS_MAX_NUM; ++idx) {
-		if (buf && idx == ent)
-			return snprintf(buf, size, "%u", idx);
-		++nb;
-	}
-	return nb;
-}
-
-/** Complete operation for modify_field command. */
-static int
-comp_set_modify_field_op(struct context *ctx, const struct token *token,
-		   unsigned int ent, char *buf, unsigned int size)
-{
-	RTE_SET_USED(ctx);
-	RTE_SET_USED(token);
-	if (!buf)
-		return RTE_DIM(modify_field_ops);
-	if (ent < RTE_DIM(modify_field_ops) - 1)
-		return strlcpy(buf, modify_field_ops[ent], size);
-	return -1;
-}
-
-/** Complete field id for modify_field command. */
-static int
-comp_set_modify_field_id(struct context *ctx, const struct token *token,
-		   unsigned int ent, char *buf, unsigned int size)
-{
-	const char *name;
-
-	RTE_SET_USED(token);
-	if (!buf)
-		return RTE_DIM(modify_field_ids);
-	if (ent >= RTE_DIM(modify_field_ids) - 1)
-		return -1;
-	name = modify_field_ids[ent];
-	if (ctx->curr == ACTION_MODIFY_FIELD_SRC_TYPE ||
-	    (strcmp(name, "pointer") && strcmp(name, "value")))
-		return strlcpy(buf, name, size);
-	return -1;
-}
-
-/** Complete available pattern template IDs. */
-static int
-comp_pattern_template_id(struct context *ctx, const struct token *token,
-			 unsigned int ent, char *buf, unsigned int size)
-{
-	unsigned int i = 0;
-	struct rte_port *port;
-	struct port_template *pt;
-
-	(void)token;
-	if (port_id_is_invalid(ctx->port, DISABLED_WARN) ||
-	    ctx->port == (portid_t)RTE_PORT_ALL)
-		return -1;
-	port = &ports[ctx->port];
-	for (pt = port->pattern_templ_list; pt != NULL; pt = pt->next) {
-		if (buf && i == ent)
-			return snprintf(buf, size, "%u", pt->id);
-		++i;
-	}
-	if (buf)
-		return -1;
-	return i;
-}
-
-/** Complete available actions template IDs. */
-static int
-comp_actions_template_id(struct context *ctx, const struct token *token,
-			 unsigned int ent, char *buf, unsigned int size)
-{
-	unsigned int i = 0;
-	struct rte_port *port;
-	struct port_template *pt;
-
-	(void)token;
-	if (port_id_is_invalid(ctx->port, DISABLED_WARN) ||
-	    ctx->port == (portid_t)RTE_PORT_ALL)
-		return -1;
-	port = &ports[ctx->port];
-	for (pt = port->actions_templ_list; pt != NULL; pt = pt->next) {
-		if (buf && i == ent)
-			return snprintf(buf, size, "%u", pt->id);
-		++i;
-	}
-	if (buf)
-		return -1;
-	return i;
-}
-
-/** Complete available table IDs. */
-static int
-comp_table_id(struct context *ctx, const struct token *token,
-	      unsigned int ent, char *buf, unsigned int size)
-{
-	unsigned int i = 0;
-	struct rte_port *port;
-	struct port_table *pt;
-
-	(void)token;
-	if (port_id_is_invalid(ctx->port, DISABLED_WARN) ||
-	    ctx->port == (portid_t)RTE_PORT_ALL)
-		return -1;
-	port = &ports[ctx->port];
-	for (pt = port->table_list; pt != NULL; pt = pt->next) {
-		if (buf && i == ent)
-			return snprintf(buf, size, "%u", pt->id);
-		++i;
-	}
-	if (buf)
-		return -1;
-	return i;
-}
-
-/** Complete available queue IDs. */
-static int
-comp_queue_id(struct context *ctx, const struct token *token,
-	      unsigned int ent, char *buf, unsigned int size)
-{
-	unsigned int i = 0;
-	struct rte_port *port;
-
-	(void)token;
-	if (port_id_is_invalid(ctx->port, DISABLED_WARN) ||
-	    ctx->port == (portid_t)RTE_PORT_ALL)
-		return -1;
-	port = &ports[ctx->port];
-	for (i = 0; i < port->queue_nb; i++) {
-		if (buf && i == ent)
-			return snprintf(buf, size, "%u", i);
-	}
-	if (buf)
-		return -1;
-	return i;
-}
-
-/** Complete available Meter colors. */
-static int
-comp_meter_color(struct context *ctx, const struct token *token,
-		 unsigned int ent, char *buf, unsigned int size)
-{
-	RTE_SET_USED(ctx);
-	RTE_SET_USED(token);
-	if (!buf)
-		return RTE_DIM(meter_colors);
-	if (ent < RTE_DIM(meter_colors) - 1)
-		return strlcpy(buf, meter_colors[ent], size);
-	return -1;
-}
-
 /** Internal context. */
 static struct context cmd_flow_context;
 
@@ -10464,30 +5919,6 @@
 	return len;
 }
 
-int
-flow_parse(const char *src, void *result, unsigned int size,
-	   struct rte_flow_attr **attr,
-	   struct rte_flow_item **pattern, struct rte_flow_action **actions)
-{
-	int ret;
-	struct context saved_flow_ctx = cmd_flow_context;
-
-	cmd_flow_context_init(&cmd_flow_context);
-	do {
-		ret = cmd_flow_parse(NULL, src, result, size);
-		if (ret > 0) {
-			src += ret;
-			while (isspace(*src))
-				src++;
-		}
-	} while (ret > 0 && strlen(src));
-	cmd_flow_context = saved_flow_ctx;
-	*attr = &((struct buffer *)result)->args.vc.attr;
-	*pattern = ((struct buffer *)result)->args.vc.pattern;
-	*actions = ((struct buffer *)result)->args.vc.actions;
-	return (ret >= 0 && !strlen(src)) ? 0 : -1;
-}
-
 /** Return number of completion entries (cmdline API). */
 static int
 cmd_flow_complete_get_nb(cmdline_parse_token_hdr_t *hdr)
@@ -10622,138 +6053,13 @@
 cmd_flow_parsed(const struct buffer *in)
 {
 	switch (in->command) {
-	case INFO:
-		port_flow_get_info(in->port);
-		break;
-	case CONFIGURE:
-		port_flow_configure(in->port,
-				    &in->args.configure.port_attr,
-				    in->args.configure.nb_queue,
-				    &in->args.configure.queue_attr);
-		break;
-	case PATTERN_TEMPLATE_CREATE:
-		port_flow_pattern_template_create(in->port,
-				in->args.vc.pat_templ_id,
-				&((const struct rte_flow_pattern_template_attr) {
-					.relaxed_matching = in->args.vc.attr.reserved,
-					.ingress = in->args.vc.attr.ingress,
-					.egress = in->args.vc.attr.egress,
-					.transfer = in->args.vc.attr.transfer,
-				}),
-				in->args.vc.pattern);
-		break;
-	case PATTERN_TEMPLATE_DESTROY:
-		port_flow_pattern_template_destroy(in->port,
-				in->args.templ_destroy.template_id_n,
-				in->args.templ_destroy.template_id);
-		break;
-	case ACTIONS_TEMPLATE_CREATE:
-		port_flow_actions_template_create(in->port,
-				in->args.vc.act_templ_id,
-				&((const struct rte_flow_actions_template_attr) {
-					.ingress = in->args.vc.attr.ingress,
-					.egress = in->args.vc.attr.egress,
-					.transfer = in->args.vc.attr.transfer,
-				}),
-				in->args.vc.actions,
-				in->args.vc.masks);
-		break;
-	case ACTIONS_TEMPLATE_DESTROY:
-		port_flow_actions_template_destroy(in->port,
-				in->args.templ_destroy.template_id_n,
-				in->args.templ_destroy.template_id);
-		break;
-	case TABLE_CREATE:
-		port_flow_template_table_create(in->port, in->args.table.id,
-			&in->args.table.attr, in->args.table.pat_templ_id_n,
-			in->args.table.pat_templ_id, in->args.table.act_templ_id_n,
-			in->args.table.act_templ_id);
-		break;
-	case TABLE_DESTROY:
-		port_flow_template_table_destroy(in->port,
-					in->args.table_destroy.table_id_n,
-					in->args.table_destroy.table_id);
-		break;
-	case QUEUE_CREATE:
-		port_queue_flow_create(in->port, in->queue, in->postpone,
-				       in->args.vc.table_id, in->args.vc.pat_templ_id,
-				       in->args.vc.act_templ_id, in->args.vc.pattern,
-				       in->args.vc.actions);
-		break;
-	case QUEUE_DESTROY:
-		port_queue_flow_destroy(in->port, in->queue, in->postpone,
-					in->args.destroy.rule_n,
-					in->args.destroy.rule);
-		break;
-	case PUSH:
-		port_queue_flow_push(in->port, in->queue);
-		break;
-	case PULL:
-		port_queue_flow_pull(in->port, in->queue);
-		break;
-	case QUEUE_AGED:
-		port_queue_flow_aged(in->port, in->queue,
-				     in->args.aged.destroy);
-		break;
-	case QUEUE_INDIRECT_ACTION_CREATE:
-		port_queue_action_handle_create(
-				in->port, in->queue, in->postpone,
-				in->args.vc.attr.group,
-				&((const struct rte_flow_indir_action_conf) {
-					.ingress = in->args.vc.attr.ingress,
-					.egress = in->args.vc.attr.egress,
-					.transfer = in->args.vc.attr.transfer,
-				}),
-				in->args.vc.actions);
-		break;
-	case QUEUE_INDIRECT_ACTION_DESTROY:
-		port_queue_action_handle_destroy(in->port,
-					   in->queue, in->postpone,
-					   in->args.ia_destroy.action_id_n,
-					   in->args.ia_destroy.action_id);
-		break;
-	case QUEUE_INDIRECT_ACTION_UPDATE:
-		port_queue_action_handle_update(in->port,
-						in->queue, in->postpone,
-						in->args.vc.attr.group,
-						in->args.vc.actions);
-		break;
-	case QUEUE_INDIRECT_ACTION_QUERY:
-		port_queue_action_handle_query(in->port,
-					       in->queue, in->postpone,
-					       in->args.vc.attr.group);
-		break;
-	case INDIRECT_ACTION_CREATE:
-		port_action_handle_create(
-				in->port, in->args.vc.attr.group,
-				&((const struct rte_flow_indir_action_conf) {
-					.ingress = in->args.vc.attr.ingress,
-					.egress = in->args.vc.attr.egress,
-					.transfer = in->args.vc.attr.transfer,
-				}),
-				in->args.vc.actions);
-		break;
-	case INDIRECT_ACTION_DESTROY:
-		port_action_handle_destroy(in->port,
-					   in->args.ia_destroy.action_id_n,
-					   in->args.ia_destroy.action_id);
-		break;
-	case INDIRECT_ACTION_UPDATE:
-		port_action_handle_update(in->port, in->args.vc.attr.group,
-					  in->args.vc.actions);
-		break;
-	case INDIRECT_ACTION_QUERY:
-		port_action_handle_query(in->port, in->args.ia.action_id);
-		break;
 	case VALIDATE:
 		port_flow_validate(in->port, &in->args.vc.attr,
-				   in->args.vc.pattern, in->args.vc.actions,
-				   &in->args.vc.tunnel_ops);
+				   in->args.vc.pattern, in->args.vc.actions);
 		break;
 	case CREATE:
 		port_flow_create(in->port, &in->args.vc.attr,
-				 in->args.vc.pattern, in->args.vc.actions,
-				 &in->args.vc.tunnel_ops);
+				 in->args.vc.pattern, in->args.vc.actions);
 		break;
 	case DESTROY:
 		port_flow_destroy(in->port, in->args.destroy.rule_n,
@@ -10762,11 +6068,6 @@
 	case FLUSH:
 		port_flow_flush(in->port);
 		break;
-	case DUMP_ONE:
-	case DUMP_ALL:
-		port_flow_dump(in->port, in->args.dump.mode,
-				in->args.dump.rule, in->args.dump.file);
-		break;
 	case QUERY:
 		port_flow_query(in->port, in->args.query.rule,
 				&in->args.query.action);
@@ -10778,29 +6079,6 @@
 	case ISOLATE:
 		port_flow_isolate(in->port, in->args.isolate.set);
 		break;
-	case AGED:
-		port_flow_aged(in->port, in->args.aged.destroy);
-		break;
-	case TUNNEL_CREATE:
-		port_flow_tunnel_create(in->port, &in->args.vc.tunnel_ops);
-		break;
-	case TUNNEL_DESTROY:
-		port_flow_tunnel_destroy(in->port, in->args.vc.tunnel_ops.id);
-		break;
-	case TUNNEL_LIST:
-		port_flow_tunnel_list(in->port);
-		break;
-	case ACTION_POL_G:
-		port_meter_policy_add(in->port, in->args.policy.policy_id,
-					in->args.vc.actions);
-		break;
-	case FLEX_ITEM_CREATE:
-		flex_item_create(in->port, in->args.flex.token,
-				 in->args.flex.filename);
-		break;
-	case FLEX_ITEM_DESTROY:
-		flex_item_destroy(in->port, in->args.flex.token);
-		break;
 	default:
 		break;
 	}
@@ -10831,43 +6109,42 @@
 static void
 update_fields(uint8_t *buf, struct rte_flow_item *item, uint16_t next_proto)
 {
-	struct rte_ipv4_hdr *ipv4;
-	struct rte_ether_hdr *eth;
-	struct rte_ipv6_hdr *ipv6;
-	struct rte_vxlan_hdr *vxlan;
-	struct rte_vxlan_gpe_hdr *gpe;
+	struct rte_flow_item_ipv4 *ipv4;
+	struct rte_flow_item_eth *eth;
+	struct rte_flow_item_ipv6 *ipv6;
+	struct rte_flow_item_vxlan *vxlan;
+	struct rte_flow_item_vxlan_gpe *gpe;
 	struct rte_flow_item_nvgre *nvgre;
 	uint32_t ipv6_vtc_flow;
 
 	switch (item->type) {
 	case RTE_FLOW_ITEM_TYPE_ETH:
-		eth = (struct rte_ether_hdr *)buf;
+		eth = (struct rte_flow_item_eth *)buf;
 		if (next_proto)
-			eth->ether_type = rte_cpu_to_be_16(next_proto);
+			eth->type = rte_cpu_to_be_16(next_proto);
 		break;
 	case RTE_FLOW_ITEM_TYPE_IPV4:
-		ipv4 = (struct rte_ipv4_hdr *)buf;
-		if (!ipv4->version_ihl)
-			ipv4->version_ihl = RTE_IPV4_VHL_DEF;
-		if (next_proto && ipv4->next_proto_id == 0)
-			ipv4->next_proto_id = (uint8_t)next_proto;
+		ipv4 = (struct rte_flow_item_ipv4 *)buf;
+		ipv4->hdr.version_ihl = 0x45;
+		if (next_proto && ipv4->hdr.next_proto_id == 0)
+			ipv4->hdr.next_proto_id = (uint8_t)next_proto;
 		break;
 	case RTE_FLOW_ITEM_TYPE_IPV6:
-		ipv6 = (struct rte_ipv6_hdr *)buf;
-		if (next_proto && ipv6->proto == 0)
-			ipv6->proto = (uint8_t)next_proto;
-		ipv6_vtc_flow = rte_be_to_cpu_32(ipv6->vtc_flow);
+		ipv6 = (struct rte_flow_item_ipv6 *)buf;
+		if (next_proto && ipv6->hdr.proto == 0)
+			ipv6->hdr.proto = (uint8_t)next_proto;
+		ipv6_vtc_flow = rte_be_to_cpu_32(ipv6->hdr.vtc_flow);
 		ipv6_vtc_flow &= 0x0FFFFFFF; /*< reset version bits. */
 		ipv6_vtc_flow |= 0x60000000; /*< set ipv6 version. */
-		ipv6->vtc_flow = rte_cpu_to_be_32(ipv6_vtc_flow);
+		ipv6->hdr.vtc_flow = rte_cpu_to_be_32(ipv6_vtc_flow);
 		break;
 	case RTE_FLOW_ITEM_TYPE_VXLAN:
-		vxlan = (struct rte_vxlan_hdr *)buf;
-		vxlan->vx_flags = 0x08;
+		vxlan = (struct rte_flow_item_vxlan *)buf;
+		vxlan->flags = 0x08;
 		break;
 	case RTE_FLOW_ITEM_TYPE_VXLAN_GPE:
-		gpe = (struct rte_vxlan_gpe_hdr *)buf;
-		gpe->vx_flags = 0x0C;
+		gpe = (struct rte_flow_item_vxlan_gpe *)buf;
+		gpe->flags = 0x0C;
 		break;
 	case RTE_FLOW_ITEM_TYPE_NVGRE:
 		nvgre = (struct rte_flow_item_nvgre *)buf;
@@ -10890,6 +6167,9 @@
 	case RTE_FLOW_ITEM_TYPE_ANY:
 		mask = &rte_flow_item_any_mask;
 		break;
+	case RTE_FLOW_ITEM_TYPE_VF:
+		mask = &rte_flow_item_vf_mask;
+		break;
 	case RTE_FLOW_ITEM_TYPE_PORT_ID:
 		mask = &rte_flow_item_port_id_mask;
 		break;
@@ -10950,162 +6230,21 @@
 	case RTE_FLOW_ITEM_TYPE_GTP:
 		mask = &rte_flow_item_gtp_mask;
 		break;
+	case RTE_FLOW_ITEM_TYPE_ESP:
+		mask = &rte_flow_item_esp_mask;
+		break;
 	case RTE_FLOW_ITEM_TYPE_GTP_PSC:
 		mask = &rte_flow_item_gtp_psc_mask;
 		break;
-	case RTE_FLOW_ITEM_TYPE_GENEVE:
-		mask = &rte_flow_item_geneve_mask;
-		break;
-	case RTE_FLOW_ITEM_TYPE_GENEVE_OPT:
-		mask = &rte_flow_item_geneve_opt_mask;
-		break;
 	case RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID:
 		mask = &rte_flow_item_pppoe_proto_id_mask;
-		break;
-	case RTE_FLOW_ITEM_TYPE_L2TPV3OIP:
-		mask = &rte_flow_item_l2tpv3oip_mask;
-		break;
-	case RTE_FLOW_ITEM_TYPE_ESP:
-		mask = &rte_flow_item_esp_mask;
-		break;
-	case RTE_FLOW_ITEM_TYPE_AH:
-		mask = &rte_flow_item_ah_mask;
-		break;
-	case RTE_FLOW_ITEM_TYPE_PFCP:
-		mask = &rte_flow_item_pfcp_mask;
-		break;
-	case RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR:
-	case RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT:
-		mask = &rte_flow_item_ethdev_mask;
-		break;
-	case RTE_FLOW_ITEM_TYPE_L2TPV2:
-		mask = &rte_flow_item_l2tpv2_mask;
-		break;
-	case RTE_FLOW_ITEM_TYPE_PPP:
-		mask = &rte_flow_item_ppp_mask;
-		break;
-	case RTE_FLOW_ITEM_TYPE_METER_COLOR:
-		mask = &rte_flow_item_meter_color_mask;
-		break;
 	default:
 		break;
 	}
 	return mask;
 }
 
-/** Dispatch parsed buffer to function calls. */
-static void
-cmd_set_raw_parsed_sample(const struct buffer *in)
-{
-	uint32_t n = in->args.vc.actions_n;
-	uint32_t i = 0;
-	struct rte_flow_action *action = NULL;
-	struct rte_flow_action *data = NULL;
-	const struct rte_flow_action_rss *rss = NULL;
-	size_t size = 0;
-	uint16_t idx = in->port; /* We borrow port field as index */
-	uint32_t max_size = sizeof(struct rte_flow_action) *
-						ACTION_SAMPLE_ACTIONS_NUM;
 
-	RTE_ASSERT(in->command == SET_SAMPLE_ACTIONS);
-	data = (struct rte_flow_action *)&raw_sample_confs[idx].data;
-	memset(data, 0x00, max_size);
-	for (; i <= n - 1; i++) {
-		action = in->args.vc.actions + i;
-		if (action->type == RTE_FLOW_ACTION_TYPE_END)
-			break;
-		switch (action->type) {
-		case RTE_FLOW_ACTION_TYPE_MARK:
-			size = sizeof(struct rte_flow_action_mark);
-			rte_memcpy(&sample_mark[idx],
-				(const void *)action->conf, size);
-			action->conf = &sample_mark[idx];
-			break;
-		case RTE_FLOW_ACTION_TYPE_COUNT:
-			size = sizeof(struct rte_flow_action_count);
-			rte_memcpy(&sample_count[idx],
-				(const void *)action->conf, size);
-			action->conf = &sample_count[idx];
-			break;
-		case RTE_FLOW_ACTION_TYPE_QUEUE:
-			size = sizeof(struct rte_flow_action_queue);
-			rte_memcpy(&sample_queue[idx],
-				(const void *)action->conf, size);
-			action->conf = &sample_queue[idx];
-			break;
-		case RTE_FLOW_ACTION_TYPE_RSS:
-			size = sizeof(struct rte_flow_action_rss);
-			rss = action->conf;
-			rte_memcpy(&sample_rss_data[idx].conf,
-				   (const void *)rss, size);
-			if (rss->key_len && rss->key) {
-				sample_rss_data[idx].conf.key =
-						sample_rss_data[idx].key;
-				rte_memcpy((void *)((uintptr_t)
-					   sample_rss_data[idx].conf.key),
-					   (const void *)rss->key,
-					   sizeof(uint8_t) * rss->key_len);
-			}
-			if (rss->queue_num && rss->queue) {
-				sample_rss_data[idx].conf.queue =
-						sample_rss_data[idx].queue;
-				rte_memcpy((void *)((uintptr_t)
-					   sample_rss_data[idx].conf.queue),
-					   (const void *)rss->queue,
-					   sizeof(uint16_t) * rss->queue_num);
-			}
-			action->conf = &sample_rss_data[idx].conf;
-			break;
-		case RTE_FLOW_ACTION_TYPE_RAW_ENCAP:
-			size = sizeof(struct rte_flow_action_raw_encap);
-			rte_memcpy(&sample_encap[idx],
-				(const void *)action->conf, size);
-			action->conf = &sample_encap[idx];
-			break;
-		case RTE_FLOW_ACTION_TYPE_PORT_ID:
-			size = sizeof(struct rte_flow_action_port_id);
-			rte_memcpy(&sample_port_id[idx],
-				(const void *)action->conf, size);
-			action->conf = &sample_port_id[idx];
-			break;
-		case RTE_FLOW_ACTION_TYPE_PF:
-			break;
-		case RTE_FLOW_ACTION_TYPE_VF:
-			size = sizeof(struct rte_flow_action_vf);
-			rte_memcpy(&sample_vf[idx],
-					(const void *)action->conf, size);
-			action->conf = &sample_vf[idx];
-			break;
-		case RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP:
-			size = sizeof(struct rte_flow_action_vxlan_encap);
-			parse_setup_vxlan_encap_data(&sample_vxlan_encap[idx]);
-			action->conf = &sample_vxlan_encap[idx].conf;
-			break;
-		case RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP:
-			size = sizeof(struct rte_flow_action_nvgre_encap);
-			parse_setup_nvgre_encap_data(&sample_nvgre_encap[idx]);
-			action->conf = &sample_nvgre_encap[idx];
-			break;
-		case RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR:
-			size = sizeof(struct rte_flow_action_ethdev);
-			rte_memcpy(&sample_port_representor[idx],
-					(const void *)action->conf, size);
-			action->conf = &sample_port_representor[idx];
-			break;
-		case RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT:
-			size = sizeof(struct rte_flow_action_ethdev);
-			rte_memcpy(&sample_represented_port[idx],
-					(const void *)action->conf, size);
-			action->conf = &sample_represented_port[idx];
-			break;
-		default:
-			fprintf(stderr, "Error - Not supported action\n");
-			return;
-		}
-		rte_memcpy(data, action, sizeof(struct rte_flow_action));
-		data++;
-	}
-}
 
 /** Dispatch parsed buffer to function calls. */
 static void
@@ -11121,10 +6260,7 @@
 	uint16_t upper_layer = 0;
 	uint16_t proto = 0;
 	uint16_t idx = in->port; /* We borrow port field as index */
-	int gtp_psc = -1; /* GTP PSC option index. */
 
-	if (in->command == SET_SAMPLE_ACTIONS)
-		return cmd_set_raw_parsed_sample(in);
 	RTE_ASSERT(in->command == SET_RAW_ENCAP ||
 		   in->command == SET_RAW_DECAP);
 	if (in->command == SET_RAW_ENCAP) {
@@ -11139,44 +6275,41 @@
 	/* process hdr from upper layer to low layer (L3/L4 -> L2). */
 	data_tail = data + ACTION_RAW_ENCAP_MAX_DATA;
 	for (i = n - 1 ; i >= 0; --i) {
-		const struct rte_flow_item_gtp *gtp;
-		const struct rte_flow_item_geneve_opt *opt;
-
 		item = in->args.vc.pattern + i;
 		if (item->spec == NULL)
 			item->spec = flow_item_default_mask(item);
 		switch (item->type) {
 		case RTE_FLOW_ITEM_TYPE_ETH:
-			size = sizeof(struct rte_ether_hdr);
+			size = sizeof(struct rte_flow_item_eth);
 			break;
 		case RTE_FLOW_ITEM_TYPE_VLAN:
-			size = sizeof(struct rte_vlan_hdr);
+			size = sizeof(struct rte_flow_item_vlan);
 			proto = RTE_ETHER_TYPE_VLAN;
 			break;
 		case RTE_FLOW_ITEM_TYPE_IPV4:
-			size = sizeof(struct rte_ipv4_hdr);
+			size = sizeof(struct rte_flow_item_ipv4);
 			proto = RTE_ETHER_TYPE_IPV4;
 			break;
 		case RTE_FLOW_ITEM_TYPE_IPV6:
-			size = sizeof(struct rte_ipv6_hdr);
+			size = sizeof(struct rte_flow_item_ipv6);
 			proto = RTE_ETHER_TYPE_IPV6;
 			break;
 		case RTE_FLOW_ITEM_TYPE_UDP:
-			size = sizeof(struct rte_udp_hdr);
+			size = sizeof(struct rte_flow_item_udp);
 			proto = 0x11;
 			break;
 		case RTE_FLOW_ITEM_TYPE_TCP:
-			size = sizeof(struct rte_tcp_hdr);
+			size = sizeof(struct rte_flow_item_tcp);
 			proto = 0x06;
 			break;
 		case RTE_FLOW_ITEM_TYPE_VXLAN:
-			size = sizeof(struct rte_vxlan_hdr);
+			size = sizeof(struct rte_flow_item_vxlan);
 			break;
 		case RTE_FLOW_ITEM_TYPE_VXLAN_GPE:
-			size = sizeof(struct rte_vxlan_gpe_hdr);
+			size = sizeof(struct rte_flow_item_vxlan_gpe);
 			break;
 		case RTE_FLOW_ITEM_TYPE_GRE:
-			size = sizeof(struct rte_gre_hdr);
+			size = sizeof(struct rte_flow_item_gre);
 			proto = 0x2F;
 			break;
 		case RTE_FLOW_ITEM_TYPE_GRE_KEY:
@@ -11184,7 +6317,7 @@
 			proto = 0x0;
 			break;
 		case RTE_FLOW_ITEM_TYPE_MPLS:
-			size = sizeof(struct rte_mpls_hdr);
+			size = sizeof(struct rte_flow_item_mpls);
 			proto = 0x0;
 			break;
 		case RTE_FLOW_ITEM_TYPE_NVGRE:
@@ -11192,120 +6325,13 @@
 			proto = 0x2F;
 			break;
 		case RTE_FLOW_ITEM_TYPE_GENEVE:
-			size = sizeof(struct rte_geneve_hdr);
-			break;
-		case RTE_FLOW_ITEM_TYPE_GENEVE_OPT:
-			opt = (const struct rte_flow_item_geneve_opt *)
-								item->spec;
-			size = offsetof(struct rte_flow_item_geneve_opt,
-					option_len) + sizeof(uint8_t);
-			if (opt->option_len && opt->data) {
-				*total_size += opt->option_len *
-					       sizeof(uint32_t);
-				rte_memcpy(data_tail - (*total_size),
-					   opt->data,
-					   opt->option_len * sizeof(uint32_t));
-			}
-			break;
-		case RTE_FLOW_ITEM_TYPE_L2TPV3OIP:
-			size = sizeof(rte_be32_t);
-			proto = 0x73;
-			break;
-		case RTE_FLOW_ITEM_TYPE_ESP:
-			size = sizeof(struct rte_esp_hdr);
-			proto = 0x32;
-			break;
-		case RTE_FLOW_ITEM_TYPE_AH:
-			size = sizeof(struct rte_flow_item_ah);
-			proto = 0x33;
-			break;
-		case RTE_FLOW_ITEM_TYPE_GTP:
-			if (gtp_psc < 0) {
-				size = sizeof(struct rte_gtp_hdr);
-				break;
-			}
-			if (gtp_psc != i + 1) {
-				fprintf(stderr,
-					"Error - GTP PSC does not follow GTP\n");
-				goto error;
-			}
-			gtp = item->spec;
-			if ((gtp->v_pt_rsv_flags & 0x07) != 0x04) {
-				/* Only E flag should be set. */
-				fprintf(stderr,
-					"Error - GTP unsupported flags\n");
-				goto error;
-			} else {
-				struct rte_gtp_hdr_ext_word ext_word = {
-					.next_ext = 0x85
-				};
-
-				/* We have to add GTP header extra word. */
-				*total_size += sizeof(ext_word);
-				rte_memcpy(data_tail - (*total_size),
-					   &ext_word, sizeof(ext_word));
-			}
-			size = sizeof(struct rte_gtp_hdr);
-			break;
-		case RTE_FLOW_ITEM_TYPE_GTP_PSC:
-			if (gtp_psc >= 0) {
-				fprintf(stderr,
-					"Error - Multiple GTP PSC items\n");
-				goto error;
-			} else {
-				const struct rte_flow_item_gtp_psc
-					*opt = item->spec;
-				struct rte_gtp_psc_generic_hdr *hdr;
-				size_t hdr_size = RTE_ALIGN(sizeof(*hdr),
-							 sizeof(int32_t));
-
-				*total_size += hdr_size;
-				hdr = (typeof(hdr))(data_tail - (*total_size));
-				memset(hdr, 0, hdr_size);
-				*hdr = opt->hdr;
-				hdr->ext_hdr_len = 1;
-				gtp_psc = i;
-				size = 0;
-			}
-			break;
-		case RTE_FLOW_ITEM_TYPE_PFCP:
-			size = sizeof(struct rte_flow_item_pfcp);
-			break;
-		case RTE_FLOW_ITEM_TYPE_FLEX:
-			size = item->spec ?
-				((const struct rte_flow_item_flex *)
-				item->spec)->length : 0;
-			break;
-		case RTE_FLOW_ITEM_TYPE_GRE_OPTION:
-			size = 0;
-			if (item->spec) {
-				const struct rte_flow_item_gre_opt
-					*opt = item->spec;
-				if (opt->checksum_rsvd.checksum) {
-					*total_size +=
-						sizeof(opt->checksum_rsvd);
-					rte_memcpy(data_tail - (*total_size),
-						   &opt->checksum_rsvd,
-						   sizeof(opt->checksum_rsvd));
-				}
-				if (opt->key.key) {
-					*total_size += sizeof(opt->key.key);
-					rte_memcpy(data_tail - (*total_size),
-						   &opt->key.key,
-						   sizeof(opt->key.key));
-				}
-				if (opt->sequence.sequence) {
-					*total_size += sizeof(opt->sequence.sequence);
-					rte_memcpy(data_tail - (*total_size),
-						   &opt->sequence.sequence,
-						   sizeof(opt->sequence.sequence));
-				}
-			}
-			proto = 0x2F;
+			size = sizeof(struct rte_flow_item_geneve);
 			break;
 		default:
-			fprintf(stderr, "Error - Not supported item\n");
-			goto error;
+			printf("Error - Not supported item\n");
+			*total_size = 0;
+			memset(data, 0x00, ACTION_RAW_ENCAP_MAX_DATA);
+			return;
 		}
 		*total_size += size;
 		rte_memcpy(data_tail - (*total_size), item->spec, size);
@@ -11318,11 +6344,6 @@
 		printf("total data size is %zu\n", (*total_size));
 	RTE_ASSERT((*total_size) <= ACTION_RAW_ENCAP_MAX_DATA);
 	memmove(data, (data_tail - (*total_size)), *total_size);
-	return;
-
-error:
-	*total_size = 0;
-	memset(data, 0x00, ACTION_RAW_ENCAP_MAX_DATA);
 }
 
 /** Populate help strings for current token (cmdline API). */
@@ -11432,8 +6453,7 @@
 		all = 1;
 		index = 0;
 	} else if (index >= RAW_ENCAP_CONFS_MAX_NUM) {
-		fprintf(stderr, "index should be 0-%u\n",
-			RAW_ENCAP_CONFS_MAX_NUM - 1);
+		printf("index should be 0-%u\n", RAW_ENCAP_CONFS_MAX_NUM - 1);
 		return;
 	}
 	do {
@@ -11451,16 +6471,16 @@
 	} while (all && ++index < RAW_ENCAP_CONFS_MAX_NUM);
 }
 
-static cmdline_parse_token_string_t cmd_show_set_raw_cmd_show =
+cmdline_parse_token_string_t cmd_show_set_raw_cmd_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_set_raw_result,
 			cmd_show, "show");
-static cmdline_parse_token_string_t cmd_show_set_raw_cmd_what =
+cmdline_parse_token_string_t cmd_show_set_raw_cmd_what =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_set_raw_result,
 			cmd_what, "raw_encap#raw_decap");
-static cmdline_parse_token_num_t cmd_show_set_raw_cmd_index =
+cmdline_parse_token_num_t cmd_show_set_raw_cmd_index =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_set_raw_result,
-			cmd_index, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_show_set_raw_cmd_all =
+			cmd_index, UINT16);
+cmdline_parse_token_string_t cmd_show_set_raw_cmd_all =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_set_raw_result,
 			cmd_all, "all");
 cmdline_parse_inst_t cmd_show_set_raw = {
diff -urN dpdk/app/test-pmd/cmdline_mtr.c testpmd-as-load-balancer/v19.11/test-pmd/cmdline_mtr.c
--- dpdk/app/test-pmd/cmdline_mtr.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/cmdline_mtr.c	2023-12-15 15:26:37.089199123 +0100
@@ -2,8 +2,6 @@
  * Copyright(c) 2017 Intel Corporation
  */
 
-#include <stdlib.h>
-
 #include <cmdline_parse.h>
 #include <cmdline_parse_num.h>
 #include <cmdline_parse_string.h>
@@ -16,7 +14,6 @@
 #include "cmdline_mtr.h"
 
 #define PARSE_DELIMITER				" \f\n\r\t\v"
-#define MAX_VLAN_TABLE_ENTRIES		16
 #define MAX_DSCP_TABLE_ENTRIES		64
 
 /** Display Meter Error Message */
@@ -40,8 +37,6 @@
 		[RTE_MTR_ERROR_TYPE_STATS] = "stats",
 		[RTE_MTR_ERROR_TYPE_SHARED]
 			= "shared meter",
-		[RTE_MTR_ERROR_TYPE_METER_POLICY_ID] = "meter policy id",
-		[RTE_MTR_ERROR_TYPE_METER_POLICY] = "meter policy null",
 	};
 
 	const char *errstr;
@@ -56,18 +51,11 @@
 	if (error->cause)
 		snprintf(buf, sizeof(buf), "cause: %p, ", error->cause);
 
-	fprintf(stderr, "%s: %s%s (error %d)\n",
-		errstr, error->cause ? buf : "",
+	printf("%s: %s%s (error %d)\n", errstr, error->cause ? buf : "",
 		error->message ? error->message : "(no stated reason)",
 		error->type);
 }
 
-void
-print_mtr_err_msg(struct rte_mtr_error *error)
-{
-	print_err_msg(error);
-}
-
 static int
 parse_uint(uint64_t *value, const char *str)
 {
@@ -86,126 +74,6 @@
 }
 
 static int
-parse_input_color_table_entries(char *str, enum rte_color **dscp_table,
-	enum rte_color **vlan_table)
-{
-	enum rte_color *vlan, *dscp;
-	char *token;
-	int i = 0;
-
-	token = strtok_r(str, PARSE_DELIMITER, &str);
-	if (token == NULL)
-		return 0;
-
-	/* Allocate memory for dscp table */
-	dscp = (enum rte_color *)malloc(MAX_DSCP_TABLE_ENTRIES *
-		sizeof(enum rte_color));
-	if (dscp == NULL)
-		return -1;
-
-	while (1) {
-		if (strcasecmp(token, "G") == 0)
-			dscp[i++] = RTE_COLOR_GREEN;
-		else if (strcasecmp(token, "Y") == 0)
-			dscp[i++] = RTE_COLOR_YELLOW;
-		else if (strcasecmp(token, "R") == 0)
-			dscp[i++] = RTE_COLOR_RED;
-		else {
-			free(dscp);
-			return -1;
-		}
-		if (i == MAX_DSCP_TABLE_ENTRIES)
-			break;
-
-		token = strtok_r(str, PARSE_DELIMITER, &str);
-		if (token == NULL) {
-			free(dscp);
-			return -1;
-		}
-	}
-
-	*dscp_table = dscp;
-
-	token = strtok_r(str, PARSE_DELIMITER, &str);
-	if (token == NULL)
-		return 0;
-
-	/* Allocate memory for vlan table */
-	vlan = (enum rte_color *)malloc(MAX_VLAN_TABLE_ENTRIES *
-		sizeof(enum rte_color));
-	if (vlan == NULL) {
-		free(*dscp_table);
-		return -1;
-	}
-
-	i = 0;
-	while (1) {
-		if (strcasecmp(token, "G") == 0)
-			vlan[i++] = RTE_COLOR_GREEN;
-		else if (strcasecmp(token, "Y") == 0)
-			vlan[i++] = RTE_COLOR_YELLOW;
-		else if (strcasecmp(token, "R") == 0)
-			vlan[i++] = RTE_COLOR_RED;
-		else {
-			free(vlan);
-			free(*dscp_table);
-			return -1;
-		}
-		if (i == MAX_VLAN_TABLE_ENTRIES)
-			break;
-
-		token = strtok_r(str, PARSE_DELIMITER, &str);
-		if (token == NULL) {
-			free(vlan);
-			free(*dscp_table);
-			return -1;
-		}
-	}
-
-	*vlan_table = vlan;
-	return 0;
-}
-
-static int
-parse_vlan_table_entries(char *str, enum rte_color **vlan_table)
-{
-	char *token;
-	int i = 0;
-
-	token = strtok_r(str, PARSE_DELIMITER, &str);
-	if (token == NULL)
-		return 0;
-
-	/* Allocate memory for vlan table */
-	*vlan_table = (enum rte_color *)malloc(MAX_VLAN_TABLE_ENTRIES *
-		sizeof(enum rte_color));
-	if (*vlan_table == NULL)
-		return -1;
-
-	while (1) {
-		if (strcasecmp(token, "G") == 0)
-			(*vlan_table)[i++] = RTE_COLOR_GREEN;
-		else if (strcasecmp(token, "Y") == 0)
-			(*vlan_table)[i++] = RTE_COLOR_YELLOW;
-		else if (strcasecmp(token, "R") == 0)
-			(*vlan_table)[i++] = RTE_COLOR_RED;
-		else {
-			free(*vlan_table);
-			return -1;
-		}
-		if (i == MAX_VLAN_TABLE_ENTRIES)
-			break;
-
-		token = strtok_r(str, PARSE_DELIMITER, &str);
-		if (token == NULL) {
-			free(*vlan_table);
-			return -1;
-		}
-	}
-	return 0;
-}
-
-static int
 parse_dscp_table_entries(char *str, enum rte_color **dscp_table)
 {
 	char *token;
@@ -224,13 +92,13 @@
 	while (1) {
 		if (strcmp(token, "G") == 0 ||
 			strcmp(token, "g") == 0)
-			(*dscp_table)[i++] = RTE_COLOR_GREEN;
+			*dscp_table[i++] = RTE_COLOR_GREEN;
 		else if (strcmp(token, "Y") == 0 ||
 			strcmp(token, "y") == 0)
-			(*dscp_table)[i++] = RTE_COLOR_YELLOW;
+			*dscp_table[i++] = RTE_COLOR_YELLOW;
 		else if (strcmp(token, "R") == 0 ||
 			strcmp(token, "r") == 0)
-			(*dscp_table)[i++] = RTE_COLOR_RED;
+			*dscp_table[i++] = RTE_COLOR_RED;
 		else {
 			free(*dscp_table);
 			return -1;
@@ -248,29 +116,8 @@
 }
 
 static int
-parse_default_input_color_str(char *str, uint64_t *def_inp_color)
-{
-	char *token;
-
-	token = strtok_r(str, PARSE_DELIMITER, &str);
-	if (token == NULL)
-		return 0;
-
-	if (strcasecmp(token, "G") == 0)
-		*def_inp_color = RTE_COLOR_GREEN;
-	else if (strcasecmp(token, "Y") == 0)
-		*def_inp_color = RTE_COLOR_YELLOW;
-	else if (strcasecmp(token, "R") == 0)
-		*def_inp_color = RTE_COLOR_RED;
-	else
-		return -1;
-
-	return 0;
-}
-
-static int
 parse_meter_color_str(char *c_str, uint32_t *use_prev_meter_color,
-	enum rte_color **vlan_table, enum rte_color **dscp_table)
+	enum rte_color **dscp_table)
 {
 	char *token;
 	uint64_t previous_mtr_color = 0;
@@ -291,7 +138,8 @@
 		return 0;
 	}
 
-	ret = parse_input_color_table_entries(c_str, dscp_table, vlan_table);
+	/* Parse dscp table entries */
+	ret = parse_dscp_table_entries(c_str, dscp_table);
 	if (ret != 0)
 		return -1;
 
@@ -299,58 +147,58 @@
 }
 
 static int
-parse_multi_token_string(char *t_str, uint16_t *port_id, uint32_t *mtr_id,
-	enum rte_mtr_color_in_protocol *proto, enum rte_color **dscp_table)
+string_to_policer_action(char *s)
 {
-	char *token;
-	uint64_t val;
-	int ret;
+	if ((strcmp(s, "G") == 0) || (strcmp(s, "g") == 0))
+		return MTR_POLICER_ACTION_COLOR_GREEN;
 
-	/* First token: port id */
-	token = strtok_r(t_str, PARSE_DELIMITER, &t_str);
-	if (token ==  NULL)
-		return -1;
+	if ((strcmp(s, "Y") == 0) || (strcmp(s, "y") == 0))
+		return MTR_POLICER_ACTION_COLOR_YELLOW;
 
-	ret = parse_uint(&val, token);
-	if (ret != 0 || val > UINT16_MAX)
-		return -1;
+	if ((strcmp(s, "R") == 0) || (strcmp(s, "r") == 0))
+		return MTR_POLICER_ACTION_COLOR_RED;
 
-	*port_id = val;
+	if ((strcmp(s, "D") == 0) || (strcmp(s, "d") == 0))
+		return MTR_POLICER_ACTION_DROP;
 
-	/* Second token: meter id */
-	token = strtok_r(t_str, PARSE_DELIMITER, &t_str);
-	if (token == NULL)
-		return 0;
-
-	ret = parse_uint(&val, token);
-	if (ret != 0 || val > UINT32_MAX)
-		return -1;
-
-	*mtr_id = val;
+	return -1;
+}
 
-	/* Third token: protocol  */
-	token = strtok_r(t_str, PARSE_DELIMITER, &t_str);
-	if (token == NULL)
-		return 0;
+static int
+parse_policer_action_string(char *p_str, uint32_t action_mask,
+	enum rte_mtr_policer_action actions[])
+{
+	char *token;
+	int count = __builtin_popcount(action_mask);
+	int g_color = 0, y_color = 0, action, i;
 
-	if (strcmp(token, "outer_ip") == 0)
-		*proto = RTE_MTR_COLOR_IN_PROTO_OUTER_IP;
-	else if (strcmp(token, "inner_ip") == 0)
-		*proto = RTE_MTR_COLOR_IN_PROTO_INNER_IP;
+	for (i = 0; i < count; i++) {
+		token = strtok_r(p_str, PARSE_DELIMITER, &p_str);
+		if (token ==  NULL)
+			return -1;
 
-	ret = parse_dscp_table_entries(t_str, dscp_table);
-	if (ret != 0)
-		return -1;
+		action = string_to_policer_action(token);
+		if (action == -1)
+			return -1;
 
+		if (g_color == 0 && (action_mask & 0x1)) {
+			actions[RTE_COLOR_GREEN] = action;
+			g_color = 1;
+		} else if (y_color == 0 && (action_mask & 0x2)) {
+			actions[RTE_COLOR_YELLOW] = action;
+			y_color = 1;
+		} else
+			actions[RTE_COLOR_RED] = action;
+	}
 	return 0;
 }
 
 static int
-parse_multi_token_vlan_str(char *t_str, uint16_t *port_id, uint32_t *mtr_id,
-	enum rte_mtr_color_in_protocol *proto, enum rte_color **vlan_table)
+parse_multi_token_string(char *t_str, uint16_t *port_id,
+	uint32_t *mtr_id, enum rte_color **dscp_table)
 {
-	uint64_t val;
 	char *token;
+	uint64_t val;
 	int ret;
 
 	/* First token: port id */
@@ -375,17 +223,7 @@
 
 	*mtr_id = val;
 
-	/* Third token: protocol  */
-	token = strtok_r(t_str, PARSE_DELIMITER, &t_str);
-	if (token == NULL)
-		return 0;
-
-	if (strcmp(token, "outer_vlan") == 0)
-		*proto = RTE_MTR_COLOR_IN_PROTO_OUTER_VLAN;
-	else if (strcmp(token, "inner_vlan") == 0)
-		*proto = RTE_MTR_COLOR_IN_PROTO_INNER_VLAN;
-
-	ret = parse_vlan_table_entries(t_str, vlan_table);
+	ret = parse_dscp_table_entries(t_str, dscp_table);
 	if (ret != 0)
 		return -1;
 
@@ -401,25 +239,25 @@
 	uint16_t port_id;
 };
 
-static cmdline_parse_token_string_t cmd_show_port_meter_cap_show =
+cmdline_parse_token_string_t cmd_show_port_meter_cap_show =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_meter_cap_result, show, "show");
-static cmdline_parse_token_string_t cmd_show_port_meter_cap_port =
+cmdline_parse_token_string_t cmd_show_port_meter_cap_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_meter_cap_result, port, "port");
-static cmdline_parse_token_string_t cmd_show_port_meter_cap_meter =
+cmdline_parse_token_string_t cmd_show_port_meter_cap_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_meter_cap_result, meter, "meter");
-static cmdline_parse_token_string_t cmd_show_port_meter_cap_cap =
+cmdline_parse_token_string_t cmd_show_port_meter_cap_cap =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_meter_cap_result, cap, "cap");
-static cmdline_parse_token_num_t cmd_show_port_meter_cap_port_id =
+cmdline_parse_token_num_t cmd_show_port_meter_cap_port_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_show_port_meter_cap_result, port_id, RTE_UINT16);
+		struct cmd_show_port_meter_cap_result, port_id, UINT16);
 
 static void cmd_show_port_meter_cap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_show_port_meter_cap_result *res = parsed_result;
 	struct rte_mtr_capabilities cap;
@@ -464,29 +302,17 @@
 		cap.color_aware_trtcm_rfc2698_supported);
 	printf("cap.color_aware_trtcm_rfc4115_supported %" PRId32 "\n",
 		cap.color_aware_trtcm_rfc4115_supported);
-	printf("cap.srtcm_rfc2697_byte_mode_supported %" PRId32 "\n",
-		cap.srtcm_rfc2697_byte_mode_supported);
-	printf("cap.srtcm_rfc2697_packet_mode_supported %" PRId32 "\n",
-		cap.srtcm_rfc2697_packet_mode_supported);
-	printf("cap.trtcm_rfc2698_byte_mode_supported %" PRId32 "\n",
-		cap.trtcm_rfc2698_byte_mode_supported);
-	printf("cap.trtcm_rfc2698_packet_mode_supported %" PRId32 "\n",
-		cap.trtcm_rfc2698_packet_mode_supported);
-	printf("cap.trtcm_rfc4115_byte_mode_supported %" PRId32 "\n",
-		cap.trtcm_rfc4115_byte_mode_supported);
-	printf("cap.trtcm_rfc4115_packet_mode_supported %" PRId32 "\n",
-		cap.trtcm_rfc4115_packet_mode_supported);
+	printf("cap.policer_action_recolor_supported %" PRId32 "\n",
+		cap.policer_action_recolor_supported);
+	printf("cap.policer_action_drop_supported %" PRId32 "\n",
+		cap.policer_action_drop_supported);
 	printf("cap.stats_mask %" PRIx64 "\n", cap.stats_mask);
-	printf("cap.input_color_proto_mask 0x%" PRIx64 "\n",
-		cap.input_color_proto_mask);
-	printf("cap.separate_input_color_table_per_port %" PRId32 "\n",
-		cap.separate_input_color_table_per_port);
 }
 
 cmdline_parse_inst_t cmd_show_port_meter_cap = {
 	.f = cmd_show_port_meter_cap_parsed,
 	.data = NULL,
-	.help_str = "show port meter cap <port_id>",
+	.help_str = "Show port meter cap",
 	.tokens = {
 		(void *)&cmd_show_port_meter_cap_show,
 		(void *)&cmd_show_port_meter_cap_port,
@@ -509,56 +335,51 @@
 	uint64_t cir;
 	uint64_t cbs;
 	uint64_t ebs;
-	int packet_mode;
 };
 
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_add =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_add =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result, add, "add");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_port =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_meter =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result,
 			meter, "meter");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_profile =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result,
 			profile, "profile");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_srtcm_rfc2697 =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_srtcm_srtcm_rfc2697 =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result,
 			srtcm_rfc2697, "srtcm_rfc2697");
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_port_id =
+cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_profile_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_profile_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result,
-			profile_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_cir =
+			profile_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_cir =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result,
-			cir, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_cbs =
+			cir, UINT64);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_cbs =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result,
-			cbs, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_ebs =
+			cbs, UINT64);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_ebs =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_srtcm_result,
-			ebs, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_srtcm_packet_mode =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_add_port_meter_profile_srtcm_result,
-			packet_mode, RTE_UINT32);
+			ebs, UINT64);
 
 static void cmd_add_port_meter_profile_srtcm_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_add_port_meter_profile_srtcm_result *res = parsed_result;
 	struct rte_mtr_meter_profile mp;
@@ -576,7 +397,6 @@
 	mp.srtcm_rfc2697.cir = res->cir;
 	mp.srtcm_rfc2697.cbs = res->cbs;
 	mp.srtcm_rfc2697.ebs = res->ebs;
-	mp.packet_mode = res->packet_mode;
 
 	ret = rte_mtr_meter_profile_add(port_id, profile_id, &mp, &error);
 	if (ret != 0) {
@@ -588,7 +408,7 @@
 cmdline_parse_inst_t cmd_add_port_meter_profile_srtcm = {
 	.f = cmd_add_port_meter_profile_srtcm_parsed,
 	.data = NULL,
-	.help_str = "add port meter profile srtcm_rfc2697 <port_id> <profile_id> <cir> <cbs> <ebs> <packet_mode>",
+	.help_str = "Add port meter profile srtcm (rfc2697)",
 	.tokens = {
 		(void *)&cmd_add_port_meter_profile_srtcm_add,
 		(void *)&cmd_add_port_meter_profile_srtcm_port,
@@ -600,7 +420,6 @@
 		(void *)&cmd_add_port_meter_profile_srtcm_cir,
 		(void *)&cmd_add_port_meter_profile_srtcm_cbs,
 		(void *)&cmd_add_port_meter_profile_srtcm_ebs,
-		(void *)&cmd_add_port_meter_profile_srtcm_packet_mode,
 		NULL,
 	},
 };
@@ -618,60 +437,55 @@
 	uint64_t pir;
 	uint64_t cbs;
 	uint64_t pbs;
-	int packet_mode;
 };
 
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_add =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_add =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result, add, "add");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_port =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_meter =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
 			meter, "meter");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_profile =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
 			profile, "profile");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_trtcm_rfc2698 =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_trtcm_rfc2698 =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
 			trtcm_rfc2698, "trtcm_rfc2698");
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_port_id =
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_profile_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_profile_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
-			profile_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_cir =
+			profile_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_cir =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
-			cir, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_pir =
+			cir, UINT64);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_pir =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
-			pir, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_cbs =
+			pir, UINT64);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_cbs =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
-			cbs, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_pbs =
+			cbs, UINT64);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_pbs =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_result,
-			pbs, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_packet_mode =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_add_port_meter_profile_trtcm_result,
-			packet_mode, RTE_UINT32);
+			pbs, UINT64);
 
 static void cmd_add_port_meter_profile_trtcm_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_add_port_meter_profile_trtcm_result *res = parsed_result;
 	struct rte_mtr_meter_profile mp;
@@ -690,7 +504,6 @@
 	mp.trtcm_rfc2698.pir = res->pir;
 	mp.trtcm_rfc2698.cbs = res->cbs;
 	mp.trtcm_rfc2698.pbs = res->pbs;
-	mp.packet_mode = res->packet_mode;
 
 	ret = rte_mtr_meter_profile_add(port_id, profile_id, &mp, &error);
 	if (ret != 0) {
@@ -702,7 +515,7 @@
 cmdline_parse_inst_t cmd_add_port_meter_profile_trtcm = {
 	.f = cmd_add_port_meter_profile_trtcm_parsed,
 	.data = NULL,
-	.help_str = "add port meter profile trtcm_rfc2698 <port_id> <profile_id> <cir> <pir> <cbs> <pbs> <packet_mode>",
+	.help_str = "Add port meter profile trtcm (rfc2698)",
 	.tokens = {
 		(void *)&cmd_add_port_meter_profile_trtcm_add,
 		(void *)&cmd_add_port_meter_profile_trtcm_port,
@@ -715,7 +528,6 @@
 		(void *)&cmd_add_port_meter_profile_trtcm_pir,
 		(void *)&cmd_add_port_meter_profile_trtcm_cbs,
 		(void *)&cmd_add_port_meter_profile_trtcm_pbs,
-		(void *)&cmd_add_port_meter_profile_trtcm_packet_mode,
 		NULL,
 	},
 };
@@ -733,64 +545,58 @@
 	uint64_t eir;
 	uint64_t cbs;
 	uint64_t ebs;
-	int packet_mode;
 };
 
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_rfc4115_add =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_rfc4115_add =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result, add,
 		"add");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_rfc4115_port =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_rfc4115_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_rfc4115_meter =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_rfc4115_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
 			meter, "meter");
-static cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_rfc4115_profile =
+cmdline_parse_token_string_t cmd_add_port_meter_profile_trtcm_rfc4115_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
 			profile, "profile");
-static cmdline_parse_token_string_t
+cmdline_parse_token_string_t
 	cmd_add_port_meter_profile_trtcm_rfc4115_trtcm_rfc4115 =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
 			trtcm_rfc4115, "trtcm_rfc4115");
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_port_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_profile_id =
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
-			profile_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_cir =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_profile_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
-			cir, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_eir =
+			profile_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_cir =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
-			eir, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_cbs =
+			cir, UINT64);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_eir =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
-			cbs, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_ebs =
+			eir, UINT64);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_cbs =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
-			ebs, RTE_UINT64);
-static cmdline_parse_token_num_t
-	cmd_add_port_meter_profile_trtcm_rfc4115_packet_mode =
+			cbs, UINT64);
+cmdline_parse_token_num_t cmd_add_port_meter_profile_trtcm_rfc4115_ebs =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_meter_profile_trtcm_rfc4115_result,
-			packet_mode, RTE_UINT32);
+			ebs, UINT64);
 
 static void cmd_add_port_meter_profile_trtcm_rfc4115_parsed(
 	void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_add_port_meter_profile_trtcm_rfc4115_result *res =
 		parsed_result;
@@ -810,7 +616,6 @@
 	mp.trtcm_rfc4115.eir = res->eir;
 	mp.trtcm_rfc4115.cbs = res->cbs;
 	mp.trtcm_rfc4115.ebs = res->ebs;
-	mp.packet_mode = res->packet_mode;
 
 	ret = rte_mtr_meter_profile_add(port_id, profile_id, &mp, &error);
 	if (ret != 0) {
@@ -822,7 +627,7 @@
 cmdline_parse_inst_t cmd_add_port_meter_profile_trtcm_rfc4115 = {
 	.f = cmd_add_port_meter_profile_trtcm_rfc4115_parsed,
 	.data = NULL,
-	.help_str = "add port meter profile trtcm_rfc4115 <port_id> <profile_id> <cir> <eir> <cbs> <ebs> <packet_mode>",
+	.help_str = "Add port meter profile trtcm (rfc4115)",
 	.tokens = {
 		(void *)&cmd_add_port_meter_profile_trtcm_rfc4115_add,
 		(void *)&cmd_add_port_meter_profile_trtcm_rfc4115_port,
@@ -835,7 +640,6 @@
 		(void *)&cmd_add_port_meter_profile_trtcm_rfc4115_eir,
 		(void *)&cmd_add_port_meter_profile_trtcm_rfc4115_cbs,
 		(void *)&cmd_add_port_meter_profile_trtcm_rfc4115_ebs,
-		(void *)&cmd_add_port_meter_profile_trtcm_rfc4115_packet_mode,
 		NULL,
 	},
 };
@@ -850,33 +654,33 @@
 	uint32_t profile_id;
 };
 
-static cmdline_parse_token_string_t cmd_del_port_meter_profile_del =
+cmdline_parse_token_string_t cmd_del_port_meter_profile_del =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_meter_profile_result, del, "del");
-static cmdline_parse_token_string_t cmd_del_port_meter_profile_port =
+cmdline_parse_token_string_t cmd_del_port_meter_profile_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_meter_profile_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_del_port_meter_profile_meter =
+cmdline_parse_token_string_t cmd_del_port_meter_profile_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_meter_profile_result,
 			meter, "meter");
-static cmdline_parse_token_string_t cmd_del_port_meter_profile_profile =
+cmdline_parse_token_string_t cmd_del_port_meter_profile_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_meter_profile_result,
 			profile, "profile");
-static cmdline_parse_token_num_t cmd_del_port_meter_profile_port_id =
+cmdline_parse_token_num_t cmd_del_port_meter_profile_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_del_port_meter_profile_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_del_port_meter_profile_profile_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_del_port_meter_profile_profile_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_del_port_meter_profile_result,
-			profile_id, RTE_UINT32);
+			profile_id, UINT32);
 
 static void cmd_del_port_meter_profile_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_del_port_meter_profile_result *res = parsed_result;
 	struct rte_mtr_error error;
@@ -898,7 +702,7 @@
 cmdline_parse_inst_t cmd_del_port_meter_profile = {
 	.f = cmd_del_port_meter_profile_parsed,
 	.data = NULL,
-	.help_str = "del port meter profile <port_id> <profile_id>",
+	.help_str = "Delete port meter profile",
 	.tokens = {
 		(void *)&cmd_del_port_meter_profile_del,
 		(void *)&cmd_del_port_meter_profile_port,
@@ -918,57 +722,58 @@
 	uint16_t port_id;
 	uint32_t mtr_id;
 	uint32_t profile_id;
-	uint32_t policy_id;
 	cmdline_fixed_string_t meter_enable;
 	cmdline_fixed_string_t g_action;
 	cmdline_fixed_string_t y_action;
 	cmdline_fixed_string_t r_action;
 	uint64_t statistics_mask;
 	uint32_t shared;
-	cmdline_fixed_string_t default_input_color;
 	cmdline_multi_string_t meter_input_color;
 };
 
-static cmdline_parse_token_string_t cmd_create_port_meter_create =
+cmdline_parse_token_string_t cmd_create_port_meter_create =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_create_port_meter_result, create, "create");
-static cmdline_parse_token_string_t cmd_create_port_meter_port =
+cmdline_parse_token_string_t cmd_create_port_meter_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_create_port_meter_result, port, "port");
-static cmdline_parse_token_string_t cmd_create_port_meter_meter =
+cmdline_parse_token_string_t cmd_create_port_meter_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_create_port_meter_result, meter, "meter");
-static cmdline_parse_token_num_t cmd_create_port_meter_port_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_create_port_meter_result, port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_create_port_meter_mtr_id =
+cmdline_parse_token_num_t cmd_create_port_meter_port_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_create_port_meter_result, mtr_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_create_port_meter_profile_id =
+		struct cmd_create_port_meter_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_create_port_meter_mtr_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_create_port_meter_result, profile_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_create_port_meter_policy_id =
+		struct cmd_create_port_meter_result, mtr_id, UINT32);
+cmdline_parse_token_num_t cmd_create_port_meter_profile_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_create_port_meter_result, policy_id, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_create_port_meter_meter_enable =
+		struct cmd_create_port_meter_result, profile_id, UINT32);
+cmdline_parse_token_string_t cmd_create_port_meter_meter_enable =
 	TOKEN_STRING_INITIALIZER(struct cmd_create_port_meter_result,
 		meter_enable, "yes#no");
-static cmdline_parse_token_num_t cmd_create_port_meter_statistics_mask =
+cmdline_parse_token_string_t cmd_create_port_meter_g_action =
+	TOKEN_STRING_INITIALIZER(struct cmd_create_port_meter_result,
+		g_action, "R#Y#G#D#r#y#g#d");
+cmdline_parse_token_string_t cmd_create_port_meter_y_action =
+	TOKEN_STRING_INITIALIZER(struct cmd_create_port_meter_result,
+		y_action, "R#Y#G#D#r#y#g#d");
+cmdline_parse_token_string_t cmd_create_port_meter_r_action =
+	TOKEN_STRING_INITIALIZER(struct cmd_create_port_meter_result,
+		r_action, "R#Y#G#D#r#y#g#d");
+cmdline_parse_token_num_t cmd_create_port_meter_statistics_mask =
 	TOKEN_NUM_INITIALIZER(struct cmd_create_port_meter_result,
-		statistics_mask, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_create_port_meter_shared =
+		statistics_mask, UINT64);
+cmdline_parse_token_num_t cmd_create_port_meter_shared =
 	TOKEN_NUM_INITIALIZER(struct cmd_create_port_meter_result,
-		shared, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_create_port_meter_default_input_color =
-	TOKEN_STRING_INITIALIZER(struct cmd_create_port_meter_result,
-		default_input_color, "R#Y#G#r#y#g");
-static cmdline_parse_token_string_t cmd_create_port_meter_input_color =
+		shared, UINT32);
+cmdline_parse_token_string_t cmd_create_port_meter_input_color =
 	TOKEN_STRING_INITIALIZER(struct cmd_create_port_meter_result,
 		meter_input_color, TOKEN_STRING_MULTI);
 
 static void cmd_create_port_meter_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_create_port_meter_result *res = parsed_result;
 	struct rte_mtr_error error;
@@ -977,10 +782,7 @@
 	uint32_t shared = res->shared;
 	uint32_t use_prev_meter_color = 0;
 	uint16_t port_id = res->port_id;
-	uint64_t def_inp_color = 0;
 	enum rte_color *dscp_table = NULL;
-	enum rte_color *vlan_table = NULL;
-	char *def_color_str = res->default_input_color;
 	char *c_str = res->meter_input_color;
 	int ret;
 
@@ -990,40 +792,32 @@
 	/* Meter params */
 	memset(&params, 0, sizeof(struct rte_mtr_params));
 	params.meter_profile_id = res->profile_id;
-	params.meter_policy_id = res->policy_id;
-
-	/* Parse meter default input color string params */
-	ret = parse_default_input_color_str(def_color_str, &def_inp_color);
-	if (ret) {
-		fprintf(stderr,
-			" Meter default input color is invalid\n");
-		return;
-	}
 
 	/* Parse meter input color string params */
-	ret = parse_meter_color_str(c_str, &use_prev_meter_color, &vlan_table,
-		&dscp_table);
+	ret = parse_meter_color_str(c_str, &use_prev_meter_color, &dscp_table);
 	if (ret) {
-		fprintf(stderr,
-			" Meter input color params string parse error\n");
+		printf(" Meter input color params string parse error\n");
 		return;
 	}
 
 	params.use_prev_mtr_color = use_prev_meter_color;
-	params.vlan_table = vlan_table;
 	params.dscp_table = dscp_table;
-	params.default_input_color = def_inp_color;
 
 	if (strcmp(res->meter_enable, "yes") == 0)
 		params.meter_enable = 1;
 	else
 		params.meter_enable = 0;
 
+	params.action[RTE_COLOR_GREEN] =
+		string_to_policer_action(res->g_action);
+	params.action[RTE_COLOR_YELLOW] =
+		string_to_policer_action(res->y_action);
+	params.action[RTE_COLOR_RED] =
+		string_to_policer_action(res->r_action);
 	params.stats_mask = res->statistics_mask;
 
 	ret = rte_mtr_create(port_id, mtr_id, &params, shared, &error);
 	if (ret != 0) {
-		free(vlan_table);
 		free(dscp_table);
 		print_err_msg(&error);
 		return;
@@ -1033,11 +827,7 @@
 cmdline_parse_inst_t cmd_create_port_meter = {
 	.f = cmd_create_port_meter_parsed,
 	.data = NULL,
-	.help_str = "create port meter <port_id> <mtr_id> <profile_id> <policy_id> "
-		"<meter_enable>(yes|no) <stats_mask> <shared> "
-		"<default_input_color>(g|y|r) <use_pre_meter_color> "
-		"[<dscp_tbl_entry0> <dscp_tbl_entry1> ...<dscp_tbl_entry63>] "
-		"[<vlan_tbl_entry0> <vlan_tbl_entry1> ... <vlan_tbl_entry15>]",
+	.help_str = "Create port meter",
 	.tokens = {
 		(void *)&cmd_create_port_meter_create,
 		(void *)&cmd_create_port_meter_port,
@@ -1045,11 +835,12 @@
 		(void *)&cmd_create_port_meter_port_id,
 		(void *)&cmd_create_port_meter_mtr_id,
 		(void *)&cmd_create_port_meter_profile_id,
-		(void *)&cmd_create_port_meter_policy_id,
 		(void *)&cmd_create_port_meter_meter_enable,
+		(void *)&cmd_create_port_meter_g_action,
+		(void *)&cmd_create_port_meter_y_action,
+		(void *)&cmd_create_port_meter_r_action,
 		(void *)&cmd_create_port_meter_statistics_mask,
 		(void *)&cmd_create_port_meter_shared,
-		(void *)&cmd_create_port_meter_default_input_color,
 		(void *)&cmd_create_port_meter_input_color,
 		NULL,
 	},
@@ -1064,25 +855,25 @@
 	uint32_t mtr_id;
 };
 
-static cmdline_parse_token_string_t cmd_enable_port_meter_enable =
+cmdline_parse_token_string_t cmd_enable_port_meter_enable =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_enable_port_meter_result, enable, "enable");
-static cmdline_parse_token_string_t cmd_enable_port_meter_port =
+cmdline_parse_token_string_t cmd_enable_port_meter_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_enable_port_meter_result, port, "port");
-static cmdline_parse_token_string_t cmd_enable_port_meter_meter =
+cmdline_parse_token_string_t cmd_enable_port_meter_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_enable_port_meter_result, meter, "meter");
-static cmdline_parse_token_num_t cmd_enable_port_meter_port_id =
+cmdline_parse_token_num_t cmd_enable_port_meter_port_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_enable_port_meter_result, port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_enable_port_meter_mtr_id =
+		struct cmd_enable_port_meter_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_enable_port_meter_mtr_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_enable_port_meter_result, mtr_id, RTE_UINT32);
+		struct cmd_enable_port_meter_result, mtr_id, UINT32);
 
 static void cmd_enable_port_meter_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_enable_port_meter_result *res = parsed_result;
 	struct rte_mtr_error error;
@@ -1105,7 +896,7 @@
 cmdline_parse_inst_t cmd_enable_port_meter = {
 	.f = cmd_enable_port_meter_parsed,
 	.data = NULL,
-	.help_str = "enable port meter <port_id> <mtr_id>",
+	.help_str = "Enable port meter",
 	.tokens = {
 		(void *)&cmd_enable_port_meter_enable,
 		(void *)&cmd_enable_port_meter_port,
@@ -1125,25 +916,25 @@
 	uint32_t mtr_id;
 };
 
-static cmdline_parse_token_string_t cmd_disable_port_meter_disable =
+cmdline_parse_token_string_t cmd_disable_port_meter_disable =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_disable_port_meter_result, disable, "disable");
-static cmdline_parse_token_string_t cmd_disable_port_meter_port =
+cmdline_parse_token_string_t cmd_disable_port_meter_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_disable_port_meter_result, port, "port");
-static cmdline_parse_token_string_t cmd_disable_port_meter_meter =
+cmdline_parse_token_string_t cmd_disable_port_meter_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_disable_port_meter_result, meter, "meter");
-static cmdline_parse_token_num_t cmd_disable_port_meter_port_id =
+cmdline_parse_token_num_t cmd_disable_port_meter_port_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_disable_port_meter_result, port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_disable_port_meter_mtr_id =
+		struct cmd_disable_port_meter_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_disable_port_meter_mtr_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_disable_port_meter_result, mtr_id, RTE_UINT32);
+		struct cmd_disable_port_meter_result, mtr_id, UINT32);
 
 static void cmd_disable_port_meter_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_disable_port_meter_result *res = parsed_result;
 	struct rte_mtr_error error;
@@ -1166,7 +957,7 @@
 cmdline_parse_inst_t cmd_disable_port_meter = {
 	.f = cmd_disable_port_meter_parsed,
 	.data = NULL,
-	.help_str = "disable port meter <port_id> <mtr_id>",
+	.help_str = "Disable port meter",
 	.tokens = {
 		(void *)&cmd_disable_port_meter_disable,
 		(void *)&cmd_disable_port_meter_port,
@@ -1177,71 +968,6 @@
 	},
 };
 
-/* *** Delete Port Meter Policy Object *** */
-struct cmd_del_port_meter_policy_result {
-	cmdline_fixed_string_t del;
-	cmdline_fixed_string_t port;
-	cmdline_fixed_string_t meter;
-	cmdline_fixed_string_t policy;
-	uint16_t port_id;
-	uint32_t policy_id;
-};
-
-static cmdline_parse_token_string_t cmd_del_port_meter_policy_del =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_del_port_meter_policy_result, del, "del");
-static cmdline_parse_token_string_t cmd_del_port_meter_policy_port =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_del_port_meter_policy_result, port, "port");
-static cmdline_parse_token_string_t cmd_del_port_meter_policy_meter =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_del_port_meter_policy_result, meter, "meter");
-static cmdline_parse_token_string_t cmd_del_port_meter_policy_policy =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_del_port_meter_policy_result, policy, "policy");
-static cmdline_parse_token_num_t cmd_del_port_meter_policy_port_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_del_port_meter_policy_result, port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_del_port_meter_policy_policy_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_del_port_meter_policy_result, policy_id, RTE_UINT32);
-
-static void cmd_del_port_meter_policy_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
-{
-	struct cmd_del_port_meter_policy_result *res = parsed_result;
-	struct rte_mtr_error error;
-	uint32_t policy_id = res->policy_id;
-	uint16_t port_id = res->port_id;
-	int ret;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN))
-		return;
-
-	/* Delete Meter Policy*/
-	ret = rte_mtr_meter_policy_delete(port_id, policy_id, &error);
-	if (ret != 0) {
-		print_err_msg(&error);
-		return;
-	}
-}
-
-cmdline_parse_inst_t cmd_del_port_meter_policy = {
-	.f = cmd_del_port_meter_policy_parsed,
-	.data = NULL,
-	.help_str = "Delete port meter policy",
-	.tokens = {
-		(void *)&cmd_del_port_meter_policy_del,
-		(void *)&cmd_del_port_meter_policy_port,
-		(void *)&cmd_del_port_meter_policy_meter,
-		(void *)&cmd_del_port_meter_policy_policy,
-		(void *)&cmd_del_port_meter_policy_port_id,
-		(void *)&cmd_del_port_meter_policy_policy_id,
-		NULL,
-	},
-};
-
 /* *** Delete Port Meter Object *** */
 struct cmd_del_port_meter_result {
 	cmdline_fixed_string_t del;
@@ -1251,25 +977,25 @@
 	uint32_t mtr_id;
 };
 
-static cmdline_parse_token_string_t cmd_del_port_meter_del =
+cmdline_parse_token_string_t cmd_del_port_meter_del =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_meter_result, del, "del");
-static cmdline_parse_token_string_t cmd_del_port_meter_port =
+cmdline_parse_token_string_t cmd_del_port_meter_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_meter_result, port, "port");
-static cmdline_parse_token_string_t cmd_del_port_meter_meter =
+cmdline_parse_token_string_t cmd_del_port_meter_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_meter_result, meter, "meter");
-static cmdline_parse_token_num_t cmd_del_port_meter_port_id =
+cmdline_parse_token_num_t cmd_del_port_meter_port_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_del_port_meter_result, port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_del_port_meter_mtr_id =
+		struct cmd_del_port_meter_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_del_port_meter_mtr_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_del_port_meter_result, mtr_id, RTE_UINT32);
+		struct cmd_del_port_meter_result, mtr_id, UINT32);
 
 static void cmd_del_port_meter_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_del_port_meter_result *res = parsed_result;
 	struct rte_mtr_error error;
@@ -1292,7 +1018,7 @@
 cmdline_parse_inst_t cmd_del_port_meter = {
 	.f = cmd_del_port_meter_parsed,
 	.data = NULL,
-	.help_str = "del port meter <port_id> <mtr_id>",
+	.help_str = "Delete port meter",
 	.tokens = {
 		(void *)&cmd_del_port_meter_del,
 		(void *)&cmd_del_port_meter_port,
@@ -1314,34 +1040,31 @@
 	uint32_t profile_id;
 };
 
-static cmdline_parse_token_string_t cmd_set_port_meter_profile_set =
+cmdline_parse_token_string_t cmd_set_port_meter_profile_set =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_profile_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_port_meter_profile_port =
+cmdline_parse_token_string_t cmd_set_port_meter_profile_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_profile_result, port, "port");
-static cmdline_parse_token_string_t cmd_set_port_meter_profile_meter =
+cmdline_parse_token_string_t cmd_set_port_meter_profile_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_profile_result, meter, "meter");
-static cmdline_parse_token_string_t cmd_set_port_meter_profile_profile =
+cmdline_parse_token_string_t cmd_set_port_meter_profile_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_profile_result, profile, "profile");
-static cmdline_parse_token_num_t cmd_set_port_meter_profile_port_id =
+cmdline_parse_token_num_t cmd_set_port_meter_profile_port_id =
+	TOKEN_NUM_INITIALIZER(
+		struct cmd_set_port_meter_profile_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_set_port_meter_profile_mtr_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_meter_profile_result, port_id,
-		RTE_UINT16);
-static cmdline_parse_token_num_t cmd_set_port_meter_profile_mtr_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_meter_profile_result, mtr_id,
-		RTE_UINT32);
-static cmdline_parse_token_num_t cmd_set_port_meter_profile_profile_id =
+		struct cmd_set_port_meter_profile_result, mtr_id, UINT32);
+cmdline_parse_token_num_t cmd_set_port_meter_profile_profile_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_meter_profile_result, profile_id,
-		RTE_UINT32);
+		struct cmd_set_port_meter_profile_result, profile_id, UINT32);
 
 static void cmd_set_port_meter_profile_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_port_meter_profile_result *res = parsed_result;
 	struct rte_mtr_error error;
@@ -1366,7 +1089,7 @@
 cmdline_parse_inst_t cmd_set_port_meter_profile = {
 	.f = cmd_set_port_meter_profile_parsed,
 	.data = NULL,
-	.help_str = "set port meter profile <port_id> <mtr_id> <profile_id>",
+	.help_str = "Set port meter profile",
 	.tokens = {
 		(void *)&cmd_set_port_meter_profile_set,
 		(void *)&cmd_set_port_meter_profile_port,
@@ -1388,29 +1111,28 @@
 	cmdline_multi_string_t token_string;
 };
 
-static cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_set =
+cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_set =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_dscp_table_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_port =
+cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_dscp_table_result, port, "port");
-static cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_meter =
+cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_dscp_table_result, meter, "meter");
-static cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_dscp_table =
+cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_dscp_table =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_dscp_table_result,
 		dscp_table, "dscp table");
-static cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_token_string =
+cmdline_parse_token_string_t cmd_set_port_meter_dscp_table_token_string =
 	TOKEN_STRING_INITIALIZER(struct cmd_set_port_meter_dscp_table_result,
 		token_string, TOKEN_STRING_MULTI);
 
 static void cmd_set_port_meter_dscp_table_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_port_meter_dscp_table_result *res = parsed_result;
-	enum rte_mtr_color_in_protocol proto = 0;
 	struct rte_mtr_error error;
 	enum rte_color *dscp_table = NULL;
 	char *t_str = res->token_string;
@@ -1419,10 +1141,9 @@
 	int ret;
 
 	/* Parse string */
-	ret = parse_multi_token_string(t_str, &port_id, &mtr_id, &proto,
-				       &dscp_table);
+	ret = parse_multi_token_string(t_str, &port_id, &mtr_id, &dscp_table);
 	if (ret) {
-		fprintf(stderr, " Multi token string parse error\n");
+		printf(" Multi token string parse error\n");
 		return;
 	}
 
@@ -1430,7 +1151,7 @@
 		goto free_table;
 
 	/* Update Meter DSCP Table*/
-	ret = rte_mtr_meter_dscp_table_update(port_id, mtr_id, proto,
+	ret = rte_mtr_meter_dscp_table_update(port_id, mtr_id,
 		dscp_table, &error);
 	if (ret != 0)
 		print_err_msg(&error);
@@ -1442,8 +1163,7 @@
 cmdline_parse_inst_t cmd_set_port_meter_dscp_table = {
 	.f = cmd_set_port_meter_dscp_table_parsed,
 	.data = NULL,
-	.help_str = "set port meter dscp table <port_id> <mtr_id> <proto> "
-		"[<dscp_tbl_entry0> <dscp_tbl_entry1> ... <dscp_tbl_entry63>]",
+	.help_str = "Update port meter dscp table",
 	.tokens = {
 		(void *)&cmd_set_port_meter_dscp_table_set,
 		(void *)&cmd_set_port_meter_dscp_table_port,
@@ -1454,342 +1174,115 @@
 	},
 };
 
-/* *** Set Port Meter VLAN Table *** */
-struct cmd_set_port_meter_vlan_table_result {
+/* *** Set Port Meter Policer Action *** */
+struct cmd_set_port_meter_policer_action_result {
 	cmdline_fixed_string_t set;
 	cmdline_fixed_string_t port;
 	cmdline_fixed_string_t meter;
-	cmdline_fixed_string_t vlan_table;
-	cmdline_multi_string_t token_string;
-};
-
-static cmdline_parse_token_string_t cmd_set_port_meter_vlan_table_set =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_set_port_meter_vlan_table_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_port_meter_vlan_table_port =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_set_port_meter_vlan_table_result, port, "port");
-static cmdline_parse_token_string_t cmd_set_port_meter_vlan_table_meter =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_set_port_meter_vlan_table_result, meter, "meter");
-static cmdline_parse_token_string_t cmd_set_port_meter_vlan_table_vlan_table =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_set_port_meter_vlan_table_result,
-		vlan_table, "vlan table");
-static cmdline_parse_token_string_t cmd_set_port_meter_vlan_table_token_string =
-	TOKEN_STRING_INITIALIZER(struct cmd_set_port_meter_vlan_table_result,
-		token_string, TOKEN_STRING_MULTI);
-
-static void cmd_set_port_meter_vlan_table_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
-{
-	struct cmd_set_port_meter_vlan_table_result *res = parsed_result;
-	enum rte_mtr_color_in_protocol proto = 0;
-	struct rte_mtr_error error;
-	enum rte_color *vlan_table = NULL;
-	char *t_str = res->token_string;
-	uint32_t mtr_id = 0;
+	cmdline_fixed_string_t policer;
+	cmdline_fixed_string_t action;
 	uint16_t port_id;
-	int ret;
-
-	/* Parse string */
-	ret = parse_multi_token_vlan_str(t_str, &port_id, &mtr_id, &proto,
-					 &vlan_table);
-	if (ret) {
-		fprintf(stderr, " Multi token string parse error\n");
-		return;
-	}
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN))
-		goto free_table;
-
-	/* Update Meter VLAN Table*/
-	ret = rte_mtr_meter_vlan_table_update(port_id, mtr_id, proto,
-		vlan_table, &error);
-	if (ret != 0)
-		print_err_msg(&error);
-
-free_table:
-	free(vlan_table);
-}
-
-cmdline_parse_inst_t cmd_set_port_meter_vlan_table = {
-	.f = cmd_set_port_meter_vlan_table_parsed,
-	.data = NULL,
-	.help_str = "set port meter vlan table <port_id> <mtr_id> <proto> "
-		"[<vlan_tbl_entry0> <vlan_tbl_entry1> ... <vlan_tbl_entry15>]",
-	.tokens = {
-		(void *)&cmd_set_port_meter_vlan_table_set,
-		(void *)&cmd_set_port_meter_vlan_table_port,
-		(void *)&cmd_set_port_meter_vlan_table_meter,
-		(void *)&cmd_set_port_meter_vlan_table_vlan_table,
-		(void *)&cmd_set_port_meter_vlan_table_token_string,
-		NULL,
-	},
-};
-
-/* *** Set Port Meter input protocol *** */
-struct cmd_set_port_meter_in_proto_result {
-	cmdline_fixed_string_t set;
-	cmdline_fixed_string_t port;
-	cmdline_fixed_string_t meter;
-	cmdline_fixed_string_t protocol;
-	cmdline_fixed_string_t proto;
-	uint32_t prio;
 	uint32_t mtr_id;
-	uint16_t port_id;
+	uint32_t action_mask;
+	cmdline_multi_string_t policer_action;
 };
 
-static cmdline_parse_token_string_t cmd_set_port_meter_in_proto_set =
+cmdline_parse_token_string_t cmd_set_port_meter_policer_action_set =
 	TOKEN_STRING_INITIALIZER(
-		struct cmd_set_port_meter_in_proto_result, set, "set");
-
-static cmdline_parse_token_string_t cmd_set_port_meter_in_proto_port =
+		struct cmd_set_port_meter_policer_action_result, set, "set");
+cmdline_parse_token_string_t cmd_set_port_meter_policer_action_port =
 	TOKEN_STRING_INITIALIZER(
-		struct cmd_set_port_meter_in_proto_result, port, "port");
-
-static cmdline_parse_token_string_t cmd_set_port_meter_in_proto_meter =
+		struct cmd_set_port_meter_policer_action_result, port, "port");
+cmdline_parse_token_string_t cmd_set_port_meter_policer_action_meter =
 	TOKEN_STRING_INITIALIZER(
-		struct cmd_set_port_meter_in_proto_result, meter, "meter");
-
-static cmdline_parse_token_string_t cmd_set_port_meter_in_proto_protocol =
+		struct cmd_set_port_meter_policer_action_result, meter,
+		"meter");
+cmdline_parse_token_string_t cmd_set_port_meter_policer_action_policer =
 	TOKEN_STRING_INITIALIZER(
-		struct cmd_set_port_meter_in_proto_result, protocol, "proto");
-
-static cmdline_parse_token_string_t cmd_set_port_meter_in_proto_proto =
+		struct cmd_set_port_meter_policer_action_result, policer,
+		"policer");
+cmdline_parse_token_string_t cmd_set_port_meter_policer_action_action =
 	TOKEN_STRING_INITIALIZER(
-		struct cmd_set_port_meter_in_proto_result, proto,
-		"outer_vlan#inner_vlan#outer_ip#inner_ip");
-
-static cmdline_parse_token_num_t cmd_set_port_meter_in_proto_prio =
+		struct cmd_set_port_meter_policer_action_result, action,
+		"action");
+cmdline_parse_token_num_t cmd_set_port_meter_policer_action_port_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_meter_in_proto_result, prio, RTE_UINT32);
-
-static cmdline_parse_token_num_t cmd_set_port_meter_in_proto_port_id =
+		struct cmd_set_port_meter_policer_action_result, port_id,
+		UINT16);
+cmdline_parse_token_num_t cmd_set_port_meter_policer_action_mtr_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_meter_in_proto_result, port_id, RTE_UINT16);
-
-static cmdline_parse_token_num_t cmd_set_port_meter_in_proto_mtr_id =
+		struct cmd_set_port_meter_policer_action_result, mtr_id,
+		UINT32);
+cmdline_parse_token_num_t cmd_set_port_meter_policer_action_action_mask =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_meter_in_proto_result, mtr_id, RTE_UINT32);
+		struct cmd_set_port_meter_policer_action_result, action_mask,
+		UINT32);
+cmdline_parse_token_string_t cmd_set_port_meter_policer_action_policer_action =
+	TOKEN_STRING_INITIALIZER(
+		struct cmd_set_port_meter_policer_action_result,
+		policer_action, TOKEN_STRING_MULTI);
 
-static void cmd_set_port_meter_in_proto_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+static void cmd_set_port_meter_policer_action_parsed(void *parsed_result,
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
-	struct cmd_set_port_meter_in_proto_result *res = parsed_result;
-	enum rte_mtr_color_in_protocol proto;
+	struct cmd_set_port_meter_policer_action_result *res = parsed_result;
+	enum rte_mtr_policer_action *actions;
 	struct rte_mtr_error error;
+	uint32_t mtr_id = res->mtr_id;
+	uint32_t action_mask = res->action_mask;
+	uint16_t port_id = res->port_id;
+	char *p_str = res->policer_action;
 	int ret;
 
-	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
 		return;
 
-	if (strcmp(res->proto, "outer_vlan") == 0)
-		proto = RTE_MTR_COLOR_IN_PROTO_OUTER_VLAN;
-	else if (strcmp(res->proto, "inner_vlan") == 0)
-		proto = RTE_MTR_COLOR_IN_PROTO_INNER_VLAN;
-	else if (strcmp(res->proto, "outer_ip") == 0)
-		proto = RTE_MTR_COLOR_IN_PROTO_OUTER_IP;
-	else if (strcmp(res->proto, "inner_ip") == 0)
-		proto = RTE_MTR_COLOR_IN_PROTO_INNER_IP;
-	else {
-		printf("Invalid protocol\n");
+	/* Check: action mask */
+	if (action_mask == 0 || (action_mask & (~0x7UL))) {
+		printf(" Policer action mask not correct (error)\n");
 		return;
 	}
 
-	/* Update Meter input proto and priority */
-	ret = rte_mtr_color_in_protocol_set(res->port_id, res->mtr_id,
-		proto, res->prio, &error);
-	if (ret != 0)
-		print_err_msg(&error);
-}
-
-cmdline_parse_inst_t cmd_set_port_meter_in_proto = {
-	.f = cmd_set_port_meter_in_proto_parsed,
-	.data = NULL,
-	.help_str = "set port meter proto <port_id> <mtr_id> <proto> "
-		"<prio>",
-	.tokens = {
-		(void *)&cmd_set_port_meter_in_proto_set,
-		(void *)&cmd_set_port_meter_in_proto_port,
-		(void *)&cmd_set_port_meter_in_proto_meter,
-		(void *)&cmd_set_port_meter_in_proto_protocol,
-		(void *)&cmd_set_port_meter_in_proto_port_id,
-		(void *)&cmd_set_port_meter_in_proto_mtr_id,
-		(void *)&cmd_set_port_meter_in_proto_proto,
-		(void *)&cmd_set_port_meter_in_proto_prio,
-		NULL,
-	},
-};
-
-/* *** Get Port Meter input protocol *** */
-struct cmd_get_port_meter_in_proto_result {
-	cmdline_fixed_string_t get;
-	cmdline_fixed_string_t port;
-	cmdline_fixed_string_t meter;
-	cmdline_fixed_string_t protocol;
-	uint32_t mtr_id;
-	uint16_t port_id;
-};
-
-static cmdline_parse_token_string_t cmd_get_port_meter_in_proto_get =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_result, get, "get");
-
-static cmdline_parse_token_string_t cmd_get_port_meter_in_proto_port =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_result, port, "port");
-
-static cmdline_parse_token_string_t cmd_get_port_meter_in_proto_meter =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_result, meter, "meter");
-
-static cmdline_parse_token_string_t cmd_get_port_meter_in_proto_protocol =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_result, protocol, "proto");
-
-static cmdline_parse_token_num_t cmd_get_port_meter_in_proto_port_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_result, port_id, RTE_UINT16);
-
-static cmdline_parse_token_num_t cmd_get_port_meter_in_proto_mtr_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_result, mtr_id, RTE_UINT32);
-
-static void cmd_get_port_meter_in_proto_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
-{
-	struct cmd_set_port_meter_in_proto_result *res = parsed_result;
-	struct rte_mtr_error error;
-	uint64_t proto_mask = 0;
-	int ret;
-
-	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+	/* Allocate memory for policer actions */
+	actions = (enum rte_mtr_policer_action *)malloc(RTE_COLORS *
+		sizeof(enum rte_mtr_policer_action));
+	if (actions == NULL) {
+		printf("Memory for policer actions not allocated (error)\n");
 		return;
-
-	/* Update Meter input proto and priority */
-	ret = rte_mtr_color_in_protocol_get(res->port_id, res->mtr_id,
-		&proto_mask, &error);
-	if (ret != 0)
-		print_err_msg(&error);
-
-	printf("Enabled protocols:\n");
-	if (proto_mask & RTE_MTR_COLOR_IN_PROTO_OUTER_VLAN)
-		printf("\touter_vlan\n");
-	if (proto_mask & RTE_MTR_COLOR_IN_PROTO_INNER_VLAN)
-		printf("\tinner_vlan\n");
-	if (proto_mask & RTE_MTR_COLOR_IN_PROTO_OUTER_IP)
-		printf("\touter_ip\n");
-	if (proto_mask & RTE_MTR_COLOR_IN_PROTO_INNER_IP)
-		printf("\tinner_ip\n");
-}
-
-cmdline_parse_inst_t cmd_get_port_meter_in_proto = {
-	.f = cmd_get_port_meter_in_proto_parsed,
-	.data = NULL,
-	.help_str = "get port meter proto <port_id> <mtr_id>",
-	.tokens = {
-		(void *)&cmd_get_port_meter_in_proto_get,
-		(void *)&cmd_get_port_meter_in_proto_port,
-		(void *)&cmd_get_port_meter_in_proto_meter,
-		(void *)&cmd_get_port_meter_in_proto_protocol,
-		(void *)&cmd_get_port_meter_in_proto_port_id,
-		(void *)&cmd_get_port_meter_in_proto_mtr_id,
-		NULL,
-	},
-};
-
-/* *** Get Port Meter input protocol priority *** */
-struct cmd_get_port_meter_in_proto_prio_result {
-	cmdline_fixed_string_t get;
-	cmdline_fixed_string_t port;
-	cmdline_fixed_string_t meter;
-	cmdline_fixed_string_t protocol;
-	cmdline_fixed_string_t proto;
-	uint32_t mtr_id;
-	uint16_t port_id;
-};
-
-static cmdline_parse_token_string_t cmd_get_port_meter_in_proto_prio_get =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_prio_result, get, "get");
-
-static cmdline_parse_token_string_t cmd_get_port_meter_in_proto_prio_port =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_prio_result, port, "port");
-
-static cmdline_parse_token_string_t cmd_get_port_meter_in_proto_prio_meter =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_prio_result, meter, "meter");
-
-static cmdline_parse_token_string_t cmd_get_port_meter_in_proto_prio_protocol =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_prio_result, protocol,
-		"proto_prio");
-
-static cmdline_parse_token_string_t cmd_get_port_meter_in_proto_prio_proto =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_prio_result, proto,
-		"outer_vlan#inner_vlan#outer_ip#inner_ip");
-
-static cmdline_parse_token_num_t cmd_get_port_meter_in_proto_prio_port_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_prio_result, port_id,
-		RTE_UINT16);
-
-static cmdline_parse_token_num_t cmd_get_port_meter_in_proto_prio_mtr_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_get_port_meter_in_proto_prio_result, mtr_id,
-		RTE_UINT32);
-
-static void cmd_get_port_meter_in_proto_prio_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
-{
-	struct cmd_get_port_meter_in_proto_prio_result *res = parsed_result;
-	enum rte_mtr_color_in_protocol proto;
-	struct rte_mtr_error error;
-	uint32_t prio = 0;
-	int ret;
-
-	if (port_id_is_invalid(res->port_id, ENABLED_WARN))
+	}
+	/* Parse policer action string */
+	ret = parse_policer_action_string(p_str, action_mask, actions);
+	if (ret) {
+		printf(" Policer action string parse error\n");
+		free(actions);
 		return;
+	}
 
-	if (strcmp(res->proto, "outer_vlan") == 0)
-		proto = RTE_MTR_COLOR_IN_PROTO_OUTER_VLAN;
-	else if (strcmp(res->proto, "inner_vlan") == 0)
-		proto = RTE_MTR_COLOR_IN_PROTO_INNER_VLAN;
-	else if (strcmp(res->proto, "outer_ip") == 0)
-		proto = RTE_MTR_COLOR_IN_PROTO_OUTER_IP;
-	else if (strcmp(res->proto, "inner_ip") == 0)
-		proto = RTE_MTR_COLOR_IN_PROTO_INNER_IP;
-	else {
-		printf("Invalid protocol\n");
+	ret = rte_mtr_policer_actions_update(port_id, mtr_id,
+		action_mask, actions, &error);
+	if (ret != 0) {
+		print_err_msg(&error);
 		return;
 	}
 
-	/* Get Meter input proto and priority */
-	ret = rte_mtr_color_in_protocol_priority_get(res->port_id, res->mtr_id,
-		proto, &prio, &error);
-	if (ret != 0)
-		print_err_msg(&error);
+	free(actions);
 }
 
-cmdline_parse_inst_t cmd_get_port_meter_in_proto_prio = {
-	.f = cmd_get_port_meter_in_proto_prio_parsed,
+cmdline_parse_inst_t cmd_set_port_meter_policer_action = {
+	.f = cmd_set_port_meter_policer_action_parsed,
 	.data = NULL,
-	.help_str = "get port meter proto_prio <port_id> <mtr_id> <proto>",
+	.help_str = "Set port meter policer action",
 	.tokens = {
-		(void *)&cmd_get_port_meter_in_proto_prio_get,
-		(void *)&cmd_get_port_meter_in_proto_prio_port,
-		(void *)&cmd_get_port_meter_in_proto_prio_meter,
-		(void *)&cmd_get_port_meter_in_proto_prio_protocol,
-		(void *)&cmd_get_port_meter_in_proto_prio_port_id,
-		(void *)&cmd_get_port_meter_in_proto_prio_mtr_id,
-		(void *)&cmd_get_port_meter_in_proto_prio_proto,
+		(void *)&cmd_set_port_meter_policer_action_set,
+		(void *)&cmd_set_port_meter_policer_action_port,
+		(void *)&cmd_set_port_meter_policer_action_meter,
+		(void *)&cmd_set_port_meter_policer_action_policer,
+		(void *)&cmd_set_port_meter_policer_action_action,
+		(void *)&cmd_set_port_meter_policer_action_port_id,
+		(void *)&cmd_set_port_meter_policer_action_mtr_id,
+		(void *)&cmd_set_port_meter_policer_action_action_mask,
+		(void *)&cmd_set_port_meter_policer_action_policer_action,
 		NULL,
 	},
 };
@@ -1806,37 +1299,35 @@
 	uint64_t stats_mask;
 };
 
-static cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_set =
+cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_set =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_stats_mask_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_port =
+cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_stats_mask_result, port, "port");
-static cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_meter =
+cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_stats_mask_result, meter, "meter");
-static cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_stats =
+cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_stats =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_stats_mask_result, stats, "stats");
-static cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_mask =
+cmdline_parse_token_string_t cmd_set_port_meter_stats_mask_mask =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_meter_stats_mask_result, mask, "mask");
-static cmdline_parse_token_num_t cmd_set_port_meter_stats_mask_port_id =
+cmdline_parse_token_num_t cmd_set_port_meter_stats_mask_port_id =
+	TOKEN_NUM_INITIALIZER(
+		struct cmd_set_port_meter_stats_mask_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_set_port_meter_stats_mask_mtr_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_meter_stats_mask_result, port_id,
-		RTE_UINT16);
-static cmdline_parse_token_num_t cmd_set_port_meter_stats_mask_mtr_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_meter_stats_mask_result, mtr_id,
-		RTE_UINT32);
-static cmdline_parse_token_num_t cmd_set_port_meter_stats_mask_stats_mask =
+		struct cmd_set_port_meter_stats_mask_result, mtr_id, UINT32);
+cmdline_parse_token_num_t cmd_set_port_meter_stats_mask_stats_mask =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_set_port_meter_stats_mask_result, stats_mask,
-		RTE_UINT64);
+		UINT64);
 
 static void cmd_set_port_meter_stats_mask_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_port_meter_stats_mask_result *res = parsed_result;
 	struct rte_mtr_error error;
@@ -1858,7 +1349,7 @@
 cmdline_parse_inst_t cmd_set_port_meter_stats_mask = {
 	.f = cmd_set_port_meter_stats_mask_parsed,
 	.data = NULL,
-	.help_str = "set port meter stats mask <port_id> <mtr_id> <stats_mask>",
+	.help_str = "Set port meter stats mask",
 	.tokens = {
 		(void *)&cmd_set_port_meter_stats_mask_set,
 		(void *)&cmd_set_port_meter_stats_mask_port,
@@ -1883,31 +1374,31 @@
 	cmdline_fixed_string_t clear;
 };
 
-static cmdline_parse_token_string_t cmd_show_port_meter_stats_show =
+cmdline_parse_token_string_t cmd_show_port_meter_stats_show =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_meter_stats_result, show, "show");
-static cmdline_parse_token_string_t cmd_show_port_meter_stats_port =
+cmdline_parse_token_string_t cmd_show_port_meter_stats_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_meter_stats_result, port, "port");
-static cmdline_parse_token_string_t cmd_show_port_meter_stats_meter =
+cmdline_parse_token_string_t cmd_show_port_meter_stats_meter =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_meter_stats_result, meter, "meter");
-static cmdline_parse_token_string_t cmd_show_port_meter_stats_stats =
+cmdline_parse_token_string_t cmd_show_port_meter_stats_stats =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_meter_stats_result, stats, "stats");
-static cmdline_parse_token_num_t cmd_show_port_meter_stats_port_id =
+cmdline_parse_token_num_t cmd_show_port_meter_stats_port_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_show_port_meter_stats_result, port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_show_port_meter_stats_mtr_id =
+		struct cmd_show_port_meter_stats_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_show_port_meter_stats_mtr_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_show_port_meter_stats_result, mtr_id, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_show_port_meter_stats_clear =
+		struct cmd_show_port_meter_stats_result, mtr_id, UINT32);
+cmdline_parse_token_string_t cmd_show_port_meter_stats_clear =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_meter_stats_result, clear, "yes#no");
 
 static void cmd_show_port_meter_stats_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_show_port_meter_stats_result *res = parsed_result;
 	struct rte_mtr_stats stats;
@@ -1962,7 +1453,7 @@
 cmdline_parse_inst_t cmd_show_port_meter_stats = {
 	.f = cmd_show_port_meter_stats_parsed,
 	.data = NULL,
-	.help_str = "show port meter stats <port_id> <mtr_id> <clear>(yes|no)",
+	.help_str = "Show port meter stats",
 	.tokens = {
 		(void *)&cmd_show_port_meter_stats_show,
 		(void *)&cmd_show_port_meter_stats_port,
diff -urN dpdk/app/test-pmd/cmdline_mtr.h testpmd-as-load-balancer/v19.11/test-pmd/cmdline_mtr.h
--- dpdk/app/test-pmd/cmdline_mtr.h	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/cmdline_mtr.h	2023-12-15 15:26:37.089199123 +0100
@@ -4,7 +4,6 @@
 
 #ifndef _CMDLINE_MTR_H_
 #define _CMDLINE_MTR_H_
-#include <rte_mtr.h>
 
 /* Traffic Metering and Policing */
 extern cmdline_parse_inst_t cmd_show_port_meter_cap;
@@ -16,15 +15,10 @@
 extern cmdline_parse_inst_t cmd_enable_port_meter;
 extern cmdline_parse_inst_t cmd_disable_port_meter;
 extern cmdline_parse_inst_t cmd_del_port_meter;
-extern cmdline_parse_inst_t cmd_del_port_meter_policy;
 extern cmdline_parse_inst_t cmd_set_port_meter_profile;
 extern cmdline_parse_inst_t cmd_set_port_meter_dscp_table;
-extern cmdline_parse_inst_t cmd_set_port_meter_vlan_table;
-extern cmdline_parse_inst_t cmd_set_port_meter_in_proto;
-extern cmdline_parse_inst_t cmd_get_port_meter_in_proto;
-extern cmdline_parse_inst_t cmd_get_port_meter_in_proto_prio;
+extern cmdline_parse_inst_t cmd_set_port_meter_policer_action;
 extern cmdline_parse_inst_t cmd_set_port_meter_stats_mask;
 extern cmdline_parse_inst_t cmd_show_port_meter_stats;
-void print_mtr_err_msg(struct rte_mtr_error *error);
 
 #endif /* _CMDLINE_MTR_H_ */
diff -urN dpdk/app/test-pmd/cmdline_tm.c testpmd-as-load-balancer/v19.11/test-pmd/cmdline_tm.c
--- dpdk/app/test-pmd/cmdline_tm.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/cmdline_tm.c	2023-12-15 15:26:37.089199123 +0100
@@ -2,9 +2,6 @@
  * Copyright(c) 2017 Intel Corporation
  */
 
-#include <ctype.h>
-#include <stdlib.h>
-
 #include <cmdline_parse.h>
 #include <cmdline_parse_num.h>
 #include <cmdline_parse_string.h>
@@ -57,8 +54,6 @@
 			= "peak size field (shaper profile)",
 		[RTE_TM_ERROR_TYPE_SHAPER_PROFILE_PKT_ADJUST_LEN]
 			= "packet adjust length field (shaper profile)",
-		[RTE_TM_ERROR_TYPE_SHAPER_PROFILE_PACKET_MODE]
-			= "packet mode field (shaper profile)",
 		[RTE_TM_ERROR_TYPE_SHAPER_PROFILE_ID] = "shaper profile id",
 		[RTE_TM_ERROR_TYPE_SHARED_SHAPER_ID] = "shared shaper id",
 		[RTE_TM_ERROR_TYPE_NODE_PARENT_NODE_ID] = "parent node id",
@@ -72,7 +67,7 @@
 		[RTE_TM_ERROR_TYPE_NODE_PARAMS_N_SHARED_SHAPERS]
 			= "num shared shapers field (node params)",
 		[RTE_TM_ERROR_TYPE_NODE_PARAMS_WFQ_WEIGHT_MODE]
-			= "wfq weight mode field (node params)",
+			= "wfq weght mode field (node params)",
 		[RTE_TM_ERROR_TYPE_NODE_PARAMS_N_SP_PRIORITIES]
 			= "num strict priorities field (node params)",
 		[RTE_TM_ERROR_TYPE_NODE_PARAMS_CMAN]
@@ -100,8 +95,7 @@
 	if (error->cause)
 		snprintf(buf, sizeof(buf), "cause: %p, ", error->cause);
 
-	fprintf(stderr, "%s: %s%s (error %d)\n",
-		errstr, error->cause ? buf : "",
+	printf("%s: %s%s (error %d)\n", errstr, error->cause ? buf : "",
 		error->message ? error->message : "(no stated reason)",
 		error->type);
 }
@@ -178,8 +172,7 @@
 
 	/* Check: num of shared shaper */
 	if (n_shared_shapers >= MAX_NUM_SHARED_SHAPERS) {
-		fprintf(stderr,
-			" Number of shared shapers exceed the max (error)\n");
+		printf(" Number of shared shapers exceed the max (error)\n");
 		return -1;
 	}
 
@@ -210,25 +203,25 @@
 	uint16_t port_id;
 };
 
-static cmdline_parse_token_string_t cmd_show_port_tm_cap_show =
+cmdline_parse_token_string_t cmd_show_port_tm_cap_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_cap_result,
 		show, "show");
-static cmdline_parse_token_string_t cmd_show_port_tm_cap_port =
+cmdline_parse_token_string_t cmd_show_port_tm_cap_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_cap_result,
 		port, "port");
-static cmdline_parse_token_string_t cmd_show_port_tm_cap_tm =
+cmdline_parse_token_string_t cmd_show_port_tm_cap_tm =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_cap_result,
 		tm, "tm");
-static cmdline_parse_token_string_t cmd_show_port_tm_cap_cap =
+cmdline_parse_token_string_t cmd_show_port_tm_cap_cap =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_cap_result,
 		cap, "cap");
-static cmdline_parse_token_num_t cmd_show_port_tm_cap_port_id =
+cmdline_parse_token_num_t cmd_show_port_tm_cap_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_port_tm_cap_result,
-		 port_id, RTE_UINT16);
+		 port_id, UINT16);
 
 static void cmd_show_port_tm_cap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_show_port_tm_cap_result *res = parsed_result;
 	struct rte_tm_capabilities cap;
@@ -264,10 +257,6 @@
 		cap.shaper_private_rate_min);
 	printf("cap.shaper_private_rate_max %" PRIu64 "\n",
 		cap.shaper_private_rate_max);
-	printf("cap.shaper_private_packet_mode_supported %" PRId32 "\n",
-		cap.shaper_private_packet_mode_supported);
-	printf("cap.shaper_private_byte_mode_supported %" PRId32 "\n",
-		cap.shaper_private_byte_mode_supported);
 	printf("cap.shaper_shared_n_max %" PRIu32 "\n",
 		cap.shaper_shared_n_max);
 	printf("cap.shaper_shared_n_nodes_per_shaper_max %" PRIu32 "\n",
@@ -280,10 +269,6 @@
 		cap.shaper_shared_rate_min);
 	printf("cap.shaper_shared_rate_max %" PRIu64 "\n",
 		cap.shaper_shared_rate_max);
-	printf("cap.shaper_shared_packet_mode_supported %" PRId32 "\n",
-		cap.shaper_shared_packet_mode_supported);
-	printf("cap.shaper_shared_byte_mode_supported %" PRId32 "\n",
-		cap.shaper_shared_byte_mode_supported);
 	printf("cap.shaper_pkt_length_adjust_min %" PRId32 "\n",
 		cap.shaper_pkt_length_adjust_min);
 	printf("cap.shaper_pkt_length_adjust_max %" PRId32 "\n",
@@ -298,10 +283,6 @@
 		cap.sched_wfq_n_groups_max);
 	printf("cap.sched_wfq_weight_max %" PRIu32 "\n",
 		cap.sched_wfq_weight_max);
-	printf("cap.sched_wfq_packet_mode_supported %" PRId32 "\n",
-		cap.sched_wfq_packet_mode_supported);
-	printf("cap.sched_wfq_byte_mode_supported %" PRId32 "\n",
-		cap.sched_wfq_byte_mode_supported);
 	printf("cap.cman_head_drop_supported %" PRId32 "\n",
 		cap.cman_head_drop_supported);
 	printf("cap.cman_wred_context_n_max %" PRIu32 "\n",
@@ -356,32 +337,32 @@
 	uint32_t level_id;
 };
 
-static cmdline_parse_token_string_t cmd_show_port_tm_level_cap_show =
+cmdline_parse_token_string_t cmd_show_port_tm_level_cap_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_level_cap_result,
 		show, "show");
-static cmdline_parse_token_string_t cmd_show_port_tm_level_cap_port =
+cmdline_parse_token_string_t cmd_show_port_tm_level_cap_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_level_cap_result,
 		port, "port");
-static cmdline_parse_token_string_t cmd_show_port_tm_level_cap_tm =
+cmdline_parse_token_string_t cmd_show_port_tm_level_cap_tm =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_level_cap_result,
 		tm, "tm");
-static cmdline_parse_token_string_t cmd_show_port_tm_level_cap_level =
+cmdline_parse_token_string_t cmd_show_port_tm_level_cap_level =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_level_cap_result,
 		level, "level");
-static cmdline_parse_token_string_t cmd_show_port_tm_level_cap_cap =
+cmdline_parse_token_string_t cmd_show_port_tm_level_cap_cap =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_level_cap_result,
 		cap, "cap");
-static cmdline_parse_token_num_t cmd_show_port_tm_level_cap_port_id =
+cmdline_parse_token_num_t cmd_show_port_tm_level_cap_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_port_tm_level_cap_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_show_port_tm_level_cap_level_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_show_port_tm_level_cap_level_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_port_tm_level_cap_result,
-		 level_id, RTE_UINT32);
+		 level_id, UINT32);
 
 
 static void cmd_show_port_tm_level_cap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_show_port_tm_level_cap_result *res = parsed_result;
 	struct rte_tm_level_capabilities lcap;
@@ -420,19 +401,8 @@
 			lcap.nonleaf.shaper_private_rate_min);
 		printf("cap.nonleaf.shaper_private_rate_max %" PRIu64 "\n",
 			lcap.nonleaf.shaper_private_rate_max);
-		printf("cap.nonleaf.shaper_private_packet_mode_supported %"
-		       PRId32 "\n",
-			lcap.nonleaf.shaper_private_packet_mode_supported);
-		printf("cap.nonleaf.shaper_private_byte_mode_supported %" PRId32
-		       "\n", lcap.nonleaf.shaper_private_byte_mode_supported);
 		printf("cap.nonleaf.shaper_shared_n_max %" PRIu32 "\n",
 			lcap.nonleaf.shaper_shared_n_max);
-		printf("cap.nonleaf.shaper_shared_packet_mode_supported %"
-		       PRId32 "\n",
-		       lcap.nonleaf.shaper_shared_packet_mode_supported);
-		printf("cap.nonleaf.shaper_shared_byte_mode_supported %"
-		       PRId32 "\n",
-		       lcap.nonleaf.shaper_shared_byte_mode_supported);
 		printf("cap.nonleaf.sched_n_children_max %" PRIu32 "\n",
 			lcap.nonleaf.sched_n_children_max);
 		printf("cap.nonleaf.sched_sp_n_priorities_max %" PRIu32 "\n",
@@ -443,10 +413,6 @@
 			lcap.nonleaf.sched_wfq_n_groups_max);
 		printf("cap.nonleaf.sched_wfq_weight_max %" PRIu32 "\n",
 			lcap.nonleaf.sched_wfq_weight_max);
-		printf("cap.nonleaf.sched_wfq_packet_mode_supported %" PRId32 "\n",
-			lcap.nonleaf.sched_wfq_packet_mode_supported);
-		printf("cap.nonleaf.sched_wfq_byte_mode_supported %" PRId32
-		       "\n", lcap.nonleaf.sched_wfq_byte_mode_supported);
 		printf("cap.nonleaf.stats_mask %" PRIx64 "\n",
 			lcap.nonleaf.stats_mask);
 	} else {
@@ -458,16 +424,8 @@
 			lcap.leaf.shaper_private_rate_min);
 		printf("cap.leaf.shaper_private_rate_max %" PRIu64 "\n",
 			lcap.leaf.shaper_private_rate_max);
-		printf("cap.leaf.shaper_private_packet_mode_supported %" PRId32
-		       "\n", lcap.leaf.shaper_private_packet_mode_supported);
-		printf("cap.leaf.shaper_private_byte_mode_supported %" PRId32 "\n",
-			lcap.leaf.shaper_private_byte_mode_supported);
 		printf("cap.leaf.shaper_shared_n_max %" PRIu32 "\n",
 			lcap.leaf.shaper_shared_n_max);
-		printf("cap.leaf.shaper_shared_packet_mode_supported %" PRId32 "\n",
-		       lcap.leaf.shaper_shared_packet_mode_supported);
-		printf("cap.leaf.shaper_shared_byte_mode_supported %" PRId32 "\n",
-		       lcap.leaf.shaper_shared_byte_mode_supported);
 		printf("cap.leaf.cman_head_drop_supported %" PRId32 "\n",
 			lcap.leaf.cman_head_drop_supported);
 		printf("cap.leaf.cman_wred_context_private_supported %"	PRId32
@@ -482,7 +440,7 @@
 cmdline_parse_inst_t cmd_show_port_tm_level_cap = {
 	.f = cmd_show_port_tm_level_cap_parsed,
 	.data = NULL,
-	.help_str = "Show port TM hierarchical level capabilities",
+	.help_str = "Show Port TM Hierarhical level Capabilities",
 	.tokens = {
 		(void *)&cmd_show_port_tm_level_cap_show,
 		(void *)&cmd_show_port_tm_level_cap_port,
@@ -506,31 +464,31 @@
 	uint32_t node_id;
 };
 
-static cmdline_parse_token_string_t cmd_show_port_tm_node_cap_show =
+cmdline_parse_token_string_t cmd_show_port_tm_node_cap_show =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_node_cap_result,
 		show, "show");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_cap_port =
+cmdline_parse_token_string_t cmd_show_port_tm_node_cap_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_node_cap_result,
 		port, "port");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_cap_tm =
+cmdline_parse_token_string_t cmd_show_port_tm_node_cap_tm =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_node_cap_result,
 		tm, "tm");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_cap_node =
+cmdline_parse_token_string_t cmd_show_port_tm_node_cap_node =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_node_cap_result,
 		node, "node");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_cap_cap =
+cmdline_parse_token_string_t cmd_show_port_tm_node_cap_cap =
 	TOKEN_STRING_INITIALIZER(struct cmd_show_port_tm_node_cap_result,
 		cap, "cap");
-static cmdline_parse_token_num_t cmd_show_port_tm_node_cap_port_id =
+cmdline_parse_token_num_t cmd_show_port_tm_node_cap_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_port_tm_node_cap_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_show_port_tm_node_cap_node_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_show_port_tm_node_cap_node_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_port_tm_node_cap_result,
-		 node_id, RTE_UINT32);
+		 node_id, UINT32);
 
 static void cmd_show_port_tm_node_cap_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_show_port_tm_node_cap_result *res = parsed_result;
 	struct rte_tm_node_capabilities ncap;
@@ -566,16 +524,8 @@
 		ncap.shaper_private_rate_min);
 	printf("cap.shaper_private_rate_max %" PRIu64 "\n",
 		ncap.shaper_private_rate_max);
-	printf("cap.shaper_private_packet_mode_supported %" PRId32 "\n",
-		ncap.shaper_private_packet_mode_supported);
-	printf("cap.shaper_private_byte_mode_supported %" PRId32 "\n",
-		ncap.shaper_private_byte_mode_supported);
 	printf("cap.shaper_shared_n_max %" PRIu32 "\n",
 		ncap.shaper_shared_n_max);
-	printf("cap.shaper_shared_packet_mode_supported %" PRId32 "\n",
-		ncap.shaper_shared_packet_mode_supported);
-	printf("cap.shaper_shared_byte_mode_supported %" PRId32 "\n",
-		ncap.shaper_shared_byte_mode_supported);
 	if (!is_leaf) {
 		printf("cap.nonleaf.sched_n_children_max %" PRIu32 "\n",
 			ncap.nonleaf.sched_n_children_max);
@@ -587,10 +537,6 @@
 			ncap.nonleaf.sched_wfq_n_groups_max);
 		printf("cap.nonleaf.sched_wfq_weight_max %" PRIu32 "\n",
 			ncap.nonleaf.sched_wfq_weight_max);
-		printf("cap.nonleaf.sched_wfq_packet_mode_supported %" PRId32 "\n",
-			ncap.nonleaf.sched_wfq_packet_mode_supported);
-		printf("cap.nonleaf.sched_wfq_byte_mode_supported %" PRId32 "\n",
-			ncap.nonleaf.sched_wfq_byte_mode_supported);
 	} else {
 		printf("cap.leaf.cman_head_drop_supported %" PRId32 "\n",
 			ncap.leaf.cman_head_drop_supported);
@@ -630,35 +576,35 @@
 	uint32_t clear;
 };
 
-static cmdline_parse_token_string_t cmd_show_port_tm_node_stats_show =
+cmdline_parse_token_string_t cmd_show_port_tm_node_stats_show =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_stats_result, show, "show");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_stats_port =
+cmdline_parse_token_string_t cmd_show_port_tm_node_stats_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_stats_result, port, "port");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_stats_tm =
+cmdline_parse_token_string_t cmd_show_port_tm_node_stats_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_stats_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_stats_node =
+cmdline_parse_token_string_t cmd_show_port_tm_node_stats_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_stats_result, node, "node");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_stats_stats =
+cmdline_parse_token_string_t cmd_show_port_tm_node_stats_stats =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_stats_result, stats, "stats");
-static cmdline_parse_token_num_t cmd_show_port_tm_node_stats_port_id =
+cmdline_parse_token_num_t cmd_show_port_tm_node_stats_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_show_port_tm_node_stats_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_show_port_tm_node_stats_node_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_show_port_tm_node_stats_node_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_show_port_tm_node_stats_result,
-			node_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_show_port_tm_node_stats_clear =
+			node_id, UINT32);
+cmdline_parse_token_num_t cmd_show_port_tm_node_stats_clear =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_show_port_tm_node_stats_result, clear, RTE_UINT32);
+		struct cmd_show_port_tm_node_stats_result, clear, UINT32);
 
 static void cmd_show_port_tm_node_stats_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_show_port_tm_node_stats_result *res = parsed_result;
 	struct rte_tm_node_stats stats;
@@ -675,7 +621,7 @@
 	memset(&error, 0, sizeof(struct rte_tm_error));
 	/* Port status */
 	if (!port_is_started(port_id)) {
-		fprintf(stderr, " Port %u not started (error)\n", port_id);
+		printf(" Port %u not started (error)\n", port_id);
 		return;
 	}
 
@@ -748,33 +694,33 @@
 	uint32_t node_id;
 };
 
-static cmdline_parse_token_string_t cmd_show_port_tm_node_type_show =
+cmdline_parse_token_string_t cmd_show_port_tm_node_type_show =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_type_result, show, "show");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_type_port =
+cmdline_parse_token_string_t cmd_show_port_tm_node_type_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_type_result, port, "port");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_type_tm =
+cmdline_parse_token_string_t cmd_show_port_tm_node_type_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_type_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_type_node =
+cmdline_parse_token_string_t cmd_show_port_tm_node_type_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_type_result, node, "node");
-static cmdline_parse_token_string_t cmd_show_port_tm_node_type_type =
+cmdline_parse_token_string_t cmd_show_port_tm_node_type_type =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_show_port_tm_node_type_result, type, "type");
-static cmdline_parse_token_num_t cmd_show_port_tm_node_type_port_id =
+cmdline_parse_token_num_t cmd_show_port_tm_node_type_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_show_port_tm_node_type_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_show_port_tm_node_type_node_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_show_port_tm_node_type_node_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_show_port_tm_node_type_result,
-			node_id, RTE_UINT32);
+			node_id, UINT32);
 
 static void cmd_show_port_tm_node_type_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_show_port_tm_node_type_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -830,68 +776,63 @@
 	uint64_t peak_tb_rate;
 	uint64_t peak_tb_size;
 	uint32_t pktlen_adjust;
-	int pkt_mode;
 };
 
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_add =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_add =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result, add, "add");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_port =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_tm =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
 			tm, "tm");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_node =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
 			node, "node");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_shaper =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_shaper =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
 			shaper, "shaper");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_profile =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shaper_profile_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
 			profile, "profile");
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_port_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_add_port_tm_node_shaper_profile_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_shaper_id =
+cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
-			shaper_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_cmit_tb_rate =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_shaper_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
-			cmit_tb_rate, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_cmit_tb_size =
+			shaper_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_cmit_tb_rate =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
-			cmit_tb_size, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_peak_tb_rate =
+			cmit_tb_rate, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_cmit_tb_size =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
-			peak_tb_rate, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_peak_tb_size =
+			cmit_tb_size, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_peak_tb_rate =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
-			peak_tb_size, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_pktlen_adjust =
+			peak_tb_rate, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_peak_tb_size =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
-			pktlen_adjust, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_packet_mode =
+			peak_tb_size, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_shaper_profile_pktlen_adjust =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shaper_profile_result,
-			pkt_mode, RTE_UINT32);
+			pktlen_adjust, UINT32);
 
 static void cmd_add_port_tm_node_shaper_profile_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_add_port_tm_node_shaper_profile_result *res = parsed_result;
 	struct rte_tm_shaper_params sp;
@@ -912,7 +853,6 @@
 	sp.peak.rate = res->peak_tb_rate;
 	sp.peak.size = res->peak_tb_size;
 	sp.pkt_length_adjust = pkt_len_adjust;
-	sp.packet_mode = res->pkt_mode;
 
 	ret = rte_tm_shaper_profile_add(port_id, shaper_id, &sp, &error);
 	if (ret != 0) {
@@ -939,7 +879,6 @@
 		(void *)&cmd_add_port_tm_node_shaper_profile_peak_tb_rate,
 		(void *)&cmd_add_port_tm_node_shaper_profile_peak_tb_size,
 		(void *)&cmd_add_port_tm_node_shaper_profile_pktlen_adjust,
-		(void *)&cmd_add_port_tm_node_shaper_profile_packet_mode,
 		NULL,
 	},
 };
@@ -956,40 +895,40 @@
 	uint32_t shaper_id;
 };
 
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_del =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_del =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shaper_profile_result, del, "del");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_port =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shaper_profile_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_tm =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shaper_profile_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_node =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shaper_profile_result,
 			node, "node");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_shaper =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_shaper =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shaper_profile_result,
 			shaper, "shaper");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_profile =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shaper_profile_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shaper_profile_result,
 			profile, "profile");
-static cmdline_parse_token_num_t cmd_del_port_tm_node_shaper_profile_port_id =
+cmdline_parse_token_num_t cmd_del_port_tm_node_shaper_profile_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_del_port_tm_node_shaper_profile_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_del_port_tm_node_shaper_profile_shaper_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_del_port_tm_node_shaper_profile_shaper_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_del_port_tm_node_shaper_profile_result,
-			shaper_id, RTE_UINT32);
+			shaper_id, UINT32);
 
 static void cmd_del_port_tm_node_shaper_profile_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_del_port_tm_node_shaper_profile_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -1038,43 +977,43 @@
 	uint32_t shaper_profile_id;
 };
 
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_cmd_type =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_cmd_type =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shared_shaper_result,
 			cmd_type, "add#set");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_port =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shared_shaper_result, port, "port");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_tm =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shared_shaper_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_node =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shared_shaper_result, node, "node");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_shared =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_shared =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shared_shaper_result,
 			shared, "shared");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_shaper =
+cmdline_parse_token_string_t cmd_add_port_tm_node_shared_shaper_shaper =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_shared_shaper_result,
 			shaper, "shaper");
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shared_shaper_port_id =
+cmdline_parse_token_num_t cmd_add_port_tm_node_shared_shaper_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shared_shaper_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shared_shaper_shared_shaper_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_add_port_tm_node_shared_shaper_shared_shaper_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shared_shaper_result,
-			shared_shaper_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_shared_shaper_shaper_profile_id =
+			shared_shaper_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_node_shared_shaper_shaper_profile_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_shared_shaper_result,
-			shaper_profile_id, RTE_UINT32);
+			shaper_profile_id, UINT32);
 
 static void cmd_add_port_tm_node_shared_shaper_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_add_port_tm_node_shared_shaper_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -1090,14 +1029,14 @@
 	/* Command type: add */
 	if ((strcmp(res->cmd_type, "add") == 0) &&
 		(port_is_started(port_id))) {
-		fprintf(stderr, " Port %u not stopped (error)\n", port_id);
+		printf(" Port %u not stopped (error)\n", port_id);
 		return;
 	}
 
 	/* Command type: set (update) */
 	if ((strcmp(res->cmd_type, "set") == 0) &&
 		(!port_is_started(port_id))) {
-		fprintf(stderr, " Port %u not started (error)\n", port_id);
+		printf(" Port %u not started (error)\n", port_id);
 		return;
 	}
 
@@ -1139,38 +1078,38 @@
 	uint32_t shared_shaper_id;
 };
 
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_del =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_del =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shared_shaper_result, del, "del");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_port =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shared_shaper_result, port, "port");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_tm =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shared_shaper_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_node =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shared_shaper_result, node, "node");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_shared =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_shared =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shared_shaper_result,
 			shared, "shared");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_shaper =
+cmdline_parse_token_string_t cmd_del_port_tm_node_shared_shaper_shaper =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_shared_shaper_result,
 			shaper, "shaper");
-static cmdline_parse_token_num_t cmd_del_port_tm_node_shared_shaper_port_id =
+cmdline_parse_token_num_t cmd_del_port_tm_node_shared_shaper_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_del_port_tm_node_shared_shaper_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_del_port_tm_node_shared_shaper_shared_shaper_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_del_port_tm_node_shared_shaper_shared_shaper_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_del_port_tm_node_shared_shaper_result,
-			shared_shaper_id, RTE_UINT32);
+			shared_shaper_id, UINT32);
 
 static void cmd_del_port_tm_node_shared_shaper_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_del_port_tm_node_shared_shaper_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -1233,98 +1172,98 @@
 	uint16_t wq_log2_r;
 };
 
-static cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_add =
+cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_add =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result, add, "add");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_port =
+cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result, port, "port");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_tm =
+cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_node =
+cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result, node, "node");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_wred =
+cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_wred =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result, wred, "wred");
-static cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_profile =
+cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
 			profile, "profile");
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_port_id =
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_wred_profile_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_wred_profile_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			wred_profile_id, RTE_UINT32);
-static cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_color_g =
+			wred_profile_id, UINT32);
+cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_color_g =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
 			color_g, "G#g");
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_min_th_g =
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_min_th_g =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			min_th_g, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_max_th_g =
+			min_th_g, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_max_th_g =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			max_th_g, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_maxp_inv_g =
+			max_th_g, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_maxp_inv_g =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			maxp_inv_g, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_wq_log2_g =
+			maxp_inv_g, UINT16);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_wq_log2_g =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			wq_log2_g, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_color_y =
+			wq_log2_g, UINT16);
+cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_color_y =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
 			color_y, "Y#y");
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_min_th_y =
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_min_th_y =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			min_th_y, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_max_th_y =
+			min_th_y, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_max_th_y =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			max_th_y, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_maxp_inv_y =
+			max_th_y, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_maxp_inv_y =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			maxp_inv_y, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_wq_log2_y =
+			maxp_inv_y, UINT16);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_wq_log2_y =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			wq_log2_y, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_color_r =
+			wq_log2_y, UINT16);
+cmdline_parse_token_string_t cmd_add_port_tm_node_wred_profile_color_r =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
 			color_r, "R#r");
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_min_th_r =
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_min_th_r =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			min_th_r, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_max_th_r =
+			min_th_r, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_max_th_r =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			max_th_r, RTE_UINT64);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_maxp_inv_r =
+			max_th_r, UINT64);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_maxp_inv_r =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			maxp_inv_r, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_wq_log2_r =
+			maxp_inv_r, UINT16);
+cmdline_parse_token_num_t cmd_add_port_tm_node_wred_profile_wq_log2_r =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_node_wred_profile_result,
-			wq_log2_r, RTE_UINT16);
+			wq_log2_r, UINT16);
 
 
 static void cmd_add_port_tm_node_wred_profile_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_add_port_tm_node_wred_profile_result *res = parsed_result;
 	struct rte_tm_wred_params wp;
@@ -1413,37 +1352,37 @@
 	uint32_t wred_profile_id;
 };
 
-static cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_del =
+cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_del =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_wred_profile_result, del, "del");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_port =
+cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_wred_profile_result, port, "port");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_tm =
+cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_wred_profile_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_node =
+cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_wred_profile_result, node, "node");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_wred =
+cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_wred =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_wred_profile_result, wred, "wred");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_profile =
+cmdline_parse_token_string_t cmd_del_port_tm_node_wred_profile_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_wred_profile_result,
 			profile, "profile");
-static cmdline_parse_token_num_t cmd_del_port_tm_node_wred_profile_port_id =
+cmdline_parse_token_num_t cmd_del_port_tm_node_wred_profile_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_del_port_tm_node_wred_profile_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_del_port_tm_node_wred_profile_wred_profile_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_del_port_tm_node_wred_profile_wred_profile_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_del_port_tm_node_wred_profile_result,
-			wred_profile_id, RTE_UINT32);
+			wred_profile_id, UINT32);
 
 static void cmd_del_port_tm_node_wred_profile_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_del_port_tm_node_wred_profile_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -1492,44 +1431,44 @@
 	uint32_t shaper_profile_id;
 };
 
-static cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_set =
+cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_set =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_shaper_profile_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_port =
+cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_shaper_profile_result,
 			port, "port");
-static cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_tm =
+cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_shaper_profile_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_node =
+cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_shaper_profile_result,
 			node, "node");
-static cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_shaper =
+cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_shaper =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_shaper_profile_result,
 			shaper, "shaper");
-static cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_profile =
+cmdline_parse_token_string_t cmd_set_port_tm_node_shaper_profile_profile =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_shaper_profile_result,
 			profile, "profile");
-static cmdline_parse_token_num_t cmd_set_port_tm_node_shaper_profile_port_id =
+cmdline_parse_token_num_t cmd_set_port_tm_node_shaper_profile_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_set_port_tm_node_shaper_profile_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_set_port_tm_node_shaper_profile_node_id =
+			port_id, UINT16);
+cmdline_parse_token_num_t cmd_set_port_tm_node_shaper_profile_node_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_port_tm_node_shaper_profile_result,
-		node_id, RTE_UINT32);
-static cmdline_parse_token_num_t
+		node_id, UINT32);
+cmdline_parse_token_num_t
 	cmd_set_port_tm_node_shaper_shaper_profile_profile_id =
 		TOKEN_NUM_INITIALIZER(
 			struct cmd_set_port_tm_node_shaper_profile_result,
-			shaper_profile_id, RTE_UINT32);
+			shaper_profile_id, UINT32);
 
 static void cmd_set_port_tm_node_shaper_profile_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_port_tm_node_shaper_profile_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -1544,7 +1483,7 @@
 	memset(&error, 0, sizeof(struct rte_tm_error));
 	/* Port status */
 	if (!port_is_started(port_id)) {
-		fprintf(stderr, " Port %u not started (error)\n", port_id);
+		printf(" Port %u not started (error)\n", port_id);
 		return;
 	}
 
@@ -1593,57 +1532,57 @@
 	cmdline_multi_string_t multi_shared_shaper_id;
 };
 
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_add =
+cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_add =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_nonleaf_node_result, add, "add");
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_port =
+cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_nonleaf_node_result, port, "port");
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_tm =
+cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_nonleaf_node_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_nonleaf =
+cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_nonleaf =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_nonleaf_node_result, nonleaf, "nonleaf");
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_node =
+cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_nonleaf_node_result, node, "node");
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_port_id =
+cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_add_port_tm_nonleaf_node_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_node_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_node_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_result,
-		 node_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_parent_node_id =
+		 node_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_parent_node_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_result,
-		 parent_node_id, RTE_INT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_priority =
+		 parent_node_id, INT32);
+cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_priority =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_result,
-		 priority, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_weight =
+		 priority, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_weight =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_result,
-		 weight, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_level_id =
+		 weight, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_level_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_result,
-		 level_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_shaper_profile_id =
+		 level_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_shaper_profile_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_result,
-		 shaper_profile_id, RTE_INT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_n_sp_priorities =
+		 shaper_profile_id, INT32);
+cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_n_sp_priorities =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_result,
-		 n_sp_priorities, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_stats_mask =
+		 n_sp_priorities, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_stats_mask =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_result,
-		 stats_mask, RTE_UINT64);
-static cmdline_parse_token_string_t
+		 stats_mask, UINT64);
+cmdline_parse_token_string_t
 	cmd_add_port_tm_nonleaf_node_multi_shared_shaper_id =
 	TOKEN_STRING_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_result,
 		 multi_shared_shaper_id, TOKEN_STRING_MULTI);
 
 static void cmd_add_port_tm_nonleaf_node_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_add_port_tm_nonleaf_node_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -1669,15 +1608,14 @@
 	shared_shaper_id = (uint32_t *)malloc(MAX_NUM_SHARED_SHAPERS *
 		sizeof(uint32_t));
 	if (shared_shaper_id == NULL) {
-		fprintf(stderr,
-			" Memory not allocated for shared shapers (error)\n");
+		printf(" Memory not allocated for shared shapers (error)\n");
 		return;
 	}
 
 	/* Parse multi shared shaper id string */
 	ret = parse_multi_ss_id_str(s_str, &n_shared_shapers, shared_shaper_id);
 	if (ret) {
-		fprintf(stderr, " Shared shapers params string parse error\n");
+		printf(" Shared shapers params string parse error\n");
 		free(shared_shaper_id);
 		return;
 	}
@@ -1733,173 +1671,6 @@
 	},
 };
 
-/* *** Add Port TM nonleaf node pkt mode *** */
-struct cmd_add_port_tm_nonleaf_node_pmode_result {
-	cmdline_fixed_string_t add;
-	cmdline_fixed_string_t port;
-	cmdline_fixed_string_t tm;
-	cmdline_fixed_string_t nonleaf;
-	cmdline_fixed_string_t node;
-	uint16_t port_id;
-	uint32_t node_id;
-	int32_t parent_node_id;
-	uint32_t priority;
-	uint32_t weight;
-	uint32_t level_id;
-	int32_t shaper_profile_id;
-	uint32_t n_sp_priorities;
-	uint64_t stats_mask;
-	cmdline_multi_string_t multi_shared_shaper_id;
-};
-
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_pmode_add =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_add_port_tm_nonleaf_node_pmode_result, add, "add");
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_pmode_port =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_add_port_tm_nonleaf_node_pmode_result, port, "port");
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_pmode_tm =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_add_port_tm_nonleaf_node_pmode_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_pmode_nonleaf =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_add_port_tm_nonleaf_node_pmode_result, nonleaf, "nonleaf");
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_pmode_node =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_add_port_tm_nonleaf_node_pmode_result, node, "node");
-static cmdline_parse_token_string_t cmd_add_port_tm_nonleaf_node_pmode_pktmode =
-	TOKEN_STRING_INITIALIZER(
-		struct cmd_add_port_tm_nonleaf_node_pmode_result, node, "pktmode");
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_pmode_port_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_add_port_tm_nonleaf_node_pmode_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_pmode_node_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_pmode_result,
-		 node_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_pmode_parent_node_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_pmode_result,
-		 parent_node_id, RTE_INT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_pmode_priority =
-	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_pmode_result,
-		 priority, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_pmode_weight =
-	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_pmode_result,
-		 weight, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_pmode_level_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_pmode_result,
-		 level_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_pmode_shaper_profile_id =
-	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_pmode_result,
-		 shaper_profile_id, RTE_INT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_pmode_n_sp_priorities =
-	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_pmode_result,
-		 n_sp_priorities, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_nonleaf_node_pmode_stats_mask =
-	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_nonleaf_node_pmode_result,
-		 stats_mask, RTE_UINT64);
-static cmdline_parse_token_string_t
-	cmd_add_port_tm_nonleaf_node_pmode_multi_shrd_shpr_id =
-	TOKEN_STRING_INITIALIZER(
-			struct cmd_add_port_tm_nonleaf_node_pmode_result,
-			multi_shared_shaper_id, TOKEN_STRING_MULTI);
-
-static void cmd_add_port_tm_nonleaf_node_pmode_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
-{
-	struct cmd_add_port_tm_nonleaf_node_pmode_result *res = parsed_result;
-	uint32_t parent_node_id, n_shared_shapers = 0;
-	char *s_str = res->multi_shared_shaper_id;
-	portid_t port_id = res->port_id;
-	struct rte_tm_node_params np;
-	int *wfq_weight_mode = NULL;
-	uint32_t *shared_shaper_id;
-	struct rte_tm_error error;
-	int ret;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN))
-		return;
-
-	memset(&np, 0, sizeof(struct rte_tm_node_params));
-	memset(&error, 0, sizeof(struct rte_tm_error));
-
-	/* Node parameters */
-	if (res->parent_node_id < 0)
-		parent_node_id = UINT32_MAX;
-	else
-		parent_node_id = res->parent_node_id;
-
-	shared_shaper_id = (uint32_t *)malloc(MAX_NUM_SHARED_SHAPERS *
-		sizeof(uint32_t));
-	if (shared_shaper_id == NULL) {
-		fprintf(stderr,
-			" Memory not allocated for shared shapers (error)\n");
-		return;
-	}
-
-	/* Parse multi shared shaper id string */
-	ret = parse_multi_ss_id_str(s_str, &n_shared_shapers, shared_shaper_id);
-	if (ret) {
-		fprintf(stderr, " Shared shapers params string parse error\n");
-		free(shared_shaper_id);
-		return;
-	}
-
-	if (res->shaper_profile_id < 0)
-		np.shaper_profile_id = UINT32_MAX;
-	else
-		np.shaper_profile_id = res->shaper_profile_id;
-
-	np.n_shared_shapers = n_shared_shapers;
-	if (np.n_shared_shapers) {
-		np.shared_shaper_id = &shared_shaper_id[0];
-	} else {
-		free(shared_shaper_id);
-		shared_shaper_id = NULL;
-	}
-
-	if (res->n_sp_priorities)
-		wfq_weight_mode = calloc(res->n_sp_priorities, sizeof(int));
-	np.nonleaf.n_sp_priorities = res->n_sp_priorities;
-	np.stats_mask = res->stats_mask;
-	np.nonleaf.wfq_weight_mode = wfq_weight_mode;
-
-	ret = rte_tm_node_add(port_id, res->node_id, parent_node_id,
-				res->priority, res->weight, res->level_id,
-				&np, &error);
-	if (ret != 0) {
-		print_err_msg(&error);
-		free(shared_shaper_id);
-		free(wfq_weight_mode);
-		return;
-	}
-}
-
-cmdline_parse_inst_t cmd_add_port_tm_nonleaf_node_pmode = {
-	.f = cmd_add_port_tm_nonleaf_node_pmode_parsed,
-	.data = NULL,
-	.help_str = "Add port tm nonleaf node pktmode",
-	.tokens = {
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_add,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_port,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_tm,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_nonleaf,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_node,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_pktmode,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_port_id,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_node_id,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_parent_node_id,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_priority,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_weight,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_level_id,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_shaper_profile_id,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_n_sp_priorities,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_stats_mask,
-		(void *)&cmd_add_port_tm_nonleaf_node_pmode_multi_shrd_shpr_id,
-		NULL,
-	},
-};
 /* *** Add Port TM leaf node *** */
 struct cmd_add_port_tm_leaf_node_result {
 	cmdline_fixed_string_t add;
@@ -1920,59 +1691,59 @@
 	cmdline_multi_string_t multi_shared_shaper_id;
 };
 
-static cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_add =
+cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_add =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_leaf_node_result, add, "add");
-static cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_port =
+cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_leaf_node_result, port, "port");
-static cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_tm =
+cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_leaf_node_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_nonleaf =
+cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_nonleaf =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_leaf_node_result, leaf, "leaf");
-static cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_node =
+cmdline_parse_token_string_t cmd_add_port_tm_leaf_node_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_add_port_tm_leaf_node_result, node, "node");
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_port_id =
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_node_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_node_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 node_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_parent_node_id =
+		 node_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_parent_node_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 parent_node_id, RTE_INT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_priority =
+		 parent_node_id, INT32);
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_priority =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 priority, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_weight =
+		 priority, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_weight =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 weight, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_level_id =
+		 weight, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_level_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 level_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_shaper_profile_id =
+		 level_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_shaper_profile_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 shaper_profile_id, RTE_INT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_cman_mode =
+		 shaper_profile_id, INT32);
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_cman_mode =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 cman_mode, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_wred_profile_id =
+		 cman_mode, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_wred_profile_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 wred_profile_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_stats_mask =
+		 wred_profile_id, UINT32);
+cmdline_parse_token_num_t cmd_add_port_tm_leaf_node_stats_mask =
 	TOKEN_NUM_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
-		 stats_mask, RTE_UINT64);
-static cmdline_parse_token_string_t
+		 stats_mask, UINT64);
+cmdline_parse_token_string_t
 	cmd_add_port_tm_leaf_node_multi_shared_shaper_id =
 	TOKEN_STRING_INITIALIZER(struct cmd_add_port_tm_leaf_node_result,
 		 multi_shared_shaper_id, TOKEN_STRING_MULTI);
 
 static void cmd_add_port_tm_leaf_node_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_add_port_tm_leaf_node_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -1998,15 +1769,14 @@
 	shared_shaper_id = (uint32_t *)malloc(MAX_NUM_SHARED_SHAPERS *
 		sizeof(uint32_t));
 	if (shared_shaper_id == NULL) {
-		fprintf(stderr,
-			" Memory not allocated for shared shapers (error)\n");
+		printf(" Memory not allocated for shared shapers (error)\n");
 		return;
 	}
 
 	/* Parse multi shared shaper id string */
 	ret = parse_multi_ss_id_str(s_str, &n_shared_shapers, shared_shaper_id);
 	if (ret) {
-		fprintf(stderr, " Shared shapers params string parse error\n");
+		printf(" Shared shapers params string parse error\n");
 		free(shared_shaper_id);
 		return;
 	}
@@ -2074,28 +1844,28 @@
 	uint32_t node_id;
 };
 
-static cmdline_parse_token_string_t cmd_del_port_tm_node_del =
+cmdline_parse_token_string_t cmd_del_port_tm_node_del =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_result, del, "del");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_port =
+cmdline_parse_token_string_t cmd_del_port_tm_node_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_result, port, "port");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_tm =
+cmdline_parse_token_string_t cmd_del_port_tm_node_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_del_port_tm_node_node =
+cmdline_parse_token_string_t cmd_del_port_tm_node_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_del_port_tm_node_result, node, "node");
-static cmdline_parse_token_num_t cmd_del_port_tm_node_port_id =
+cmdline_parse_token_num_t cmd_del_port_tm_node_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_del_port_tm_node_result,
-		 port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_del_port_tm_node_node_id =
+		 port_id, UINT16);
+cmdline_parse_token_num_t cmd_del_port_tm_node_node_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_del_port_tm_node_result,
-		node_id, RTE_UINT32);
+		node_id, UINT32);
 
 static void cmd_del_port_tm_node_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_del_port_tm_node_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -2109,7 +1879,7 @@
 	memset(&error, 0, sizeof(struct rte_tm_error));
 	/* Port status */
 	if (port_is_started(port_id)) {
-		fprintf(stderr, " Port %u not stopped (error)\n", port_id);
+		printf(" Port %u not stopped (error)\n", port_id);
 		return;
 	}
 
@@ -2149,42 +1919,40 @@
 	uint32_t weight;
 };
 
-static cmdline_parse_token_string_t cmd_set_port_tm_node_parent_set =
+cmdline_parse_token_string_t cmd_set_port_tm_node_parent_set =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_parent_result, set, "set");
-static cmdline_parse_token_string_t cmd_set_port_tm_node_parent_port =
+cmdline_parse_token_string_t cmd_set_port_tm_node_parent_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_parent_result, port, "port");
-static cmdline_parse_token_string_t cmd_set_port_tm_node_parent_tm =
+cmdline_parse_token_string_t cmd_set_port_tm_node_parent_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_parent_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_set_port_tm_node_parent_node =
+cmdline_parse_token_string_t cmd_set_port_tm_node_parent_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_parent_result, node, "node");
-static cmdline_parse_token_string_t cmd_set_port_tm_node_parent_parent =
+cmdline_parse_token_string_t cmd_set_port_tm_node_parent_parent =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_set_port_tm_node_parent_result, parent, "parent");
-static cmdline_parse_token_num_t cmd_set_port_tm_node_parent_port_id =
+cmdline_parse_token_num_t cmd_set_port_tm_node_parent_port_id =
+	TOKEN_NUM_INITIALIZER(
+		struct cmd_set_port_tm_node_parent_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_set_port_tm_node_parent_node_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_tm_node_parent_result, port_id,
-		RTE_UINT16);
-static cmdline_parse_token_num_t cmd_set_port_tm_node_parent_node_id =
-	TOKEN_NUM_INITIALIZER(
-		struct cmd_set_port_tm_node_parent_result, node_id,
-		RTE_UINT32);
-static cmdline_parse_token_num_t cmd_set_port_tm_node_parent_parent_id =
+		struct cmd_set_port_tm_node_parent_result, node_id, UINT32);
+cmdline_parse_token_num_t cmd_set_port_tm_node_parent_parent_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_port_tm_node_parent_result,
-		parent_id, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_set_port_tm_node_parent_priority =
+		parent_id, UINT32);
+cmdline_parse_token_num_t cmd_set_port_tm_node_parent_priority =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_port_tm_node_parent_result,
-		priority, RTE_UINT32);
-static cmdline_parse_token_num_t cmd_set_port_tm_node_parent_weight =
+		priority, UINT32);
+cmdline_parse_token_num_t cmd_set_port_tm_node_parent_weight =
 	TOKEN_NUM_INITIALIZER(struct cmd_set_port_tm_node_parent_result,
-		weight, RTE_UINT32);
+		weight, UINT32);
 
 static void cmd_set_port_tm_node_parent_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_set_port_tm_node_parent_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -2201,7 +1969,7 @@
 	memset(&error, 0, sizeof(struct rte_tm_error));
 	/* Port status */
 	if (!port_is_started(port_id)) {
-		fprintf(stderr, " Port %u not started (error)\n", port_id);
+		printf(" Port %u not started (error)\n", port_id);
 		return;
 	}
 
@@ -2242,30 +2010,28 @@
 	uint32_t node_id;
 };
 
-static cmdline_parse_token_string_t cmd_suspend_port_tm_node_suspend =
+cmdline_parse_token_string_t cmd_suspend_port_tm_node_suspend =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_suspend_port_tm_node_result, suspend, "suspend");
-static cmdline_parse_token_string_t cmd_suspend_port_tm_node_port =
+cmdline_parse_token_string_t cmd_suspend_port_tm_node_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_suspend_port_tm_node_result, port, "port");
-static cmdline_parse_token_string_t cmd_suspend_port_tm_node_tm =
+cmdline_parse_token_string_t cmd_suspend_port_tm_node_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_suspend_port_tm_node_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_suspend_port_tm_node_node =
+cmdline_parse_token_string_t cmd_suspend_port_tm_node_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_suspend_port_tm_node_result, node, "node");
-static cmdline_parse_token_num_t cmd_suspend_port_tm_node_port_id =
+cmdline_parse_token_num_t cmd_suspend_port_tm_node_port_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_suspend_port_tm_node_result, port_id,
-		RTE_UINT16);
-static cmdline_parse_token_num_t cmd_suspend_port_tm_node_node_id =
+		struct cmd_suspend_port_tm_node_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_suspend_port_tm_node_node_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_suspend_port_tm_node_result, node_id,
-		RTE_UINT32);
+		struct cmd_suspend_port_tm_node_result, node_id, UINT32);
 
 static void cmd_suspend_port_tm_node_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_suspend_port_tm_node_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -2309,28 +2075,28 @@
 	uint32_t node_id;
 };
 
-static cmdline_parse_token_string_t cmd_resume_port_tm_node_resume =
+cmdline_parse_token_string_t cmd_resume_port_tm_node_resume =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_resume_port_tm_node_result, resume, "resume");
-static cmdline_parse_token_string_t cmd_resume_port_tm_node_port =
+cmdline_parse_token_string_t cmd_resume_port_tm_node_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_resume_port_tm_node_result, port, "port");
-static cmdline_parse_token_string_t cmd_resume_port_tm_node_tm =
+cmdline_parse_token_string_t cmd_resume_port_tm_node_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_resume_port_tm_node_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_resume_port_tm_node_node =
+cmdline_parse_token_string_t cmd_resume_port_tm_node_node =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_resume_port_tm_node_result, node, "node");
-static cmdline_parse_token_num_t cmd_resume_port_tm_node_port_id =
+cmdline_parse_token_num_t cmd_resume_port_tm_node_port_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_resume_port_tm_node_result, port_id, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_resume_port_tm_node_node_id =
+		struct cmd_resume_port_tm_node_result, port_id, UINT16);
+cmdline_parse_token_num_t cmd_resume_port_tm_node_node_id =
 	TOKEN_NUM_INITIALIZER(
-		struct cmd_resume_port_tm_node_result, node_id, RTE_UINT32);
+		struct cmd_resume_port_tm_node_result, node_id, UINT32);
 
 static void cmd_resume_port_tm_node_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_resume_port_tm_node_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -2374,30 +2140,30 @@
 	cmdline_fixed_string_t clean_on_fail;
 };
 
-static cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_port =
+cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_port =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_port_tm_hierarchy_commit_result, port, "port");
-static cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_tm =
+cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_tm =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_port_tm_hierarchy_commit_result, tm, "tm");
-static cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_hierarchy =
+cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_hierarchy =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_port_tm_hierarchy_commit_result,
 			hierarchy, "hierarchy");
-static cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_commit =
+cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_commit =
 	TOKEN_STRING_INITIALIZER(
 		struct cmd_port_tm_hierarchy_commit_result, commit, "commit");
-static cmdline_parse_token_num_t cmd_port_tm_hierarchy_commit_port_id =
+cmdline_parse_token_num_t cmd_port_tm_hierarchy_commit_port_id =
 	TOKEN_NUM_INITIALIZER(
 		struct cmd_port_tm_hierarchy_commit_result,
-			port_id, RTE_UINT16);
-static cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_clean_on_fail =
+			port_id, UINT16);
+cmdline_parse_token_string_t cmd_port_tm_hierarchy_commit_clean_on_fail =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_hierarchy_commit_result,
 		 clean_on_fail, "yes#no");
 
 static void cmd_port_tm_hierarchy_commit_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_port_tm_hierarchy_commit_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -2449,42 +2215,42 @@
 	uint16_t red;
 };
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_set =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_ecn_result,
 				 set, "set");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_port =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_ecn_result,
 				 port, "port");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_tm =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_tm =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_ecn_result, tm,
 				 "tm");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_mark =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_mark =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_ecn_result,
 				 mark, "mark");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_ip_ecn =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_ecn_ip_ecn =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_ecn_result,
 				 ip_ecn, "ip_ecn");
-static cmdline_parse_token_num_t cmd_port_tm_mark_ip_ecn_port_id =
+cmdline_parse_token_num_t cmd_port_tm_mark_ip_ecn_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_ip_ecn_result,
-			      port_id, RTE_UINT16);
+			      port_id, UINT16);
 
-static cmdline_parse_token_num_t cmd_port_tm_mark_ip_ecn_green =
+cmdline_parse_token_num_t cmd_port_tm_mark_ip_ecn_green =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_ip_ecn_result,
-			      green, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_port_tm_mark_ip_ecn_yellow =
+			      green, UINT16);
+cmdline_parse_token_num_t cmd_port_tm_mark_ip_ecn_yellow =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_ip_ecn_result,
-			      yellow, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_port_tm_mark_ip_ecn_red =
+			      yellow, UINT16);
+cmdline_parse_token_num_t cmd_port_tm_mark_ip_ecn_red =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_ip_ecn_result,
-				red, RTE_UINT16);
+				red, UINT16);
 
 static void cmd_port_tm_mark_ip_ecn_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_port_tm_mark_ip_ecn_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -2536,42 +2302,42 @@
 	uint16_t red;
 };
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_set =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_dscp_result,
 				 set, "set");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_port =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_dscp_result,
 				 port, "port");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_tm =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_tm =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_dscp_result, tm,
 				 "tm");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_mark =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_mark =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_dscp_result,
 				 mark, "mark");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_ip_dscp =
+cmdline_parse_token_string_t cmd_port_tm_mark_ip_dscp_ip_dscp =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_ip_dscp_result,
 				 ip_dscp, "ip_dscp");
-static cmdline_parse_token_num_t cmd_port_tm_mark_ip_dscp_port_id =
+cmdline_parse_token_num_t cmd_port_tm_mark_ip_dscp_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_ip_dscp_result,
-			      port_id, RTE_UINT16);
+			      port_id, UINT16);
 
-static cmdline_parse_token_num_t cmd_port_tm_mark_ip_dscp_green =
+cmdline_parse_token_num_t cmd_port_tm_mark_ip_dscp_green =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_ip_dscp_result,
-				green, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_port_tm_mark_ip_dscp_yellow =
+				green, UINT16);
+cmdline_parse_token_num_t cmd_port_tm_mark_ip_dscp_yellow =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_ip_dscp_result,
-				yellow, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_port_tm_mark_ip_dscp_red =
+				yellow, UINT16);
+cmdline_parse_token_num_t cmd_port_tm_mark_ip_dscp_red =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_ip_dscp_result,
-				red, RTE_UINT16);
+				red, UINT16);
 
 static void cmd_port_tm_mark_ip_dscp_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_port_tm_mark_ip_dscp_result *res = parsed_result;
 	struct rte_tm_error error;
@@ -2623,42 +2389,42 @@
 	uint16_t red;
 };
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_set =
+cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_set =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_vlan_dei_result,
 				 set, "set");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_port =
+cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_port =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_vlan_dei_result,
 				 port, "port");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_tm =
+cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_tm =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_vlan_dei_result, tm,
 				 "tm");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_mark =
+cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_mark =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_vlan_dei_result,
 				 mark, "mark");
 
-static cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_vlan_dei =
+cmdline_parse_token_string_t cmd_port_tm_mark_vlan_dei_vlan_dei =
 	TOKEN_STRING_INITIALIZER(struct cmd_port_tm_mark_vlan_dei_result,
 				 vlan_dei, "vlan_dei");
-static cmdline_parse_token_num_t cmd_port_tm_mark_vlan_dei_port_id =
+cmdline_parse_token_num_t cmd_port_tm_mark_vlan_dei_port_id =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_vlan_dei_result,
-			      port_id, RTE_UINT16);
+			      port_id, UINT16);
 
-static cmdline_parse_token_num_t cmd_port_tm_mark_vlan_dei_green =
+cmdline_parse_token_num_t cmd_port_tm_mark_vlan_dei_green =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_vlan_dei_result,
-				green, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_port_tm_mark_vlan_dei_yellow =
+				green, UINT16);
+cmdline_parse_token_num_t cmd_port_tm_mark_vlan_dei_yellow =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_vlan_dei_result,
-				yellow, RTE_UINT16);
-static cmdline_parse_token_num_t cmd_port_tm_mark_vlan_dei_red =
+				yellow, UINT16);
+cmdline_parse_token_num_t cmd_port_tm_mark_vlan_dei_red =
 	TOKEN_NUM_INITIALIZER(struct cmd_port_tm_mark_vlan_dei_result,
-				red, RTE_UINT16);
+				red, UINT16);
 
 static void cmd_port_tm_mark_vlan_dei_parsed(void *parsed_result,
-	__rte_unused struct cmdline *cl,
-	__rte_unused void *data)
+	__attribute__((unused)) struct cmdline *cl,
+	__attribute__((unused)) void *data)
 {
 	struct cmd_port_tm_mark_vlan_dei_result *res = parsed_result;
 	struct rte_tm_error error;
diff -urN dpdk/app/test-pmd/cmdline_tm.h testpmd-as-load-balancer/v19.11/test-pmd/cmdline_tm.h
--- dpdk/app/test-pmd/cmdline_tm.h	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/cmdline_tm.h	2023-12-15 15:26:37.089199123 +0100
@@ -19,7 +19,6 @@
 extern cmdline_parse_inst_t cmd_del_port_tm_node_wred_profile;
 extern cmdline_parse_inst_t cmd_set_port_tm_node_shaper_profile;
 extern cmdline_parse_inst_t cmd_add_port_tm_nonleaf_node;
-extern cmdline_parse_inst_t cmd_add_port_tm_nonleaf_node_pmode;
 extern cmdline_parse_inst_t cmd_add_port_tm_leaf_node;
 extern cmdline_parse_inst_t cmd_del_port_tm_node;
 extern cmdline_parse_inst_t cmd_set_port_tm_node_parent;
diff -urN dpdk/app/test-pmd/config.c testpmd-as-load-balancer/v19.11/test-pmd/config.c
--- dpdk/app/test-pmd/config.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/config.c	2023-12-15 15:26:37.089199123 +0100
@@ -3,11 +3,9 @@
  * Copyright 2013-2014 6WIND S.A.
  */
 
-#include <ctype.h>
 #include <stdarg.h>
 #include <errno.h>
 #include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
 #include <inttypes.h>
@@ -26,47 +24,36 @@
 #include <rte_memcpy.h>
 #include <rte_memzone.h>
 #include <rte_launch.h>
-#include <rte_bus.h>
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_mempool.h>
 #include <rte_mbuf.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_string_fns.h>
 #include <rte_cycles.h>
 #include <rte_flow.h>
-#include <rte_mtr.h>
 #include <rte_errno.h>
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 #include <rte_pmd_ixgbe.h>
 #endif
-#ifdef RTE_NET_I40E
+#ifdef RTE_LIBRTE_I40E_PMD
 #include <rte_pmd_i40e.h>
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 #include <rte_pmd_bnxt.h>
 #endif
-#ifdef RTE_LIB_GRO
 #include <rte_gro.h>
-#endif
-#include <rte_hexdump.h>
+#include <rte_config.h>
 
 #include "testpmd.h"
-#include "cmdline_mtr.h"
-
-#define ETHDEV_FWVERS_LEN 32
-
-#ifdef CLOCK_MONOTONIC_RAW /* Defined in glibc bits/time.h */
-#define CLOCK_TYPE_ID CLOCK_MONOTONIC_RAW
-#else
-#define CLOCK_TYPE_ID CLOCK_MONOTONIC
-#endif
 
-#define NS_PER_SEC 1E9
+static char *flowtype_to_str(uint16_t flow_type);
 
 static const struct {
 	enum tx_pkt_split split;
@@ -87,118 +74,40 @@
 };
 
 const struct rss_type_info rss_type_table[] = {
-	/* Group types */
-	{ "all", RTE_ETH_RSS_ETH | RTE_ETH_RSS_VLAN | RTE_ETH_RSS_IP | RTE_ETH_RSS_TCP |
-		RTE_ETH_RSS_UDP | RTE_ETH_RSS_SCTP | RTE_ETH_RSS_L2_PAYLOAD |
-		RTE_ETH_RSS_L2TPV3 | RTE_ETH_RSS_ESP | RTE_ETH_RSS_AH | RTE_ETH_RSS_PFCP |
-		RTE_ETH_RSS_GTPU | RTE_ETH_RSS_ECPRI | RTE_ETH_RSS_MPLS | RTE_ETH_RSS_L2TPV2},
+	{ "all", ETH_RSS_IP | ETH_RSS_TCP |
+			ETH_RSS_UDP | ETH_RSS_SCTP |
+			ETH_RSS_L2_PAYLOAD },
 	{ "none", 0 },
-	{ "ip", RTE_ETH_RSS_IP },
-	{ "udp", RTE_ETH_RSS_UDP },
-	{ "tcp", RTE_ETH_RSS_TCP },
-	{ "sctp", RTE_ETH_RSS_SCTP },
-	{ "tunnel", RTE_ETH_RSS_TUNNEL },
-	{ "vlan", RTE_ETH_RSS_VLAN },
-
-	/* Individual type */
-	{ "ipv4", RTE_ETH_RSS_IPV4 },
-	{ "ipv4-frag", RTE_ETH_RSS_FRAG_IPV4 },
-	{ "ipv4-tcp", RTE_ETH_RSS_NONFRAG_IPV4_TCP },
-	{ "ipv4-udp", RTE_ETH_RSS_NONFRAG_IPV4_UDP },
-	{ "ipv4-sctp", RTE_ETH_RSS_NONFRAG_IPV4_SCTP },
-	{ "ipv4-other", RTE_ETH_RSS_NONFRAG_IPV4_OTHER },
-	{ "ipv6", RTE_ETH_RSS_IPV6 },
-	{ "ipv6-frag", RTE_ETH_RSS_FRAG_IPV6 },
-	{ "ipv6-tcp", RTE_ETH_RSS_NONFRAG_IPV6_TCP },
-	{ "ipv6-udp", RTE_ETH_RSS_NONFRAG_IPV6_UDP },
-	{ "ipv6-sctp", RTE_ETH_RSS_NONFRAG_IPV6_SCTP },
-	{ "ipv6-other", RTE_ETH_RSS_NONFRAG_IPV6_OTHER },
-	{ "l2-payload", RTE_ETH_RSS_L2_PAYLOAD },
-	{ "ipv6-ex", RTE_ETH_RSS_IPV6_EX },
-	{ "ipv6-tcp-ex", RTE_ETH_RSS_IPV6_TCP_EX },
-	{ "ipv6-udp-ex", RTE_ETH_RSS_IPV6_UDP_EX },
-	{ "port", RTE_ETH_RSS_PORT },
-	{ "vxlan", RTE_ETH_RSS_VXLAN },
-	{ "geneve", RTE_ETH_RSS_GENEVE },
-	{ "nvgre", RTE_ETH_RSS_NVGRE },
-	{ "gtpu", RTE_ETH_RSS_GTPU },
-	{ "eth", RTE_ETH_RSS_ETH },
-	{ "s-vlan", RTE_ETH_RSS_S_VLAN },
-	{ "c-vlan", RTE_ETH_RSS_C_VLAN },
-	{ "esp", RTE_ETH_RSS_ESP },
-	{ "ah", RTE_ETH_RSS_AH },
-	{ "l2tpv3", RTE_ETH_RSS_L2TPV3 },
-	{ "pfcp", RTE_ETH_RSS_PFCP },
-	{ "pppoe", RTE_ETH_RSS_PPPOE },
-	{ "ecpri", RTE_ETH_RSS_ECPRI },
-	{ "mpls", RTE_ETH_RSS_MPLS },
-	{ "ipv4-chksum", RTE_ETH_RSS_IPV4_CHKSUM },
-	{ "l4-chksum", RTE_ETH_RSS_L4_CHKSUM },
-	{ "l2tpv2", RTE_ETH_RSS_L2TPV2 },
-	{ "l3-pre96", RTE_ETH_RSS_L3_PRE96 },
-	{ "l3-pre64", RTE_ETH_RSS_L3_PRE64 },
-	{ "l3-pre56", RTE_ETH_RSS_L3_PRE56 },
-	{ "l3-pre48", RTE_ETH_RSS_L3_PRE48 },
-	{ "l3-pre40", RTE_ETH_RSS_L3_PRE40 },
-	{ "l3-pre32", RTE_ETH_RSS_L3_PRE32 },
-	{ "l2-dst-only", RTE_ETH_RSS_L2_DST_ONLY },
-	{ "l2-src-only", RTE_ETH_RSS_L2_SRC_ONLY },
-	{ "l4-dst-only", RTE_ETH_RSS_L4_DST_ONLY },
-	{ "l4-src-only", RTE_ETH_RSS_L4_SRC_ONLY },
-	{ "l3-dst-only", RTE_ETH_RSS_L3_DST_ONLY },
-	{ "l3-src-only", RTE_ETH_RSS_L3_SRC_ONLY },
-	{ NULL, 0},
-};
-
-static const struct {
-	enum rte_eth_fec_mode mode;
-	const char *name;
-} fec_mode_name[] = {
-	{
-		.mode = RTE_ETH_FEC_NOFEC,
-		.name = "off",
-	},
-	{
-		.mode = RTE_ETH_FEC_AUTO,
-		.name = "auto",
-	},
-	{
-		.mode = RTE_ETH_FEC_BASER,
-		.name = "baser",
-	},
-	{
-		.mode = RTE_ETH_FEC_RS,
-		.name = "rs",
-	},
-};
-
-static const struct {
-	char str[32];
-	uint16_t ftype;
-} flowtype_str_table[] = {
-	{"raw", RTE_ETH_FLOW_RAW},
-	{"ipv4", RTE_ETH_FLOW_IPV4},
-	{"ipv4-frag", RTE_ETH_FLOW_FRAG_IPV4},
-	{"ipv4-tcp", RTE_ETH_FLOW_NONFRAG_IPV4_TCP},
-	{"ipv4-udp", RTE_ETH_FLOW_NONFRAG_IPV4_UDP},
-	{"ipv4-sctp", RTE_ETH_FLOW_NONFRAG_IPV4_SCTP},
-	{"ipv4-other", RTE_ETH_FLOW_NONFRAG_IPV4_OTHER},
-	{"ipv6", RTE_ETH_FLOW_IPV6},
-	{"ipv6-frag", RTE_ETH_FLOW_FRAG_IPV6},
-	{"ipv6-tcp", RTE_ETH_FLOW_NONFRAG_IPV6_TCP},
-	{"ipv6-udp", RTE_ETH_FLOW_NONFRAG_IPV6_UDP},
-	{"ipv6-sctp", RTE_ETH_FLOW_NONFRAG_IPV6_SCTP},
-	{"ipv6-other", RTE_ETH_FLOW_NONFRAG_IPV6_OTHER},
-	{"l2_payload", RTE_ETH_FLOW_L2_PAYLOAD},
-	{"ipv6-ex", RTE_ETH_FLOW_IPV6_EX},
-	{"ipv6-tcp-ex", RTE_ETH_FLOW_IPV6_TCP_EX},
-	{"ipv6-udp-ex", RTE_ETH_FLOW_IPV6_UDP_EX},
-	{"port", RTE_ETH_FLOW_PORT},
-	{"vxlan", RTE_ETH_FLOW_VXLAN},
-	{"geneve", RTE_ETH_FLOW_GENEVE},
-	{"nvgre", RTE_ETH_FLOW_NVGRE},
-	{"vxlan-gpe", RTE_ETH_FLOW_VXLAN_GPE},
-	{"gtpu", RTE_ETH_FLOW_GTPU},
+	{ "ipv4", ETH_RSS_IPV4 },
+	{ "ipv4-frag", ETH_RSS_FRAG_IPV4 },
+	{ "ipv4-tcp", ETH_RSS_NONFRAG_IPV4_TCP },
+	{ "ipv4-udp", ETH_RSS_NONFRAG_IPV4_UDP },
+	{ "ipv4-sctp", ETH_RSS_NONFRAG_IPV4_SCTP },
+	{ "ipv4-other", ETH_RSS_NONFRAG_IPV4_OTHER },
+	{ "ipv6", ETH_RSS_IPV6 },
+	{ "ipv6-frag", ETH_RSS_FRAG_IPV6 },
+	{ "ipv6-tcp", ETH_RSS_NONFRAG_IPV6_TCP },
+	{ "ipv6-udp", ETH_RSS_NONFRAG_IPV6_UDP },
+	{ "ipv6-sctp", ETH_RSS_NONFRAG_IPV6_SCTP },
+	{ "ipv6-other", ETH_RSS_NONFRAG_IPV6_OTHER },
+	{ "l2-payload", ETH_RSS_L2_PAYLOAD },
+	{ "ipv6-ex", ETH_RSS_IPV6_EX },
+	{ "ipv6-tcp-ex", ETH_RSS_IPV6_TCP_EX },
+	{ "ipv6-udp-ex", ETH_RSS_IPV6_UDP_EX },
+	{ "port", ETH_RSS_PORT },
+	{ "vxlan", ETH_RSS_VXLAN },
+	{ "geneve", ETH_RSS_GENEVE },
+	{ "nvgre", ETH_RSS_NVGRE },
+	{ "ip", ETH_RSS_IP },
+	{ "udp", ETH_RSS_UDP },
+	{ "tcp", ETH_RSS_TCP },
+	{ "sctp", ETH_RSS_SCTP },
+	{ "tunnel", ETH_RSS_TUNNEL },
+	{ "l3-src-only", ETH_RSS_L3_SRC_ONLY },
+	{ "l3-dst-only", ETH_RSS_L3_DST_ONLY },
+	{ "l4-src-only", ETH_RSS_L4_SRC_ONLY },
+	{ "l4-dst-only", ETH_RSS_L4_DST_ONLY },
+	{ NULL, 0 },
 };
 
 static void
@@ -209,65 +118,6 @@
 	printf("%s%s", name, buf);
 }
 
-static void
-nic_xstats_display_periodic(portid_t port_id)
-{
-	struct xstat_display_info *xstats_info;
-	uint64_t *prev_values, *curr_values;
-	uint64_t diff_value, value_rate;
-	struct timespec cur_time;
-	uint64_t *ids_supp;
-	size_t ids_supp_sz;
-	uint64_t diff_ns;
-	unsigned int i;
-	int rc;
-
-	xstats_info = &ports[port_id].xstats_info;
-
-	ids_supp_sz = xstats_info->ids_supp_sz;
-	if (ids_supp_sz == 0)
-		return;
-
-	printf("\n");
-
-	ids_supp = xstats_info->ids_supp;
-	prev_values = xstats_info->prev_values;
-	curr_values = xstats_info->curr_values;
-
-	rc = rte_eth_xstats_get_by_id(port_id, ids_supp, curr_values,
-				      ids_supp_sz);
-	if (rc != (int)ids_supp_sz) {
-		fprintf(stderr,
-			"Failed to get values of %zu xstats for port %u - return code %d\n",
-			ids_supp_sz, port_id, rc);
-		return;
-	}
-
-	diff_ns = 0;
-	if (clock_gettime(CLOCK_TYPE_ID, &cur_time) == 0) {
-		uint64_t ns;
-
-		ns = cur_time.tv_sec * NS_PER_SEC;
-		ns += cur_time.tv_nsec;
-
-		if (xstats_info->prev_ns != 0)
-			diff_ns = ns - xstats_info->prev_ns;
-		xstats_info->prev_ns = ns;
-	}
-
-	printf("%-31s%-17s%s\n", " ", "Value", "Rate (since last show)");
-	for (i = 0; i < ids_supp_sz; i++) {
-		diff_value = (curr_values[i] > prev_values[i]) ?
-			     (curr_values[i] - prev_values[i]) : 0;
-		prev_values[i] = curr_values[i];
-		value_rate = diff_ns > 0 ?
-				(double)diff_value / diff_ns * NS_PER_SEC : 0;
-
-		printf("  %-25s%12"PRIu64" %15"PRIu64"\n",
-		       xstats_display[i].name, curr_values[i], value_rate);
-	}
-}
-
 void
 nic_stats_display(portid_t port_id)
 {
@@ -275,58 +125,80 @@
 	static uint64_t prev_pkts_tx[RTE_MAX_ETHPORTS];
 	static uint64_t prev_bytes_rx[RTE_MAX_ETHPORTS];
 	static uint64_t prev_bytes_tx[RTE_MAX_ETHPORTS];
-	static uint64_t prev_ns[RTE_MAX_ETHPORTS];
-	struct timespec cur_time;
+	static uint64_t prev_cycles[RTE_MAX_ETHPORTS];
 	uint64_t diff_pkts_rx, diff_pkts_tx, diff_bytes_rx, diff_bytes_tx,
-								diff_ns;
+								diff_cycles;
 	uint64_t mpps_rx, mpps_tx, mbps_rx, mbps_tx;
 	struct rte_eth_stats stats;
+	struct rte_port *port = &ports[port_id];
+	uint8_t i;
+
 	static const char *nic_stats_border = "########################";
-	int ret;
 
 	if (port_id_is_invalid(port_id, ENABLED_WARN)) {
 		print_valid_ports();
 		return;
 	}
-	ret = rte_eth_stats_get(port_id, &stats);
-	if (ret != 0) {
-		fprintf(stderr,
-			"%s: Error: failed to get stats (port %u): %d",
-			__func__, port_id, ret);
-		return;
-	}
+	rte_eth_stats_get(port_id, &stats);
 	printf("\n  %s NIC statistics for port %-2d %s\n",
 	       nic_stats_border, port_id, nic_stats_border);
 
-	printf("  RX-packets: %-10"PRIu64" RX-missed: %-10"PRIu64" RX-bytes:  "
-	       "%-"PRIu64"\n", stats.ipackets, stats.imissed, stats.ibytes);
-	printf("  RX-errors: %-"PRIu64"\n", stats.ierrors);
-	printf("  RX-nombuf:  %-10"PRIu64"\n", stats.rx_nombuf);
-	printf("  TX-packets: %-10"PRIu64" TX-errors: %-10"PRIu64" TX-bytes:  "
-	       "%-"PRIu64"\n", stats.opackets, stats.oerrors, stats.obytes);
-
-	diff_ns = 0;
-	if (clock_gettime(CLOCK_TYPE_ID, &cur_time) == 0) {
-		uint64_t ns;
-
-		ns = cur_time.tv_sec * NS_PER_SEC;
-		ns += cur_time.tv_nsec;
-
-		if (prev_ns[port_id] != 0)
-			diff_ns = ns - prev_ns[port_id];
-		prev_ns[port_id] = ns;
+	if ((!port->rx_queue_stats_mapping_enabled) && (!port->tx_queue_stats_mapping_enabled)) {
+		printf("  RX-packets: %-10"PRIu64" RX-missed: %-10"PRIu64" RX-bytes:  "
+		       "%-"PRIu64"\n",
+		       stats.ipackets, stats.imissed, stats.ibytes);
+		printf("  RX-errors: %-"PRIu64"\n", stats.ierrors);
+		printf("  RX-nombuf:  %-10"PRIu64"\n",
+		       stats.rx_nombuf);
+		printf("  TX-packets: %-10"PRIu64" TX-errors: %-10"PRIu64" TX-bytes:  "
+		       "%-"PRIu64"\n",
+		       stats.opackets, stats.oerrors, stats.obytes);
+	}
+	else {
+		printf("  RX-packets:              %10"PRIu64"    RX-errors: %10"PRIu64
+		       "    RX-bytes: %10"PRIu64"\n",
+		       stats.ipackets, stats.ierrors, stats.ibytes);
+		printf("  RX-errors:  %10"PRIu64"\n", stats.ierrors);
+		printf("  RX-nombuf:               %10"PRIu64"\n",
+		       stats.rx_nombuf);
+		printf("  TX-packets:              %10"PRIu64"    TX-errors: %10"PRIu64
+		       "    TX-bytes: %10"PRIu64"\n",
+		       stats.opackets, stats.oerrors, stats.obytes);
+	}
+
+	if (port->rx_queue_stats_mapping_enabled) {
+		printf("\n");
+		for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+			printf("  Stats reg %2d RX-packets: %10"PRIu64
+			       "    RX-errors: %10"PRIu64
+			       "    RX-bytes: %10"PRIu64"\n",
+			       i, stats.q_ipackets[i], stats.q_errors[i], stats.q_ibytes[i]);
+		}
+	}
+	if (port->tx_queue_stats_mapping_enabled) {
+		printf("\n");
+		for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS; i++) {
+			printf("  Stats reg %2d TX-packets: %10"PRIu64
+			       "                             TX-bytes: %10"PRIu64"\n",
+			       i, stats.q_opackets[i], stats.q_obytes[i]);
+		}
 	}
 
+	diff_cycles = prev_cycles[port_id];
+	prev_cycles[port_id] = rte_rdtsc();
+	if (diff_cycles > 0)
+		diff_cycles = prev_cycles[port_id] - diff_cycles;
+
 	diff_pkts_rx = (stats.ipackets > prev_pkts_rx[port_id]) ?
 		(stats.ipackets - prev_pkts_rx[port_id]) : 0;
 	diff_pkts_tx = (stats.opackets > prev_pkts_tx[port_id]) ?
 		(stats.opackets - prev_pkts_tx[port_id]) : 0;
 	prev_pkts_rx[port_id] = stats.ipackets;
 	prev_pkts_tx[port_id] = stats.opackets;
-	mpps_rx = diff_ns > 0 ?
-		(double)diff_pkts_rx / diff_ns * NS_PER_SEC : 0;
-	mpps_tx = diff_ns > 0 ?
-		(double)diff_pkts_tx / diff_ns * NS_PER_SEC : 0;
+	mpps_rx = diff_cycles > 0 ?
+		diff_pkts_rx * rte_get_tsc_hz() / diff_cycles : 0;
+	mpps_tx = diff_cycles > 0 ?
+		diff_pkts_tx * rte_get_tsc_hz() / diff_cycles : 0;
 
 	diff_bytes_rx = (stats.ibytes > prev_bytes_rx[port_id]) ?
 		(stats.ibytes - prev_bytes_rx[port_id]) : 0;
@@ -334,19 +206,16 @@
 		(stats.obytes - prev_bytes_tx[port_id]) : 0;
 	prev_bytes_rx[port_id] = stats.ibytes;
 	prev_bytes_tx[port_id] = stats.obytes;
-	mbps_rx = diff_ns > 0 ?
-		(double)diff_bytes_rx / diff_ns * NS_PER_SEC : 0;
-	mbps_tx = diff_ns > 0 ?
-		(double)diff_bytes_tx / diff_ns * NS_PER_SEC : 0;
+	mbps_rx = diff_cycles > 0 ?
+		diff_bytes_rx * rte_get_tsc_hz() / diff_cycles : 0;
+	mbps_tx = diff_cycles > 0 ?
+		diff_bytes_tx * rte_get_tsc_hz() / diff_cycles : 0;
 
 	printf("\n  Throughput (since last show)\n");
 	printf("  Rx-pps: %12"PRIu64"          Rx-bps: %12"PRIu64"\n  Tx-pps: %12"
 	       PRIu64"          Tx-bps: %12"PRIu64"\n", mpps_rx, mbps_rx * 8,
 	       mpps_tx, mbps_tx * 8);
 
-	if (xstats_display_num > 0)
-		nic_xstats_display_periodic(port_id);
-
 	printf("  %s############################%s\n",
 	       nic_stats_border, nic_stats_border);
 }
@@ -354,30 +223,11 @@
 void
 nic_stats_clear(portid_t port_id)
 {
-	int ret;
-
 	if (port_id_is_invalid(port_id, ENABLED_WARN)) {
 		print_valid_ports();
 		return;
 	}
-
-	ret = rte_eth_stats_reset(port_id);
-	if (ret != 0) {
-		fprintf(stderr,
-			"%s: Error: failed to reset stats (port %u): %s",
-			__func__, port_id, strerror(-ret));
-		return;
-	}
-
-	ret = rte_eth_stats_get(port_id, &ports[port_id].stats);
-	if (ret != 0) {
-		if (ret < 0)
-			ret = -ret;
-		fprintf(stderr,
-			"%s: Error: failed to get stats (port %u): %s",
-			__func__, port_id, strerror(ret));
-		return;
-	}
+	rte_eth_stats_reset(port_id);
 	printf("\n  NIC statistics for port %d cleared\n", port_id);
 }
 
@@ -394,26 +244,26 @@
 	}
 	printf("###### NIC extended statistics for port %-2d\n", port_id);
 	if (!rte_eth_dev_is_valid_port(port_id)) {
-		fprintf(stderr, "Error: Invalid port number %i\n", port_id);
+		printf("Error: Invalid port number %i\n", port_id);
 		return;
 	}
 
 	/* Get count */
 	cnt_xstats = rte_eth_xstats_get_names(port_id, NULL, 0);
 	if (cnt_xstats  < 0) {
-		fprintf(stderr, "Error: Cannot get count of xstats\n");
+		printf("Error: Cannot get count of xstats\n");
 		return;
 	}
 
 	/* Get id-name lookup table */
 	xstats_names = malloc(sizeof(struct rte_eth_xstat_name) * cnt_xstats);
 	if (xstats_names == NULL) {
-		fprintf(stderr, "Cannot allocate memory for xstats lookup\n");
+		printf("Cannot allocate memory for xstats lookup\n");
 		return;
 	}
 	if (cnt_xstats != rte_eth_xstats_get_names(
 			port_id, xstats_names, cnt_xstats)) {
-		fprintf(stderr, "Error: Cannot get xstats lookup\n");
+		printf("Error: Cannot get xstats lookup\n");
 		free(xstats_names);
 		return;
 	}
@@ -421,12 +271,12 @@
 	/* Get stats themselves */
 	xstats = malloc(sizeof(struct rte_eth_xstat) * cnt_xstats);
 	if (xstats == NULL) {
-		fprintf(stderr, "Cannot allocate memory for xstats\n");
+		printf("Cannot allocate memory for xstats\n");
 		free(xstats_names);
 		return;
 	}
 	if (cnt_xstats != rte_eth_xstats_get(port_id, xstats, cnt_xstats)) {
-		fprintf(stderr, "Error: Unable to get xstats\n");
+		printf("Error: Unable to get xstats\n");
 		free(xstats_names);
 		free(xstats);
 		return;
@@ -453,36 +303,59 @@
 		print_valid_ports();
 		return;
 	}
-
 	ret = rte_eth_xstats_reset(port_id);
 	if (ret != 0) {
-		fprintf(stderr,
-			"%s: Error: failed to reset xstats (port %u): %s\n",
-			__func__, port_id, strerror(-ret));
+		printf("%s: Error: failed to reset xstats (port %u): %s",
+		       __func__, port_id, strerror(ret));
+	}
+}
+
+void
+nic_stats_mapping_display(portid_t port_id)
+{
+	struct rte_port *port = &ports[port_id];
+	uint16_t i;
+
+	static const char *nic_stats_mapping_border = "########################";
+
+	if (port_id_is_invalid(port_id, ENABLED_WARN)) {
+		print_valid_ports();
 		return;
 	}
 
-	ret = rte_eth_stats_get(port_id, &ports[port_id].stats);
-	if (ret != 0) {
-		if (ret < 0)
-			ret = -ret;
-		fprintf(stderr, "%s: Error: failed to get stats (port %u): %s",
-			__func__, port_id, strerror(ret));
+	if ((!port->rx_queue_stats_mapping_enabled) && (!port->tx_queue_stats_mapping_enabled)) {
+		printf("Port id %d - either does not support queue statistic mapping or"
+		       " no queue statistic mapping set\n", port_id);
 		return;
 	}
-}
 
-static const char *
-get_queue_state_name(uint8_t queue_state)
-{
-	if (queue_state == RTE_ETH_QUEUE_STATE_STOPPED)
-		return "stopped";
-	else if (queue_state == RTE_ETH_QUEUE_STATE_STARTED)
-		return "started";
-	else if (queue_state == RTE_ETH_QUEUE_STATE_HAIRPIN)
-		return "hairpin";
-	else
-		return "unknown";
+	printf("\n  %s NIC statistics mapping for port %-2d %s\n",
+	       nic_stats_mapping_border, port_id, nic_stats_mapping_border);
+
+	if (port->rx_queue_stats_mapping_enabled) {
+		for (i = 0; i < nb_rx_queue_stats_mappings; i++) {
+			if (rx_queue_stats_mappings[i].port_id == port_id) {
+				printf("  RX-queue %2d mapped to Stats Reg %2d\n",
+				       rx_queue_stats_mappings[i].queue_id,
+				       rx_queue_stats_mappings[i].stats_counter_id);
+			}
+		}
+		printf("\n");
+	}
+
+
+	if (port->tx_queue_stats_mapping_enabled) {
+		for (i = 0; i < nb_tx_queue_stats_mappings; i++) {
+			if (tx_queue_stats_mappings[i].port_id == port_id) {
+				printf("  TX-queue %2d mapped to Stats Reg %2d\n",
+				       tx_queue_stats_mappings[i].queue_id,
+				       tx_queue_stats_mappings[i].stats_counter_id);
+			}
+		}
+	}
+
+	printf("  %s####################################%s\n",
+	       nic_stats_mapping_border, nic_stats_mapping_border);
 }
 
 void
@@ -495,8 +368,8 @@
 
 	rc = rte_eth_rx_queue_info_get(port_id, queue_id, &qinfo);
 	if (rc != 0) {
-		fprintf(stderr,
-			"Failed to retrieve information for port: %u, RX queue: %hu\nerror desc: %s(%d)\n",
+		printf("Failed to retrieve information for port: %u, "
+			"RX queue: %hu\nerror desc: %s(%d)\n",
 			port_id, queue_id, strerror(-rc), rc);
 		return;
 	}
@@ -515,9 +388,6 @@
 		(qinfo.conf.rx_deferred_start != 0) ? "on" : "off");
 	printf("\nRX scattered packets: %s",
 		(qinfo.scattered_rx != 0) ? "on" : "off");
-	printf("\nRx queue state: %s", get_queue_state_name(qinfo.queue_state));
-	if (qinfo.rx_buf_size != 0)
-		printf("\nRX buffer size: %hu", qinfo.rx_buf_size);
 	printf("\nNumber of RXDs: %hu", qinfo.nb_desc);
 
 	if (rte_eth_rx_burst_mode_get(port_id, queue_id, &mode) == 0)
@@ -539,8 +409,8 @@
 
 	rc = rte_eth_tx_queue_info_get(port_id, queue_id, &qinfo);
 	if (rc != 0) {
-		fprintf(stderr,
-			"Failed to retrieve information for port: %u, TX queue: %hu\nerror desc: %s(%d)\n",
+		printf("Failed to retrieve information for port: %u, "
+			"TX queue: %hu\nerror desc: %s(%d)\n",
 			port_id, queue_id, strerror(-rc), rc);
 		return;
 	}
@@ -556,7 +426,6 @@
 	printf("\nTX deferred start: %s",
 		(qinfo.conf.tx_deferred_start != 0) ? "on" : "off");
 	printf("\nNumber of TXDs: %hu", qinfo.nb_desc);
-	printf("\nTx queue state: %s", get_queue_state_name(qinfo.queue_state));
 
 	if (rte_eth_tx_burst_mode_get(port_id, queue_id, &mode) == 0)
 		printf("\nBurst mode: %s%s",
@@ -574,46 +443,6 @@
 	return 0;
 }
 
-static void
-device_infos_display_speeds(uint32_t speed_capa)
-{
-	printf("\n\tDevice speed capability:");
-	if (speed_capa == RTE_ETH_LINK_SPEED_AUTONEG)
-		printf(" Autonegotiate (all speeds)");
-	if (speed_capa & RTE_ETH_LINK_SPEED_FIXED)
-		printf(" Disable autonegotiate (fixed speed)  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_10M_HD)
-		printf(" 10 Mbps half-duplex  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_10M)
-		printf(" 10 Mbps full-duplex  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_100M_HD)
-		printf(" 100 Mbps half-duplex  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_100M)
-		printf(" 100 Mbps full-duplex  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_1G)
-		printf(" 1 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_2_5G)
-		printf(" 2.5 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_5G)
-		printf(" 5 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_10G)
-		printf(" 10 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_20G)
-		printf(" 20 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_25G)
-		printf(" 25 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_40G)
-		printf(" 40 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_50G)
-		printf(" 50 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_56G)
-		printf(" 56 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_100G)
-		printf(" 100 Gbps  ");
-	if (speed_capa & RTE_ETH_LINK_SPEED_200G)
-		printf(" 200 Gbps  ");
-}
-
 void
 device_infos_display(const char *identifier)
 {
@@ -625,7 +454,6 @@
 	struct rte_device *dev;
 	struct rte_devargs da;
 	portid_t port_id;
-	struct rte_eth_dev_info dev_info;
 	char devstr[128];
 
 	memset(&da, 0, sizeof(da));
@@ -633,7 +461,9 @@
 		goto skip_parse;
 
 	if (rte_devargs_parsef(&da, "%s", identifier)) {
-		fprintf(stderr, "cannot parse identifier\n");
+		printf("cannot parse identifier\n");
+		if (da.args)
+			free(da.args);
 		return;
 	}
 
@@ -644,24 +474,26 @@
 		if (identifier && da.bus != next)
 			continue;
 
-		snprintf(devstr, sizeof(devstr), "bus=%s", rte_bus_name(next));
+		/* Skip buses that don't have iterate method */
+		if (!next->dev_iterate)
+			continue;
+
+		snprintf(devstr, sizeof(devstr), "bus=%s", next->name);
 		RTE_DEV_FOREACH(dev, devstr, &dev_iter) {
 
-			if (rte_dev_driver(dev) == NULL)
+			if (!dev->driver)
 				continue;
 			/* Check for matching device if identifier is present */
 			if (identifier &&
-			    strncmp(da.name, rte_dev_name(dev), strlen(rte_dev_name(dev))))
+			    strncmp(da.name, dev->name, strlen(dev->name)))
 				continue;
 			printf("\n%s Infos for device %s %s\n",
-			       info_border, rte_dev_name(dev), info_border);
-			printf("Bus name: %s", rte_bus_name(rte_dev_bus(dev)));
-			printf("\nBus information: %s",
-				rte_dev_bus_info(dev) ? rte_dev_bus_info(dev) : "");
-			printf("\nDriver name: %s", rte_driver_name(rte_dev_driver(dev)));
+			       info_border, dev->name, info_border);
+			printf("Bus name: %s", dev->bus->name);
+			printf("\nDriver name: %s", dev->driver->name);
 			printf("\nDevargs: %s",
-			       rte_dev_devargs(dev) ? rte_dev_devargs(dev)->args : "");
-			printf("\nConnect to socket: %d", rte_dev_numa_node(dev));
+			       dev->devargs ? dev->devargs->args : "");
+			printf("\nConnect to socket: %d", dev->numa_node);
 			printf("\n");
 
 			/* List ports with matching device name */
@@ -673,95 +505,10 @@
 						      &mac_addr);
 				rte_eth_dev_get_name_by_port(port_id, name);
 				printf("\n\tDevice name: %s", name);
-				if (rte_eth_dev_info_get(port_id, &dev_info) == 0)
-					device_infos_display_speeds(dev_info.speed_capa);
 				printf("\n");
 			}
 		}
 	};
-	rte_devargs_reset(&da);
-}
-
-static void
-print_dev_capabilities(uint64_t capabilities)
-{
-	uint64_t single_capa;
-	int begin;
-	int end;
-	int bit;
-
-	if (capabilities == 0)
-		return;
-
-	begin = __builtin_ctzll(capabilities);
-	end = sizeof(capabilities) * CHAR_BIT - __builtin_clzll(capabilities);
-
-	single_capa = 1ULL << begin;
-	for (bit = begin; bit < end; bit++) {
-		if (capabilities & single_capa)
-			printf(" %s",
-			       rte_eth_dev_capability_name(single_capa));
-		single_capa <<= 1;
-	}
-}
-
-uint64_t
-str_to_rsstypes(const char *str)
-{
-	uint16_t i;
-
-	for (i = 0; rss_type_table[i].str != NULL; i++) {
-		if (strcmp(rss_type_table[i].str, str) == 0)
-			return rss_type_table[i].rss_type;
-	}
-
-	return 0;
-}
-
-const char *
-rsstypes_to_str(uint64_t rss_type)
-{
-	uint16_t i;
-
-	for (i = 0; rss_type_table[i].str != NULL; i++) {
-		if (rss_type_table[i].rss_type == rss_type)
-			return rss_type_table[i].str;
-	}
-
-	return NULL;
-}
-
-static void
-rss_offload_types_display(uint64_t offload_types, uint16_t char_num_per_line)
-{
-	uint16_t user_defined_str_len;
-	uint16_t total_len = 0;
-	uint16_t str_len = 0;
-	uint64_t rss_offload;
-	uint16_t i;
-
-	for (i = 0; i < sizeof(offload_types) * CHAR_BIT; i++) {
-		rss_offload = RTE_BIT64(i);
-		if ((offload_types & rss_offload) != 0) {
-			const char *p = rsstypes_to_str(rss_offload);
-
-			user_defined_str_len =
-				strlen("user-defined-") + (i / 10 + 1);
-			str_len = p ? strlen(p) : user_defined_str_len;
-			str_len += 2; /* add two spaces */
-			if (total_len + str_len >= char_num_per_line) {
-				total_len = 0;
-				printf("\n");
-			}
-
-			if (p)
-				printf("  %s", p);
-			else
-				printf("  user-defined-%u", i);
-			total_len += str_len;
-		}
-	}
-	printf("\n");
 }
 
 void
@@ -777,7 +524,6 @@
 	uint16_t mtu;
 	char name[RTE_ETH_NAME_MAX_LEN];
 	int ret;
-	char fw_version[ETHDEV_FWVERS_LEN];
 
 	if (port_id_is_invalid(port_id, ENABLED_WARN)) {
 		print_valid_ports();
@@ -799,19 +545,12 @@
 	rte_eth_dev_get_name_by_port(port_id, name);
 	printf("\nDevice name: %s", name);
 	printf("\nDriver name: %s", dev_info.driver_name);
-
-	if (rte_eth_dev_fw_version_get(port_id, fw_version,
-						ETHDEV_FWVERS_LEN) == 0)
-		printf("\nFirmware-version: %s", fw_version);
-	else
-		printf("\nFirmware-version: %s", "not available");
-
-	if (rte_dev_devargs(dev_info.device) && rte_dev_devargs(dev_info.device)->args)
-		printf("\nDevargs: %s", rte_dev_devargs(dev_info.device)->args);
+	if (dev_info.device->devargs && dev_info.device->devargs->args)
+		printf("\nDevargs: %s", dev_info.device->devargs->args);
 	printf("\nConnect to socket: %u", port->socket_id);
 
 	if (port_numa[port_id] != NUMA_NO_CONFIG) {
-		mp = mbuf_pool_find(port_numa[port_id], 0);
+		mp = mbuf_pool_find(port_numa[port_id]);
 		if (mp)
 			printf("\nmemory allocation on the socket: %d",
 							port_numa[port_id]);
@@ -819,11 +558,9 @@
 		printf("\nmemory allocation on the socket: %u",port->socket_id);
 
 	printf("\nLink status: %s\n", (link.link_status) ? ("up") : ("down"));
-	printf("Link speed: %s\n", rte_eth_link_speed_to_str(link.link_speed));
-	printf("Link duplex: %s\n", (link.link_duplex == RTE_ETH_LINK_FULL_DUPLEX) ?
+	printf("Link speed: %u Mbps\n", (unsigned) link.link_speed);
+	printf("Link duplex: %s\n", (link.link_duplex == ETH_LINK_FULL_DUPLEX) ?
 	       ("full-duplex") : ("half-duplex"));
-	printf("Autoneg status: %s\n", (link.link_autoneg == RTE_ETH_LINK_AUTONEG) ?
-	       ("On") : ("Off"));
 
 	if (!rte_eth_dev_get_mtu(port_id, &mtu))
 		printf("MTU: %u\n", mtu);
@@ -840,22 +577,22 @@
 	vlan_offload = rte_eth_dev_get_vlan_offload(port_id);
 	if (vlan_offload >= 0){
 		printf("VLAN offload: \n");
-		if (vlan_offload & RTE_ETH_VLAN_STRIP_OFFLOAD)
+		if (vlan_offload & ETH_VLAN_STRIP_OFFLOAD)
 			printf("  strip on, ");
 		else
 			printf("  strip off, ");
 
-		if (vlan_offload & RTE_ETH_VLAN_FILTER_OFFLOAD)
+		if (vlan_offload & ETH_VLAN_FILTER_OFFLOAD)
 			printf("filter on, ");
 		else
 			printf("filter off, ");
 
-		if (vlan_offload & RTE_ETH_VLAN_EXTEND_OFFLOAD)
+		if (vlan_offload & ETH_VLAN_EXTEND_OFFLOAD)
 			printf("extend on, ");
 		else
 			printf("extend off, ");
 
-		if (vlan_offload & RTE_ETH_QINQ_STRIP_OFFLOAD)
+		if (vlan_offload & ETH_QINQ_STRIP_OFFLOAD)
 			printf("qinq strip on\n");
 		else
 			printf("qinq strip off\n");
@@ -868,9 +605,20 @@
 	if (!dev_info.flow_type_rss_offloads)
 		printf("No RSS offload flow type is supported.\n");
 	else {
+		uint16_t i;
+		char *p;
+
 		printf("Supported RSS offload flow types:\n");
-		rss_offload_types_display(dev_info.flow_type_rss_offloads,
-				TESTPMD_RSS_TYPES_CHAR_NUM_PER_LINE);
+		for (i = RTE_ETH_FLOW_UNKNOWN + 1;
+		     i < sizeof(dev_info.flow_type_rss_offloads) * CHAR_BIT; i++) {
+			if (!(dev_info.flow_type_rss_offloads & (1ULL << i)))
+				continue;
+			p = flowtype_to_str(i);
+			if (p)
+				printf("  %s\n", p);
+			else
+				printf("  user defined %d\n", i);
+		}
 	}
 
 	printf("Minimum size of RX buffer: %u\n", dev_info.min_rx_bufsize);
@@ -904,9 +652,6 @@
 	printf("Max segment number per MTU/TSO: %hu\n",
 		dev_info.tx_desc_lim.nb_mtu_seg_max);
 
-	printf("Device capabilities: 0x%"PRIx64"(", dev_info.dev_capa);
-	print_dev_capabilities(dev_info.dev_capa);
-	printf(" )\n");
 	/* Show switch info only if valid switch domain and port id is set */
 	if (dev_info.switch_info.domain_id !=
 		RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID) {
@@ -917,24 +662,6 @@
 			dev_info.switch_info.domain_id);
 		printf("Switch Port Id: %u\n",
 			dev_info.switch_info.port_id);
-		if ((dev_info.dev_capa & RTE_ETH_DEV_CAPA_RXQ_SHARE) != 0)
-			printf("Switch Rx domain: %u\n",
-			       dev_info.switch_info.rx_domain);
-	}
-	printf("Device error handling mode: ");
-	switch (dev_info.err_handle_mode) {
-	case RTE_ETH_ERROR_HANDLE_MODE_NONE:
-		printf("none\n");
-		break;
-	case RTE_ETH_ERROR_HANDLE_MODE_PASSIVE:
-		printf("passive\n");
-		break;
-	case RTE_ETH_ERROR_HANDLE_MODE_PROACTIVE:
-		printf("proactive\n");
-		break;
-	default:
-		printf("unknown\n");
-		break;
 	}
 }
 
@@ -976,143 +703,283 @@
 	if (ret != 0)
 		return;
 
-	printf("%-4d " RTE_ETHER_ADDR_PRT_FMT " %-12s %-14s %-8s %s\n",
-		port_id, RTE_ETHER_ADDR_BYTES(&mac_addr), name,
+	printf("%-4d %02X:%02X:%02X:%02X:%02X:%02X %-12s %-14s %-8s %uMbps\n",
+		port_id, mac_addr.addr_bytes[0], mac_addr.addr_bytes[1],
+		mac_addr.addr_bytes[2], mac_addr.addr_bytes[3],
+		mac_addr.addr_bytes[4], mac_addr.addr_bytes[5], name,
 		dev_info.driver_name, (link.link_status) ? ("up") : ("down"),
-		rte_eth_link_speed_to_str(link.link_speed));
+		(unsigned int) link.link_speed);
 }
 
 void
-port_eeprom_display(portid_t port_id)
+port_offload_cap_display(portid_t port_id)
 {
-	struct rte_dev_eeprom_info einfo;
+	struct rte_eth_dev_info dev_info;
+	static const char *info_border = "************";
 	int ret;
-	if (port_id_is_invalid(port_id, ENABLED_WARN)) {
-		print_valid_ports();
+
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
 		return;
-	}
 
-	int len_eeprom = rte_eth_dev_get_eeprom_length(port_id);
-	if (len_eeprom < 0) {
-		switch (len_eeprom) {
-		case -ENODEV:
-			fprintf(stderr, "port index %d invalid\n", port_id);
-			break;
-		case -ENOTSUP:
-			fprintf(stderr, "operation not supported by device\n");
-			break;
-		case -EIO:
-			fprintf(stderr, "device is removed\n");
-			break;
-		default:
-			fprintf(stderr, "Unable to get EEPROM: %d\n",
-				len_eeprom);
-			break;
-		}
+	ret = eth_dev_info_get_print_err(port_id, &dev_info);
+	if (ret != 0)
 		return;
+
+	printf("\n%s Port %d supported offload features: %s\n",
+		info_border, port_id, info_border);
+
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_VLAN_STRIP) {
+		printf("VLAN stripped:                 ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_VLAN_STRIP)
+			printf("on\n");
+		else
+			printf("off\n");
 	}
 
-	einfo.offset = 0;
-	einfo.length = len_eeprom;
-	einfo.data = calloc(1, len_eeprom);
-	if (!einfo.data) {
-		fprintf(stderr,
-			"Allocation of port %u eeprom data failed\n",
-			port_id);
-		return;
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_QINQ_STRIP) {
+		printf("Double VLANs stripped:         ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_QINQ_STRIP)
+			printf("on\n");
+		else
+			printf("off\n");
 	}
 
-	ret = rte_eth_dev_get_eeprom(port_id, &einfo);
-	if (ret != 0) {
-		switch (ret) {
-		case -ENODEV:
-			fprintf(stderr, "port index %d invalid\n", port_id);
-			break;
-		case -ENOTSUP:
-			fprintf(stderr, "operation not supported by device\n");
-			break;
-		case -EIO:
-			fprintf(stderr, "device is removed\n");
-			break;
-		default:
-			fprintf(stderr, "Unable to get EEPROM: %d\n", ret);
-			break;
-		}
-		free(einfo.data);
-		return;
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_IPV4_CKSUM) {
+		printf("RX IPv4 checksum:              ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_IPV4_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
 	}
-	rte_hexdump(stdout, "hexdump", einfo.data, einfo.length);
-	printf("Finish -- Port: %d EEPROM length: %d bytes\n", port_id, len_eeprom);
-	free(einfo.data);
-}
 
-void
-port_module_eeprom_display(portid_t port_id)
-{
-	struct rte_eth_dev_module_info minfo;
-	struct rte_dev_eeprom_info einfo;
-	int ret;
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_UDP_CKSUM) {
+		printf("RX UDP checksum:               ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_UDP_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
 
-	if (port_id_is_invalid(port_id, ENABLED_WARN)) {
-		print_valid_ports();
-		return;
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_TCP_CKSUM) {
+		printf("RX TCP checksum:               ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_TCP_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
 	}
 
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_SCTP_CKSUM) {
+		printf("RX SCTP checksum:              ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_SCTP_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
 
-	ret = rte_eth_dev_get_module_info(port_id, &minfo);
-	if (ret != 0) {
-		switch (ret) {
-		case -ENODEV:
-			fprintf(stderr, "port index %d invalid\n", port_id);
-			break;
-		case -ENOTSUP:
-			fprintf(stderr, "operation not supported by device\n");
-			break;
-		case -EIO:
-			fprintf(stderr, "device is removed\n");
-			break;
-		default:
-			fprintf(stderr, "Unable to get module EEPROM: %d\n",
-				ret);
-			break;
-		}
-		return;
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_OUTER_IPV4_CKSUM) {
+		printf("RX Outer IPv4 checksum:        ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_OUTER_IPV4_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
 	}
 
-	einfo.offset = 0;
-	einfo.length = minfo.eeprom_len;
-	einfo.data = calloc(1, minfo.eeprom_len);
-	if (!einfo.data) {
-		fprintf(stderr,
-			"Allocation of port %u eeprom data failed\n",
-			port_id);
-		return;
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_OUTER_UDP_CKSUM) {
+		printf("RX Outer UDP checksum:         ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_OUTER_UDP_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
 	}
 
-	ret = rte_eth_dev_get_module_eeprom(port_id, &einfo);
-	if (ret != 0) {
-		switch (ret) {
-		case -ENODEV:
-			fprintf(stderr, "port index %d invalid\n", port_id);
-			break;
-		case -ENOTSUP:
-			fprintf(stderr, "operation not supported by device\n");
-			break;
-		case -EIO:
-			fprintf(stderr, "device is removed\n");
-			break;
-		default:
-			fprintf(stderr, "Unable to get module EEPROM: %d\n",
-				ret);
-			break;
-		}
-		free(einfo.data);
-		return;
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_TCP_LRO) {
+		printf("Large receive offload:         ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_TCP_LRO)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_TIMESTAMP) {
+		printf("HW timestamp:                  ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_TIMESTAMP)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_KEEP_CRC) {
+		printf("Rx Keep CRC:                   ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_KEEP_CRC)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.rx_offload_capa & DEV_RX_OFFLOAD_SECURITY) {
+		printf("RX offload security:           ");
+		if (ports[port_id].dev_conf.rxmode.offloads &
+		    DEV_RX_OFFLOAD_SECURITY)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_VLAN_INSERT) {
+		printf("VLAN insert:                   ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_VLAN_INSERT)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_QINQ_INSERT) {
+		printf("Double VLANs insert:           ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_QINQ_INSERT)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_IPV4_CKSUM) {
+		printf("TX IPv4 checksum:              ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_IPV4_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_UDP_CKSUM) {
+		printf("TX UDP checksum:               ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_UDP_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_TCP_CKSUM) {
+		printf("TX TCP checksum:               ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_TCP_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_SCTP_CKSUM) {
+		printf("TX SCTP checksum:              ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_SCTP_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM) {
+		printf("TX Outer IPv4 checksum:        ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_TCP_TSO) {
+		printf("TX TCP segmentation:           ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_TCP_TSO)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_UDP_TSO) {
+		printf("TX UDP segmentation:           ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_UDP_TSO)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_VXLAN_TNL_TSO) {
+		printf("TSO for VXLAN tunnel packet:   ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_VXLAN_TNL_TSO)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_GRE_TNL_TSO) {
+		printf("TSO for GRE tunnel packet:     ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_GRE_TNL_TSO)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_IPIP_TNL_TSO) {
+		printf("TSO for IPIP tunnel packet:    ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_IPIP_TNL_TSO)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_GENEVE_TNL_TSO) {
+		printf("TSO for GENEVE tunnel packet:  ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_GENEVE_TNL_TSO)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_IP_TNL_TSO) {
+		printf("IP tunnel TSO:  ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_IP_TNL_TSO)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_UDP_TNL_TSO) {
+		printf("UDP tunnel TSO:  ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_UDP_TNL_TSO)
+			printf("on\n");
+		else
+			printf("off\n");
+	}
+
+	if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_OUTER_UDP_CKSUM) {
+		printf("TX Outer UDP checksum:         ");
+		if (ports[port_id].dev_conf.txmode.offloads &
+		    DEV_TX_OFFLOAD_OUTER_UDP_CKSUM)
+			printf("on\n");
+		else
+			printf("off\n");
 	}
 
-	rte_hexdump(stdout, "hexdump", einfo.data, einfo.length);
-	printf("Finish -- Port: %d MODULE EEPROM length: %d bytes\n", port_id, einfo.length);
-	free(einfo.data);
 }
 
 int
@@ -1128,7 +995,7 @@
 			return 0;
 
 	if (warning == ENABLED_WARN)
-		fprintf(stderr, "Invalid port %d\n", port_id);
+		printf("Invalid port %d\n", port_id);
 
 	return 1;
 }
@@ -1149,212 +1016,229 @@
 {
 	if (vlan_id < 4096)
 		return 0;
-	fprintf(stderr, "Invalid vlan_id %d (must be < 4096)\n", vlan_id);
+	printf("Invalid vlan_id %d (must be < 4096)\n", vlan_id);
 	return 1;
 }
 
-static uint32_t
-eth_dev_get_overhead_len(uint32_t max_rx_pktlen, uint16_t max_mtu)
+static int
+port_reg_off_is_invalid(portid_t port_id, uint32_t reg_off)
 {
-	uint32_t overhead_len;
+	const struct rte_pci_device *pci_dev;
+	const struct rte_bus *bus;
+	uint64_t pci_len;
+
+	if (reg_off & 0x3) {
+		printf("Port register offset 0x%X not aligned on a 4-byte "
+		       "boundary\n",
+		       (unsigned)reg_off);
+		return 1;
+	}
 
-	if (max_mtu != UINT16_MAX && max_rx_pktlen > max_mtu)
-		overhead_len = max_rx_pktlen - max_mtu;
-	else
-		overhead_len = RTE_ETHER_HDR_LEN + RTE_ETHER_CRC_LEN;
+	if (!ports[port_id].dev_info.device) {
+		printf("Invalid device\n");
+		return 0;
+	}
 
-	return overhead_len;
+	bus = rte_bus_find_by_device(ports[port_id].dev_info.device);
+	if (bus && !strcmp(bus->name, "pci")) {
+		pci_dev = RTE_DEV_TO_PCI(ports[port_id].dev_info.device);
+	} else {
+		printf("Not a PCI device\n");
+		return 1;
+	}
+
+	pci_len = pci_dev->mem_resource[0].len;
+	if (reg_off >= pci_len) {
+		printf("Port %d: register offset %u (0x%X) out of port PCI "
+		       "resource (length=%"PRIu64")\n",
+		       port_id, (unsigned)reg_off, (unsigned)reg_off,  pci_len);
+		return 1;
+	}
+	return 0;
 }
 
 static int
-eth_dev_validate_mtu(uint16_t port_id, uint16_t mtu)
+reg_bit_pos_is_invalid(uint8_t bit_pos)
 {
-	struct rte_eth_dev_info dev_info;
-	uint32_t overhead_len;
-	uint32_t frame_size;
-	int ret;
-
-	ret = rte_eth_dev_info_get(port_id, &dev_info);
-	if (ret != 0)
-		return ret;
-
-	if (mtu < dev_info.min_mtu) {
-		fprintf(stderr,
-			"MTU (%u) < device min MTU (%u) for port_id %u\n",
-			mtu, dev_info.min_mtu, port_id);
-		return -EINVAL;
-	}
-	if (mtu > dev_info.max_mtu) {
-		fprintf(stderr,
-			"MTU (%u) > device max MTU (%u) for port_id %u\n",
-			mtu, dev_info.max_mtu, port_id);
-		return -EINVAL;
-	}
+	if (bit_pos <= 31)
+		return 0;
+	printf("Invalid bit position %d (must be <= 31)\n", bit_pos);
+	return 1;
+}
 
-	overhead_len = eth_dev_get_overhead_len(dev_info.max_rx_pktlen,
-			dev_info.max_mtu);
-	frame_size = mtu + overhead_len;
-	if (frame_size > dev_info.max_rx_pktlen) {
-		fprintf(stderr,
-			"Frame size (%u) > device max frame size (%u) for port_id %u\n",
-			frame_size, dev_info.max_rx_pktlen, port_id);
-		return -EINVAL;
-	}
+#define display_port_and_reg_off(port_id, reg_off) \
+	printf("port %d PCI register at offset 0x%X: ", (port_id), (reg_off))
 
-	return 0;
+static inline void
+display_port_reg_value(portid_t port_id, uint32_t reg_off, uint32_t reg_v)
+{
+	display_port_and_reg_off(port_id, (unsigned)reg_off);
+	printf("0x%08X (%u)\n", (unsigned)reg_v, (unsigned)reg_v);
 }
 
 void
-port_mtu_set(portid_t port_id, uint16_t mtu)
+port_reg_bit_display(portid_t port_id, uint32_t reg_off, uint8_t bit_x)
 {
-	struct rte_port *port = &ports[port_id];
-	int diag;
+	uint32_t reg_v;
+
 
 	if (port_id_is_invalid(port_id, ENABLED_WARN))
 		return;
-
-	diag = eth_dev_validate_mtu(port_id, mtu);
-	if (diag != 0)
+	if (port_reg_off_is_invalid(port_id, reg_off))
 		return;
-
-	if (port->need_reconfig == 0) {
-		diag = rte_eth_dev_set_mtu(port_id, mtu);
-		if (diag != 0) {
-			fprintf(stderr, "Set MTU failed. diag=%d\n", diag);
-			return;
-		}
-	}
-
-	port->dev_conf.rxmode.mtu = mtu;
+	if (reg_bit_pos_is_invalid(bit_x))
+		return;
+	reg_v = port_id_pci_reg_read(port_id, reg_off);
+	display_port_and_reg_off(port_id, (unsigned)reg_off);
+	printf("bit %d=%d\n", bit_x, (int) ((reg_v & (1 << bit_x)) >> bit_x));
 }
 
-/* Generic flow management functions. */
-
-static struct port_flow_tunnel *
-port_flow_locate_tunnel_id(struct rte_port *port, uint32_t port_tunnel_id)
+void
+port_reg_bit_field_display(portid_t port_id, uint32_t reg_off,
+			   uint8_t bit1_pos, uint8_t bit2_pos)
 {
-	struct port_flow_tunnel *flow_tunnel;
+	uint32_t reg_v;
+	uint8_t  l_bit;
+	uint8_t  h_bit;
 
-	LIST_FOREACH(flow_tunnel, &port->flow_tunnel_list, chain) {
-		if (flow_tunnel->id == port_tunnel_id)
-			goto out;
-	}
-	flow_tunnel = NULL;
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+	if (port_reg_off_is_invalid(port_id, reg_off))
+		return;
+	if (reg_bit_pos_is_invalid(bit1_pos))
+		return;
+	if (reg_bit_pos_is_invalid(bit2_pos))
+		return;
+	if (bit1_pos > bit2_pos)
+		l_bit = bit2_pos, h_bit = bit1_pos;
+	else
+		l_bit = bit1_pos, h_bit = bit2_pos;
 
-out:
-	return flow_tunnel;
+	reg_v = port_id_pci_reg_read(port_id, reg_off);
+	reg_v >>= l_bit;
+	if (h_bit < 31)
+		reg_v &= ((1 << (h_bit - l_bit + 1)) - 1);
+	display_port_and_reg_off(port_id, (unsigned)reg_off);
+	printf("bits[%d, %d]=0x%0*X (%u)\n", l_bit, h_bit,
+	       ((h_bit - l_bit) / 4) + 1, (unsigned)reg_v, (unsigned)reg_v);
 }
 
-const char *
-port_flow_tunnel_type(struct rte_flow_tunnel *tunnel)
+void
+port_reg_display(portid_t port_id, uint32_t reg_off)
 {
-	const char *type;
-	switch (tunnel->type) {
-	default:
-		type = "unknown";
-		break;
-	case RTE_FLOW_ITEM_TYPE_VXLAN:
-		type = "vxlan";
-		break;
-	case RTE_FLOW_ITEM_TYPE_GRE:
-		type = "gre";
-		break;
-	case RTE_FLOW_ITEM_TYPE_NVGRE:
-		type = "nvgre";
-		break;
-	case RTE_FLOW_ITEM_TYPE_GENEVE:
-		type = "geneve";
-		break;
-	}
+	uint32_t reg_v;
 
-	return type;
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+	if (port_reg_off_is_invalid(port_id, reg_off))
+		return;
+	reg_v = port_id_pci_reg_read(port_id, reg_off);
+	display_port_reg_value(port_id, reg_off, reg_v);
 }
 
-struct port_flow_tunnel *
-port_flow_locate_tunnel(uint16_t port_id, struct rte_flow_tunnel *tun)
+void
+port_reg_bit_set(portid_t port_id, uint32_t reg_off, uint8_t bit_pos,
+		 uint8_t bit_v)
 {
-	struct rte_port *port = &ports[port_id];
-	struct port_flow_tunnel *flow_tunnel;
+	uint32_t reg_v;
 
-	LIST_FOREACH(flow_tunnel, &port->flow_tunnel_list, chain) {
-		if (!memcmp(&flow_tunnel->tunnel, tun, sizeof(*tun)))
-			goto out;
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+	if (port_reg_off_is_invalid(port_id, reg_off))
+		return;
+	if (reg_bit_pos_is_invalid(bit_pos))
+		return;
+	if (bit_v > 1) {
+		printf("Invalid bit value %d (must be 0 or 1)\n", (int) bit_v);
+		return;
 	}
-	flow_tunnel = NULL;
-
-out:
-	return flow_tunnel;
+	reg_v = port_id_pci_reg_read(port_id, reg_off);
+	if (bit_v == 0)
+		reg_v &= ~(1 << bit_pos);
+	else
+		reg_v |= (1 << bit_pos);
+	port_id_pci_reg_write(port_id, reg_off, reg_v);
+	display_port_reg_value(port_id, reg_off, reg_v);
 }
 
-void port_flow_tunnel_list(portid_t port_id)
+void
+port_reg_bit_field_set(portid_t port_id, uint32_t reg_off,
+		       uint8_t bit1_pos, uint8_t bit2_pos, uint32_t value)
 {
-	struct rte_port *port = &ports[port_id];
-	struct port_flow_tunnel *flt;
+	uint32_t max_v;
+	uint32_t reg_v;
+	uint8_t  l_bit;
+	uint8_t  h_bit;
 
-	LIST_FOREACH(flt, &port->flow_tunnel_list, chain) {
-		printf("port %u tunnel #%u type=%s",
-			port_id, flt->id, port_flow_tunnel_type(&flt->tunnel));
-		if (flt->tunnel.tun_id)
-			printf(" id=%" PRIu64, flt->tunnel.tun_id);
-		printf("\n");
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+	if (port_reg_off_is_invalid(port_id, reg_off))
+		return;
+	if (reg_bit_pos_is_invalid(bit1_pos))
+		return;
+	if (reg_bit_pos_is_invalid(bit2_pos))
+		return;
+	if (bit1_pos > bit2_pos)
+		l_bit = bit2_pos, h_bit = bit1_pos;
+	else
+		l_bit = bit1_pos, h_bit = bit2_pos;
+
+	if ((h_bit - l_bit) < 31)
+		max_v = (1 << (h_bit - l_bit + 1)) - 1;
+	else
+		max_v = 0xFFFFFFFF;
+
+	if (value > max_v) {
+		printf("Invalid value %u (0x%x) must be < %u (0x%x)\n",
+				(unsigned)value, (unsigned)value,
+				(unsigned)max_v, (unsigned)max_v);
+		return;
 	}
+	reg_v = port_id_pci_reg_read(port_id, reg_off);
+	reg_v &= ~(max_v << l_bit); /* Keep unchanged bits */
+	reg_v |= (value << l_bit); /* Set changed bits */
+	port_id_pci_reg_write(port_id, reg_off, reg_v);
+	display_port_reg_value(port_id, reg_off, reg_v);
 }
 
-void port_flow_tunnel_destroy(portid_t port_id, uint32_t tunnel_id)
+void
+port_reg_set(portid_t port_id, uint32_t reg_off, uint32_t reg_v)
 {
-	struct rte_port *port = &ports[port_id];
-	struct port_flow_tunnel *flt;
-
-	LIST_FOREACH(flt, &port->flow_tunnel_list, chain) {
-		if (flt->id == tunnel_id)
-			break;
-	}
-	if (flt) {
-		LIST_REMOVE(flt, chain);
-		free(flt);
-		printf("port %u: flow tunnel #%u destroyed\n",
-			port_id, tunnel_id);
-	}
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+	if (port_reg_off_is_invalid(port_id, reg_off))
+		return;
+	port_id_pci_reg_write(port_id, reg_off, reg_v);
+	display_port_reg_value(port_id, reg_off, reg_v);
 }
 
-void port_flow_tunnel_create(portid_t port_id, const struct tunnel_ops *ops)
+void
+port_mtu_set(portid_t port_id, uint16_t mtu)
 {
-	struct rte_port *port = &ports[port_id];
-	enum rte_flow_item_type	type;
-	struct port_flow_tunnel *flt;
+	int diag;
+	struct rte_eth_dev_info dev_info;
+	int ret;
 
-	if (!strcmp(ops->type, "vxlan"))
-		type = RTE_FLOW_ITEM_TYPE_VXLAN;
-	else if (!strcmp(ops->type, "gre"))
-		type = RTE_FLOW_ITEM_TYPE_GRE;
-	else if (!strcmp(ops->type, "nvgre"))
-		type = RTE_FLOW_ITEM_TYPE_NVGRE;
-	else if (!strcmp(ops->type, "geneve"))
-		type = RTE_FLOW_ITEM_TYPE_GENEVE;
-	else {
-		fprintf(stderr, "cannot offload \"%s\" tunnel type\n",
-			ops->type);
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+
+	ret = eth_dev_info_get_print_err(port_id, &dev_info);
+	if (ret != 0)
+		return;
+
+	if (mtu > dev_info.max_mtu || mtu < dev_info.min_mtu) {
+		printf("Set MTU failed. MTU:%u is not in valid range, min:%u - max:%u\n",
+			mtu, dev_info.min_mtu, dev_info.max_mtu);
 		return;
 	}
-	LIST_FOREACH(flt, &port->flow_tunnel_list, chain) {
-		if (flt->tunnel.type == type)
-			break;
-	}
-	if (!flt) {
-		flt = calloc(1, sizeof(*flt));
-		if (!flt) {
-			fprintf(stderr, "failed to allocate port flt object\n");
-			return;
-		}
-		flt->tunnel.type = type;
-		flt->id = LIST_EMPTY(&port->flow_tunnel_list) ? 1 :
-				  LIST_FIRST(&port->flow_tunnel_list)->id + 1;
-		LIST_INSERT_HEAD(&port->flow_tunnel_list, flt, chain);
-	}
-	printf("port %d: flow tunnel #%u type %s\n",
-		port_id, flt->id, ops->type);
+	diag = rte_eth_dev_set_mtu(port_id, mtu);
+	if (diag == 0)
+		return;
+	printf("Set MTU failed. diag=%d\n", diag);
 }
 
+/* Generic flow management functions. */
+
 /** Generate a port_flow entry from attributes/pattern/actions. */
 static struct port_flow *
 port_flow_new(const struct rte_flow_attr *attr,
@@ -1419,1883 +1303,70 @@
 		errstr = "unknown type";
 	else
 		errstr = errstrlist[error->type];
-	fprintf(stderr, "%s(): Caught PMD error type %d (%s): %s%s: %s\n",
-		__func__, error->type, errstr,
-		error->cause ? (snprintf(buf, sizeof(buf), "cause: %p, ",
-					 error->cause), buf) : "",
-		error->message ? error->message : "(no stated reason)",
-		rte_strerror(err));
-
-	switch (error->type) {
-	case RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER:
-		fprintf(stderr, "The status suggests the use of \"transfer\" "
-				"as the possible cause of the failure. Make "
-				"sure that the flow in question and its "
-				"indirect components (if any) are managed "
-				"via \"transfer\" proxy port. Use command "
-				"\"show port (port_id) flow transfer proxy\" "
-				"to figure out the proxy port ID\n");
-		break;
-	default:
-		break;
-	}
-
+	printf("Caught error type %d (%s): %s%s: %s\n",
+	       error->type, errstr,
+	       error->cause ? (snprintf(buf, sizeof(buf), "cause: %p, ",
+					error->cause), buf) : "",
+	       error->message ? error->message : "(no stated reason)",
+	       rte_strerror(err));
 	return -err;
 }
 
-static void
-rss_types_display(uint64_t rss_types, uint16_t char_num_per_line)
-{
-	uint16_t total_len = 0;
-	uint16_t str_len;
-	uint16_t i;
-
-	if (rss_types == 0)
-		return;
-
-	for (i = 0; rss_type_table[i].str; i++) {
-		if (rss_type_table[i].rss_type == 0)
-			continue;
-
-		if ((rss_types & rss_type_table[i].rss_type) ==
-					rss_type_table[i].rss_type) {
-			/* Contain two spaces */
-			str_len = strlen(rss_type_table[i].str) + 2;
-			if (total_len + str_len > char_num_per_line) {
-				printf("\n");
-				total_len = 0;
-			}
-			printf("  %s", rss_type_table[i].str);
-			total_len += str_len;
-		}
-	}
-	printf("\n");
-}
-
-static void
-rss_config_display(struct rte_flow_action_rss *rss_conf)
-{
-	uint8_t i;
-
-	if (rss_conf == NULL) {
-		fprintf(stderr, "Invalid rule\n");
-		return;
-	}
-
-	printf("RSS:\n"
-	       " queues:");
-	if (rss_conf->queue_num == 0)
-		printf(" none");
-	for (i = 0; i < rss_conf->queue_num; i++)
-		printf(" %d", rss_conf->queue[i]);
-	printf("\n");
-
-	printf(" function: ");
-	switch (rss_conf->func) {
-	case RTE_ETH_HASH_FUNCTION_DEFAULT:
-		printf("default\n");
-		break;
-	case RTE_ETH_HASH_FUNCTION_TOEPLITZ:
-		printf("toeplitz\n");
-		break;
-	case RTE_ETH_HASH_FUNCTION_SIMPLE_XOR:
-		printf("simple_xor\n");
-		break;
-	case RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ:
-		printf("symmetric_toeplitz\n");
-		break;
-	default:
-		printf("Unknown function\n");
-		return;
-	}
-
-	printf(" types:\n");
-	if (rss_conf->types == 0) {
-		printf("  none\n");
-		return;
-	}
-	rss_types_display(rss_conf->types, TESTPMD_RSS_TYPES_CHAR_NUM_PER_LINE);
-}
-
-static struct port_indirect_action *
-action_get_by_id(portid_t port_id, uint32_t id)
-{
-	struct rte_port *port;
-	struct port_indirect_action **ppia;
-	struct port_indirect_action *pia = NULL;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return NULL;
-	port = &ports[port_id];
-	ppia = &port->actions_list;
-	while (*ppia) {
-		if ((*ppia)->id == id) {
-			pia = *ppia;
-			break;
-		}
-		ppia = &(*ppia)->next;
-	}
-	if (!pia)
-		fprintf(stderr,
-			"Failed to find indirect action #%u on port %u\n",
-			id, port_id);
-	return pia;
-}
-
-static int
-action_alloc(portid_t port_id, uint32_t id,
-	     struct port_indirect_action **action)
-{
-	struct rte_port *port;
-	struct port_indirect_action **ppia;
-	struct port_indirect_action *pia = NULL;
-
-	*action = NULL;
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	if (id == UINT32_MAX) {
-		/* taking first available ID */
-		if (port->actions_list) {
-			if (port->actions_list->id == UINT32_MAX - 1) {
-				fprintf(stderr,
-					"Highest indirect action ID is already assigned, delete it first\n");
-				return -ENOMEM;
-			}
-			id = port->actions_list->id + 1;
-		} else {
-			id = 0;
-		}
-	}
-	pia = calloc(1, sizeof(*pia));
-	if (!pia) {
-		fprintf(stderr,
-			"Allocation of port %u indirect action failed\n",
-			port_id);
-		return -ENOMEM;
-	}
-	ppia = &port->actions_list;
-	while (*ppia && (*ppia)->id > id)
-		ppia = &(*ppia)->next;
-	if (*ppia && (*ppia)->id == id) {
-		fprintf(stderr,
-			"Indirect action #%u is already assigned, delete it first\n",
-			id);
-		free(pia);
-		return -EINVAL;
-	}
-	pia->next = *ppia;
-	pia->id = id;
-	*ppia = pia;
-	*action = pia;
-	return 0;
-}
-
-static int
-template_alloc(uint32_t id, struct port_template **template,
-	       struct port_template **list)
-{
-	struct port_template *lst = *list;
-	struct port_template **ppt;
-	struct port_template *pt = NULL;
-
-	*template = NULL;
-	if (id == UINT32_MAX) {
-		/* taking first available ID */
-		if (lst) {
-			if (lst->id == UINT32_MAX - 1) {
-				printf("Highest template ID is already"
-				" assigned, delete it first\n");
-				return -ENOMEM;
-			}
-			id = lst->id + 1;
-		} else {
-			id = 0;
-		}
-	}
-	pt = calloc(1, sizeof(*pt));
-	if (!pt) {
-		printf("Allocation of port template failed\n");
-		return -ENOMEM;
-	}
-	ppt = list;
-	while (*ppt && (*ppt)->id > id)
-		ppt = &(*ppt)->next;
-	if (*ppt && (*ppt)->id == id) {
-		printf("Template #%u is already assigned,"
-			" delete it first\n", id);
-		free(pt);
-		return -EINVAL;
-	}
-	pt->next = *ppt;
-	pt->id = id;
-	*ppt = pt;
-	*template = pt;
-	return 0;
-}
-
-static int
-table_alloc(uint32_t id, struct port_table **table,
-	    struct port_table **list)
-{
-	struct port_table *lst = *list;
-	struct port_table **ppt;
-	struct port_table *pt = NULL;
-
-	*table = NULL;
-	if (id == UINT32_MAX) {
-		/* taking first available ID */
-		if (lst) {
-			if (lst->id == UINT32_MAX - 1) {
-				printf("Highest table ID is already"
-				" assigned, delete it first\n");
-				return -ENOMEM;
-			}
-			id = lst->id + 1;
-		} else {
-			id = 0;
-		}
-	}
-	pt = calloc(1, sizeof(*pt));
-	if (!pt) {
-		printf("Allocation of table failed\n");
-		return -ENOMEM;
-	}
-	ppt = list;
-	while (*ppt && (*ppt)->id > id)
-		ppt = &(*ppt)->next;
-	if (*ppt && (*ppt)->id == id) {
-		printf("Table #%u is already assigned,"
-			" delete it first\n", id);
-		free(pt);
-		return -EINVAL;
-	}
-	pt->next = *ppt;
-	pt->id = id;
-	*ppt = pt;
-	*table = pt;
-	return 0;
-}
-
-/** Get info about flow management resources. */
-int
-port_flow_get_info(portid_t port_id)
-{
-	struct rte_flow_port_info port_info;
-	struct rte_flow_queue_info queue_info;
-	struct rte_flow_error error;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x99, sizeof(error));
-	memset(&port_info, 0, sizeof(port_info));
-	memset(&queue_info, 0, sizeof(queue_info));
-	if (rte_flow_info_get(port_id, &port_info, &queue_info, &error))
-		return port_flow_complain(&error);
-	printf("Flow engine resources on port %u:\n"
-	       "Number of queues: %d\n"
-		   "Size of queues: %d\n"
-	       "Number of counters: %d\n"
-	       "Number of aging objects: %d\n"
-	       "Number of meter actions: %d\n",
-	       port_id, port_info.max_nb_queues,
-		   queue_info.max_size,
-	       port_info.max_nb_counters,
-	       port_info.max_nb_aging_objects,
-	       port_info.max_nb_meters);
-	return 0;
-}
-
-/** Configure flow management resources. */
-int
-port_flow_configure(portid_t port_id,
-	const struct rte_flow_port_attr *port_attr,
-	uint16_t nb_queue,
-	const struct rte_flow_queue_attr *queue_attr)
-{
-	struct rte_port *port;
-	struct rte_flow_error error;
-	const struct rte_flow_queue_attr *attr_list[nb_queue];
-	int std_queue;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	port->queue_nb = nb_queue;
-	port->queue_sz = queue_attr->size;
-	for (std_queue = 0; std_queue < nb_queue; std_queue++)
-		attr_list[std_queue] = queue_attr;
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x66, sizeof(error));
-	if (rte_flow_configure(port_id, port_attr, nb_queue, attr_list, &error))
-		return port_flow_complain(&error);
-	printf("Configure flows on port %u: "
-	       "number of queues %d with %d elements\n",
-	       port_id, nb_queue, queue_attr->size);
-	return 0;
-}
-
-/** Create indirect action */
-int
-port_action_handle_create(portid_t port_id, uint32_t id,
-			  const struct rte_flow_indir_action_conf *conf,
-			  const struct rte_flow_action *action)
-{
-	struct port_indirect_action *pia;
-	int ret;
-	struct rte_flow_error error;
-
-	ret = action_alloc(port_id, id, &pia);
-	if (ret)
-		return ret;
-	if (action->type == RTE_FLOW_ACTION_TYPE_AGE) {
-		struct rte_flow_action_age *age =
-			(struct rte_flow_action_age *)(uintptr_t)(action->conf);
-
-		pia->age_type = ACTION_AGE_CONTEXT_TYPE_INDIRECT_ACTION;
-		age->context = &pia->age_type;
-	} else if (action->type == RTE_FLOW_ACTION_TYPE_CONNTRACK) {
-		struct rte_flow_action_conntrack *ct =
-		(struct rte_flow_action_conntrack *)(uintptr_t)(action->conf);
-
-		memcpy(ct, &conntrack_context, sizeof(*ct));
-	}
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x22, sizeof(error));
-	pia->handle = rte_flow_action_handle_create(port_id, conf, action,
-						    &error);
-	if (!pia->handle) {
-		uint32_t destroy_id = pia->id;
-		port_action_handle_destroy(port_id, 1, &destroy_id);
-		return port_flow_complain(&error);
-	}
-	pia->type = action->type;
-	printf("Indirect action #%u created\n", pia->id);
-	return 0;
-}
-
-/** Destroy indirect action */
-int
-port_action_handle_destroy(portid_t port_id,
-			   uint32_t n,
-			   const uint32_t *actions)
-{
-	struct rte_port *port;
-	struct port_indirect_action **tmp;
-	int ret = 0;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	tmp = &port->actions_list;
-	while (*tmp) {
-		uint32_t i;
-
-		for (i = 0; i != n; ++i) {
-			struct rte_flow_error error;
-			struct port_indirect_action *pia = *tmp;
-
-			if (actions[i] != pia->id)
-				continue;
-			/*
-			 * Poisoning to make sure PMDs update it in case
-			 * of error.
-			 */
-			memset(&error, 0x33, sizeof(error));
-
-			if (pia->handle && rte_flow_action_handle_destroy(
-					port_id, pia->handle, &error)) {
-				ret = port_flow_complain(&error);
-				continue;
-			}
-			*tmp = pia->next;
-			printf("Indirect action #%u destroyed\n", pia->id);
-			free(pia);
-			break;
-		}
-		if (i == n)
-			tmp = &(*tmp)->next;
-	}
-	return ret;
-}
-
-int
-port_action_handle_flush(portid_t port_id)
-{
-	struct rte_port *port;
-	struct port_indirect_action **tmp;
-	int ret = 0;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	tmp = &port->actions_list;
-	while (*tmp != NULL) {
-		struct rte_flow_error error;
-		struct port_indirect_action *pia = *tmp;
-
-		/* Poisoning to make sure PMDs update it in case of error. */
-		memset(&error, 0x44, sizeof(error));
-		if (pia->handle != NULL &&
-		    rte_flow_action_handle_destroy
-					(port_id, pia->handle, &error) != 0) {
-			printf("Indirect action #%u not destroyed\n", pia->id);
-			ret = port_flow_complain(&error);
-			tmp = &pia->next;
-		} else {
-			*tmp = pia->next;
-			free(pia);
-		}
-	}
-	return ret;
-}
-
-/** Get indirect action by port + id */
-struct rte_flow_action_handle *
-port_action_handle_get_by_id(portid_t port_id, uint32_t id)
-{
-
-	struct port_indirect_action *pia = action_get_by_id(port_id, id);
-
-	return (pia) ? pia->handle : NULL;
-}
-
-/** Update indirect action */
-int
-port_action_handle_update(portid_t port_id, uint32_t id,
-			  const struct rte_flow_action *action)
-{
-	struct rte_flow_error error;
-	struct rte_flow_action_handle *action_handle;
-	struct port_indirect_action *pia;
-	struct rte_flow_update_meter_mark mtr_update;
-	const void *update;
-
-	action_handle = port_action_handle_get_by_id(port_id, id);
-	if (!action_handle)
-		return -EINVAL;
-	pia = action_get_by_id(port_id, id);
-	if (!pia)
-		return -EINVAL;
-	switch (pia->type) {
-	case RTE_FLOW_ACTION_TYPE_AGE:
-	case RTE_FLOW_ACTION_TYPE_CONNTRACK:
-		update = action->conf;
-		break;
-	case RTE_FLOW_ACTION_TYPE_METER_MARK:
-		memcpy(&mtr_update.meter_mark, action->conf,
-		       sizeof(struct rte_flow_action_meter_mark));
-		if (mtr_update.meter_mark.profile)
-			mtr_update.profile_valid = 1;
-		if (mtr_update.meter_mark.policy)
-			mtr_update.policy_valid = 1;
-		mtr_update.color_mode_valid = 1;
-		mtr_update.state_valid = 1;
-		update = &mtr_update;
-		break;
-	default:
-		update = action;
-		break;
-	}
-	if (rte_flow_action_handle_update(port_id, action_handle, update,
-					  &error)) {
-		return port_flow_complain(&error);
-	}
-	printf("Indirect action #%u updated\n", id);
-	return 0;
-}
-
-static void
-port_action_handle_query_dump(uint32_t type, union port_action_query *query)
-{
-	switch (type) {
-	case RTE_FLOW_ACTION_TYPE_AGE:
-		printf("Indirect AGE action:\n"
-		       " aged: %u\n"
-		       " sec_since_last_hit_valid: %u\n"
-		       " sec_since_last_hit: %" PRIu32 "\n",
-		       query->age.aged,
-		       query->age.sec_since_last_hit_valid,
-		       query->age.sec_since_last_hit);
-		break;
-	case RTE_FLOW_ACTION_TYPE_COUNT:
-		printf("Indirect COUNT action:\n"
-		       " hits_set: %u\n"
-		       " bytes_set: %u\n"
-		       " hits: %" PRIu64 "\n"
-		       " bytes: %" PRIu64 "\n",
-		       query->count.hits_set,
-		       query->count.bytes_set,
-		       query->count.hits,
-		       query->count.bytes);
-		break;
-	case RTE_FLOW_ACTION_TYPE_CONNTRACK:
-		printf("Conntrack Context:\n"
-		       "  Peer: %u, Flow dir: %s, Enable: %u\n"
-		       "  Live: %u, SACK: %u, CACK: %u\n"
-		       "  Packet dir: %s, Liberal: %u, State: %u\n"
-		       "  Factor: %u, Retrans: %u, TCP flags: %u\n"
-		       "  Last Seq: %u, Last ACK: %u\n"
-		       "  Last Win: %u, Last End: %u\n",
-		       query->ct.peer_port,
-		       query->ct.is_original_dir ? "Original" : "Reply",
-		       query->ct.enable, query->ct.live_connection,
-		       query->ct.selective_ack, query->ct.challenge_ack_passed,
-		       query->ct.last_direction ? "Original" : "Reply",
-		       query->ct.liberal_mode, query->ct.state,
-		       query->ct.max_ack_window, query->ct.retransmission_limit,
-		       query->ct.last_index, query->ct.last_seq,
-		       query->ct.last_ack, query->ct.last_window,
-		       query->ct.last_end);
-		printf("  Original Dir:\n"
-		       "    scale: %u, fin: %u, ack seen: %u\n"
-		       " unacked data: %u\n    Sent end: %u,"
-		       "    Reply end: %u, Max win: %u, Max ACK: %u\n",
-		       query->ct.original_dir.scale,
-		       query->ct.original_dir.close_initiated,
-		       query->ct.original_dir.last_ack_seen,
-		       query->ct.original_dir.data_unacked,
-		       query->ct.original_dir.sent_end,
-		       query->ct.original_dir.reply_end,
-		       query->ct.original_dir.max_win,
-		       query->ct.original_dir.max_ack);
-		printf("  Reply Dir:\n"
-		       "    scale: %u, fin: %u, ack seen: %u\n"
-		       " unacked data: %u\n    Sent end: %u,"
-		       "    Reply end: %u, Max win: %u, Max ACK: %u\n",
-		       query->ct.reply_dir.scale,
-		       query->ct.reply_dir.close_initiated,
-		       query->ct.reply_dir.last_ack_seen,
-		       query->ct.reply_dir.data_unacked,
-		       query->ct.reply_dir.sent_end,
-		       query->ct.reply_dir.reply_end,
-		       query->ct.reply_dir.max_win,
-		       query->ct.reply_dir.max_ack);
-		break;
-	default:
-		fprintf(stderr,
-			"Indirect action (type: %d) doesn't support query\n",
-			type);
-		break;
-	}
-
-}
-
-int
-port_action_handle_query(portid_t port_id, uint32_t id)
-{
-	struct rte_flow_error error;
-	struct port_indirect_action *pia;
-	union port_action_query query;
-
-	pia = action_get_by_id(port_id, id);
-	if (!pia)
-		return -EINVAL;
-	switch (pia->type) {
-	case RTE_FLOW_ACTION_TYPE_AGE:
-	case RTE_FLOW_ACTION_TYPE_COUNT:
-		break;
-	default:
-		fprintf(stderr,
-			"Indirect action %u (type: %d) on port %u doesn't support query\n",
-			id, pia->type, port_id);
-		return -ENOTSUP;
-	}
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x55, sizeof(error));
-	memset(&query, 0, sizeof(query));
-	if (rte_flow_action_handle_query(port_id, pia->handle, &query, &error))
-		return port_flow_complain(&error);
-	port_action_handle_query_dump(pia->type, &query);
-	return 0;
-}
-
-static struct port_flow_tunnel *
-port_flow_tunnel_offload_cmd_prep(portid_t port_id,
-				  const struct rte_flow_item *pattern,
-				  const struct rte_flow_action *actions,
-				  const struct tunnel_ops *tunnel_ops)
-{
-	int ret;
-	struct rte_port *port;
-	struct port_flow_tunnel *pft;
-	struct rte_flow_error error;
-
-	port = &ports[port_id];
-	pft = port_flow_locate_tunnel_id(port, tunnel_ops->id);
-	if (!pft) {
-		fprintf(stderr, "failed to locate port flow tunnel #%u\n",
-			tunnel_ops->id);
-		return NULL;
-	}
-	if (tunnel_ops->actions) {
-		uint32_t num_actions;
-		const struct rte_flow_action *aptr;
-
-		ret = rte_flow_tunnel_decap_set(port_id, &pft->tunnel,
-						&pft->pmd_actions,
-						&pft->num_pmd_actions,
-						&error);
-		if (ret) {
-			port_flow_complain(&error);
-			return NULL;
-		}
-		for (aptr = actions, num_actions = 1;
-		     aptr->type != RTE_FLOW_ACTION_TYPE_END;
-		     aptr++, num_actions++);
-		pft->actions = malloc(
-				(num_actions +  pft->num_pmd_actions) *
-				sizeof(actions[0]));
-		if (!pft->actions) {
-			rte_flow_tunnel_action_decap_release(
-					port_id, pft->actions,
-					pft->num_pmd_actions, &error);
-			return NULL;
-		}
-		rte_memcpy(pft->actions, pft->pmd_actions,
-			   pft->num_pmd_actions * sizeof(actions[0]));
-		rte_memcpy(pft->actions + pft->num_pmd_actions, actions,
-			   num_actions * sizeof(actions[0]));
-	}
-	if (tunnel_ops->items) {
-		uint32_t num_items;
-		const struct rte_flow_item *iptr;
-
-		ret = rte_flow_tunnel_match(port_id, &pft->tunnel,
-					    &pft->pmd_items,
-					    &pft->num_pmd_items,
-					    &error);
-		if (ret) {
-			port_flow_complain(&error);
-			return NULL;
-		}
-		for (iptr = pattern, num_items = 1;
-		     iptr->type != RTE_FLOW_ITEM_TYPE_END;
-		     iptr++, num_items++);
-		pft->items = malloc((num_items + pft->num_pmd_items) *
-				    sizeof(pattern[0]));
-		if (!pft->items) {
-			rte_flow_tunnel_item_release(
-					port_id, pft->pmd_items,
-					pft->num_pmd_items, &error);
-			return NULL;
-		}
-		rte_memcpy(pft->items, pft->pmd_items,
-			   pft->num_pmd_items * sizeof(pattern[0]));
-		rte_memcpy(pft->items + pft->num_pmd_items, pattern,
-			   num_items * sizeof(pattern[0]));
-	}
-
-	return pft;
-}
-
-static void
-port_flow_tunnel_offload_cmd_release(portid_t port_id,
-				     const struct tunnel_ops *tunnel_ops,
-				     struct port_flow_tunnel *pft)
-{
-	struct rte_flow_error error;
-
-	if (tunnel_ops->actions) {
-		free(pft->actions);
-		rte_flow_tunnel_action_decap_release(
-			port_id, pft->pmd_actions,
-			pft->num_pmd_actions, &error);
-		pft->actions = NULL;
-		pft->pmd_actions = NULL;
-	}
-	if (tunnel_ops->items) {
-		free(pft->items);
-		rte_flow_tunnel_item_release(port_id, pft->pmd_items,
-					     pft->num_pmd_items,
-					     &error);
-		pft->items = NULL;
-		pft->pmd_items = NULL;
-	}
-}
-
-/** Add port meter policy */
-int
-port_meter_policy_add(portid_t port_id, uint32_t policy_id,
-			const struct rte_flow_action *actions)
-{
-	struct rte_mtr_error error;
-	const struct rte_flow_action *act = actions;
-	const struct rte_flow_action *start;
-	struct rte_mtr_meter_policy_params policy;
-	uint32_t i = 0, act_n;
-	int ret;
-
-	for (i = 0; i < RTE_COLORS; i++) {
-		for (act_n = 0, start = act;
-			act->type != RTE_FLOW_ACTION_TYPE_END; act++)
-			act_n++;
-		if (act_n && act->type == RTE_FLOW_ACTION_TYPE_END)
-			policy.actions[i] = start;
-		else
-			policy.actions[i] = NULL;
-		act++;
-	}
-	ret = rte_mtr_meter_policy_add(port_id,
-			policy_id,
-			&policy, &error);
-	if (ret)
-		print_mtr_err_msg(&error);
-	return ret;
-}
-
-struct rte_flow_meter_profile *
-port_meter_profile_get_by_id(portid_t port_id, uint32_t id)
-{
-	struct rte_mtr_error error;
-	struct rte_flow_meter_profile *profile;
-
-	profile = rte_mtr_meter_profile_get(port_id, id, &error);
-	if (!profile)
-		print_mtr_err_msg(&error);
-	return profile;
-}
-struct rte_flow_meter_policy *
-port_meter_policy_get_by_id(portid_t port_id, uint32_t id)
-{
-	struct rte_mtr_error error;
-	struct rte_flow_meter_policy *policy;
-
-	policy = rte_mtr_meter_policy_get(port_id, id, &error);
-	if (!policy)
-		print_mtr_err_msg(&error);
-	return policy;
-}
-
 /** Validate flow rule. */
 int
 port_flow_validate(portid_t port_id,
 		   const struct rte_flow_attr *attr,
 		   const struct rte_flow_item *pattern,
-		   const struct rte_flow_action *actions,
-		   const struct tunnel_ops *tunnel_ops)
+		   const struct rte_flow_action *actions)
 {
 	struct rte_flow_error error;
-	struct port_flow_tunnel *pft = NULL;
-	int ret;
 
 	/* Poisoning to make sure PMDs update it in case of error. */
 	memset(&error, 0x11, sizeof(error));
-	if (tunnel_ops->enabled) {
-		pft = port_flow_tunnel_offload_cmd_prep(port_id, pattern,
-							actions, tunnel_ops);
-		if (!pft)
-			return -ENOENT;
-		if (pft->items)
-			pattern = pft->items;
-		if (pft->actions)
-			actions = pft->actions;
-	}
-	ret = rte_flow_validate(port_id, attr, pattern, actions, &error);
-	if (tunnel_ops->enabled)
-		port_flow_tunnel_offload_cmd_release(port_id, tunnel_ops, pft);
-	if (ret)
+	if (rte_flow_validate(port_id, attr, pattern, actions, &error))
 		return port_flow_complain(&error);
 	printf("Flow rule validated\n");
 	return 0;
 }
 
-/** Return age action structure if exists, otherwise NULL. */
-static struct rte_flow_action_age *
-age_action_get(const struct rte_flow_action *actions)
-{
-	for (; actions->type != RTE_FLOW_ACTION_TYPE_END; actions++) {
-		switch (actions->type) {
-		case RTE_FLOW_ACTION_TYPE_AGE:
-			return (struct rte_flow_action_age *)
-				(uintptr_t)actions->conf;
-		default:
-			break;
-		}
-	}
-	return NULL;
-}
-
-/** Create pattern template */
-int
-port_flow_pattern_template_create(portid_t port_id, uint32_t id,
-				  const struct rte_flow_pattern_template_attr *attr,
-				  const struct rte_flow_item *pattern)
-{
-	struct rte_port *port;
-	struct port_template *pit;
-	int ret;
-	struct rte_flow_error error;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	ret = template_alloc(id, &pit, &port->pattern_templ_list);
-	if (ret)
-		return ret;
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x22, sizeof(error));
-	pit->template.pattern_template = rte_flow_pattern_template_create(port_id,
-						attr, pattern, &error);
-	if (!pit->template.pattern_template) {
-		uint32_t destroy_id = pit->id;
-		port_flow_pattern_template_destroy(port_id, 1, &destroy_id);
-		return port_flow_complain(&error);
-	}
-	printf("Pattern template #%u created\n", pit->id);
-	return 0;
-}
-
-/** Destroy pattern template */
-int
-port_flow_pattern_template_destroy(portid_t port_id, uint32_t n,
-				   const uint32_t *template)
-{
-	struct rte_port *port;
-	struct port_template **tmp;
-	int ret = 0;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	tmp = &port->pattern_templ_list;
-	while (*tmp) {
-		uint32_t i;
-
-		for (i = 0; i != n; ++i) {
-			struct rte_flow_error error;
-			struct port_template *pit = *tmp;
-
-			if (template[i] != pit->id)
-				continue;
-			/*
-			 * Poisoning to make sure PMDs update it in case
-			 * of error.
-			 */
-			memset(&error, 0x33, sizeof(error));
-
-			if (pit->template.pattern_template &&
-			    rte_flow_pattern_template_destroy(port_id,
-							   pit->template.pattern_template,
-							   &error)) {
-				ret = port_flow_complain(&error);
-				continue;
-			}
-			*tmp = pit->next;
-			printf("Pattern template #%u destroyed\n", pit->id);
-			free(pit);
-			break;
-		}
-		if (i == n)
-			tmp = &(*tmp)->next;
-	}
-	return ret;
-}
-
-/** Flush pattern template */
-int
-port_flow_pattern_template_flush(portid_t port_id)
-{
-	struct rte_port *port;
-	struct port_template **tmp;
-	int ret = 0;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	tmp = &port->pattern_templ_list;
-	while (*tmp) {
-		struct rte_flow_error error;
-		struct port_template *pit = *tmp;
-
-		/*
-		 * Poisoning to make sure PMDs update it in case
-		 * of error.
-		 */
-		memset(&error, 0x33, sizeof(error));
-		if (pit->template.pattern_template &&
-		    rte_flow_pattern_template_destroy(port_id,
-			pit->template.pattern_template, &error)) {
-			printf("Pattern template #%u not destroyed\n", pit->id);
-			ret = port_flow_complain(&error);
-			tmp = &pit->next;
-		} else {
-			*tmp = pit->next;
-			free(pit);
-		}
-	}
-	return ret;
-}
-
-/** Create actions template */
-int
-port_flow_actions_template_create(portid_t port_id, uint32_t id,
-				  const struct rte_flow_actions_template_attr *attr,
-				  const struct rte_flow_action *actions,
-				  const struct rte_flow_action *masks)
-{
-	struct rte_port *port;
-	struct port_template *pat;
-	int ret;
-	struct rte_flow_error error;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	ret = template_alloc(id, &pat, &port->actions_templ_list);
-	if (ret)
-		return ret;
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x22, sizeof(error));
-	pat->template.actions_template = rte_flow_actions_template_create(port_id,
-						attr, actions, masks, &error);
-	if (!pat->template.actions_template) {
-		uint32_t destroy_id = pat->id;
-		port_flow_actions_template_destroy(port_id, 1, &destroy_id);
-		return port_flow_complain(&error);
-	}
-	printf("Actions template #%u created\n", pat->id);
-	return 0;
-}
-
-/** Destroy actions template */
-int
-port_flow_actions_template_destroy(portid_t port_id, uint32_t n,
-				   const uint32_t *template)
-{
-	struct rte_port *port;
-	struct port_template **tmp;
-	int ret = 0;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	tmp = &port->actions_templ_list;
-	while (*tmp) {
-		uint32_t i;
-
-		for (i = 0; i != n; ++i) {
-			struct rte_flow_error error;
-			struct port_template *pat = *tmp;
-
-			if (template[i] != pat->id)
-				continue;
-			/*
-			 * Poisoning to make sure PMDs update it in case
-			 * of error.
-			 */
-			memset(&error, 0x33, sizeof(error));
-
-			if (pat->template.actions_template &&
-			    rte_flow_actions_template_destroy(port_id,
-					pat->template.actions_template, &error)) {
-				ret = port_flow_complain(&error);
-				continue;
-			}
-			*tmp = pat->next;
-			printf("Actions template #%u destroyed\n", pat->id);
-			free(pat);
-			break;
-		}
-		if (i == n)
-			tmp = &(*tmp)->next;
-	}
-	return ret;
-}
-
-/** Flush actions template */
-int
-port_flow_actions_template_flush(portid_t port_id)
-{
-	struct rte_port *port;
-	struct port_template **tmp;
-	int ret = 0;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	tmp = &port->actions_templ_list;
-	while (*tmp) {
-		struct rte_flow_error error;
-		struct port_template *pat = *tmp;
-
-		/*
-		 * Poisoning to make sure PMDs update it in case
-		 * of error.
-		 */
-		memset(&error, 0x33, sizeof(error));
-
-		if (pat->template.actions_template &&
-		    rte_flow_actions_template_destroy(port_id,
-			pat->template.actions_template, &error)) {
-			ret = port_flow_complain(&error);
-			printf("Actions template #%u not destroyed\n", pat->id);
-			tmp = &pat->next;
-		} else {
-			*tmp = pat->next;
-			free(pat);
-		}
-	}
-	return ret;
-}
-
-/** Create table */
-int
-port_flow_template_table_create(portid_t port_id, uint32_t id,
-		const struct rte_flow_template_table_attr *table_attr,
-		uint32_t nb_pattern_templates, uint32_t *pattern_templates,
-		uint32_t nb_actions_templates, uint32_t *actions_templates)
-{
-	struct rte_port *port;
-	struct port_table *pt;
-	struct port_template *temp = NULL;
-	int ret;
-	uint32_t i;
-	struct rte_flow_error error;
-	struct rte_flow_pattern_template
-			*flow_pattern_templates[nb_pattern_templates];
-	struct rte_flow_actions_template
-			*flow_actions_templates[nb_actions_templates];
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	for (i = 0; i < nb_pattern_templates; ++i) {
-		bool found = false;
-		temp = port->pattern_templ_list;
-		while (temp) {
-			if (pattern_templates[i] == temp->id) {
-				flow_pattern_templates[i] =
-					temp->template.pattern_template;
-				found = true;
-				break;
-			}
-			temp = temp->next;
-		}
-		if (!found) {
-			printf("Pattern template #%u is invalid\n",
-			       pattern_templates[i]);
-			return -EINVAL;
-		}
-	}
-	for (i = 0; i < nb_actions_templates; ++i) {
-		bool found = false;
-		temp = port->actions_templ_list;
-		while (temp) {
-			if (actions_templates[i] == temp->id) {
-				flow_actions_templates[i] =
-					temp->template.actions_template;
-				found = true;
-				break;
-			}
-			temp = temp->next;
-		}
-		if (!found) {
-			printf("Actions template #%u is invalid\n",
-			       actions_templates[i]);
-			return -EINVAL;
-		}
-	}
-	ret = table_alloc(id, &pt, &port->table_list);
-	if (ret)
-		return ret;
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x22, sizeof(error));
-	pt->table = rte_flow_template_table_create(port_id, table_attr,
-		      flow_pattern_templates, nb_pattern_templates,
-		      flow_actions_templates, nb_actions_templates,
-		      &error);
-
-	if (!pt->table) {
-		uint32_t destroy_id = pt->id;
-		port_flow_template_table_destroy(port_id, 1, &destroy_id);
-		return port_flow_complain(&error);
-	}
-	pt->nb_pattern_templates = nb_pattern_templates;
-	pt->nb_actions_templates = nb_actions_templates;
-	rte_memcpy(&pt->flow_attr, &table_attr->flow_attr,
-		   sizeof(struct rte_flow_attr));
-	printf("Template table #%u created\n", pt->id);
-	return 0;
-}
-
-/** Destroy table */
-int
-port_flow_template_table_destroy(portid_t port_id,
-				 uint32_t n, const uint32_t *table)
-{
-	struct rte_port *port;
-	struct port_table **tmp;
-	int ret = 0;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	tmp = &port->table_list;
-	while (*tmp) {
-		uint32_t i;
-
-		for (i = 0; i != n; ++i) {
-			struct rte_flow_error error;
-			struct port_table *pt = *tmp;
-
-			if (table[i] != pt->id)
-				continue;
-			/*
-			 * Poisoning to make sure PMDs update it in case
-			 * of error.
-			 */
-			memset(&error, 0x33, sizeof(error));
-
-			if (pt->table &&
-			    rte_flow_template_table_destroy(port_id,
-							    pt->table,
-							    &error)) {
-				ret = port_flow_complain(&error);
-				continue;
-			}
-			*tmp = pt->next;
-			printf("Template table #%u destroyed\n", pt->id);
-			free(pt);
-			break;
-		}
-		if (i == n)
-			tmp = &(*tmp)->next;
-	}
-	return ret;
-}
-
-/** Flush table */
-int
-port_flow_template_table_flush(portid_t port_id)
-{
-	struct rte_port *port;
-	struct port_table **tmp;
-	int ret = 0;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-	tmp = &port->table_list;
-	while (*tmp) {
-		struct rte_flow_error error;
-		struct port_table *pt = *tmp;
-
-		/*
-		 * Poisoning to make sure PMDs update it in case
-		 * of error.
-		 */
-		memset(&error, 0x33, sizeof(error));
-
-		if (pt->table &&
-		    rte_flow_template_table_destroy(port_id,
-						   pt->table,
-						   &error)) {
-			ret = port_flow_complain(&error);
-			printf("Template table #%u not destroyed\n", pt->id);
-			tmp = &pt->next;
-		} else {
-			*tmp = pt->next;
-			free(pt);
-		}
-	}
-	return ret;
-}
-
-/** Enqueue create flow rule operation. */
-int
-port_queue_flow_create(portid_t port_id, queueid_t queue_id,
-		       bool postpone, uint32_t table_id,
-		       uint32_t pattern_idx, uint32_t actions_idx,
-		       const struct rte_flow_item *pattern,
-		       const struct rte_flow_action *actions)
-{
-	struct rte_flow_op_attr op_attr = { .postpone = postpone };
-	struct rte_flow *flow;
-	struct rte_port *port;
-	struct port_flow *pf;
-	struct port_table *pt;
-	uint32_t id = 0;
-	bool found;
-	struct rte_flow_error error = { RTE_FLOW_ERROR_TYPE_NONE, NULL, NULL };
-	struct rte_flow_action_age *age = age_action_get(actions);
-	struct queue_job *job;
-
-	port = &ports[port_id];
-	if (port->flow_list) {
-		if (port->flow_list->id == UINT32_MAX) {
-			printf("Highest rule ID is already assigned,"
-			       " delete it first");
-			return -ENOMEM;
-		}
-		id = port->flow_list->id + 1;
-	}
-
-	if (queue_id >= port->queue_nb) {
-		printf("Queue #%u is invalid\n", queue_id);
-		return -EINVAL;
-	}
-
-	found = false;
-	pt = port->table_list;
-	while (pt) {
-		if (table_id == pt->id) {
-			found = true;
-			break;
-		}
-		pt = pt->next;
-	}
-	if (!found) {
-		printf("Table #%u is invalid\n", table_id);
-		return -EINVAL;
-	}
-
-	if (pattern_idx >= pt->nb_pattern_templates) {
-		printf("Pattern template index #%u is invalid,"
-		       " %u templates present in the table\n",
-		       pattern_idx, pt->nb_pattern_templates);
-		return -EINVAL;
-	}
-	if (actions_idx >= pt->nb_actions_templates) {
-		printf("Actions template index #%u is invalid,"
-		       " %u templates present in the table\n",
-		       actions_idx, pt->nb_actions_templates);
-		return -EINVAL;
-	}
-
-	job = calloc(1, sizeof(*job));
-	if (!job) {
-		printf("Queue flow create job allocate failed\n");
-		return -ENOMEM;
-	}
-	job->type = QUEUE_JOB_TYPE_FLOW_CREATE;
-
-	pf = port_flow_new(&pt->flow_attr, pattern, actions, &error);
-	if (!pf) {
-		free(job);
-		return port_flow_complain(&error);
-	}
-	if (age) {
-		pf->age_type = ACTION_AGE_CONTEXT_TYPE_FLOW;
-		age->context = &pf->age_type;
-	}
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x11, sizeof(error));
-	flow = rte_flow_async_create(port_id, queue_id, &op_attr, pt->table,
-		pattern, pattern_idx, actions, actions_idx, job, &error);
-	if (!flow) {
-		uint32_t flow_id = pf->id;
-		port_queue_flow_destroy(port_id, queue_id, true, 1, &flow_id);
-		free(job);
-		return port_flow_complain(&error);
-	}
-
-	pf->next = port->flow_list;
-	pf->id = id;
-	pf->flow = flow;
-	job->pf = pf;
-	port->flow_list = pf;
-	printf("Flow rule #%u creation enqueued\n", pf->id);
-	return 0;
-}
-
-/** Enqueue number of destroy flow rules operations. */
-int
-port_queue_flow_destroy(portid_t port_id, queueid_t queue_id,
-			bool postpone, uint32_t n, const uint32_t *rule)
-{
-	struct rte_flow_op_attr op_attr = { .postpone = postpone };
-	struct rte_port *port;
-	struct port_flow **tmp;
-	int ret = 0;
-	struct queue_job *job;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-
-	if (queue_id >= port->queue_nb) {
-		printf("Queue #%u is invalid\n", queue_id);
-		return -EINVAL;
-	}
-
-	tmp = &port->flow_list;
-	while (*tmp) {
-		uint32_t i;
-
-		for (i = 0; i != n; ++i) {
-			struct rte_flow_error error;
-			struct port_flow *pf = *tmp;
-
-			if (rule[i] != pf->id)
-				continue;
-			/*
-			 * Poisoning to make sure PMD
-			 * update it in case of error.
-			 */
-			memset(&error, 0x33, sizeof(error));
-			job = calloc(1, sizeof(*job));
-			if (!job) {
-				printf("Queue flow destroy job allocate failed\n");
-				return -ENOMEM;
-			}
-			job->type = QUEUE_JOB_TYPE_FLOW_DESTROY;
-			job->pf = pf;
-
-			if (rte_flow_async_destroy(port_id, queue_id, &op_attr,
-						   pf->flow, job, &error)) {
-				free(job);
-				ret = port_flow_complain(&error);
-				continue;
-			}
-			printf("Flow rule #%u destruction enqueued\n", pf->id);
-			*tmp = pf->next;
-			break;
-		}
-		if (i == n)
-			tmp = &(*tmp)->next;
-	}
-	return ret;
-}
-
-/** Enqueue indirect action create operation. */
-int
-port_queue_action_handle_create(portid_t port_id, uint32_t queue_id,
-				bool postpone, uint32_t id,
-				const struct rte_flow_indir_action_conf *conf,
-				const struct rte_flow_action *action)
-{
-	const struct rte_flow_op_attr attr = { .postpone = postpone};
-	struct rte_port *port;
-	struct port_indirect_action *pia;
-	int ret;
-	struct rte_flow_error error;
-	struct queue_job *job;
-
-	ret = action_alloc(port_id, id, &pia);
-	if (ret)
-		return ret;
-
-	port = &ports[port_id];
-	if (queue_id >= port->queue_nb) {
-		printf("Queue #%u is invalid\n", queue_id);
-		return -EINVAL;
-	}
-	job = calloc(1, sizeof(*job));
-	if (!job) {
-		printf("Queue action create job allocate failed\n");
-		return -ENOMEM;
-	}
-	job->type = QUEUE_JOB_TYPE_ACTION_CREATE;
-	job->pia = pia;
-
-	if (action->type == RTE_FLOW_ACTION_TYPE_AGE) {
-		struct rte_flow_action_age *age =
-			(struct rte_flow_action_age *)(uintptr_t)(action->conf);
-
-		pia->age_type = ACTION_AGE_CONTEXT_TYPE_INDIRECT_ACTION;
-		age->context = &pia->age_type;
-	}
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x88, sizeof(error));
-	pia->handle = rte_flow_async_action_handle_create(port_id, queue_id,
-					&attr, conf, action, job, &error);
-	if (!pia->handle) {
-		uint32_t destroy_id = pia->id;
-		port_queue_action_handle_destroy(port_id, queue_id,
-						 postpone, 1, &destroy_id);
-		free(job);
-		return port_flow_complain(&error);
-	}
-	pia->type = action->type;
-	printf("Indirect action #%u creation queued\n", pia->id);
-	return 0;
-}
-
-/** Enqueue indirect action destroy operation. */
-int
-port_queue_action_handle_destroy(portid_t port_id,
-				 uint32_t queue_id, bool postpone,
-				 uint32_t n, const uint32_t *actions)
-{
-	const struct rte_flow_op_attr attr = { .postpone = postpone};
-	struct rte_port *port;
-	struct port_indirect_action **tmp;
-	int ret = 0;
-	struct queue_job *job;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-
-	if (queue_id >= port->queue_nb) {
-		printf("Queue #%u is invalid\n", queue_id);
-		return -EINVAL;
-	}
-
-	tmp = &port->actions_list;
-	while (*tmp) {
-		uint32_t i;
-
-		for (i = 0; i != n; ++i) {
-			struct rte_flow_error error;
-			struct port_indirect_action *pia = *tmp;
-
-			if (actions[i] != pia->id)
-				continue;
-			/*
-			 * Poisoning to make sure PMDs update it in case
-			 * of error.
-			 */
-			memset(&error, 0x99, sizeof(error));
-			job = calloc(1, sizeof(*job));
-			if (!job) {
-				printf("Queue action destroy job allocate failed\n");
-				return -ENOMEM;
-			}
-			job->type = QUEUE_JOB_TYPE_ACTION_DESTROY;
-			job->pia = pia;
-
-			if (rte_flow_async_action_handle_destroy(port_id,
-				queue_id, &attr, pia->handle, job, &error)) {
-				free(job);
-				ret = port_flow_complain(&error);
-				continue;
-			}
-			*tmp = pia->next;
-			printf("Indirect action #%u destruction queued\n",
-			       pia->id);
-			break;
-		}
-		if (i == n)
-			tmp = &(*tmp)->next;
-	}
-	return ret;
-}
-
-/** Enqueue indirect action update operation. */
-int
-port_queue_action_handle_update(portid_t port_id,
-				uint32_t queue_id, bool postpone, uint32_t id,
-				const struct rte_flow_action *action)
-{
-	const struct rte_flow_op_attr attr = { .postpone = postpone};
-	struct rte_port *port;
-	struct rte_flow_error error;
-	struct rte_flow_action_handle *action_handle;
-	struct queue_job *job;
-	struct port_indirect_action *pia;
-	struct rte_flow_update_meter_mark mtr_update;
-	const void *update;
-
-	action_handle = port_action_handle_get_by_id(port_id, id);
-	if (!action_handle)
-		return -EINVAL;
-
-	port = &ports[port_id];
-	if (queue_id >= port->queue_nb) {
-		printf("Queue #%u is invalid\n", queue_id);
-		return -EINVAL;
-	}
-
-	job = calloc(1, sizeof(*job));
-	if (!job) {
-		printf("Queue action update job allocate failed\n");
-		return -ENOMEM;
-	}
-	job->type = QUEUE_JOB_TYPE_ACTION_UPDATE;
-
-	pia = action_get_by_id(port_id, id);
-	if (!pia) {
-		free(job);
-		return -EINVAL;
-	}
-
-	switch (pia->type) {
-	case RTE_FLOW_ACTION_TYPE_AGE:
-		update = action->conf;
-		break;
-	case RTE_FLOW_ACTION_TYPE_METER_MARK:
-		rte_memcpy(&mtr_update.meter_mark, action->conf,
-			sizeof(struct rte_flow_action_meter_mark));
-		if (mtr_update.meter_mark.profile)
-			mtr_update.profile_valid = 1;
-		if (mtr_update.meter_mark.policy)
-			mtr_update.policy_valid = 1;
-		mtr_update.color_mode_valid = 1;
-		mtr_update.init_color_valid = 1;
-		mtr_update.state_valid = 1;
-		update = &mtr_update;
-		break;
-	default:
-		update = action;
-		break;
-	}
-
-	if (rte_flow_async_action_handle_update(port_id, queue_id, &attr,
-				    action_handle, update, job, &error)) {
-		free(job);
-		return port_flow_complain(&error);
-	}
-	printf("Indirect action #%u update queued\n", id);
-	return 0;
-}
-
-/** Enqueue indirect action query operation. */
-int
-port_queue_action_handle_query(portid_t port_id,
-			       uint32_t queue_id, bool postpone, uint32_t id)
-{
-	const struct rte_flow_op_attr attr = { .postpone = postpone};
-	struct rte_port *port;
-	struct rte_flow_error error;
-	struct rte_flow_action_handle *action_handle;
-	struct port_indirect_action *pia;
-	struct queue_job *job;
-
-	pia = action_get_by_id(port_id, id);
-	action_handle = pia ? pia->handle : NULL;
-	if (!action_handle)
-		return -EINVAL;
-
-	port = &ports[port_id];
-	if (queue_id >= port->queue_nb) {
-		printf("Queue #%u is invalid\n", queue_id);
-		return -EINVAL;
-	}
-
-	job = calloc(1, sizeof(*job));
-	if (!job) {
-		printf("Queue action update job allocate failed\n");
-		return -ENOMEM;
-	}
-	job->type = QUEUE_JOB_TYPE_ACTION_QUERY;
-	job->pia = pia;
-
-	if (rte_flow_async_action_handle_query(port_id, queue_id, &attr,
-				    action_handle, &job->query, job, &error)) {
-		free(job);
-		return port_flow_complain(&error);
-	}
-	printf("Indirect action #%u update queued\n", id);
-	return 0;
-}
-
-/** Push all the queue operations in the queue to the NIC. */
-int
-port_queue_flow_push(portid_t port_id, queueid_t queue_id)
-{
-	struct rte_port *port;
-	struct rte_flow_error error;
-	int ret = 0;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-
-	if (queue_id >= port->queue_nb) {
-		printf("Queue #%u is invalid\n", queue_id);
-		return -EINVAL;
-	}
-
-	memset(&error, 0x55, sizeof(error));
-	ret = rte_flow_push(port_id, queue_id, &error);
-	if (ret < 0) {
-		printf("Failed to push operations in the queue\n");
-		return -EINVAL;
-	}
-	printf("Queue #%u operations pushed\n", queue_id);
-	return ret;
-}
-
-/** Pull queue operation results from the queue. */
-static int
-port_queue_aged_flow_destroy(portid_t port_id, queueid_t queue_id,
-			     const uint32_t *rule, int nb_flows)
-{
-	struct rte_port *port = &ports[port_id];
-	struct rte_flow_op_result *res;
-	struct rte_flow_error error;
-	uint32_t n = nb_flows;
-	int ret = 0;
-	int i;
-
-	res = calloc(port->queue_sz, sizeof(struct rte_flow_op_result));
-	if (!res) {
-		printf("Failed to allocate memory for pulled results\n");
-		return -ENOMEM;
-	}
-
-	memset(&error, 0x66, sizeof(error));
-	while (nb_flows > 0) {
-		int success = 0;
-
-		if (n > port->queue_sz)
-			n = port->queue_sz;
-		ret = port_queue_flow_destroy(port_id, queue_id, true, n, rule);
-		if (ret < 0) {
-			free(res);
-			return ret;
-		}
-		ret = rte_flow_push(port_id, queue_id, &error);
-		if (ret < 0) {
-			printf("Failed to push operations in the queue: %s\n",
-			       strerror(-ret));
-			free(res);
-			return ret;
-		}
-		while (success < nb_flows) {
-			ret = rte_flow_pull(port_id, queue_id, res,
-					    port->queue_sz, &error);
-			if (ret < 0) {
-				printf("Failed to pull a operation results: %s\n",
-				       strerror(-ret));
-				free(res);
-				return ret;
-			}
-
-			for (i = 0; i < ret; i++) {
-				if (res[i].status == RTE_FLOW_OP_SUCCESS)
-					success++;
-			}
-		}
-		rule += n;
-		nb_flows -= n;
-		n = nb_flows;
-	}
-
-	free(res);
-	return ret;
-}
-
-/** List simply and destroy all aged flows per queue. */
-void
-port_queue_flow_aged(portid_t port_id, uint32_t queue_id, uint8_t destroy)
-{
-	void **contexts;
-	int nb_context, total = 0, idx;
-	uint32_t *rules = NULL;
-	struct rte_port *port;
-	struct rte_flow_error error;
-	enum age_action_context_type *type;
-	union {
-		struct port_flow *pf;
-		struct port_indirect_action *pia;
-	} ctx;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return;
-	port = &ports[port_id];
-	if (queue_id >= port->queue_nb) {
-		printf("Error: queue #%u is invalid\n", queue_id);
-		return;
-	}
-	total = rte_flow_get_q_aged_flows(port_id, queue_id, NULL, 0, &error);
-	if (total < 0) {
-		port_flow_complain(&error);
-		return;
-	}
-	printf("Port %u queue %u total aged flows: %d\n",
-	       port_id, queue_id, total);
-	if (total == 0)
-		return;
-	contexts = calloc(total, sizeof(void *));
-	if (contexts == NULL) {
-		printf("Cannot allocate contexts for aged flow\n");
-		return;
-	}
-	printf("%-20s\tID\tGroup\tPrio\tAttr\n", "Type");
-	nb_context = rte_flow_get_q_aged_flows(port_id, queue_id, contexts,
-					       total, &error);
-	if (nb_context > total) {
-		printf("Port %u queue %u get aged flows count(%d) > total(%d)\n",
-		       port_id, queue_id, nb_context, total);
-		free(contexts);
-		return;
-	}
-	if (destroy) {
-		rules = malloc(sizeof(uint32_t) * nb_context);
-		if (rules == NULL)
-			printf("Cannot allocate memory for destroy aged flow\n");
-	}
-	total = 0;
-	for (idx = 0; idx < nb_context; idx++) {
-		if (!contexts[idx]) {
-			printf("Error: get Null context in port %u queue %u\n",
-			       port_id, queue_id);
-			continue;
-		}
-		type = (enum age_action_context_type *)contexts[idx];
-		switch (*type) {
-		case ACTION_AGE_CONTEXT_TYPE_FLOW:
-			ctx.pf = container_of(type, struct port_flow, age_type);
-			printf("%-20s\t%" PRIu32 "\t%" PRIu32 "\t%" PRIu32
-								 "\t%c%c%c\t\n",
-			       "Flow",
-			       ctx.pf->id,
-			       ctx.pf->rule.attr->group,
-			       ctx.pf->rule.attr->priority,
-			       ctx.pf->rule.attr->ingress ? 'i' : '-',
-			       ctx.pf->rule.attr->egress ? 'e' : '-',
-			       ctx.pf->rule.attr->transfer ? 't' : '-');
-			if (rules != NULL) {
-				rules[total] = ctx.pf->id;
-				total++;
-			}
-			break;
-		case ACTION_AGE_CONTEXT_TYPE_INDIRECT_ACTION:
-			ctx.pia = container_of(type,
-					       struct port_indirect_action,
-					       age_type);
-			printf("%-20s\t%" PRIu32 "\n", "Indirect action",
-			       ctx.pia->id);
-			break;
-		default:
-			printf("Error: invalid context type %u\n", port_id);
-			break;
-		}
-	}
-	if (rules != NULL) {
-		port_queue_aged_flow_destroy(port_id, queue_id, rules, total);
-		free(rules);
-	}
-	printf("\n%d flows destroyed\n", total);
-	free(contexts);
-}
-
-/** Pull queue operation results from the queue. */
-int
-port_queue_flow_pull(portid_t port_id, queueid_t queue_id)
-{
-	struct rte_port *port;
-	struct rte_flow_op_result *res;
-	struct rte_flow_error error;
-	int ret = 0;
-	int success = 0;
-	int i;
-	struct queue_job *job;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-
-	if (queue_id >= port->queue_nb) {
-		printf("Queue #%u is invalid\n", queue_id);
-		return -EINVAL;
-	}
-
-	res = calloc(port->queue_sz, sizeof(struct rte_flow_op_result));
-	if (!res) {
-		printf("Failed to allocate memory for pulled results\n");
-		return -ENOMEM;
-	}
-
-	memset(&error, 0x66, sizeof(error));
-	ret = rte_flow_pull(port_id, queue_id, res,
-				 port->queue_sz, &error);
-	if (ret < 0) {
-		printf("Failed to pull a operation results\n");
-		free(res);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < ret; i++) {
-		if (res[i].status == RTE_FLOW_OP_SUCCESS)
-			success++;
-		job = (struct queue_job *)res[i].user_data;
-		if (job->type == QUEUE_JOB_TYPE_FLOW_DESTROY)
-			free(job->pf);
-		else if (job->type == QUEUE_JOB_TYPE_ACTION_DESTROY)
-			free(job->pia);
-		else if (job->type == QUEUE_JOB_TYPE_ACTION_QUERY)
-			port_action_handle_query_dump(job->pia->type, &job->query);
-		free(job);
-	}
-	printf("Queue #%u pulled %u operations (%u failed, %u succeeded)\n",
-	       queue_id, ret, ret - success, success);
-	free(res);
-	return ret;
-}
-
 /** Create flow rule. */
 int
 port_flow_create(portid_t port_id,
 		 const struct rte_flow_attr *attr,
 		 const struct rte_flow_item *pattern,
-		 const struct rte_flow_action *actions,
-		 const struct tunnel_ops *tunnel_ops)
+		 const struct rte_flow_action *actions)
 {
 	struct rte_flow *flow;
 	struct rte_port *port;
 	struct port_flow *pf;
-	uint32_t id = 0;
+	uint32_t id;
 	struct rte_flow_error error;
-	struct port_flow_tunnel *pft = NULL;
-	struct rte_flow_action_age *age = age_action_get(actions);
 
+	/* Poisoning to make sure PMDs update it in case of error. */
+	memset(&error, 0x22, sizeof(error));
+	flow = rte_flow_create(port_id, attr, pattern, actions, &error);
+	if (!flow)
+		return port_flow_complain(&error);
 	port = &ports[port_id];
 	if (port->flow_list) {
 		if (port->flow_list->id == UINT32_MAX) {
-			fprintf(stderr,
-				"Highest rule ID is already assigned, delete it first");
+			printf("Highest rule ID is already assigned, delete"
+			       " it first");
+			rte_flow_destroy(port_id, flow, NULL);
 			return -ENOMEM;
 		}
 		id = port->flow_list->id + 1;
-	}
-	if (tunnel_ops->enabled) {
-		pft = port_flow_tunnel_offload_cmd_prep(port_id, pattern,
-							actions, tunnel_ops);
-		if (!pft)
-			return -ENOENT;
-		if (pft->items)
-			pattern = pft->items;
-		if (pft->actions)
-			actions = pft->actions;
-	}
+	} else
+		id = 0;
 	pf = port_flow_new(attr, pattern, actions, &error);
-	if (!pf)
-		return port_flow_complain(&error);
-	if (age) {
-		pf->age_type = ACTION_AGE_CONTEXT_TYPE_FLOW;
-		age->context = &pf->age_type;
-	}
-	/* Poisoning to make sure PMDs update it in case of error. */
-	memset(&error, 0x22, sizeof(error));
-	flow = rte_flow_create(port_id, attr, pattern, actions, &error);
-	if (!flow) {
-		if (tunnel_ops->enabled)
-			port_flow_tunnel_offload_cmd_release(port_id,
-							     tunnel_ops, pft);
-		free(pf);
+	if (!pf) {
+		rte_flow_destroy(port_id, flow, NULL);
 		return port_flow_complain(&error);
 	}
 	pf->next = port->flow_list;
 	pf->id = id;
 	pf->flow = flow;
 	port->flow_list = pf;
-	if (tunnel_ops->enabled)
-		port_flow_tunnel_offload_cmd_release(port_id, tunnel_ops, pft);
 	printf("Flow rule #%u created\n", pf->id);
 	return 0;
 }
@@ -3306,6 +1377,7 @@
 {
 	struct rte_port *port;
 	struct port_flow **tmp;
+	uint32_t c = 0;
 	int ret = 0;
 
 	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
@@ -3338,6 +1410,7 @@
 		}
 		if (i == n)
 			tmp = &(*tmp)->next;
+		++c;
 	}
 	return ret;
 }
@@ -3350,21 +1423,15 @@
 	struct rte_port *port;
 	int ret = 0;
 
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-		port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-
-	port = &ports[port_id];
-
-	if (port->flow_list == NULL)
-		return ret;
-
 	/* Poisoning to make sure PMDs update it in case of error. */
 	memset(&error, 0x44, sizeof(error));
 	if (rte_flow_flush(port_id, &error)) {
-		port_flow_complain(&error);
+		ret = port_flow_complain(&error);
+		if (port_id_is_invalid(port_id, DISABLED_WARN) ||
+		    port_id == (portid_t)RTE_PORT_ALL)
+			return ret;
 	}
-
+	port = &ports[port_id];
 	while (port->flow_list) {
 		struct port_flow *pf = port->flow_list->next;
 
@@ -3374,65 +1441,6 @@
 	return ret;
 }
 
-/** Dump flow rules. */
-int
-port_flow_dump(portid_t port_id, bool dump_all, uint32_t rule_id,
-		const char *file_name)
-{
-	int ret = 0;
-	FILE *file = stdout;
-	struct rte_flow_error error;
-	struct rte_port *port;
-	struct port_flow *pflow;
-	struct rte_flow *tmpFlow = NULL;
-	bool found = false;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-		port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-
-	if (!dump_all) {
-		port = &ports[port_id];
-		pflow = port->flow_list;
-		while (pflow) {
-			if (rule_id != pflow->id) {
-				pflow = pflow->next;
-			} else {
-				tmpFlow = pflow->flow;
-				if (tmpFlow)
-					found = true;
-				break;
-			}
-		}
-		if (found == false) {
-			fprintf(stderr, "Failed to dump to flow %d\n", rule_id);
-			return -EINVAL;
-		}
-	}
-
-	if (file_name && strlen(file_name)) {
-		file = fopen(file_name, "w");
-		if (!file) {
-			fprintf(stderr, "Failed to create file %s: %s\n",
-				file_name, strerror(errno));
-			return -errno;
-		}
-	}
-
-	if (!dump_all)
-		ret = rte_flow_dev_dump(port_id, tmpFlow, file, &error);
-	else
-		ret = rte_flow_dev_dump(port_id, NULL, file, &error);
-	if (ret) {
-		port_flow_complain(&error);
-		fprintf(stderr, "Failed to dump flow: %s\n", strerror(-ret));
-	} else
-		printf("Flow dump finished\n");
-	if (file_name && strlen(file_name))
-		fclose(file);
-	return ret;
-}
-
 /** Query a flow rule. */
 int
 port_flow_query(portid_t port_id, uint32_t rule,
@@ -3444,8 +1452,6 @@
 	const char *name;
 	union {
 		struct rte_flow_query_count count;
-		struct rte_flow_action_rss rss_conf;
-		struct rte_flow_query_age age;
 	} query;
 	int ret;
 
@@ -3457,7 +1463,7 @@
 		if (pf->id == rule)
 			break;
 	if (!pf) {
-		fprintf(stderr, "Flow rule #%u not found\n", rule);
+		printf("Flow rule #%u not found\n", rule);
 		return -ENOENT;
 	}
 	ret = rte_flow_conv(RTE_FLOW_CONV_OP_ACTION_NAME_PTR,
@@ -3467,11 +1473,9 @@
 		return port_flow_complain(&error);
 	switch (action->type) {
 	case RTE_FLOW_ACTION_TYPE_COUNT:
-	case RTE_FLOW_ACTION_TYPE_RSS:
-	case RTE_FLOW_ACTION_TYPE_AGE:
 		break;
 	default:
-		fprintf(stderr, "Cannot query action type %d (%s)\n",
+		printf("Cannot query action type %d (%s)\n",
 			action->type, name);
 		return -ENOTSUP;
 	}
@@ -3493,109 +1497,17 @@
 		       query.count.hits,
 		       query.count.bytes);
 		break;
-	case RTE_FLOW_ACTION_TYPE_RSS:
-		rss_config_display(&query.rss_conf);
-		break;
-	case RTE_FLOW_ACTION_TYPE_AGE:
-		printf("%s:\n"
-		       " aged: %u\n"
-		       " sec_since_last_hit_valid: %u\n"
-		       " sec_since_last_hit: %" PRIu32 "\n",
-		       name,
-		       query.age.aged,
-		       query.age.sec_since_last_hit_valid,
-		       query.age.sec_since_last_hit);
-		break;
 	default:
-		fprintf(stderr,
-			"Cannot display result for action type %d (%s)\n",
-			action->type, name);
+		printf("Cannot display result for action type %d (%s)\n",
+		       action->type, name);
 		break;
 	}
 	return 0;
 }
 
-/** List simply and destroy all aged flows. */
-void
-port_flow_aged(portid_t port_id, uint8_t destroy)
-{
-	void **contexts;
-	int nb_context, total = 0, idx;
-	struct rte_flow_error error;
-	enum age_action_context_type *type;
-	union {
-		struct port_flow *pf;
-		struct port_indirect_action *pia;
-	} ctx;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return;
-	total = rte_flow_get_aged_flows(port_id, NULL, 0, &error);
-	printf("Port %u total aged flows: %d\n", port_id, total);
-	if (total < 0) {
-		port_flow_complain(&error);
-		return;
-	}
-	if (total == 0)
-		return;
-	contexts = malloc(sizeof(void *) * total);
-	if (contexts == NULL) {
-		fprintf(stderr, "Cannot allocate contexts for aged flow\n");
-		return;
-	}
-	printf("%-20s\tID\tGroup\tPrio\tAttr\n", "Type");
-	nb_context = rte_flow_get_aged_flows(port_id, contexts, total, &error);
-	if (nb_context != total) {
-		fprintf(stderr,
-			"Port:%d get aged flows count(%d) != total(%d)\n",
-			port_id, nb_context, total);
-		free(contexts);
-		return;
-	}
-	total = 0;
-	for (idx = 0; idx < nb_context; idx++) {
-		if (!contexts[idx]) {
-			fprintf(stderr, "Error: get Null context in port %u\n",
-				port_id);
-			continue;
-		}
-		type = (enum age_action_context_type *)contexts[idx];
-		switch (*type) {
-		case ACTION_AGE_CONTEXT_TYPE_FLOW:
-			ctx.pf = container_of(type, struct port_flow, age_type);
-			printf("%-20s\t%" PRIu32 "\t%" PRIu32 "\t%" PRIu32
-								 "\t%c%c%c\t\n",
-			       "Flow",
-			       ctx.pf->id,
-			       ctx.pf->rule.attr->group,
-			       ctx.pf->rule.attr->priority,
-			       ctx.pf->rule.attr->ingress ? 'i' : '-',
-			       ctx.pf->rule.attr->egress ? 'e' : '-',
-			       ctx.pf->rule.attr->transfer ? 't' : '-');
-			if (destroy && !port_flow_destroy(port_id, 1,
-							  &ctx.pf->id))
-				total++;
-			break;
-		case ACTION_AGE_CONTEXT_TYPE_INDIRECT_ACTION:
-			ctx.pia = container_of(type,
-					struct port_indirect_action, age_type);
-			printf("%-20s\t%" PRIu32 "\n", "Indirect action",
-			       ctx.pia->id);
-			break;
-		default:
-			fprintf(stderr, "Error: invalid context type %u\n",
-				port_id);
-			break;
-		}
-	}
-	printf("\n%d flows destroyed\n", total);
-	free(contexts);
-}
-
 /** List flow rules. */
 void
-port_flow_list(portid_t port_id, uint32_t n, const uint32_t *group)
+port_flow_list(portid_t port_id, uint32_t n, const uint32_t group[n])
 {
 	struct rte_port *port;
 	struct port_flow *pf;
@@ -3650,9 +1562,7 @@
 		       pf->rule.attr->egress ? 'e' : '-',
 		       pf->rule.attr->transfer ? 't' : '-');
 		while (item->type != RTE_FLOW_ITEM_TYPE_END) {
-			if ((uint32_t)item->type > INT_MAX)
-				name = "PMD_INTERNAL";
-			else if (rte_flow_conv(RTE_FLOW_CONV_OP_ITEM_NAME_PTR,
+			if (rte_flow_conv(RTE_FLOW_CONV_OP_ITEM_NAME_PTR,
 					  &name, sizeof(name),
 					  (void *)(uintptr_t)item->type,
 					  NULL) <= 0)
@@ -3663,9 +1573,7 @@
 		}
 		printf("=>");
 		while (action->type != RTE_FLOW_ACTION_TYPE_END) {
-			if ((uint32_t)action->type > INT_MAX)
-				name = "PMD_INTERNAL";
-			else if (rte_flow_conv(RTE_FLOW_CONV_OP_ACTION_NAME_PTR,
+			if (rte_flow_conv(RTE_FLOW_CONV_OP_ACTION_NAME_PTR,
 					  &name, sizeof(name),
 					  (void *)(uintptr_t)action->type,
 					  NULL) <= 0)
@@ -3702,8 +1610,7 @@
 {
 	if (rxq_id < nb_rxq)
 		return 0;
-	fprintf(stderr, "Invalid RX queue %d (must be < nb_rxq=%d)\n",
-		rxq_id, nb_rxq);
+	printf("Invalid RX queue %d (must be < nb_rxq=%d)\n", rxq_id, nb_rxq);
 	return 1;
 }
 
@@ -3712,108 +1619,27 @@
 {
 	if (txq_id < nb_txq)
 		return 0;
-	fprintf(stderr, "Invalid TX queue %d (must be < nb_txq=%d)\n",
-		txq_id, nb_txq);
+	printf("Invalid TX queue %d (must be < nb_rxq=%d)\n", txq_id, nb_txq);
 	return 1;
 }
 
 static int
-get_rx_ring_size(portid_t port_id, queueid_t rxq_id, uint16_t *ring_size)
-{
-	struct rte_port *port = &ports[port_id];
-	struct rte_eth_rxq_info rx_qinfo;
-	int ret;
-
-	ret = rte_eth_rx_queue_info_get(port_id, rxq_id, &rx_qinfo);
-	if (ret == 0) {
-		*ring_size = rx_qinfo.nb_desc;
-		return ret;
-	}
-
-	if (ret != -ENOTSUP)
-		return ret;
-	/*
-	 * If the rte_eth_rx_queue_info_get is not support for this PMD,
-	 * ring_size stored in testpmd will be used for validity verification.
-	 * When configure the rxq by rte_eth_rx_queue_setup with nb_rx_desc
-	 * being 0, it will use a default value provided by PMDs to setup this
-	 * rxq. If the default value is 0, it will use the
-	 * RTE_ETH_DEV_FALLBACK_RX_RINGSIZE to setup this rxq.
-	 */
-	if (port->nb_rx_desc[rxq_id])
-		*ring_size = port->nb_rx_desc[rxq_id];
-	else if (port->dev_info.default_rxportconf.ring_size)
-		*ring_size = port->dev_info.default_rxportconf.ring_size;
-	else
-		*ring_size = RTE_ETH_DEV_FALLBACK_RX_RINGSIZE;
-	return 0;
-}
-
-static int
-get_tx_ring_size(portid_t port_id, queueid_t txq_id, uint16_t *ring_size)
-{
-	struct rte_port *port = &ports[port_id];
-	struct rte_eth_txq_info tx_qinfo;
-	int ret;
-
-	ret = rte_eth_tx_queue_info_get(port_id, txq_id, &tx_qinfo);
-	if (ret == 0) {
-		*ring_size = tx_qinfo.nb_desc;
-		return ret;
-	}
-
-	if (ret != -ENOTSUP)
-		return ret;
-	/*
-	 * If the rte_eth_tx_queue_info_get is not support for this PMD,
-	 * ring_size stored in testpmd will be used for validity verification.
-	 * When configure the txq by rte_eth_tx_queue_setup with nb_tx_desc
-	 * being 0, it will use a default value provided by PMDs to setup this
-	 * txq. If the default value is 0, it will use the
-	 * RTE_ETH_DEV_FALLBACK_TX_RINGSIZE to setup this txq.
-	 */
-	if (port->nb_tx_desc[txq_id])
-		*ring_size = port->nb_tx_desc[txq_id];
-	else if (port->dev_info.default_txportconf.ring_size)
-		*ring_size = port->dev_info.default_txportconf.ring_size;
-	else
-		*ring_size = RTE_ETH_DEV_FALLBACK_TX_RINGSIZE;
-	return 0;
-}
-
-static int
-rx_desc_id_is_invalid(portid_t port_id, queueid_t rxq_id, uint16_t rxdesc_id)
+rx_desc_id_is_invalid(uint16_t rxdesc_id)
 {
-	uint16_t ring_size;
-	int ret;
-
-	ret = get_rx_ring_size(port_id, rxq_id, &ring_size);
-	if (ret)
-		return 1;
-
-	if (rxdesc_id < ring_size)
+	if (rxdesc_id < nb_rxd)
 		return 0;
-
-	fprintf(stderr, "Invalid RX descriptor %u (must be < ring_size=%u)\n",
-		rxdesc_id, ring_size);
+	printf("Invalid RX descriptor %d (must be < nb_rxd=%d)\n",
+	       rxdesc_id, nb_rxd);
 	return 1;
 }
 
 static int
-tx_desc_id_is_invalid(portid_t port_id, queueid_t txq_id, uint16_t txdesc_id)
+tx_desc_id_is_invalid(uint16_t txdesc_id)
 {
-	uint16_t ring_size;
-	int ret;
-
-	ret = get_tx_ring_size(port_id, txq_id, &ring_size);
-	if (ret)
-		return 1;
-
-	if (txdesc_id < ring_size)
+	if (txdesc_id < nb_txd)
 		return 0;
-
-	fprintf(stderr, "Invalid TX descriptor %u (must be < ring_size=%u)\n",
-		txdesc_id, ring_size);
+	printf("Invalid TX descriptor %d (must be < nb_txd=%d)\n",
+	       txdesc_id, nb_txd);
 	return 1;
 }
 
@@ -3827,9 +1653,9 @@
 			port_id, q_id, ring_name);
 	mz = rte_memzone_lookup(mz_name);
 	if (mz == NULL)
-		fprintf(stderr,
-			"%s ring memory zoneof (port %d, queue %d) not found (zone name = %s\n",
-			ring_name, port_id, q_id, mz_name);
+		printf("%s ring memory zoneof (port %d, queue %d) not"
+		       "found (zone name = %s\n",
+		       ring_name, port_id, q_id, mz_name);
 	return mz;
 }
 
@@ -3934,7 +1760,11 @@
 {
 	const struct rte_memzone *rx_mz;
 
-	if (rx_desc_id_is_invalid(port_id, rxq_id, rxd_id))
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+	if (rx_queue_id_is_invalid(rxq_id))
+		return;
+	if (rx_desc_id_is_invalid(rxd_id))
 		return;
 	rx_mz = ring_dma_zone_lookup("rx_ring", port_id, rxq_id);
 	if (rx_mz == NULL)
@@ -3947,7 +1777,11 @@
 {
 	const struct rte_memzone *tx_mz;
 
-	if (tx_desc_id_is_invalid(port_id, txq_id, txd_id))
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+	if (tx_queue_id_is_invalid(txq_id))
+		return;
+	if (tx_desc_id_is_invalid(txd_id))
 		return;
 	tx_mz = ring_dma_zone_lookup("tx_ring", port_id, txq_id);
 	if (tx_mz == NULL)
@@ -3984,21 +1818,14 @@
 	       nb_fwd_lcores, nb_fwd_ports);
 
 	RTE_ETH_FOREACH_DEV(pid) {
-		struct rte_eth_rxconf *rx_conf = &ports[pid].rxq[0].conf;
-		struct rte_eth_txconf *tx_conf = &ports[pid].txq[0].conf;
+		struct rte_eth_rxconf *rx_conf = &ports[pid].rx_conf[0];
+		struct rte_eth_txconf *tx_conf = &ports[pid].tx_conf[0];
 		uint16_t *nb_rx_desc = &ports[pid].nb_rx_desc[0];
 		uint16_t *nb_tx_desc = &ports[pid].nb_tx_desc[0];
-		struct rte_eth_rxq_info rx_qinfo;
-		struct rte_eth_txq_info tx_qinfo;
-		uint16_t rx_free_thresh_tmp;
-		uint16_t tx_free_thresh_tmp;
-		uint16_t tx_rs_thresh_tmp;
 		uint16_t nb_rx_desc_tmp;
 		uint16_t nb_tx_desc_tmp;
-		uint64_t offloads_tmp;
-		uint8_t pthresh_tmp;
-		uint8_t hthresh_tmp;
-		uint8_t wthresh_tmp;
+		struct rte_eth_rxq_info rx_qinfo;
+		struct rte_eth_txq_info tx_qinfo;
 		int32_t rc;
 
 		/* per port config */
@@ -4012,69 +1839,41 @@
 		/* per rx queue config only for first queue to be less verbose */
 		for (qid = 0; qid < 1; qid++) {
 			rc = rte_eth_rx_queue_info_get(pid, qid, &rx_qinfo);
-			if (rc) {
+			if (rc)
 				nb_rx_desc_tmp = nb_rx_desc[qid];
-				rx_free_thresh_tmp =
-					rx_conf[qid].rx_free_thresh;
-				pthresh_tmp = rx_conf[qid].rx_thresh.pthresh;
-				hthresh_tmp = rx_conf[qid].rx_thresh.hthresh;
-				wthresh_tmp = rx_conf[qid].rx_thresh.wthresh;
-				offloads_tmp = rx_conf[qid].offloads;
-			} else {
+			else
 				nb_rx_desc_tmp = rx_qinfo.nb_desc;
-				rx_free_thresh_tmp =
-						rx_qinfo.conf.rx_free_thresh;
-				pthresh_tmp = rx_qinfo.conf.rx_thresh.pthresh;
-				hthresh_tmp = rx_qinfo.conf.rx_thresh.hthresh;
-				wthresh_tmp = rx_qinfo.conf.rx_thresh.wthresh;
-				offloads_tmp = rx_qinfo.conf.offloads;
-			}
 
 			printf("    RX queue: %d\n", qid);
 			printf("      RX desc=%d - RX free threshold=%d\n",
-				nb_rx_desc_tmp, rx_free_thresh_tmp);
+				nb_rx_desc_tmp, rx_conf[qid].rx_free_thresh);
 			printf("      RX threshold registers: pthresh=%d hthresh=%d "
 				" wthresh=%d\n",
-				pthresh_tmp, hthresh_tmp, wthresh_tmp);
-			printf("      RX Offloads=0x%"PRIx64, offloads_tmp);
-			if (rx_conf->share_group > 0)
-				printf(" share_group=%u share_qid=%u",
-				       rx_conf->share_group,
-				       rx_conf->share_qid);
-			printf("\n");
+				rx_conf[qid].rx_thresh.pthresh,
+				rx_conf[qid].rx_thresh.hthresh,
+				rx_conf[qid].rx_thresh.wthresh);
+			printf("      RX Offloads=0x%"PRIx64"\n",
+				rx_conf[qid].offloads);
 		}
 
 		/* per tx queue config only for first queue to be less verbose */
 		for (qid = 0; qid < 1; qid++) {
 			rc = rte_eth_tx_queue_info_get(pid, qid, &tx_qinfo);
-			if (rc) {
+			if (rc)
 				nb_tx_desc_tmp = nb_tx_desc[qid];
-				tx_free_thresh_tmp =
-					tx_conf[qid].tx_free_thresh;
-				pthresh_tmp = tx_conf[qid].tx_thresh.pthresh;
-				hthresh_tmp = tx_conf[qid].tx_thresh.hthresh;
-				wthresh_tmp = tx_conf[qid].tx_thresh.wthresh;
-				offloads_tmp = tx_conf[qid].offloads;
-				tx_rs_thresh_tmp = tx_conf[qid].tx_rs_thresh;
-			} else {
+			else
 				nb_tx_desc_tmp = tx_qinfo.nb_desc;
-				tx_free_thresh_tmp =
-						tx_qinfo.conf.tx_free_thresh;
-				pthresh_tmp = tx_qinfo.conf.tx_thresh.pthresh;
-				hthresh_tmp = tx_qinfo.conf.tx_thresh.hthresh;
-				wthresh_tmp = tx_qinfo.conf.tx_thresh.wthresh;
-				offloads_tmp = tx_qinfo.conf.offloads;
-				tx_rs_thresh_tmp = tx_qinfo.conf.tx_rs_thresh;
-			}
 
 			printf("    TX queue: %d\n", qid);
 			printf("      TX desc=%d - TX free threshold=%d\n",
-				nb_tx_desc_tmp, tx_free_thresh_tmp);
+				nb_tx_desc_tmp, tx_conf[qid].tx_free_thresh);
 			printf("      TX threshold registers: pthresh=%d hthresh=%d "
 				" wthresh=%d\n",
-				pthresh_tmp, hthresh_tmp, wthresh_tmp);
+				tx_conf[qid].tx_thresh.pthresh,
+				tx_conf[qid].tx_thresh.hthresh,
+				tx_conf[qid].tx_thresh.wthresh);
 			printf("      TX offloads=0x%"PRIx64" - TX RS bit threshold=%d\n",
-				offloads_tmp, tx_rs_thresh_tmp);
+				tx_conf[qid].offloads, tx_conf->tx_rs_thresh);
 		}
 	}
 }
@@ -4092,15 +1891,13 @@
 
 	ret = rte_eth_dev_rss_reta_query(port_id, reta_conf, nb_entries);
 	if (ret != 0) {
-		fprintf(stderr,
-			"Failed to get RSS RETA info, return code = %d\n",
-			ret);
+		printf("Failed to get RSS RETA info, return code = %d\n", ret);
 		return;
 	}
 
 	for (i = 0; i < nb_entries; i++) {
-		idx = i / RTE_ETH_RETA_GROUP_SIZE;
-		shift = i % RTE_ETH_RETA_GROUP_SIZE;
+		idx = i / RTE_RETA_GROUP_SIZE;
+		shift = i % RTE_RETA_GROUP_SIZE;
 		if (!(reta_conf[idx].mask & (1ULL << shift)))
 			continue;
 		printf("RSS RETA configuration: hash index=%u, queue=%u\n",
@@ -4109,7 +1906,7 @@
 }
 
 /*
- * Displays the RSS hash functions of a port, and, optionally, the RSS hash
+ * Displays the RSS hash functions of a port, and, optionaly, the RSS hash
  * key of the port.
  */
 void
@@ -4135,8 +1932,7 @@
 			dev_info.hash_key_size <= sizeof(rss_key))
 		hash_key_size = dev_info.hash_key_size;
 	else {
-		fprintf(stderr,
-			"dev_info did not provide a valid hash key size\n");
+		printf("dev_info did not provide a valid hash key size\n");
 		return;
 	}
 
@@ -4147,13 +1943,13 @@
 	if (diag != 0) {
 		switch (diag) {
 		case -ENODEV:
-			fprintf(stderr, "port index %d invalid\n", port_id);
+			printf("port index %d invalid\n", port_id);
 			break;
 		case -ENOTSUP:
-			fprintf(stderr, "operation not supported by device\n");
+			printf("operation not supported by device\n");
 			break;
 		default:
-			fprintf(stderr, "operation failed - diag=%d\n", diag);
+			printf("operation failed - diag=%d\n", diag);
 			break;
 		}
 		return;
@@ -4163,8 +1959,12 @@
 		printf("RSS disabled\n");
 		return;
 	}
-	printf("RSS functions:\n");
-	rss_types_display(rss_hf, TESTPMD_RSS_TYPES_CHAR_NUM_PER_LINE);
+	printf("RSS functions:\n ");
+	for (i = 0; rss_type_table[i].str; i++) {
+		if (rss_hf & rss_type_table[i].rss_type)
+			printf("%s ", rss_type_table[i].str);
+	}
+	printf("\n");
 	if (!show_rss_key)
 		return;
 	printf("RSS key:\n");
@@ -4175,18 +1975,22 @@
 
 void
 port_rss_hash_key_update(portid_t port_id, char rss_type[], uint8_t *hash_key,
-			 uint8_t hash_key_len)
+			 uint hash_key_len)
 {
 	struct rte_eth_rss_conf rss_conf;
 	int diag;
+	unsigned int i;
 
 	rss_conf.rss_key = NULL;
-	rss_conf.rss_key_len = 0;
-	rss_conf.rss_hf = str_to_rsstypes(rss_type);
+	rss_conf.rss_key_len = hash_key_len;
+	rss_conf.rss_hf = 0;
+	for (i = 0; rss_type_table[i].str; i++) {
+		if (!strcmp(rss_type_table[i].str, rss_type))
+			rss_conf.rss_hf = rss_type_table[i].rss_type;
+	}
 	diag = rte_eth_dev_rss_hash_conf_get(port_id, &rss_conf);
 	if (diag == 0) {
 		rss_conf.rss_key = hash_key;
-		rss_conf.rss_key_len = hash_key_len;
 		diag = rte_eth_dev_rss_hash_update(port_id, &rss_conf);
 	}
 	if (diag == 0)
@@ -4194,123 +1998,18 @@
 
 	switch (diag) {
 	case -ENODEV:
-		fprintf(stderr, "port index %d invalid\n", port_id);
+		printf("port index %d invalid\n", port_id);
 		break;
 	case -ENOTSUP:
-		fprintf(stderr, "operation not supported by device\n");
+		printf("operation not supported by device\n");
 		break;
 	default:
-		fprintf(stderr, "operation failed - diag=%d\n", diag);
+		printf("operation failed - diag=%d\n", diag);
 		break;
 	}
 }
 
 /*
- * Check whether a shared rxq scheduled on other lcores.
- */
-static bool
-fwd_stream_on_other_lcores(uint16_t domain_id, lcoreid_t src_lc,
-			   portid_t src_port, queueid_t src_rxq,
-			   uint32_t share_group, queueid_t share_rxq)
-{
-	streamid_t sm_id;
-	streamid_t nb_fs_per_lcore;
-	lcoreid_t  nb_fc;
-	lcoreid_t  lc_id;
-	struct fwd_stream *fs;
-	struct rte_port *port;
-	struct rte_eth_dev_info *dev_info;
-	struct rte_eth_rxconf *rxq_conf;
-
-	nb_fc = cur_fwd_config.nb_fwd_lcores;
-	/* Check remaining cores. */
-	for (lc_id = src_lc + 1; lc_id < nb_fc; lc_id++) {
-		sm_id = fwd_lcores[lc_id]->stream_idx;
-		nb_fs_per_lcore = fwd_lcores[lc_id]->stream_nb;
-		for (; sm_id < fwd_lcores[lc_id]->stream_idx + nb_fs_per_lcore;
-		     sm_id++) {
-			fs = fwd_streams[sm_id];
-			port = &ports[fs->rx_port];
-			dev_info = &port->dev_info;
-			rxq_conf = &port->rxq[fs->rx_queue].conf;
-			if ((dev_info->dev_capa & RTE_ETH_DEV_CAPA_RXQ_SHARE)
-			    == 0 || rxq_conf->share_group == 0)
-				/* Not shared rxq. */
-				continue;
-			if (domain_id != port->dev_info.switch_info.domain_id)
-				continue;
-			if (rxq_conf->share_group != share_group)
-				continue;
-			if (rxq_conf->share_qid != share_rxq)
-				continue;
-			printf("Shared Rx queue group %u queue %hu can't be scheduled on different cores:\n",
-			       share_group, share_rxq);
-			printf("  lcore %hhu Port %hu queue %hu\n",
-			       src_lc, src_port, src_rxq);
-			printf("  lcore %hhu Port %hu queue %hu\n",
-			       lc_id, fs->rx_port, fs->rx_queue);
-			printf("Please use --nb-cores=%hu to limit number of forwarding cores\n",
-			       nb_rxq);
-			return true;
-		}
-	}
-	return false;
-}
-
-/*
- * Check shared rxq configuration.
- *
- * Shared group must not being scheduled on different core.
- */
-bool
-pkt_fwd_shared_rxq_check(void)
-{
-	streamid_t sm_id;
-	streamid_t nb_fs_per_lcore;
-	lcoreid_t  nb_fc;
-	lcoreid_t  lc_id;
-	struct fwd_stream *fs;
-	uint16_t domain_id;
-	struct rte_port *port;
-	struct rte_eth_dev_info *dev_info;
-	struct rte_eth_rxconf *rxq_conf;
-
-	if (rxq_share == 0)
-		return true;
-	nb_fc = cur_fwd_config.nb_fwd_lcores;
-	/*
-	 * Check streams on each core, make sure the same switch domain +
-	 * group + queue doesn't get scheduled on other cores.
-	 */
-	for (lc_id = 0; lc_id < nb_fc; lc_id++) {
-		sm_id = fwd_lcores[lc_id]->stream_idx;
-		nb_fs_per_lcore = fwd_lcores[lc_id]->stream_nb;
-		for (; sm_id < fwd_lcores[lc_id]->stream_idx + nb_fs_per_lcore;
-		     sm_id++) {
-			fs = fwd_streams[sm_id];
-			/* Update lcore info stream being scheduled. */
-			fs->lcore = fwd_lcores[lc_id];
-			port = &ports[fs->rx_port];
-			dev_info = &port->dev_info;
-			rxq_conf = &port->rxq[fs->rx_queue].conf;
-			if ((dev_info->dev_capa & RTE_ETH_DEV_CAPA_RXQ_SHARE)
-			    == 0 || rxq_conf->share_group == 0)
-				/* Not shared rxq. */
-				continue;
-			/* Check shared rxq not scheduled on remaining cores. */
-			domain_id = port->dev_info.switch_info.domain_id;
-			if (fwd_stream_on_other_lcores(domain_id, lc_id,
-						       fs->rx_port,
-						       fs->rx_queue,
-						       rxq_conf->share_group,
-						       rxq_conf->share_qid))
-				return false;
-		}
-	}
-	return true;
-}
-
-/*
  * Setup forwarding configuration for each logical core.
  */
 static void
@@ -4367,8 +2066,10 @@
 			if (rxp + 1 < cur_fwd_config.nb_fwd_ports)
 				return rxp + 1;
 			if (warning_once) {
-				fprintf(stderr,
-					"\nWarning! port-topology=paired and odd forward ports number, the last port will pair with itself.\n\n");
+				printf("\nWarning! port-topology=paired"
+				       " and odd forward ports number,"
+				       " the last port will pair with"
+				       " itself.\n\n");
 				warning_once = 0;
 			}
 			return rxp;
@@ -4414,6 +2115,139 @@
 	}
 }
 
+static void
+lb_fwd_config_setup_sm(struct fwd_stream *fs, portid_t rxp, portid_t txp, portid_t rxp_index, queueid_t queue, uint8_t generate)
+{
+	fs->rx_port = rxp;
+	fs->rx_queue = queue;
+	fs->tx_port = txp;
+	fs->tx_queue = queue;
+	if (generate == 0)
+	{
+		fs->peer_addr = rxp_index;
+		fs->generate = 0;
+	}
+	else
+	{
+		fs->peer_addr = nb_fwd_ports;
+		fs->generate = 1;
+	}
+	fs->retry_enabled = retry_enabled;
+}
+
+static void
+lb_fwd_config_setup_4ports_bi(void)
+{
+	portid_t   rxp;
+	queueid_t  rxq;
+	queueid_t  nb_q;
+	streamid_t sm_id;
+	portid_t  *dut_fwd_ports, *gen_fwd_ports;
+	uint32_t   nb_dut_fwd_ports, nb_gen_fwd_ports;
+	uint32_t   i, j;
+	char name[RTE_ETH_NAME_MAX_LEN];
+	uint8_t dut_pci_found;
+	struct rte_pci_addr port_pci;
+
+	nb_q = nb_rxq;
+	if (nb_q > nb_txq)
+		nb_q = nb_txq;
+	cur_fwd_config.nb_fwd_lcores = (lcoreid_t) nb_fwd_lcores;
+	cur_fwd_config.nb_fwd_ports = nb_fwd_ports;
+	cur_fwd_config.nb_fwd_streams =
+		(streamid_t) (nb_q * cur_fwd_config.nb_fwd_ports);
+
+	if (cur_fwd_config.nb_fwd_streams < cur_fwd_config.nb_fwd_lcores)
+		cur_fwd_config.nb_fwd_lcores =
+			(lcoreid_t)cur_fwd_config.nb_fwd_streams;
+
+	/* reinitialize forwarding streams */
+	init_fwd_streams();
+
+	if (2 * nb_lb_dut_pcis != nb_fwd_ports)
+	{
+		printf("Number of ports: %u\n", nb_fwd_ports);
+		printf("Number of DUT PCIs: %u\n", nb_lb_dut_pcis);
+		rte_exit(-1, "Number DUT ports should be half of total number of ports\n");
+		return;
+	}
+
+	dut_fwd_ports = malloc(nb_lb_dut_pcis * sizeof(portid_t));
+	nb_dut_fwd_ports = 0;
+	gen_fwd_ports = malloc(nb_lb_dut_pcis * sizeof(portid_t));
+	nb_gen_fwd_ports = 0;
+	for (i = 0; i < nb_fwd_ports; i++)
+	{
+		rte_eth_dev_get_name_by_port(fwd_ports_ids[i], name);
+		printf("Port(%u) PCI(%s)\n", i, name);
+	}
+	for (i = 0; i < nb_fwd_ports; i++)
+	{
+		dut_pci_found = 0;
+		rte_eth_dev_get_name_by_port(fwd_ports_ids[i], name);
+		rte_pci_addr_parse(name, &port_pci);
+		for (j = 0; j < nb_lb_dut_pcis; j++)
+		{
+			if (0 == rte_pci_addr_cmp(&port_pci, &lb_dut_pcis[j]))
+			{
+				dut_pci_found = 1;
+			}
+		}
+
+		if (dut_pci_found == 1)
+			dut_fwd_ports[nb_dut_fwd_ports++] = fwd_ports_ids[i];
+		else
+			gen_fwd_ports[nb_gen_fwd_ports++] = fwd_ports_ids[i];
+	}
+
+	if (nb_dut_fwd_ports != nb_gen_fwd_ports)
+	{
+		rte_exit(1, "Packet generator and DUT ports should match");
+		return;
+	}
+
+	setup_fwd_config_of_each_lcore(&cur_fwd_config);
+	rxp = 0; rxq = 0;
+	for (sm_id = 0; sm_id < cur_fwd_config.nb_fwd_streams - 1; sm_id++, sm_id++) {
+		struct fwd_stream *fs_gen, *fs_dut;
+
+		fs_gen = fwd_streams[sm_id];
+		fs_dut = fwd_streams[sm_id + 1];
+
+		lb_fwd_config_setup_sm(fs_gen, gen_fwd_ports[rxp], dut_fwd_ports[rxp], rxp, rxq, 1);
+		lb_fwd_config_setup_sm(fs_dut, dut_fwd_ports[rxp], gen_fwd_ports[rxp], rxp, rxq, 0);
+
+		rxp++;
+		if (rxp < nb_dut_fwd_ports)
+			continue;
+		rxp = 0;
+		rxq++;
+	}
+}
+
+/**
+ * For TestPMD as load balancer setup
+ * Possible combinations:
+ * 4 Ports Bi  - 2 ports connected to Packet Generator, 2 ports connected to DUT
+ * 4 Ports Uni - Each port with with Packet Gen input, DUT input, DUT output, Packet Gen output in single direction
+ * 2 Ports Bi  - 2 ports connected to both Packet Generator and DUT
+ * 2 Ports Bi DSR - 2 ports connected to both Packet Generator and DUT. DUT return path is direct to Packet Gen
+ */
+static void
+lb_fwd_config_setup(void)
+{
+	if (nb_fwd_ports % 4 == 0)
+	{
+		printf("4 ports configured for load balancer with bi-directional traffic\n");
+		lb_fwd_config_setup_4ports_bi();
+	}
+	else
+	{
+		rte_exit(1, "configuration is not supported");
+		return;
+	}
+}
+
 /**
  * For the RSS forwarding test all streams distributed over lcores. Each stream
  * being composed of a RX queue to poll on a RX port for input messages,
@@ -4427,8 +2261,6 @@
 	queueid_t  rxq;
 	queueid_t  nb_q;
 	streamid_t  sm_id;
-	int start;
-	int end;
 
 	nb_q = nb_rxq;
 	if (nb_q > nb_txq)
@@ -4446,21 +2278,7 @@
 	init_fwd_streams();
 
 	setup_fwd_config_of_each_lcore(&cur_fwd_config);
-
-	if (proc_id > 0 && nb_q % num_procs != 0)
-		printf("Warning! queue numbers should be multiple of processes, or packet loss will happen.\n");
-
-	/**
-	 * In multi-process, All queues are allocated to different
-	 * processes based on num_procs and proc_id. For example:
-	 * if supports 4 queues(nb_q), 2 processes(num_procs),
-	 * the 0~1 queue for primary process.
-	 * the 2~3 queue for secondary process.
-	 */
-	start = proc_id * nb_q / num_procs;
-	end = start + nb_q / num_procs;
-	rxp = 0;
-	rxq = start;
+	rxp = 0; rxq = 0;
 	for (sm_id = 0; sm_id < cur_fwd_config.nb_fwd_streams; sm_id++) {
 		struct fwd_stream *fs;
 
@@ -4477,26 +2295,9 @@
 			continue;
 		rxp = 0;
 		rxq++;
-		if (rxq >= end)
-			rxq = start;
 	}
 }
 
-static uint16_t
-get_fwd_port_total_tc_num(void)
-{
-	struct rte_eth_dcb_info dcb_info;
-	uint16_t total_tc_num = 0;
-	unsigned int i;
-
-	for (i = 0; i < nb_fwd_ports; i++) {
-		(void)rte_eth_dev_get_dcb_info(fwd_ports_ids[i], &dcb_info);
-		total_tc_num += dcb_info.nb_tcs;
-	}
-
-	return total_tc_num;
-}
-
 /**
  * For the DCB forwarding test, each core is assigned on each traffic class.
  *
@@ -4516,43 +2317,12 @@
 	lcoreid_t  lc_id;
 	uint16_t nb_rx_queue, nb_tx_queue;
 	uint16_t i, j, k, sm_id = 0;
-	uint16_t total_tc_num;
-	struct rte_port *port;
 	uint8_t tc = 0;
-	portid_t pid;
-	int ret;
-
-	/*
-	 * The fwd_config_setup() is called when the port is RTE_PORT_STARTED
-	 * or RTE_PORT_STOPPED.
-	 *
-	 * Re-configure ports to get updated mapping between tc and queue in
-	 * case the queue number of the port is changed. Skip for started ports
-	 * since modifying queue number and calling dev_configure need to stop
-	 * ports first.
-	 */
-	for (pid = 0; pid < nb_fwd_ports; pid++) {
-		if (port_is_started(pid) == 1)
-			continue;
-
-		port = &ports[pid];
-		ret = rte_eth_dev_configure(pid, nb_rxq, nb_txq,
-					    &port->dev_conf);
-		if (ret < 0) {
-			fprintf(stderr,
-				"Failed to re-configure port %d, ret = %d.\n",
-				pid, ret);
-			return;
-		}
-	}
 
 	cur_fwd_config.nb_fwd_lcores = (lcoreid_t) nb_fwd_lcores;
 	cur_fwd_config.nb_fwd_ports = nb_fwd_ports;
 	cur_fwd_config.nb_fwd_streams =
 		(streamid_t) (nb_rxq * cur_fwd_config.nb_fwd_ports);
-	total_tc_num = get_fwd_port_total_tc_num();
-	if (cur_fwd_config.nb_fwd_lcores > total_tc_num)
-		cur_fwd_config.nb_fwd_lcores = total_tc_num;
 
 	/* reinitialize forwarding streams */
 	init_fwd_streams();
@@ -4565,7 +2335,7 @@
 	for (lc_id = 0; lc_id < cur_fwd_config.nb_fwd_lcores; lc_id++) {
 		fwd_lcores[lc_id]->stream_nb = 0;
 		fwd_lcores[lc_id]->stream_idx = sm_id;
-		for (i = 0; i < RTE_ETH_MAX_VMDQ_POOL; i++) {
+		for (i = 0; i < ETH_MAX_VMDQ_POOL; i++) {
 			/* if the nb_queue is zero, means this tc is
 			 * not enabled on the POOL
 			 */
@@ -4671,38 +2441,77 @@
 	}
 }
 
-void
-fwd_config_setup(void)
+#if defined RTE_LIBRTE_PMD_SOFTNIC
+static void
+softnic_fwd_config_setup(void)
 {
 	struct rte_port *port;
-	portid_t pt_id;
-	unsigned int i;
+	portid_t pid, softnic_portid;
+	queueid_t i;
+	uint8_t softnic_enable = 0;
+
+	RTE_ETH_FOREACH_DEV(pid) {
+			port = &ports[pid];
+			const char *driver = port->dev_info.driver_name;
+
+			if (strcmp(driver, "net_softnic") == 0) {
+				softnic_portid = pid;
+				softnic_enable = 1;
+				break;
+			}
+	}
+
+	if (softnic_enable == 0) {
+		printf("Softnic mode not configured(%s)!\n", __func__);
+		return;
+	}
+
+	cur_fwd_config.nb_fwd_ports = 1;
+	cur_fwd_config.nb_fwd_streams = (streamid_t) nb_rxq;
+
+	/* Re-initialize forwarding streams */
+	init_fwd_streams();
+
+	/*
+	 * In the softnic forwarding test, the number of forwarding cores
+	 * is set to one and remaining are used for softnic packet processing.
+	 */
+	cur_fwd_config.nb_fwd_lcores = 1;
+	setup_fwd_config_of_each_lcore(&cur_fwd_config);
+
+	for (i = 0; i < cur_fwd_config.nb_fwd_streams; i++) {
+		fwd_streams[i]->rx_port   = softnic_portid;
+		fwd_streams[i]->rx_queue  = i;
+		fwd_streams[i]->tx_port   = softnic_portid;
+		fwd_streams[i]->tx_queue  = i;
+		fwd_streams[i]->peer_addr = fwd_streams[i]->tx_port;
+		fwd_streams[i]->retry_enabled = retry_enabled;
+	}
+}
+#endif
 
+void
+fwd_config_setup(void)
+{
 	cur_fwd_config.fwd_eng = cur_fwd_eng;
 	if (strcmp(cur_fwd_eng->fwd_mode_name, "icmpecho") == 0) {
 		icmp_echo_config_setup();
 		return;
 	}
 
-	if ((nb_rxq > 1) && (nb_txq > 1)){
-		if (dcb_config) {
-			for (i = 0; i < nb_fwd_ports; i++) {
-				pt_id = fwd_ports_ids[i];
-				port = &ports[pt_id];
-				if (!port->dcb_flag) {
-					fprintf(stderr,
-						"In DCB mode, all forwarding ports must be configured in this mode.\n");
-					return;
-				}
-			}
-			if (nb_fwd_lcores == 1) {
-				fprintf(stderr,
-					"In DCB mode,the nb forwarding cores should be larger than 1.\n");
-				return;
-			}
+#if defined RTE_LIBRTE_PMD_SOFTNIC
+	if (strcmp(cur_fwd_eng->fwd_mode_name, "softnic") == 0) {
+		softnic_fwd_config_setup();
+		return;
+	}
+#endif
 
+	if (lb_enabled == 1)
+		lb_fwd_config_setup();
+	else if ((nb_rxq > 1) && (nb_txq > 1)){
+		if (dcb_config)
 			dcb_fwd_config_setup();
-		} else
+		else
 			rss_fwd_config_setup();
 	}
 	else
@@ -4721,8 +2530,6 @@
 		return "xmem";
 	case MP_ALLOC_XMEM_HUGE:
 		return "xmemhuge";
-	case MP_ALLOC_XBUF:
-		return "xbuf";
 	default:
 		return "invalid";
 	}
@@ -4773,12 +2580,11 @@
 {
 	struct rte_ether_addr new_peer_addr;
 	if (!rte_eth_dev_is_valid_port(port_id)) {
-		fprintf(stderr, "Error: Invalid port number %i\n", port_id);
+		printf("Error: Invalid port number %i\n", port_id);
 		return;
 	}
 	if (rte_ether_unformat_addr(peer_addr, &new_peer_addr) < 0) {
-		fprintf(stderr, "Error: Invalid ethernet address: %s\n",
-			peer_addr);
+		printf("Error: Invalid ethernet address: %s\n", peer_addr);
 		return;
 	}
 	peer_eth_addrs[port_id] = new_peer_addr;
@@ -4796,13 +2602,14 @@
 	for (i = 0; i < nb_lc; i++) {
 		lcore_cpuid = lcorelist[i];
 		if (! rte_lcore_is_enabled(lcore_cpuid)) {
-			fprintf(stderr, "lcore %u not enabled\n", lcore_cpuid);
+			printf("lcore %u not enabled\n", lcore_cpuid);
 			return -1;
 		}
-		if (lcore_cpuid == rte_get_main_lcore()) {
-			fprintf(stderr,
-				"lcore %u cannot be masked on for running packet forwarding, which is the main lcore and reserved for command line parsing only\n",
-				lcore_cpuid);
+		if (lcore_cpuid == rte_get_master_lcore()) {
+			printf("lcore %u cannot be masked on for running "
+			       "packet forwarding, which is the master lcore "
+			       "and reserved for command line parsing only\n",
+			       lcore_cpuid);
 			return -1;
 		}
 		if (record_now)
@@ -4831,7 +2638,7 @@
 	unsigned int i;
 
 	if (lcoremask == 0) {
-		fprintf(stderr, "Invalid NULL mask of cores\n");
+		printf("Invalid NULL mask of cores\n");
 		return -1;
 	}
 	nb_lc = 0;
@@ -4846,14 +2653,10 @@
 void
 set_fwd_lcores_number(uint16_t nb_lc)
 {
-	if (test_done == 0) {
-		fprintf(stderr, "Please stop forwarding first\n");
-		return;
-	}
 	if (nb_lc > nb_cfg_lcores) {
-		fprintf(stderr,
-			"nb fwd cores %u > %u (max. number of configured lcores) - ignored\n",
-			(unsigned int) nb_lc, (unsigned int) nb_cfg_lcores);
+		printf("nb fwd cores %u > %u (max. number of configured "
+		       "lcores) - ignored\n",
+		       (unsigned int) nb_lc, (unsigned int) nb_cfg_lcores);
 		return;
 	}
 	nb_fwd_lcores = (lcoreid_t) nb_lc;
@@ -4890,112 +2693,6 @@
 	}
 }
 
-/**
- * Parse the user input and obtain the list of forwarding ports
- *
- * @param[in] list
- *   String containing the user input. User can specify
- *   in these formats 1,3,5 or 1-3 or 1-2,5 or 3,5-6.
- *   For example, if the user wants to use all the available
- *   4 ports in his system, then the input can be 0-3 or 0,1,2,3.
- *   If the user wants to use only the ports 1,2 then the input
- *   is 1,2.
- *   valid characters are '-' and ','
- * @param[out] values
- *   This array will be filled with a list of port IDs
- *   based on the user input
- *   Note that duplicate entries are discarded and only the first
- *   count entries in this array are port IDs and all the rest
- *   will contain default values
- * @param[in] maxsize
- *   This parameter denotes 2 things
- *   1) Number of elements in the values array
- *   2) Maximum value of each element in the values array
- * @return
- *   On success, returns total count of parsed port IDs
- *   On failure, returns 0
- */
-static unsigned int
-parse_port_list(const char *list, unsigned int *values, unsigned int maxsize)
-{
-	unsigned int count = 0;
-	char *end = NULL;
-	int min, max;
-	int value, i;
-	unsigned int marked[maxsize];
-
-	if (list == NULL || values == NULL)
-		return 0;
-
-	for (i = 0; i < (int)maxsize; i++)
-		marked[i] = 0;
-
-	min = INT_MAX;
-
-	do {
-		/*Remove the blank spaces if any*/
-		while (isblank(*list))
-			list++;
-		if (*list == '\0')
-			break;
-		errno = 0;
-		value = strtol(list, &end, 10);
-		if (errno || end == NULL)
-			return 0;
-		if (value < 0 || value >= (int)maxsize)
-			return 0;
-		while (isblank(*end))
-			end++;
-		if (*end == '-' && min == INT_MAX) {
-			min = value;
-		} else if ((*end == ',') || (*end == '\0')) {
-			max = value;
-			if (min == INT_MAX)
-				min = value;
-			for (i = min; i <= max; i++) {
-				if (count < maxsize) {
-					if (marked[i])
-						continue;
-					values[count] = i;
-					marked[i] = 1;
-					count++;
-				}
-			}
-			min = INT_MAX;
-		} else
-			return 0;
-		list = end + 1;
-	} while (*end != '\0');
-
-	return count;
-}
-
-void
-parse_fwd_portlist(const char *portlist)
-{
-	unsigned int portcount;
-	unsigned int portindex[RTE_MAX_ETHPORTS];
-	unsigned int i, valid_port_count = 0;
-
-	portcount = parse_port_list(portlist, portindex, RTE_MAX_ETHPORTS);
-	if (!portcount)
-		rte_exit(EXIT_FAILURE, "Invalid fwd port list\n");
-
-	/*
-	 * Here we verify the validity of the ports
-	 * and thereby calculate the total number of
-	 * valid ports
-	 */
-	for (i = 0; i < portcount && i < RTE_DIM(portindex); i++) {
-		if (rte_eth_dev_is_valid_port(portindex[i])) {
-			portindex[valid_port_count] = portindex[i];
-			valid_port_count++;
-		}
-	}
-
-	set_fwd_ports_list(portindex, valid_port_count);
-}
-
 void
 set_fwd_ports_mask(uint64_t portmask)
 {
@@ -5004,7 +2701,7 @@
 	unsigned int i;
 
 	if (portmask == 0) {
-		fprintf(stderr, "Invalid NULL mask of ports\n");
+		printf("Invalid NULL mask of ports\n");
 		return;
 	}
 	nb_pt = 0;
@@ -5020,9 +2717,9 @@
 set_fwd_ports_number(uint16_t nb_pt)
 {
 	if (nb_pt > nb_cfg_ports) {
-		fprintf(stderr,
-			"nb fwd ports %u > %u (number of configured ports) - ignored\n",
-			(unsigned int) nb_pt, (unsigned int) nb_cfg_ports);
+		printf("nb fwd ports %u > %u (number of configured "
+		       "ports) - ignored\n",
+		       (unsigned int) nb_pt, (unsigned int) nb_cfg_ports);
 		return;
 	}
 	nb_fwd_ports = (portid_t) nb_pt;
@@ -5050,9 +2747,9 @@
 set_nb_pkt_per_burst(uint16_t nb)
 {
 	if (nb > MAX_PKT_BURST) {
-		fprintf(stderr,
-			"nb pkt per burst: %u > %u (maximum packet per burst)  ignored\n",
-			(unsigned int) nb, (unsigned int) MAX_PKT_BURST);
+		printf("nb pkt per burst: %u > %u (maximum packet per burst) "
+		       " ignored\n",
+		       (unsigned int) nb, (unsigned int) MAX_PKT_BURST);
 		return;
 	}
 	nb_pkt_per_burst = nb;
@@ -5083,244 +2780,7 @@
 			return;
 		}
 	}
-	fprintf(stderr, "unknown value: \"%s\"\n", name);
-}
-
-int
-parse_fec_mode(const char *name, uint32_t *fec_capa)
-{
-	uint8_t i;
-
-	for (i = 0; i < RTE_DIM(fec_mode_name); i++) {
-		if (strcmp(fec_mode_name[i].name, name) == 0) {
-			*fec_capa =
-				RTE_ETH_FEC_MODE_TO_CAPA(fec_mode_name[i].mode);
-			return 0;
-		}
-	}
-	return -1;
-}
-
-void
-show_fec_capability(unsigned int num, struct rte_eth_fec_capa *speed_fec_capa)
-{
-	unsigned int i, j;
-
-	printf("FEC capabilities:\n");
-
-	for (i = 0; i < num; i++) {
-		printf("%s : ",
-			rte_eth_link_speed_to_str(speed_fec_capa[i].speed));
-
-		for (j = 0; j < RTE_DIM(fec_mode_name); j++) {
-			if (RTE_ETH_FEC_MODE_TO_CAPA(j) &
-						speed_fec_capa[i].capa)
-				printf("%s ", fec_mode_name[j].name);
-		}
-		printf("\n");
-	}
-}
-
-void
-show_rx_pkt_offsets(void)
-{
-	uint32_t i, n;
-
-	n = rx_pkt_nb_offs;
-	printf("Number of offsets: %u\n", n);
-	if (n) {
-		printf("Segment offsets: ");
-		for (i = 0; i != n - 1; i++)
-			printf("%hu,", rx_pkt_seg_offsets[i]);
-		printf("%hu\n", rx_pkt_seg_lengths[i]);
-	}
-}
-
-void
-set_rx_pkt_offsets(unsigned int *seg_offsets, unsigned int nb_offs)
-{
-	unsigned int i;
-
-	if (nb_offs >= MAX_SEGS_BUFFER_SPLIT) {
-		printf("nb segments per RX packets=%u >= "
-		       "MAX_SEGS_BUFFER_SPLIT - ignored\n", nb_offs);
-		return;
-	}
-
-	/*
-	 * No extra check here, the segment length will be checked by PMD
-	 * in the extended queue setup.
-	 */
-	for (i = 0; i < nb_offs; i++) {
-		if (seg_offsets[i] >= UINT16_MAX) {
-			printf("offset[%u]=%u > UINT16_MAX - give up\n",
-			       i, seg_offsets[i]);
-			return;
-		}
-	}
-
-	for (i = 0; i < nb_offs; i++)
-		rx_pkt_seg_offsets[i] = (uint16_t) seg_offsets[i];
-
-	rx_pkt_nb_offs = (uint8_t) nb_offs;
-}
-
-void
-show_rx_pkt_segments(void)
-{
-	uint32_t i, n;
-
-	n = rx_pkt_nb_segs;
-	printf("Number of segments: %u\n", n);
-	if (n) {
-		printf("Segment sizes: ");
-		for (i = 0; i != n - 1; i++)
-			printf("%hu,", rx_pkt_seg_lengths[i]);
-		printf("%hu\n", rx_pkt_seg_lengths[i]);
-	}
-}
-
-static const char *get_ptype_str(uint32_t ptype)
-{
-	const char *str;
-
-	switch (ptype) {
-	case RTE_PTYPE_L2_ETHER:
-		str = "eth";
-		break;
-	case RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4_EXT_UNKNOWN:
-		str = "ipv4";
-		break;
-	case RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV6_EXT_UNKNOWN:
-		str = "ipv6";
-		break;
-	case RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_L4_TCP:
-		str = "ipv4-tcp";
-		break;
-	case RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_L4_UDP:
-		str = "ipv4-udp";
-		break;
-	case RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_L4_SCTP:
-		str = "ipv4-sctp";
-		break;
-	case RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_L4_TCP:
-		str = "ipv6-tcp";
-		break;
-	case RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_L4_UDP:
-		str = "ipv6-udp";
-		break;
-	case RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_L4_SCTP:
-		str = "ipv6-sctp";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT:
-		str = "grenat";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER:
-		str = "inner-eth";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER
-			| RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN:
-		str = "inner-ipv4";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER
-			| RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN:
-		str = "inner-ipv6";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-			RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_TCP:
-		str = "inner-ipv4-tcp";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-			RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_UDP:
-		str = "inner-ipv4-udp";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-			RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_SCTP:
-		str = "inner-ipv4-sctp";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-			RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_TCP:
-		str = "inner-ipv6-tcp";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-			RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_UDP:
-		str = "inner-ipv6-udp";
-		break;
-	case RTE_PTYPE_TUNNEL_GRENAT | RTE_PTYPE_INNER_L2_ETHER |
-			RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN | RTE_PTYPE_INNER_L4_SCTP:
-		str = "inner-ipv6-sctp";
-		break;
-	default:
-		str = "unsupported";
-	}
-
-	return str;
-}
-
-void
-show_rx_pkt_hdrs(void)
-{
-	uint32_t i, n;
-
-	n = rx_pkt_nb_segs;
-	printf("Number of segments: %u\n", n);
-	if (n) {
-		printf("Packet segs: ");
-		for (i = 0; i < n - 1; i++)
-			printf("%s, ", get_ptype_str(rx_pkt_hdr_protos[i]));
-		printf("payload\n");
-	}
-}
-
-void
-set_rx_pkt_hdrs(unsigned int *seg_hdrs, unsigned int nb_segs)
-{
-	unsigned int i;
-
-	if (nb_segs + 1 > MAX_SEGS_BUFFER_SPLIT) {
-		printf("nb segments per RX packets=%u > "
-		       "MAX_SEGS_BUFFER_SPLIT - ignored\n", nb_segs + 1);
-		return;
-	}
-
-	memset(rx_pkt_hdr_protos, 0, sizeof(rx_pkt_hdr_protos));
-
-	for (i = 0; i < nb_segs; i++)
-		rx_pkt_hdr_protos[i] = (uint32_t)seg_hdrs[i];
-	/*
-	 * We calculate the number of hdrs, but payload is not included,
-	 * so rx_pkt_nb_segs would increase 1.
-	 */
-	rx_pkt_nb_segs = nb_segs + 1;
-}
-
-void
-set_rx_pkt_segments(unsigned int *seg_lengths, unsigned int nb_segs)
-{
-	unsigned int i;
-
-	if (nb_segs >= MAX_SEGS_BUFFER_SPLIT) {
-		printf("nb segments per RX packets=%u >= "
-		       "MAX_SEGS_BUFFER_SPLIT - ignored\n", nb_segs);
-		return;
-	}
-
-	/*
-	 * No extra check here, the segment length will be checked by PMD
-	 * in the extended queue setup.
-	 */
-	for (i = 0; i < nb_segs; i++) {
-		if (seg_lengths[i] >= UINT16_MAX) {
-			printf("length[%u]=%u > UINT16_MAX - give up\n",
-			       i, seg_lengths[i]);
-			return;
-		}
-	}
-
-	for (i = 0; i < nb_segs; i++)
-		rx_pkt_seg_lengths[i] = (uint16_t) seg_lengths[i];
-
-	rx_pkt_nb_segs = (uint8_t) nb_segs;
+	printf("unknown value: \"%s\"\n", name);
 }
 
 void
@@ -5340,79 +2800,36 @@
 	printf("Split packet: %s\n", split);
 }
 
-static bool
-nb_segs_is_invalid(unsigned int nb_segs)
-{
-	uint16_t ring_size;
-	uint16_t queue_id;
-	uint16_t port_id;
-	int ret;
-
-	RTE_ETH_FOREACH_DEV(port_id) {
-		for (queue_id = 0; queue_id < nb_txq; queue_id++) {
-			ret = get_tx_ring_size(port_id, queue_id, &ring_size);
-			if (ret) {
-				/* Port may not be initialized yet, can't say
-				 * the port is invalid in this stage.
-				 */
-				continue;
-			}
-			if (ring_size < nb_segs) {
-				printf("nb segments per TX packets=%u >= TX "
-				       "queue(%u) ring_size=%u - txpkts ignored\n",
-				       nb_segs, queue_id, ring_size);
-				return true;
-			}
-		}
-	}
-
-	return false;
-}
-
 void
-set_tx_pkt_segments(unsigned int *seg_lengths, unsigned int nb_segs)
+set_tx_pkt_segments(unsigned *seg_lengths, unsigned nb_segs)
 {
 	uint16_t tx_pkt_len;
-	unsigned int i;
-
-	/*
-	 * For single segment settings failed check is ignored.
-	 * It is a very basic capability to send the single segment
-	 * packets, suppose it is always supported.
-	 */
-	if (nb_segs > 1 && nb_segs_is_invalid(nb_segs)) {
-		fprintf(stderr,
-			"Tx segment size(%u) is not supported - txpkts ignored\n",
-			nb_segs);
-		return;
-	}
+	unsigned i;
 
-	if (nb_segs > RTE_MAX_SEGS_PER_PKT) {
-		fprintf(stderr,
-			"Tx segment size(%u) is bigger than max number of segment(%u)\n",
-			nb_segs, RTE_MAX_SEGS_PER_PKT);
+	if (nb_segs >= (unsigned) nb_txd) {
+		printf("nb segments per TX packets=%u >= nb_txd=%u - ignored\n",
+		       nb_segs, (unsigned int) nb_txd);
 		return;
 	}
 
 	/*
 	 * Check that each segment length is greater or equal than
-	 * the mbuf data size.
+	 * the mbuf data sise.
 	 * Check also that the total packet length is greater or equal than the
 	 * size of an empty UDP/IP packet (sizeof(struct rte_ether_hdr) +
 	 * 20 + 8).
 	 */
 	tx_pkt_len = 0;
 	for (i = 0; i < nb_segs; i++) {
-		if (seg_lengths[i] > mbuf_data_size[0]) {
-			fprintf(stderr,
-				"length[%u]=%u > mbuf_data_size=%u - give up\n",
-				i, seg_lengths[i], mbuf_data_size[0]);
+		if (seg_lengths[i] > (unsigned) mbuf_data_size) {
+			printf("length[%u]=%u > mbuf_data_size=%u - give up\n",
+			       i, seg_lengths[i], (unsigned) mbuf_data_size);
 			return;
 		}
 		tx_pkt_len = (uint16_t)(tx_pkt_len + seg_lengths[i]);
 	}
 	if (tx_pkt_len < (sizeof(struct rte_ether_hdr) + 20 + 8)) {
-		fprintf(stderr, "total packet length=%u < %d - give up\n",
+		printf("total packet length=%u < %d - give up\n",
 				(unsigned) tx_pkt_len,
 				(int)(sizeof(struct rte_ether_hdr) + 20 + 8));
 		return;
@@ -5426,37 +2843,21 @@
 }
 
 void
-show_tx_pkt_times(void)
-{
-	printf("Interburst gap: %u\n", tx_pkt_times_inter);
-	printf("Intraburst gap: %u\n", tx_pkt_times_intra);
-}
-
-void
-set_tx_pkt_times(unsigned int *tx_times)
-{
-	tx_pkt_times_inter = tx_times[0];
-	tx_pkt_times_intra = tx_times[1];
-}
-
-#ifdef RTE_LIB_GRO
-void
 setup_gro(const char *onoff, portid_t port_id)
 {
 	if (!rte_eth_dev_is_valid_port(port_id)) {
-		fprintf(stderr, "invalid port id %u\n", port_id);
+		printf("invalid port id %u\n", port_id);
 		return;
 	}
 	if (test_done == 0) {
-		fprintf(stderr,
-			"Before enable/disable GRO, please stop forwarding first\n");
+		printf("Before enable/disable GRO,"
+				" please stop forwarding first\n");
 		return;
 	}
 	if (strcmp(onoff, "on") == 0) {
 		if (gro_ports[port_id].enable != 0) {
-			fprintf(stderr,
-				"Port %u has enabled GRO. Please disable GRO first\n",
-				port_id);
+			printf("Port %u has enabled GRO. Please"
+					" disable GRO first\n", port_id);
 			return;
 		}
 		if (gro_flush_cycles == GRO_DEFAULT_FLUSH_CYCLES) {
@@ -5469,7 +2870,7 @@
 		gro_ports[port_id].enable = 1;
 	} else {
 		if (gro_ports[port_id].enable == 0) {
-			fprintf(stderr, "Port %u has disabled GRO\n", port_id);
+			printf("Port %u has disabled GRO\n", port_id);
 			return;
 		}
 		gro_ports[port_id].enable = 0;
@@ -5480,16 +2881,18 @@
 setup_gro_flush_cycles(uint8_t cycles)
 {
 	if (test_done == 0) {
-		fprintf(stderr,
-			"Before change flush interval for GRO, please stop forwarding first.\n");
+		printf("Before change flush interval for GRO,"
+				" please stop forwarding first.\n");
 		return;
 	}
 
 	if (cycles > GRO_MAX_FLUSH_CYCLES || cycles <
 			GRO_DEFAULT_FLUSH_CYCLES) {
-		fprintf(stderr,
-			"The flushing cycle be in the range of 1 to %u. Revert to the default value %u.\n",
-			GRO_MAX_FLUSH_CYCLES, GRO_DEFAULT_FLUSH_CYCLES);
+		printf("The flushing cycle be in the range"
+				" of 1 to %u. Revert to the default"
+				" value %u.\n",
+				GRO_MAX_FLUSH_CYCLES,
+				GRO_DEFAULT_FLUSH_CYCLES);
 		cycles = GRO_DEFAULT_FLUSH_CYCLES;
 	}
 
@@ -5505,7 +2908,7 @@
 	param = &gro_ports[port_id].param;
 
 	if (!rte_eth_dev_is_valid_port(port_id)) {
-		fprintf(stderr, "Invalid port id %u.\n", port_id);
+		printf("Invalid port id %u.\n", port_id);
 		return;
 	}
 	if (gro_ports[port_id].enable) {
@@ -5521,33 +2924,30 @@
 	} else
 		printf("Port %u doesn't enable GRO.\n", port_id);
 }
-#endif /* RTE_LIB_GRO */
 
-#ifdef RTE_LIB_GSO
 void
 setup_gso(const char *mode, portid_t port_id)
 {
 	if (!rte_eth_dev_is_valid_port(port_id)) {
-		fprintf(stderr, "invalid port id %u\n", port_id);
+		printf("invalid port id %u\n", port_id);
 		return;
 	}
 	if (strcmp(mode, "on") == 0) {
 		if (test_done == 0) {
-			fprintf(stderr,
-				"before enabling GSO, please stop forwarding first\n");
+			printf("before enabling GSO,"
+					" please stop forwarding first\n");
 			return;
 		}
 		gso_ports[port_id].enable = 1;
 	} else if (strcmp(mode, "off") == 0) {
 		if (test_done == 0) {
-			fprintf(stderr,
-				"before disabling GSO, please stop forwarding first\n");
+			printf("before disabling GSO,"
+					" please stop forwarding first\n");
 			return;
 		}
 		gso_ports[port_id].enable = 0;
 	}
 }
-#endif /* RTE_LIB_GSO */
 
 char*
 list_pkt_forwarding_modes(void)
@@ -5612,7 +3012,7 @@
 		}
 		i++;
 	}
-	fprintf(stderr, "Invalid %s packet forwarding mode\n", fwd_mode_name);
+	printf("Invalid %s packet forwarding mode\n", fwd_mode_name);
 }
 
 void
@@ -5746,20 +3146,17 @@
 	vlan_offload = rte_eth_dev_get_vlan_offload(port_id);
 
 	if (on) {
-		vlan_offload |= RTE_ETH_VLAN_EXTEND_OFFLOAD;
-		port_rx_offloads |= RTE_ETH_RX_OFFLOAD_VLAN_EXTEND;
+		vlan_offload |= ETH_VLAN_EXTEND_OFFLOAD;
+		port_rx_offloads |= DEV_RX_OFFLOAD_VLAN_EXTEND;
 	} else {
-		vlan_offload &= ~RTE_ETH_VLAN_EXTEND_OFFLOAD;
-		port_rx_offloads &= ~RTE_ETH_RX_OFFLOAD_VLAN_EXTEND;
+		vlan_offload &= ~ETH_VLAN_EXTEND_OFFLOAD;
+		port_rx_offloads &= ~DEV_RX_OFFLOAD_VLAN_EXTEND;
 	}
 
 	diag = rte_eth_dev_set_vlan_offload(port_id, vlan_offload);
-	if (diag < 0) {
-		fprintf(stderr,
-			"rx_vlan_extend_set(port_pi=%d, on=%d) failed diag=%d\n",
-			port_id, on, diag);
-		return;
-	}
+	if (diag < 0)
+		printf("rx_vlan_extend_set(port_pi=%d, on=%d) failed "
+	       "diag=%d\n", port_id, on, diag);
 	ports[port_id].dev_conf.rxmode.offloads = port_rx_offloads;
 }
 
@@ -5776,20 +3173,17 @@
 	vlan_offload = rte_eth_dev_get_vlan_offload(port_id);
 
 	if (on) {
-		vlan_offload |= RTE_ETH_VLAN_STRIP_OFFLOAD;
-		port_rx_offloads |= RTE_ETH_RX_OFFLOAD_VLAN_STRIP;
+		vlan_offload |= ETH_VLAN_STRIP_OFFLOAD;
+		port_rx_offloads |= DEV_RX_OFFLOAD_VLAN_STRIP;
 	} else {
-		vlan_offload &= ~RTE_ETH_VLAN_STRIP_OFFLOAD;
-		port_rx_offloads &= ~RTE_ETH_RX_OFFLOAD_VLAN_STRIP;
+		vlan_offload &= ~ETH_VLAN_STRIP_OFFLOAD;
+		port_rx_offloads &= ~DEV_RX_OFFLOAD_VLAN_STRIP;
 	}
 
 	diag = rte_eth_dev_set_vlan_offload(port_id, vlan_offload);
-	if (diag < 0) {
-		fprintf(stderr,
-			"%s(port_pi=%d, on=%d) failed diag=%d\n",
-			__func__, port_id, on, diag);
-		return;
-	}
+	if (diag < 0)
+		printf("rx_vlan_strip_set(port_pi=%d, on=%d) failed "
+	       "diag=%d\n", port_id, on, diag);
 	ports[port_id].dev_conf.rxmode.offloads = port_rx_offloads;
 }
 
@@ -5803,9 +3197,8 @@
 
 	diag = rte_eth_dev_set_vlan_strip_on_queue(port_id, queue_id, on);
 	if (diag < 0)
-		fprintf(stderr,
-			"%s(port_pi=%d, queue_id=%d, on=%d) failed diag=%d\n",
-			__func__, port_id, queue_id, on, diag);
+		printf("rx_vlan_strip_set_on_queue(port_pi=%d, queue_id=%d, on=%d) failed "
+	       "diag=%d\n", port_id, queue_id, on, diag);
 }
 
 void
@@ -5821,20 +3214,17 @@
 	vlan_offload = rte_eth_dev_get_vlan_offload(port_id);
 
 	if (on) {
-		vlan_offload |= RTE_ETH_VLAN_FILTER_OFFLOAD;
-		port_rx_offloads |= RTE_ETH_RX_OFFLOAD_VLAN_FILTER;
+		vlan_offload |= ETH_VLAN_FILTER_OFFLOAD;
+		port_rx_offloads |= DEV_RX_OFFLOAD_VLAN_FILTER;
 	} else {
-		vlan_offload &= ~RTE_ETH_VLAN_FILTER_OFFLOAD;
-		port_rx_offloads &= ~RTE_ETH_RX_OFFLOAD_VLAN_FILTER;
+		vlan_offload &= ~ETH_VLAN_FILTER_OFFLOAD;
+		port_rx_offloads &= ~DEV_RX_OFFLOAD_VLAN_FILTER;
 	}
 
 	diag = rte_eth_dev_set_vlan_offload(port_id, vlan_offload);
-	if (diag < 0) {
-		fprintf(stderr,
-			"%s(port_pi=%d, on=%d) failed diag=%d\n",
-			__func__, port_id, on, diag);
-		return;
-	}
+	if (diag < 0)
+		printf("rx_vlan_filter_set(port_pi=%d, on=%d) failed "
+	       "diag=%d\n", port_id, on, diag);
 	ports[port_id].dev_conf.rxmode.offloads = port_rx_offloads;
 }
 
@@ -5851,19 +3241,17 @@
 	vlan_offload = rte_eth_dev_get_vlan_offload(port_id);
 
 	if (on) {
-		vlan_offload |= RTE_ETH_QINQ_STRIP_OFFLOAD;
-		port_rx_offloads |= RTE_ETH_RX_OFFLOAD_QINQ_STRIP;
+		vlan_offload |= ETH_QINQ_STRIP_OFFLOAD;
+		port_rx_offloads |= DEV_RX_OFFLOAD_QINQ_STRIP;
 	} else {
-		vlan_offload &= ~RTE_ETH_QINQ_STRIP_OFFLOAD;
-		port_rx_offloads &= ~RTE_ETH_RX_OFFLOAD_QINQ_STRIP;
+		vlan_offload &= ~ETH_QINQ_STRIP_OFFLOAD;
+		port_rx_offloads &= ~DEV_RX_OFFLOAD_QINQ_STRIP;
 	}
 
 	diag = rte_eth_dev_set_vlan_offload(port_id, vlan_offload);
-	if (diag < 0) {
-		fprintf(stderr, "%s(port_pi=%d, on=%d) failed diag=%d\n",
-			__func__, port_id, on, diag);
-		return;
-	}
+	if (diag < 0)
+		printf("%s(port_pi=%d, on=%d) failed "
+	       "diag=%d\n", __func__, port_id, on, diag);
 	ports[port_id].dev_conf.rxmode.offloads = port_rx_offloads;
 }
 
@@ -5879,9 +3267,9 @@
 	diag = rte_eth_dev_vlan_filter(port_id, vlan_id, on);
 	if (diag == 0)
 		return 0;
-	fprintf(stderr,
-		"rte_eth_dev_vlan_filter(port_pi=%d, vlan_id=%d, on=%d) failed diag=%d\n",
-		port_id, vlan_id, on, diag);
+	printf("rte_eth_dev_vlan_filter(port_pi=%d, vlan_id=%d, on=%d) failed "
+	       "diag=%d\n",
+	       port_id, vlan_id, on, diag);
 	return -1;
 }
 
@@ -5910,9 +3298,9 @@
 	if (diag == 0)
 		return;
 
-	fprintf(stderr,
-		"tx_vlan_tpid_set(port_pi=%d, vlan_type=%d, tpid=%d) failed diag=%d\n",
-		port_id, vlan_type, tp_id, diag);
+	printf("tx_vlan_tpid_set(port_pi=%d, vlan_type=%d, tpid=%d) failed "
+	       "diag=%d\n",
+	       port_id, vlan_type, tp_id, diag);
 }
 
 void
@@ -5921,12 +3309,14 @@
 	struct rte_eth_dev_info dev_info;
 	int ret;
 
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
 	if (vlan_id_is_invalid(vlan_id))
 		return;
 
 	if (ports[port_id].dev_conf.txmode.offloads &
-	    RTE_ETH_TX_OFFLOAD_QINQ_INSERT) {
-		fprintf(stderr, "Error, as QinQ has been enabled.\n");
+	    DEV_TX_OFFLOAD_QINQ_INSERT) {
+		printf("Error, as QinQ has been enabled.\n");
 		return;
 	}
 
@@ -5934,15 +3324,14 @@
 	if (ret != 0)
 		return;
 
-	if ((dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_VLAN_INSERT) == 0) {
-		fprintf(stderr,
-			"Error: vlan insert is not supported by port %d\n",
+	if ((dev_info.tx_offload_capa & DEV_TX_OFFLOAD_VLAN_INSERT) == 0) {
+		printf("Error: vlan insert is not supported by port %d\n",
 			port_id);
 		return;
 	}
 
 	tx_vlan_reset(port_id);
-	ports[port_id].dev_conf.txmode.offloads |= RTE_ETH_TX_OFFLOAD_VLAN_INSERT;
+	ports[port_id].dev_conf.txmode.offloads |= DEV_TX_OFFLOAD_VLAN_INSERT;
 	ports[port_id].tx_vlan_id = vlan_id;
 }
 
@@ -5952,6 +3341,8 @@
 	struct rte_eth_dev_info dev_info;
 	int ret;
 
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
 	if (vlan_id_is_invalid(vlan_id))
 		return;
 	if (vlan_id_is_invalid(vlan_id_outer))
@@ -5961,16 +3352,15 @@
 	if (ret != 0)
 		return;
 
-	if ((dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_QINQ_INSERT) == 0) {
-		fprintf(stderr,
-			"Error: qinq insert not supported by port %d\n",
+	if ((dev_info.tx_offload_capa & DEV_TX_OFFLOAD_QINQ_INSERT) == 0) {
+		printf("Error: qinq insert not supported by port %d\n",
 			port_id);
 		return;
 	}
 
 	tx_vlan_reset(port_id);
-	ports[port_id].dev_conf.txmode.offloads |= (RTE_ETH_TX_OFFLOAD_VLAN_INSERT |
-						    RTE_ETH_TX_OFFLOAD_QINQ_INSERT);
+	ports[port_id].dev_conf.txmode.offloads |= (DEV_TX_OFFLOAD_VLAN_INSERT |
+						    DEV_TX_OFFLOAD_QINQ_INSERT);
 	ports[port_id].tx_vlan_id = vlan_id;
 	ports[port_id].tx_vlan_id_outer = vlan_id_outer;
 }
@@ -5978,9 +3368,11 @@
 void
 tx_vlan_reset(portid_t port_id)
 {
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
 	ports[port_id].dev_conf.txmode.offloads &=
-				~(RTE_ETH_TX_OFFLOAD_VLAN_INSERT |
-				  RTE_ETH_TX_OFFLOAD_QINQ_INSERT);
+				~(DEV_TX_OFFLOAD_VLAN_INSERT |
+				  DEV_TX_OFFLOAD_QINQ_INSERT);
 	ports[port_id].tx_vlan_id = 0;
 	ports[port_id].tx_vlan_id_outer = 0;
 }
@@ -5997,7 +3389,8 @@
 void
 set_qmap(portid_t port_id, uint8_t is_rx, uint16_t queue_id, uint8_t map_value)
 {
-	int ret;
+	uint16_t i;
+	uint8_t existing_mapping_found = 0;
 
 	if (port_id_is_invalid(port_id, ENABLED_WARN))
 		return;
@@ -6006,26 +3399,41 @@
 		return;
 
 	if (map_value >= RTE_ETHDEV_QUEUE_STAT_CNTRS) {
-		fprintf(stderr, "map_value not in required range 0..%d\n",
-			RTE_ETHDEV_QUEUE_STAT_CNTRS - 1);
+		printf("map_value not in required range 0..%d\n",
+				RTE_ETHDEV_QUEUE_STAT_CNTRS - 1);
 		return;
 	}
 
-	if (!is_rx) { /* tx */
-		ret = rte_eth_dev_set_tx_queue_stats_mapping(port_id, queue_id,
-							     map_value);
-		if (ret) {
-			fprintf(stderr,
-				"failed to set tx queue stats mapping.\n");
-			return;
+	if (!is_rx) { /*then tx*/
+		for (i = 0; i < nb_tx_queue_stats_mappings; i++) {
+			if ((tx_queue_stats_mappings[i].port_id == port_id) &&
+			    (tx_queue_stats_mappings[i].queue_id == queue_id)) {
+				tx_queue_stats_mappings[i].stats_counter_id = map_value;
+				existing_mapping_found = 1;
+				break;
+			}
 		}
-	} else { /* rx */
-		ret = rte_eth_dev_set_rx_queue_stats_mapping(port_id, queue_id,
-							     map_value);
-		if (ret) {
-			fprintf(stderr,
-				"failed to set rx queue stats mapping.\n");
-			return;
+		if (!existing_mapping_found) { /* A new additional mapping... */
+			tx_queue_stats_mappings[nb_tx_queue_stats_mappings].port_id = port_id;
+			tx_queue_stats_mappings[nb_tx_queue_stats_mappings].queue_id = queue_id;
+			tx_queue_stats_mappings[nb_tx_queue_stats_mappings].stats_counter_id = map_value;
+			nb_tx_queue_stats_mappings++;
+		}
+	}
+	else { /*rx*/
+		for (i = 0; i < nb_rx_queue_stats_mappings; i++) {
+			if ((rx_queue_stats_mappings[i].port_id == port_id) &&
+			    (rx_queue_stats_mappings[i].queue_id == queue_id)) {
+				rx_queue_stats_mappings[i].stats_counter_id = map_value;
+				existing_mapping_found = 1;
+				break;
+			}
+		}
+		if (!existing_mapping_found) { /* A new additional mapping... */
+			rx_queue_stats_mappings[nb_rx_queue_stats_mappings].port_id = port_id;
+			rx_queue_stats_mappings[nb_rx_queue_stats_mappings].queue_id = queue_id;
+			rx_queue_stats_mappings[nb_rx_queue_stats_mappings].stats_counter_id = map_value;
+			nb_rx_queue_stats_mappings++;
 		}
 	}
 }
@@ -6036,52 +3444,41 @@
 	xstats_hide_zero = on_off;
 }
 
-void
-set_record_core_cycles(uint8_t on_off)
-{
-	record_core_cycles = on_off;
-}
-
-void
-set_record_burst_stats(uint8_t on_off)
-{
-	record_burst_stats = on_off;
-}
-
-uint16_t
-str_to_flowtype(const char *string)
-{
-	uint8_t i;
-
-	for (i = 0; i < RTE_DIM(flowtype_str_table); i++) {
-		if (!strcmp(flowtype_str_table[i].str, string))
-			return flowtype_str_table[i].ftype;
-	}
-
-	if (isdigit(string[0])) {
-		int val = atoi(string);
-		if (val > 0 && val < 64)
-			return (uint16_t)val;
-	}
-
-	return RTE_ETH_FLOW_UNKNOWN;
-}
-
-const char*
-flowtype_to_str(uint16_t flow_type)
+static inline void
+print_fdir_mask(struct rte_eth_fdir_masks *mask)
 {
-	uint8_t i;
+	printf("\n    vlan_tci: 0x%04x", rte_be_to_cpu_16(mask->vlan_tci_mask));
 
-	for (i = 0; i < RTE_DIM(flowtype_str_table); i++) {
-		if (flowtype_str_table[i].ftype == flow_type)
-			return flowtype_str_table[i].str;
+	if (fdir_conf.mode == RTE_FDIR_MODE_PERFECT_TUNNEL)
+		printf(", mac_addr: 0x%02x, tunnel_type: 0x%01x,"
+			" tunnel_id: 0x%08x",
+			mask->mac_addr_byte_mask, mask->tunnel_type_mask,
+			rte_be_to_cpu_32(mask->tunnel_id_mask));
+	else if (fdir_conf.mode != RTE_FDIR_MODE_PERFECT_MAC_VLAN) {
+		printf(", src_ipv4: 0x%08x, dst_ipv4: 0x%08x",
+			rte_be_to_cpu_32(mask->ipv4_mask.src_ip),
+			rte_be_to_cpu_32(mask->ipv4_mask.dst_ip));
+
+		printf("\n    src_port: 0x%04x, dst_port: 0x%04x",
+			rte_be_to_cpu_16(mask->src_port_mask),
+			rte_be_to_cpu_16(mask->dst_port_mask));
+
+		printf("\n    src_ipv6: 0x%08x,0x%08x,0x%08x,0x%08x",
+			rte_be_to_cpu_32(mask->ipv6_mask.src_ip[0]),
+			rte_be_to_cpu_32(mask->ipv6_mask.src_ip[1]),
+			rte_be_to_cpu_32(mask->ipv6_mask.src_ip[2]),
+			rte_be_to_cpu_32(mask->ipv6_mask.src_ip[3]));
+
+		printf("\n    dst_ipv6: 0x%08x,0x%08x,0x%08x,0x%08x",
+			rte_be_to_cpu_32(mask->ipv6_mask.dst_ip[0]),
+			rte_be_to_cpu_32(mask->ipv6_mask.dst_ip[1]),
+			rte_be_to_cpu_32(mask->ipv6_mask.dst_ip[2]),
+			rte_be_to_cpu_32(mask->ipv6_mask.dst_ip[3]));
 	}
 
-	return NULL;
+	printf("\n");
 }
 
-#if defined(RTE_NET_I40E) || defined(RTE_NET_IXGBE)
-
 static inline void
 print_fdir_flex_payload(struct rte_eth_fdir_flex_conf *flex_conf, uint32_t num)
 {
@@ -6106,12 +3503,51 @@
 	printf("\n");
 }
 
+static char *
+flowtype_to_str(uint16_t flow_type)
+{
+	struct flow_type_info {
+		char str[32];
+		uint16_t ftype;
+	};
+
+	uint8_t i;
+	static struct flow_type_info flowtype_str_table[] = {
+		{"raw", RTE_ETH_FLOW_RAW},
+		{"ipv4", RTE_ETH_FLOW_IPV4},
+		{"ipv4-frag", RTE_ETH_FLOW_FRAG_IPV4},
+		{"ipv4-tcp", RTE_ETH_FLOW_NONFRAG_IPV4_TCP},
+		{"ipv4-udp", RTE_ETH_FLOW_NONFRAG_IPV4_UDP},
+		{"ipv4-sctp", RTE_ETH_FLOW_NONFRAG_IPV4_SCTP},
+		{"ipv4-other", RTE_ETH_FLOW_NONFRAG_IPV4_OTHER},
+		{"ipv6", RTE_ETH_FLOW_IPV6},
+		{"ipv6-frag", RTE_ETH_FLOW_FRAG_IPV6},
+		{"ipv6-tcp", RTE_ETH_FLOW_NONFRAG_IPV6_TCP},
+		{"ipv6-udp", RTE_ETH_FLOW_NONFRAG_IPV6_UDP},
+		{"ipv6-sctp", RTE_ETH_FLOW_NONFRAG_IPV6_SCTP},
+		{"ipv6-other", RTE_ETH_FLOW_NONFRAG_IPV6_OTHER},
+		{"l2_payload", RTE_ETH_FLOW_L2_PAYLOAD},
+		{"port", RTE_ETH_FLOW_PORT},
+		{"vxlan", RTE_ETH_FLOW_VXLAN},
+		{"geneve", RTE_ETH_FLOW_GENEVE},
+		{"nvgre", RTE_ETH_FLOW_NVGRE},
+		{"vxlan-gpe", RTE_ETH_FLOW_VXLAN_GPE},
+	};
+
+	for (i = 0; i < RTE_DIM(flowtype_str_table); i++) {
+		if (flowtype_str_table[i].ftype == flow_type)
+			return flowtype_str_table[i].str;
+	}
+
+	return NULL;
+}
+
 static inline void
 print_fdir_flex_mask(struct rte_eth_fdir_flex_conf *flex_conf, uint32_t num)
 {
 	struct rte_eth_fdir_flex_mask *mask;
 	uint32_t i, j;
-	const char *p;
+	char *p;
 
 	for (i = 0; i < flex_conf->nb_flexmasks; i++) {
 		mask = &flex_conf->flex_mask[i];
@@ -6127,7 +3563,7 @@
 print_fdir_flow_type(uint32_t flow_types_mask)
 {
 	int i;
-	const char *p;
+	char *p;
 
 	for (i = RTE_ETH_FLOW_UNKNOWN; i < RTE_ETH_FLOW_MAX; i++) {
 		if (!(flow_types_mask & (1 << i)))
@@ -6141,56 +3577,30 @@
 	printf("\n");
 }
 
-static int
-get_fdir_info(portid_t port_id, struct rte_eth_fdir_info *fdir_info,
-		    struct rte_eth_fdir_stats *fdir_stat)
-{
-	int ret = -ENOTSUP;
-
-#ifdef RTE_NET_I40E
-	if (ret == -ENOTSUP) {
-		ret = rte_pmd_i40e_get_fdir_info(port_id, fdir_info);
-		if (!ret)
-			ret = rte_pmd_i40e_get_fdir_stats(port_id, fdir_stat);
-	}
-#endif
-#ifdef RTE_NET_IXGBE
-	if (ret == -ENOTSUP) {
-		ret = rte_pmd_ixgbe_get_fdir_info(port_id, fdir_info);
-		if (!ret)
-			ret = rte_pmd_ixgbe_get_fdir_stats(port_id, fdir_stat);
-	}
-#endif
-	switch (ret) {
-	case 0:
-		break;
-	case -ENOTSUP:
-		fprintf(stderr, "\n FDIR is not supported on port %-2d\n",
-			port_id);
-		break;
-	default:
-		fprintf(stderr, "programming error: (%s)\n", strerror(-ret));
-		break;
-	}
-	return ret;
-}
-
 void
 fdir_get_infos(portid_t port_id)
 {
 	struct rte_eth_fdir_stats fdir_stat;
 	struct rte_eth_fdir_info fdir_info;
+	int ret;
 
 	static const char *fdir_stats_border = "########################";
 
 	if (port_id_is_invalid(port_id, ENABLED_WARN))
 		return;
+	ret = rte_eth_dev_filter_supported(port_id, RTE_ETH_FILTER_FDIR);
+	if (ret < 0) {
+		printf("\n FDIR is not supported on port %-2d\n",
+			port_id);
+		return;
+	}
 
 	memset(&fdir_info, 0, sizeof(fdir_info));
+	rte_eth_dev_filter_ctrl(port_id, RTE_ETH_FILTER_FDIR,
+			       RTE_ETH_FILTER_INFO, &fdir_info);
 	memset(&fdir_stat, 0, sizeof(fdir_stat));
-	if (get_fdir_info(port_id, &fdir_info, &fdir_stat))
-		return;
-
+	rte_eth_dev_filter_ctrl(port_id, RTE_ETH_FILTER_FDIR,
+			       RTE_ETH_FILTER_STATS, &fdir_stat);
 	printf("\n  %s FDIR infos for port %-2d     %s\n",
 	       fdir_stats_border, port_id, fdir_stats_border);
 	printf("  MODE: ");
@@ -6217,6 +3627,8 @@
 		fdir_info.flex_payload_unit,
 		fdir_info.max_flex_payload_segment_num,
 		fdir_info.flex_bitmask_unit, fdir_info.max_flex_bitmask_num);
+	printf("  MASK: ");
+	print_fdir_mask(&fdir_info.mask);
 	if (fdir_info.flex_conf.nb_payloads > 0) {
 		printf("  FLEX PAYLOAD SRC OFFSET:");
 		print_fdir_flex_payload(&fdir_info.flex_conf, fdir_info.max_flexpayload);
@@ -6241,12 +3653,71 @@
 	       fdir_stats_border, fdir_stats_border);
 }
 
-#endif /* RTE_NET_I40E || RTE_NET_IXGBE */
+void
+fdir_set_flex_mask(portid_t port_id, struct rte_eth_fdir_flex_mask *cfg)
+{
+	struct rte_port *port;
+	struct rte_eth_fdir_flex_conf *flex_conf;
+	int i, idx = 0;
+
+	port = &ports[port_id];
+	flex_conf = &port->dev_conf.fdir_conf.flex_conf;
+	for (i = 0; i < RTE_ETH_FLOW_MAX; i++) {
+		if (cfg->flow_type == flex_conf->flex_mask[i].flow_type) {
+			idx = i;
+			break;
+		}
+	}
+	if (i >= RTE_ETH_FLOW_MAX) {
+		if (flex_conf->nb_flexmasks < RTE_DIM(flex_conf->flex_mask)) {
+			idx = flex_conf->nb_flexmasks;
+			flex_conf->nb_flexmasks++;
+		} else {
+			printf("The flex mask table is full. Can not set flex"
+				" mask for flow_type(%u).", cfg->flow_type);
+			return;
+		}
+	}
+	rte_memcpy(&flex_conf->flex_mask[idx],
+			 cfg,
+			 sizeof(struct rte_eth_fdir_flex_mask));
+}
+
+void
+fdir_set_flex_payload(portid_t port_id, struct rte_eth_flex_payload_cfg *cfg)
+{
+	struct rte_port *port;
+	struct rte_eth_fdir_flex_conf *flex_conf;
+	int i, idx = 0;
+
+	port = &ports[port_id];
+	flex_conf = &port->dev_conf.fdir_conf.flex_conf;
+	for (i = 0; i < RTE_ETH_PAYLOAD_MAX; i++) {
+		if (cfg->type == flex_conf->flex_set[i].type) {
+			idx = i;
+			break;
+		}
+	}
+	if (i >= RTE_ETH_PAYLOAD_MAX) {
+		if (flex_conf->nb_payloads < RTE_DIM(flex_conf->flex_set)) {
+			idx = flex_conf->nb_payloads;
+			flex_conf->nb_payloads++;
+		} else {
+			printf("The flex payload table is full. Can not set"
+				" flex payload for type(%u).", cfg->type);
+			return;
+		}
+	}
+	rte_memcpy(&flex_conf->flex_set[idx],
+			 cfg,
+			 sizeof(struct rte_eth_flex_payload_cfg));
+
+}
 
 void
 set_vf_traffic(portid_t port_id, uint8_t is_rx, uint16_t vf, uint8_t on)
 {
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	int diag;
 
 	if (is_rx)
@@ -6256,19 +3727,18 @@
 
 	if (diag == 0)
 		return;
-	fprintf(stderr,
-		"rte_pmd_ixgbe_set_vf_%s for port_id=%d failed diag=%d\n",
-		is_rx ? "rx" : "tx", port_id, diag);
+	printf("rte_pmd_ixgbe_set_vf_%s for port_id=%d failed diag=%d\n",
+			is_rx ? "rx" : "tx", port_id, diag);
 	return;
 #endif
-	fprintf(stderr, "VF %s setting not supported for port %d\n",
-		is_rx ? "Rx" : "Tx", port_id);
+	printf("VF %s setting not supported for port %d\n",
+			is_rx ? "Rx" : "Tx", port_id);
 	RTE_SET_USED(vf);
 	RTE_SET_USED(on);
 }
 
 int
-set_queue_rate_limit(portid_t port_id, uint16_t queue_idx, uint32_t rate)
+set_queue_rate_limit(portid_t port_id, uint16_t queue_idx, uint16_t rate)
 {
 	int diag;
 	struct rte_eth_link link;
@@ -6279,24 +3749,21 @@
 	ret = eth_link_get_nowait_print_err(port_id, &link);
 	if (ret < 0)
 		return 1;
-	if (link.link_speed != RTE_ETH_SPEED_NUM_UNKNOWN &&
-	    rate > link.link_speed) {
-		fprintf(stderr,
-			"Invalid rate value:%u bigger than link speed: %u\n",
+	if (rate > link.link_speed) {
+		printf("Invalid rate value:%u bigger than link speed: %u\n",
 			rate, link.link_speed);
 		return 1;
 	}
 	diag = rte_eth_set_queue_rate_limit(port_id, queue_idx, rate);
 	if (diag == 0)
 		return diag;
-	fprintf(stderr,
-		"rte_eth_set_queue_rate_limit for port_id=%d failed diag=%d\n",
+	printf("rte_eth_set_queue_rate_limit for port_id=%d failed diag=%d\n",
 		port_id, diag);
 	return diag;
 }
 
 int
-set_vf_rate_limit(portid_t port_id, uint16_t vf, uint32_t rate, uint64_t q_msk)
+set_vf_rate_limit(portid_t port_id, uint16_t vf, uint16_t rate, uint64_t q_msk)
 {
 	int diag = -ENOTSUP;
 
@@ -6304,33 +3771,23 @@
 	RTE_SET_USED(rate);
 	RTE_SET_USED(q_msk);
 
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 	if (diag == -ENOTSUP)
 		diag = rte_pmd_ixgbe_set_vf_rate_limit(port_id, vf, rate,
 						       q_msk);
 #endif
-#ifdef RTE_NET_BNXT
+#ifdef RTE_LIBRTE_BNXT_PMD
 	if (diag == -ENOTSUP)
 		diag = rte_pmd_bnxt_set_vf_rate_limit(port_id, vf, rate, q_msk);
 #endif
 	if (diag == 0)
 		return diag;
 
-	fprintf(stderr,
-		"%s for port_id=%d failed diag=%d\n",
-		__func__, port_id, diag);
+	printf("set_vf_rate_limit for port_id=%d failed diag=%d\n",
+		port_id, diag);
 	return diag;
 }
 
-int
-set_rxq_avail_thresh(portid_t port_id, uint16_t queue_id, uint8_t avail_thresh)
-{
-	if (port_id_is_invalid(port_id, ENABLED_WARN))
-		return -EINVAL;
-
-	return rte_eth_rx_avail_thresh_set(port_id, queue_id, avail_thresh);
-}
-
 /*
  * Functions to manage the set of filtered Multicast MAC addresses.
  *
@@ -6374,9 +3831,8 @@
 	mc_pool = (struct rte_ether_addr *) realloc(port->mc_addr_pool,
 						mc_pool_size);
 	if (mc_pool == NULL) {
-		fprintf(stderr,
-			"allocation of pool of %u multicast addresses failed\n",
-			port->mc_addr_nb + MCAST_POOL_INC);
+		printf("allocation of pool of %u multicast addresses failed\n",
+		       port->mc_addr_nb + MCAST_POOL_INC);
 		return -ENOMEM;
 	}
 
@@ -6387,19 +3843,11 @@
 }
 
 static void
-mcast_addr_pool_append(struct rte_port *port, struct rte_ether_addr *mc_addr)
-{
-	if (mcast_addr_pool_extend(port) != 0)
-		return;
-	rte_ether_addr_copy(mc_addr, &port->mc_addr_pool[port->mc_addr_nb - 1]);
-}
-
-static void
 mcast_addr_pool_remove(struct rte_port *port, uint32_t addr_idx)
 {
 	port->mc_addr_nb--;
 	if (addr_idx == port->mc_addr_nb) {
-		/* No need to recompact the set of multicast addresses. */
+		/* No need to recompact the set of multicast addressses. */
 		if (port->mc_addr_nb == 0) {
 			/* free the pool of multicast addresses. */
 			free(port->mc_addr_pool);
@@ -6412,26 +3860,7 @@
 		sizeof(struct rte_ether_addr) * (port->mc_addr_nb - addr_idx));
 }
 
-int
-mcast_addr_pool_destroy(portid_t port_id)
-{
-	struct rte_port *port;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN) ||
-	    port_id == (portid_t)RTE_PORT_ALL)
-		return -EINVAL;
-	port = &ports[port_id];
-
-	if (port->mc_addr_nb != 0) {
-		/* free the pool of multicast addresses. */
-		free(port->mc_addr_pool);
-		port->mc_addr_pool = NULL;
-		port->mc_addr_nb = 0;
-	}
-	return 0;
-}
-
-static int
+static void
 eth_port_multicast_addr_list_set(portid_t port_id)
 {
 	struct rte_port *port;
@@ -6440,12 +3869,10 @@
 	port = &ports[port_id];
 	diag = rte_eth_dev_set_mc_addr_list(port_id, port->mc_addr_pool,
 					    port->mc_addr_nb);
-	if (diag < 0)
-		fprintf(stderr,
-			"rte_eth_dev_set_mc_addr_list(port=%d, nb=%u) failed. diag=%d\n",
-			port_id, port->mc_addr_nb, diag);
-
-	return diag;
+	if (diag == 0)
+		return;
+	printf("rte_eth_dev_set_mc_addr_list(port=%d, nb=%u) failed. diag=%d\n",
+	       port->mc_addr_nb, port_id, -diag);
 }
 
 void
@@ -6465,16 +3892,15 @@
 	 */
 	for (i = 0; i < port->mc_addr_nb; i++) {
 		if (rte_is_same_ether_addr(mc_addr, &port->mc_addr_pool[i])) {
-			fprintf(stderr,
-				"multicast address already filtered by port\n");
+			printf("multicast address already filtered by port\n");
 			return;
 		}
 	}
 
-	mcast_addr_pool_append(port, mc_addr);
-	if (eth_port_multicast_addr_list_set(port_id) < 0)
-		/* Rollback on failure, remove the address from the pool */
-		mcast_addr_pool_remove(port, i);
+	if (mcast_addr_pool_extend(port) != 0)
+		return;
+	rte_ether_addr_copy(mc_addr, &port->mc_addr_pool[i]);
+	eth_port_multicast_addr_list_set(port_id);
 }
 
 void
@@ -6496,15 +3922,12 @@
 			break;
 	}
 	if (i == port->mc_addr_nb) {
-		fprintf(stderr, "multicast address not filtered by port %d\n",
-			port_id);
+		printf("multicast address not filtered by port %d\n", port_id);
 		return;
 	}
 
 	mcast_addr_pool_remove(port, i);
-	if (eth_port_multicast_addr_list_set(port_id) < 0)
-		/* Rollback on failure, add the address back into the pool */
-		mcast_addr_pool_append(port, mc_addr);
+	eth_port_multicast_addr_list_set(port_id);
 }
 
 void
@@ -6520,7 +3943,7 @@
 
 	ret = rte_eth_dev_get_dcb_info(port_id, &dcb_info);
 	if (ret) {
-		fprintf(stderr, "\n Failed to get dcb infos on port %-2d\n",
+		printf("\n Failed to get dcb infos on port %-2d\n",
 			port_id);
 		return;
 	}
@@ -6563,34 +3986,34 @@
 		*size = 0;
 
 	if (fd == -1) {
-		fprintf(stderr, "%s: Failed to open %s\n", __func__, file_path);
+		printf("%s: Failed to open %s\n", __func__, file_path);
 		return buf;
 	}
 
 	if ((fstat(fd, &st_buf) != 0) || (!S_ISREG(st_buf.st_mode))) {
 		close(fd);
-		fprintf(stderr, "%s: File operations failed\n", __func__);
+		printf("%s: File operations failed\n", __func__);
 		return buf;
 	}
 
 	pkg_size = st_buf.st_size;
 	if (pkg_size < 0) {
 		close(fd);
-		fprintf(stderr, "%s: File operations failed\n", __func__);
+		printf("%s: File operations failed\n", __func__);
 		return buf;
 	}
 
 	buf = (uint8_t *)malloc(pkg_size);
 	if (!buf) {
 		close(fd);
-		fprintf(stderr, "%s: Failed to malloc memory\n", __func__);
+		printf("%s: Failed to malloc memory\n",	__func__);
 		return buf;
 	}
 
 	ret = read(fd, buf, pkg_size);
 	if (ret < 0) {
 		close(fd);
-		fprintf(stderr, "%s: File read operation failed\n", __func__);
+		printf("%s: File read operation failed\n", __func__);
 		close_file(buf);
 		return NULL;
 	}
@@ -6609,13 +4032,13 @@
 	FILE *fh = fopen(file_path, "wb");
 
 	if (fh == NULL) {
-		fprintf(stderr, "%s: Failed to open %s\n", __func__, file_path);
+		printf("%s: Failed to open %s\n", __func__, file_path);
 		return -1;
 	}
 
 	if (fwrite(buf, 1, size, fh) != size) {
 		fclose(fh);
-		fprintf(stderr, "%s: File write operation failed\n", __func__);
+		printf("%s: File write operation failed\n", __func__);
 		return -1;
 	}
 
@@ -6636,58 +4059,44 @@
 }
 
 void
-show_macs(portid_t port_id)
+port_queue_region_info_display(portid_t port_id, void *buf)
 {
-	char buf[RTE_ETHER_ADDR_FMT_SIZE];
-	struct rte_eth_dev_info dev_info;
-	int32_t i, rc, num_macs = 0;
-
-	if (eth_dev_info_get_print_err(port_id, &dev_info))
-		return;
-
-	struct rte_ether_addr addr[dev_info.max_mac_addrs];
-	rc = rte_eth_macaddrs_get(port_id, addr, dev_info.max_mac_addrs);
-	if (rc < 0)
-		return;
-
-	for (i = 0; i < rc; i++) {
-
-		/* skip zero address */
-		if (rte_is_zero_ether_addr(&addr[i]))
-			continue;
-
-		num_macs++;
+#ifdef RTE_LIBRTE_I40E_PMD
+	uint16_t i, j;
+	struct rte_pmd_i40e_queue_regions *info =
+		(struct rte_pmd_i40e_queue_regions *)buf;
+	static const char *queue_region_info_stats_border = "-------";
+
+	if (!info->queue_region_number)
+		printf("there is no region has been set before");
+
+	printf("\n	%s All queue region info for port=%2d %s",
+			queue_region_info_stats_border, port_id,
+			queue_region_info_stats_border);
+	printf("\n	queue_region_number: %-14u \n",
+			info->queue_region_number);
+
+	for (i = 0; i < info->queue_region_number; i++) {
+		printf("\n	region_id: %-14u queue_number: %-14u "
+			"queue_start_index: %-14u \n",
+			info->region[i].region_id,
+			info->region[i].queue_num,
+			info->region[i].queue_start_index);
+
+		printf("  user_priority_num is	%-14u :",
+					info->region[i].user_priority_num);
+		for (j = 0; j < info->region[i].user_priority_num; j++)
+			printf(" %-14u ", info->region[i].user_priority[j]);
+
+		printf("\n	flowtype_num is  %-14u :",
+				info->region[i].flowtype_num);
+		for (j = 0; j < info->region[i].flowtype_num; j++)
+			printf(" %-14u ", info->region[i].hw_flowtype[j]);
 	}
+#else
+	RTE_SET_USED(port_id);
+	RTE_SET_USED(buf);
+#endif
 
-	printf("Number of MAC address added: %d\n", num_macs);
-
-	for (i = 0; i < rc; i++) {
-
-		/* skip zero address */
-		if (rte_is_zero_ether_addr(&addr[i]))
-			continue;
-
-		rte_ether_format_addr(buf, RTE_ETHER_ADDR_FMT_SIZE, &addr[i]);
-		printf("  %s\n", buf);
-	}
-}
-
-void
-show_mcast_macs(portid_t port_id)
-{
-	char buf[RTE_ETHER_ADDR_FMT_SIZE];
-	struct rte_ether_addr *addr;
-	struct rte_port *port;
-	uint32_t i;
-
-	port = &ports[port_id];
-
-	printf("Number of Multicast MAC address added: %d\n", port->mc_addr_nb);
-
-	for (i = 0; i < port->mc_addr_nb; i++) {
-		addr = &port->mc_addr_pool[i];
-
-		rte_ether_format_addr(buf, RTE_ETHER_ADDR_FMT_SIZE, addr);
-		printf("  %s\n", buf);
-	}
+	printf("\n\n");
 }
diff -urN dpdk/app/test-pmd/csumonly.c testpmd-as-load-balancer/v19.11/test-pmd/csumonly.c
--- dpdk/app/test-pmd/csumonly.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/csumonly.c	2023-12-15 15:26:37.089199123 +0100
@@ -24,10 +24,12 @@
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_mempool.h>
 #include <rte_mbuf.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_ip.h>
@@ -39,13 +41,8 @@
 #include <rte_prefetch.h>
 #include <rte_string_fns.h>
 #include <rte_flow.h>
-#ifdef RTE_LIB_GRO
 #include <rte_gro.h>
-#endif
-#ifdef RTE_LIB_GSO
 #include <rte_gso.h>
-#endif
-#include <rte_geneve.h>
 
 #include "testpmd.h"
 
@@ -65,15 +62,12 @@
 #define _htons(x) (x)
 #endif
 
-uint16_t vxlan_gpe_udp_port = RTE_VXLAN_GPE_DEFAULT_PORT;
-uint16_t geneve_udp_port = RTE_GENEVE_DEFAULT_PORT;
+uint16_t vxlan_gpe_udp_port = 4790;
 
 /* structure that caches offload info for the current packet */
 struct testpmd_offload_info {
 	uint16_t ethertype;
-#ifdef RTE_LIB_GSO
 	uint8_t gso_enable;
-#endif
 	uint16_t l2_len;
 	uint16_t l3_len;
 	uint16_t l4_len;
@@ -92,16 +86,15 @@
 struct simple_gre_hdr {
 	uint16_t flags;
 	uint16_t proto;
-} __rte_packed;
+} __attribute__((__packed__));
 
 static uint16_t
-get_udptcp_checksum(struct rte_mbuf *m, void *l3_hdr, uint16_t l4_off,
-		    uint16_t ethertype)
+get_udptcp_checksum(void *l3_hdr, void *l4_hdr, uint16_t ethertype)
 {
 	if (ethertype == _htons(RTE_ETHER_TYPE_IPV4))
-		return rte_ipv4_udptcp_cksum_mbuf(m, l3_hdr, l4_off);
+		return rte_ipv4_udptcp_cksum(l3_hdr, l4_hdr);
 	else /* assume ethertype == RTE_ETHER_TYPE_IPV6 */
-		return rte_ipv6_udptcp_cksum_mbuf(m, l3_hdr, l4_off);
+		return rte_ipv6_udptcp_cksum(l3_hdr, l4_hdr);
 }
 
 /* Parse an IPv4 header to fill l3_len, l4_len, and l4_proto */
@@ -110,7 +103,7 @@
 {
 	struct rte_tcp_hdr *tcp_hdr;
 
-	info->l3_len = rte_ipv4_hdr_len(ipv4_hdr);
+	info->l3_len = (ipv4_hdr->version_ihl & 0x0f) * 4;
 	info->l4_proto = ipv4_hdr->next_proto_id;
 
 	/* only fill l4_len for TCP, it's useful for TSO */
@@ -146,23 +139,22 @@
 
 /*
  * Parse an ethernet header to fill the ethertype, l2_len, l3_len and
- * ipproto. This function is able to recognize IPv4/IPv6 with optional VLAN
- * headers. The l4_len argument is only set in case of TCP (useful for TSO).
+ * ipproto. This function is able to recognize IPv4/IPv6 with one optional vlan
+ * header. The l4_len argument is only set in case of TCP (useful for TSO).
  */
 static void
 parse_ethernet(struct rte_ether_hdr *eth_hdr, struct testpmd_offload_info *info)
 {
 	struct rte_ipv4_hdr *ipv4_hdr;
 	struct rte_ipv6_hdr *ipv6_hdr;
-	struct rte_vlan_hdr *vlan_hdr;
 
 	info->l2_len = sizeof(struct rte_ether_hdr);
 	info->ethertype = eth_hdr->ether_type;
 
-	while (info->ethertype == _htons(RTE_ETHER_TYPE_VLAN) ||
-	       info->ethertype == _htons(RTE_ETHER_TYPE_QINQ)) {
-		vlan_hdr = (struct rte_vlan_hdr *)
-			((char *)eth_hdr + info->l2_len);
+	if (info->ethertype == _htons(RTE_ETHER_TYPE_VLAN)) {
+		struct rte_vlan_hdr *vlan_hdr = (
+			struct rte_vlan_hdr *)(eth_hdr + 1);
+
 		info->l2_len  += sizeof(struct rte_vlan_hdr);
 		info->ethertype = vlan_hdr->eth_proto;
 	}
@@ -186,17 +178,6 @@
 	}
 }
 
-/* Fill in outer layers length */
-static void
-update_tunnel_outer(struct testpmd_offload_info *info)
-{
-	info->is_tunnel = 1;
-	info->outer_ethertype = info->ethertype;
-	info->outer_l2_len = info->l2_len;
-	info->outer_l3_len = info->l3_len;
-	info->outer_l4_proto = info->l4_proto;
-}
-
 /*
  * Parse a GTP protocol header.
  * No optional fields and next extension header type.
@@ -217,19 +198,24 @@
 	    udp_hdr->dst_port != _htons(RTE_GTPU_UDP_PORT))
 		return;
 
-	update_tunnel_outer(info);
+	info->is_tunnel = 1;
+	info->outer_ethertype = info->ethertype;
+	info->outer_l2_len = info->l2_len;
+	info->outer_l3_len = info->l3_len;
+	info->outer_l4_proto = info->l4_proto;
 	info->l2_len = 0;
 
 	gtp_hdr = (struct rte_gtp_hdr *)((char *)udp_hdr +
 		  sizeof(struct rte_udp_hdr));
-	if (gtp_hdr->e || gtp_hdr->s || gtp_hdr->pn)
-		gtp_len += sizeof(struct rte_gtp_hdr_ext_word);
+
 	/*
 	 * Check message type. If message type is 0xff, it is
 	 * a GTP data packet. If not, it is a GTP control packet
 	 */
 	if (gtp_hdr->msg_type == 0xff) {
-		ip_ver = *(uint8_t *)((char *)gtp_hdr + gtp_len);
+		ip_ver = *(uint8_t *)((char *)udp_hdr +
+			 sizeof(struct rte_udp_hdr) +
+			 sizeof(struct rte_gtp_hdr));
 		ip_ver = (ip_ver) & 0xf0;
 
 		if (ip_ver == RTE_GTP_TYPE_IPV4) {
@@ -250,24 +236,29 @@
 		info->l4_proto = 0;
 	}
 
-	info->l2_len += gtp_len + sizeof(*udp_hdr);
+	info->l2_len += RTE_ETHER_GTP_HLEN;
 }
 
 /* Parse a vxlan header */
 static void
 parse_vxlan(struct rte_udp_hdr *udp_hdr,
-	    struct testpmd_offload_info *info)
+	    struct testpmd_offload_info *info,
+	    uint32_t pkt_type)
 {
 	struct rte_ether_hdr *eth_hdr;
 
-	/* check udp destination port, RTE_VXLAN_DEFAULT_PORT (4789) is the
-	 * default vxlan port (rfc7348) or that the rx offload flag is set
-	 * (i40e only currently)
-	 */
-	if (udp_hdr->dst_port != _htons(RTE_VXLAN_DEFAULT_PORT))
+	/* check udp destination port, 4789 is the default vxlan port
+	 * (rfc7348) or that the rx offload flag is set (i40e only
+	 * currently) */
+	if (udp_hdr->dst_port != _htons(4789) &&
+		RTE_ETH_IS_TUNNEL_PKT(pkt_type) == 0)
 		return;
 
-	update_tunnel_outer(info);
+	info->is_tunnel = 1;
+	info->outer_ethertype = info->ethertype;
+	info->outer_l2_len = info->l2_len;
+	info->outer_l3_len = info->l3_len;
+	info->outer_l4_proto = info->l4_proto;
 
 	eth_hdr = (struct rte_ether_hdr *)((char *)udp_hdr +
 		sizeof(struct rte_udp_hdr) +
@@ -297,7 +288,11 @@
 
 	if (!vxlan_gpe_hdr->proto || vxlan_gpe_hdr->proto ==
 	    RTE_VXLAN_GPE_TYPE_IPV4) {
-		update_tunnel_outer(info);
+		info->is_tunnel = 1;
+		info->outer_ethertype = info->ethertype;
+		info->outer_l2_len = info->l2_len;
+		info->outer_l3_len = info->l3_len;
+		info->outer_l4_proto = info->l4_proto;
 
 		ipv4_hdr = (struct rte_ipv4_hdr *)((char *)vxlan_gpe_hdr +
 			   vxlan_gpe_len);
@@ -307,7 +302,11 @@
 		info->l2_len = 0;
 
 	} else if (vxlan_gpe_hdr->proto == RTE_VXLAN_GPE_TYPE_IPV6) {
-		update_tunnel_outer(info);
+		info->is_tunnel = 1;
+		info->outer_ethertype = info->ethertype;
+		info->outer_l2_len = info->l2_len;
+		info->outer_l3_len = info->l3_len;
+		info->outer_l4_proto = info->l4_proto;
 
 		ipv6_hdr = (struct rte_ipv6_hdr *)((char *)vxlan_gpe_hdr +
 			   vxlan_gpe_len);
@@ -317,7 +316,11 @@
 		info->l2_len = 0;
 
 	} else if (vxlan_gpe_hdr->proto == RTE_VXLAN_GPE_TYPE_ETH) {
-		update_tunnel_outer(info);
+		info->is_tunnel = 1;
+		info->outer_ethertype = info->ethertype;
+		info->outer_l2_len = info->l2_len;
+		info->outer_l3_len = info->l3_len;
+		info->outer_l4_proto = info->l4_proto;
 
 		eth_hdr = (struct rte_ether_hdr *)((char *)vxlan_gpe_hdr +
 			  vxlan_gpe_len);
@@ -329,53 +332,6 @@
 	info->l2_len += RTE_ETHER_VXLAN_GPE_HLEN;
 }
 
-/* Parse a geneve header */
-static void
-parse_geneve(struct rte_udp_hdr *udp_hdr,
-	    struct testpmd_offload_info *info)
-{
-	struct rte_ether_hdr *eth_hdr;
-	struct rte_ipv4_hdr *ipv4_hdr;
-	struct rte_ipv6_hdr *ipv6_hdr;
-	struct rte_geneve_hdr *geneve_hdr;
-	uint16_t geneve_len;
-
-	/* Check udp destination port. */
-	if (udp_hdr->dst_port != _htons(geneve_udp_port))
-		return;
-
-	geneve_hdr = (struct rte_geneve_hdr *)((char *)udp_hdr +
-				sizeof(struct rte_udp_hdr));
-	geneve_len = sizeof(struct rte_geneve_hdr) + geneve_hdr->opt_len * 4;
-	if (!geneve_hdr->proto || geneve_hdr->proto ==
-	    _htons(RTE_ETHER_TYPE_IPV4)) {
-		update_tunnel_outer(info);
-		ipv4_hdr = (struct rte_ipv4_hdr *)((char *)geneve_hdr +
-			   geneve_len);
-		parse_ipv4(ipv4_hdr, info);
-		info->ethertype = _htons(RTE_ETHER_TYPE_IPV4);
-		info->l2_len = 0;
-	} else if (geneve_hdr->proto == _htons(RTE_ETHER_TYPE_IPV6)) {
-		update_tunnel_outer(info);
-		ipv6_hdr = (struct rte_ipv6_hdr *)((char *)geneve_hdr +
-			   geneve_len);
-		info->ethertype = _htons(RTE_ETHER_TYPE_IPV6);
-		parse_ipv6(ipv6_hdr, info);
-		info->l2_len = 0;
-
-	} else if (geneve_hdr->proto == _htons(RTE_GENEVE_TYPE_ETH)) {
-		update_tunnel_outer(info);
-		eth_hdr = (struct rte_ether_hdr *)((char *)geneve_hdr +
-			  geneve_len);
-		parse_ethernet(eth_hdr, info);
-	} else
-		return;
-
-	info->l2_len +=
-		(sizeof(struct rte_udp_hdr) + sizeof(struct rte_geneve_hdr) +
-		((struct rte_geneve_hdr *)geneve_hdr)->opt_len * 4);
-}
-
 /* Parse a gre header */
 static void
 parse_gre(struct simple_gre_hdr *gre_hdr, struct testpmd_offload_info *info)
@@ -395,7 +351,11 @@
 		gre_len += GRE_EXT_LEN;
 
 	if (gre_hdr->proto == _htons(RTE_ETHER_TYPE_IPV4)) {
-		update_tunnel_outer(info);
+		info->is_tunnel = 1;
+		info->outer_ethertype = info->ethertype;
+		info->outer_l2_len = info->l2_len;
+		info->outer_l3_len = info->l3_len;
+		info->outer_l4_proto = info->l4_proto;
 
 		ipv4_hdr = (struct rte_ipv4_hdr *)((char *)gre_hdr + gre_len);
 
@@ -404,7 +364,11 @@
 		info->l2_len = 0;
 
 	} else if (gre_hdr->proto == _htons(RTE_ETHER_TYPE_IPV6)) {
-		update_tunnel_outer(info);
+		info->is_tunnel = 1;
+		info->outer_ethertype = info->ethertype;
+		info->outer_l2_len = info->l2_len;
+		info->outer_l3_len = info->l3_len;
+		info->outer_l4_proto = info->l4_proto;
 
 		ipv6_hdr = (struct rte_ipv6_hdr *)((char *)gre_hdr + gre_len);
 
@@ -413,7 +377,11 @@
 		info->l2_len = 0;
 
 	} else if (gre_hdr->proto == _htons(RTE_ETHER_TYPE_TEB)) {
-		update_tunnel_outer(info);
+		info->is_tunnel = 1;
+		info->outer_ethertype = info->ethertype;
+		info->outer_l2_len = info->l2_len;
+		info->outer_l3_len = info->l3_len;
+		info->outer_l4_proto = info->l4_proto;
 
 		eth_hdr = (struct rte_ether_hdr *)((char *)gre_hdr + gre_len);
 
@@ -457,7 +425,7 @@
  * depending on the testpmd command line configuration */
 static uint64_t
 process_inner_cksums(void *l3_hdr, const struct testpmd_offload_info *info,
-	uint64_t tx_offloads, struct rte_mbuf *m)
+	uint64_t tx_offloads)
 {
 	struct rte_ipv4_hdr *ipv4_hdr = l3_hdr;
 	struct rte_udp_hdr *udp_hdr;
@@ -465,7 +433,6 @@
 	struct rte_sctp_hdr *sctp_hdr;
 	uint64_t ol_flags = 0;
 	uint32_t max_pkt_len, tso_segsz = 0;
-	uint16_t l4_off;
 
 	/* ensure packet is large enough to require tso */
 	if (!info->is_tunnel) {
@@ -483,21 +450,20 @@
 
 	if (info->ethertype == _htons(RTE_ETHER_TYPE_IPV4)) {
 		ipv4_hdr = l3_hdr;
+		ipv4_hdr->hdr_checksum = 0;
 
-		ol_flags |= RTE_MBUF_F_TX_IPV4;
+		ol_flags |= PKT_TX_IPV4;
 		if (info->l4_proto == IPPROTO_TCP && tso_segsz) {
-			ol_flags |= RTE_MBUF_F_TX_IP_CKSUM;
+			ol_flags |= PKT_TX_IP_CKSUM;
 		} else {
-			if (tx_offloads & RTE_ETH_TX_OFFLOAD_IPV4_CKSUM) {
-				ol_flags |= RTE_MBUF_F_TX_IP_CKSUM;
-			} else {
-				ipv4_hdr->hdr_checksum = 0;
+			if (tx_offloads & DEV_TX_OFFLOAD_IPV4_CKSUM)
+				ol_flags |= PKT_TX_IP_CKSUM;
+			else
 				ipv4_hdr->hdr_checksum =
 					rte_ipv4_cksum(ipv4_hdr);
-			}
 		}
 	} else if (info->ethertype == _htons(RTE_ETHER_TYPE_IPV6))
-		ol_flags |= RTE_MBUF_F_TX_IPV6;
+		ol_flags |= PKT_TX_IPV6;
 	else
 		return 0; /* packet type not supported, nothing to do */
 
@@ -505,56 +471,41 @@
 		udp_hdr = (struct rte_udp_hdr *)((char *)l3_hdr + info->l3_len);
 		/* do not recalculate udp cksum if it was 0 */
 		if (udp_hdr->dgram_cksum != 0) {
-			if (tx_offloads & RTE_ETH_TX_OFFLOAD_UDP_CKSUM) {
-				ol_flags |= RTE_MBUF_F_TX_UDP_CKSUM;
-			} else {
-				if (info->is_tunnel)
-					l4_off = info->outer_l2_len +
-						 info->outer_l3_len +
-						 info->l2_len + info->l3_len;
-				else
-					l4_off = info->l2_len +	info->l3_len;
-				udp_hdr->dgram_cksum = 0;
+			udp_hdr->dgram_cksum = 0;
+			if (tx_offloads & DEV_TX_OFFLOAD_UDP_CKSUM)
+				ol_flags |= PKT_TX_UDP_CKSUM;
+			else {
 				udp_hdr->dgram_cksum =
-					get_udptcp_checksum(m, l3_hdr, l4_off,
+					get_udptcp_checksum(l3_hdr, udp_hdr,
 						info->ethertype);
 			}
 		}
-#ifdef RTE_LIB_GSO
 		if (info->gso_enable)
-			ol_flags |= RTE_MBUF_F_TX_UDP_SEG;
-#endif
+			ol_flags |= PKT_TX_UDP_SEG;
 	} else if (info->l4_proto == IPPROTO_TCP) {
 		tcp_hdr = (struct rte_tcp_hdr *)((char *)l3_hdr + info->l3_len);
+		tcp_hdr->cksum = 0;
 		if (tso_segsz)
-			ol_flags |= RTE_MBUF_F_TX_TCP_SEG;
-		else if (tx_offloads & RTE_ETH_TX_OFFLOAD_TCP_CKSUM) {
-			ol_flags |= RTE_MBUF_F_TX_TCP_CKSUM;
-		} else {
-			if (info->is_tunnel)
-				l4_off = info->outer_l2_len + info->outer_l3_len +
-					 info->l2_len + info->l3_len;
-			else
-				l4_off = info->l2_len + info->l3_len;
-			tcp_hdr->cksum = 0;
+			ol_flags |= PKT_TX_TCP_SEG;
+		else if (tx_offloads & DEV_TX_OFFLOAD_TCP_CKSUM)
+			ol_flags |= PKT_TX_TCP_CKSUM;
+		else {
 			tcp_hdr->cksum =
-				get_udptcp_checksum(m, l3_hdr, l4_off,
+				get_udptcp_checksum(l3_hdr, tcp_hdr,
 					info->ethertype);
 		}
-#ifdef RTE_LIB_GSO
 		if (info->gso_enable)
-			ol_flags |= RTE_MBUF_F_TX_TCP_SEG;
-#endif
+			ol_flags |= PKT_TX_TCP_SEG;
 	} else if (info->l4_proto == IPPROTO_SCTP) {
 		sctp_hdr = (struct rte_sctp_hdr *)
 			((char *)l3_hdr + info->l3_len);
+		sctp_hdr->cksum = 0;
 		/* sctp payload must be a multiple of 4 to be
 		 * offloaded */
-		if ((tx_offloads & RTE_ETH_TX_OFFLOAD_SCTP_CKSUM) &&
+		if ((tx_offloads & DEV_TX_OFFLOAD_SCTP_CKSUM) &&
 			((ipv4_hdr->total_length & 0x3) == 0)) {
-			ol_flags |= RTE_MBUF_F_TX_SCTP_CKSUM;
+			ol_flags |= PKT_TX_SCTP_CKSUM;
 		} else {
-			sctp_hdr->cksum = 0;
 			/* XXX implement CRC32c, example available in
 			 * RFC3309 */
 		}
@@ -566,7 +517,7 @@
 /* Calculate the checksum of outer header */
 static uint64_t
 process_outer_cksums(void *outer_l3_hdr, struct testpmd_offload_info *info,
-	uint64_t tx_offloads, int tso_enabled, struct rte_mbuf *m)
+	uint64_t tx_offloads, int tso_enabled)
 {
 	struct rte_ipv4_hdr *ipv4_hdr = outer_l3_hdr;
 	struct rte_ipv6_hdr *ipv6_hdr = outer_l3_hdr;
@@ -575,14 +526,14 @@
 
 	if (info->outer_ethertype == _htons(RTE_ETHER_TYPE_IPV4)) {
 		ipv4_hdr->hdr_checksum = 0;
-		ol_flags |= RTE_MBUF_F_TX_OUTER_IPV4;
+		ol_flags |= PKT_TX_OUTER_IPV4;
 
-		if (tx_offloads	& RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM)
-			ol_flags |= RTE_MBUF_F_TX_OUTER_IP_CKSUM;
+		if (tx_offloads	& DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM)
+			ol_flags |= PKT_TX_OUTER_IP_CKSUM;
 		else
 			ipv4_hdr->hdr_checksum = rte_ipv4_cksum(ipv4_hdr);
 	} else
-		ol_flags |= RTE_MBUF_F_TX_OUTER_IPV6;
+		ol_flags |= PKT_TX_OUTER_IPV6;
 
 	if (info->outer_l4_proto != IPPROTO_UDP)
 		return ol_flags;
@@ -591,10 +542,10 @@
 		((char *)outer_l3_hdr + info->outer_l3_len);
 
 	if (tso_enabled)
-		ol_flags |= RTE_MBUF_F_TX_TCP_SEG;
+		ol_flags |= PKT_TX_TCP_SEG;
 
 	/* Skip SW outer UDP checksum generation if HW supports it */
-	if (tx_offloads & RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM) {
+	if (tx_offloads & DEV_TX_OFFLOAD_OUTER_UDP_CKSUM) {
 		if (info->outer_ethertype == _htons(RTE_ETHER_TYPE_IPV4))
 			udp_hdr->dgram_cksum
 				= rte_ipv4_phdr_cksum(ipv4_hdr, ol_flags);
@@ -602,7 +553,7 @@
 			udp_hdr->dgram_cksum
 				= rte_ipv6_phdr_cksum(ipv6_hdr, ol_flags);
 
-		ol_flags |= RTE_MBUF_F_TX_OUTER_UDP_CKSUM;
+		ol_flags |= PKT_TX_OUTER_UDP_CKSUM;
 		return ol_flags;
 	}
 
@@ -620,9 +571,12 @@
 	/* do not recalculate udp cksum if it was 0 */
 	if (udp_hdr->dgram_cksum != 0) {
 		udp_hdr->dgram_cksum = 0;
-		udp_hdr->dgram_cksum = get_udptcp_checksum(m, outer_l3_hdr,
-					info->outer_l2_len + info->outer_l3_len,
-					info->outer_ethertype);
+		if (info->outer_ethertype == _htons(RTE_ETHER_TYPE_IPV4))
+			udp_hdr->dgram_cksum =
+				rte_ipv4_udptcp_cksum(ipv4_hdr, udp_hdr);
+		else
+			udp_hdr->dgram_cksum =
+				rte_ipv6_udptcp_cksum(ipv6_hdr, udp_hdr);
 	}
 
 	return ol_flags;
@@ -712,7 +666,7 @@
 	mp = current_fwd_lcore()->mbp;
 
 	if (tx_pkt_split == TX_PKT_SPLIT_RND)
-		nb_seg = rte_rand() % tx_pkt_nb_segs + 1;
+		nb_seg = random() % tx_pkt_nb_segs + 1;
 	else
 		nb_seg = tx_pkt_nb_segs;
 
@@ -777,28 +731,6 @@
 	return md[0];
 }
 
-#if defined(RTE_LIB_GRO) || defined(RTE_LIB_GSO)
-/*
- * Re-calculate IP checksum for merged/fragmented packets.
- */
-static void
-pkts_ip_csum_recalc(struct rte_mbuf **pkts_burst, const uint16_t nb_pkts, uint64_t tx_offloads)
-{
-	int i;
-	struct rte_ipv4_hdr *ipv4_hdr;
-	for (i = 0; i < nb_pkts; i++) {
-		if ((pkts_burst[i]->ol_flags & RTE_MBUF_F_TX_IPV4) &&
-			(tx_offloads & RTE_ETH_TX_OFFLOAD_IPV4_CKSUM) == 0) {
-			ipv4_hdr = rte_pktmbuf_mtod_offset(pkts_burst[i],
-						struct rte_ipv4_hdr *,
-						pkts_burst[i]->l2_len);
-			ipv4_hdr->hdr_checksum = 0;
-			ipv4_hdr->hdr_checksum = rte_ipv4_cksum(ipv4_hdr);
-		}
-	}
-}
-#endif
-
 /*
  * Receive a burst of packets, and for each packet:
  *  - parse packet, and try to recognize a supported packet type (1)
@@ -824,7 +756,7 @@
  *
  * The testpmd command line for this forward engine sets the flags
  * TESTPMD_TX_OFFLOAD_* in ports[tx_port].tx_ol_flags. They control
- * whether a checksum must be calculated in software or in hardware. The
+ * wether a checksum must be calculated in software or in hardware. The
  * IP, UDP, TCP and SCTP flags always concern the inner layer. The
  * OUTER_IP is only useful for tunnel packets.
  */
@@ -832,20 +764,16 @@
 pkt_burst_checksum_forward(struct fwd_stream *fs)
 {
 	struct rte_mbuf *pkts_burst[MAX_PKT_BURST];
-#ifdef RTE_LIB_GSO
 	struct rte_mbuf *gso_segments[GSO_MAX_PKT_BURST];
 	struct rte_gso_ctx *gso_ctx;
-#endif
 	struct rte_mbuf **tx_pkts_burst;
 	struct rte_port *txp;
 	struct rte_mbuf *m, *p;
 	struct rte_ether_hdr *eth_hdr;
 	void *l3_hdr = NULL, *outer_l3_hdr = NULL; /* can be IPv4 or IPv6 */
-#ifdef RTE_LIB_GRO
 	void **gro_ctx;
 	uint16_t gro_pkts_num;
 	uint8_t gro_enable;
-#endif
 	uint16_t nb_rx;
 	uint16_t nb_tx;
 	uint16_t nb_prep;
@@ -856,38 +784,41 @@
 	uint32_t rx_bad_ip_csum;
 	uint32_t rx_bad_l4_csum;
 	uint32_t rx_bad_outer_l4_csum;
-	uint32_t rx_bad_outer_ip_csum;
 	struct testpmd_offload_info info;
+	uint16_t nb_segments = 0;
+	int ret;
 
-	uint64_t start_tsc = 0;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+#endif
 
-	get_start_cycles(&start_tsc);
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	start_tsc = rte_rdtsc();
+#endif
 
 	/* receive a burst of packet */
 	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue, pkts_burst,
 				 nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
 	if (unlikely(nb_rx == 0))
 		return;
-
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->rx_burst_stats.pkt_burst_spread[nb_rx]++;
+#endif
 	fs->rx_packets += nb_rx;
 	rx_bad_ip_csum = 0;
 	rx_bad_l4_csum = 0;
 	rx_bad_outer_l4_csum = 0;
-	rx_bad_outer_ip_csum = 0;
-#ifdef RTE_LIB_GRO
 	gro_enable = gro_ports[fs->rx_port].enable;
-#endif
 
 	txp = &ports[fs->tx_port];
 	tx_offloads = txp->dev_conf.txmode.offloads;
 	memset(&info, 0, sizeof(info));
 	info.tso_segsz = txp->tso_segsz;
 	info.tunnel_tso_segsz = txp->tunnel_tso_segsz;
-#ifdef RTE_LIB_GSO
 	if (gso_ports[fs->tx_port].enable)
 		info.gso_enable = 1;
-#endif
 
 	for (i = 0; i < nb_rx; i++) {
 		if (likely(i < nb_rx - 1))
@@ -898,29 +829,25 @@
 		info.is_tunnel = 0;
 		info.pkt_len = rte_pktmbuf_pkt_len(m);
 		tx_ol_flags = m->ol_flags &
-			      (RTE_MBUF_F_INDIRECT | RTE_MBUF_F_EXTERNAL);
+			      (IND_ATTACHED_MBUF | EXT_ATTACHED_MBUF);
 		rx_ol_flags = m->ol_flags;
 
 		/* Update the L3/L4 checksum error packet statistics */
-		if ((rx_ol_flags & RTE_MBUF_F_RX_IP_CKSUM_MASK) == RTE_MBUF_F_RX_IP_CKSUM_BAD)
+		if ((rx_ol_flags & PKT_RX_IP_CKSUM_MASK) == PKT_RX_IP_CKSUM_BAD)
 			rx_bad_ip_csum += 1;
-		if ((rx_ol_flags & RTE_MBUF_F_RX_L4_CKSUM_MASK) == RTE_MBUF_F_RX_L4_CKSUM_BAD)
+		if ((rx_ol_flags & PKT_RX_L4_CKSUM_MASK) == PKT_RX_L4_CKSUM_BAD)
 			rx_bad_l4_csum += 1;
-		if (rx_ol_flags & RTE_MBUF_F_RX_OUTER_L4_CKSUM_BAD)
+		if (rx_ol_flags & PKT_RX_OUTER_L4_CKSUM_BAD)
 			rx_bad_outer_l4_csum += 1;
-		if (rx_ol_flags & RTE_MBUF_F_RX_OUTER_IP_CKSUM_BAD)
-			rx_bad_outer_ip_csum += 1;
 
 		/* step 1: dissect packet, parsing optional vlan, ip4/ip6, vxlan
 		 * and inner headers */
 
 		eth_hdr = rte_pktmbuf_mtod(m, struct rte_ether_hdr *);
-		if (ports[fs->tx_port].fwd_mac_swap) {
-			rte_ether_addr_copy(&peer_eth_addrs[fs->peer_addr],
-					    &eth_hdr->dst_addr);
-			rte_ether_addr_copy(&ports[fs->tx_port].eth_addr,
-					    &eth_hdr->src_addr);
-		}
+		rte_ether_addr_copy(&peer_eth_addrs[fs->peer_addr],
+				&eth_hdr->d_addr);
+		rte_ether_addr_copy(&ports[fs->tx_port].eth_addr,
+				&eth_hdr->s_addr);
 		parse_ethernet(eth_hdr, &info);
 		l3_hdr = (char *)eth_hdr + info.l2_len;
 
@@ -933,33 +860,20 @@
 					((char *)l3_hdr + info.l3_len);
 				parse_gtp(udp_hdr, &info);
 				if (info.is_tunnel) {
-					tx_ol_flags |= RTE_MBUF_F_TX_TUNNEL_GTP;
+					tx_ol_flags |= PKT_TX_TUNNEL_GTP;
 					goto tunnel_update;
 				}
 				parse_vxlan_gpe(udp_hdr, &info);
 				if (info.is_tunnel) {
 					tx_ol_flags |=
-						RTE_MBUF_F_TX_TUNNEL_VXLAN_GPE;
+						PKT_TX_TUNNEL_VXLAN_GPE;
 					goto tunnel_update;
 				}
-				parse_vxlan(udp_hdr, &info);
-				if (info.is_tunnel) {
-					tx_ol_flags |=
-						RTE_MBUF_F_TX_TUNNEL_VXLAN;
-					goto tunnel_update;
-				}
-				parse_geneve(udp_hdr, &info);
-				if (info.is_tunnel) {
+				parse_vxlan(udp_hdr, &info,
+					    m->packet_type);
+				if (info.is_tunnel)
 					tx_ol_flags |=
-						RTE_MBUF_F_TX_TUNNEL_GENEVE;
-					goto tunnel_update;
-				}
-				/* Always keep last. */
-				if (unlikely(RTE_ETH_IS_TUNNEL_PKT(
-							m->packet_type) != 0)) {
-					TESTPMD_LOG(DEBUG, "Unknown tunnel packet. UDP dst port: %hu",
-						udp_hdr->dst_port);
-				}
+						PKT_TX_TUNNEL_VXLAN;
 			} else if (info.l4_proto == IPPROTO_GRE) {
 				struct simple_gre_hdr *gre_hdr;
 
@@ -967,14 +881,14 @@
 					((char *)l3_hdr + info.l3_len);
 				parse_gre(gre_hdr, &info);
 				if (info.is_tunnel)
-					tx_ol_flags |= RTE_MBUF_F_TX_TUNNEL_GRE;
+					tx_ol_flags |= PKT_TX_TUNNEL_GRE;
 			} else if (info.l4_proto == IPPROTO_IPIP) {
 				void *encap_ip_hdr;
 
 				encap_ip_hdr = (char *)l3_hdr + info.l3_len;
 				parse_encap_ip(encap_ip_hdr, &info);
 				if (info.is_tunnel)
-					tx_ol_flags |= RTE_MBUF_F_TX_TUNNEL_IPIP;
+					tx_ol_flags |= PKT_TX_TUNNEL_IPIP;
 			}
 		}
 
@@ -992,7 +906,7 @@
 
 		/* process checksums of inner headers first */
 		tx_ol_flags |= process_inner_cksums(l3_hdr, &info,
-			tx_offloads, m);
+			tx_offloads);
 
 		/* Then process outer headers if any. Note that the software
 		 * checksum will be wrong if one of the inner checksums is
@@ -1000,8 +914,7 @@
 		if (info.is_tunnel == 1) {
 			tx_ol_flags |= process_outer_cksums(outer_l3_hdr, &info,
 					tx_offloads,
-					!!(tx_ol_flags & RTE_MBUF_F_TX_TCP_SEG),
-					m);
+					!!(tx_ol_flags & PKT_TX_TCP_SEG));
 		}
 
 		/* step 3: fill the mbuf meta data (flags and header lengths) */
@@ -1010,9 +923,10 @@
 		if (info.is_tunnel == 1) {
 			if (info.tunnel_tso_segsz ||
 			    (tx_offloads &
-			     RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM) ||
+			     DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM) ||
 			    (tx_offloads &
-			     RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM)) {
+			     DEV_TX_OFFLOAD_OUTER_UDP_CKSUM) ||
+			    (tx_ol_flags & PKT_TX_OUTER_IPV6)) {
 				m->outer_l2_len = info.outer_l2_len;
 				m->outer_l3_len = info.outer_l3_len;
 				m->l2_len = info.l2_len;
@@ -1065,7 +979,7 @@
 				"l4_proto=%d l4_len=%d flags=%s\n",
 				info.l2_len, rte_be_to_cpu_16(info.ethertype),
 				info.l3_len, info.l4_proto, info.l4_len, buf);
-			if (rx_ol_flags & RTE_MBUF_F_RX_LRO)
+			if (rx_ol_flags & PKT_RX_LRO)
 				printf("rx: m->lro_segsz=%u\n", m->tso_segsz);
 			if (info.is_tunnel == 1)
 				printf("rx: outer_l2_len=%d outer_ethertype=%x "
@@ -1073,30 +987,30 @@
 					rte_be_to_cpu_16(info.outer_ethertype),
 					info.outer_l3_len);
 			/* dump tx packet info */
-			if ((tx_offloads & (RTE_ETH_TX_OFFLOAD_IPV4_CKSUM |
-					    RTE_ETH_TX_OFFLOAD_UDP_CKSUM |
-					    RTE_ETH_TX_OFFLOAD_TCP_CKSUM |
-					    RTE_ETH_TX_OFFLOAD_SCTP_CKSUM)) ||
+			if ((tx_offloads & (DEV_TX_OFFLOAD_IPV4_CKSUM |
+					    DEV_TX_OFFLOAD_UDP_CKSUM |
+					    DEV_TX_OFFLOAD_TCP_CKSUM |
+					    DEV_TX_OFFLOAD_SCTP_CKSUM)) ||
 				info.tso_segsz != 0)
 				printf("tx: m->l2_len=%d m->l3_len=%d "
 					"m->l4_len=%d\n",
 					m->l2_len, m->l3_len, m->l4_len);
 			if (info.is_tunnel == 1) {
 				if ((tx_offloads &
-				    RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM) ||
+				    DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM) ||
 				    (tx_offloads &
-				    RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM) ||
-				    (tx_ol_flags & RTE_MBUF_F_TX_OUTER_IPV6))
+				    DEV_TX_OFFLOAD_OUTER_UDP_CKSUM) ||
+				    (tx_ol_flags & PKT_TX_OUTER_IPV6))
 					printf("tx: m->outer_l2_len=%d "
 						"m->outer_l3_len=%d\n",
 						m->outer_l2_len,
 						m->outer_l3_len);
 				if (info.tunnel_tso_segsz != 0 &&
-						(m->ol_flags & RTE_MBUF_F_TX_TCP_SEG))
+						(m->ol_flags & PKT_TX_TCP_SEG))
 					printf("tx: m->tso_segsz=%d\n",
 						m->tso_segsz);
 			} else if (info.tso_segsz != 0 &&
-					(m->ol_flags & RTE_MBUF_F_TX_TCP_SEG))
+					(m->ol_flags & PKT_TX_TCP_SEG))
 				printf("tx: m->tso_segsz=%d\n", m->tso_segsz);
 			rte_get_tx_ol_flag_list(m->ol_flags, buf, sizeof(buf));
 			printf("tx: flags=%s", buf);
@@ -1104,7 +1018,6 @@
 		}
 	}
 
-#ifdef RTE_LIB_GRO
 	if (unlikely(gro_enable)) {
 		if (gro_flush_cycles == GRO_DEFAULT_FLUSH_CYCLES) {
 			nb_rx = rte_gro_reassemble_burst(pkts_burst, nb_rx,
@@ -1125,34 +1038,20 @@
 				fs->gro_times = 0;
 			}
 		}
-
-		pkts_ip_csum_recalc(pkts_burst, nb_rx, tx_offloads);
 	}
-#endif
-
-#ifdef RTE_LIB_GSO
-	if (gso_ports[fs->tx_port].enable != 0) {
-		uint16_t nb_segments = 0;
 
+	if (gso_ports[fs->tx_port].enable == 0)
+		tx_pkts_burst = pkts_burst;
+	else {
 		gso_ctx = &(current_fwd_lcore()->gso_ctx);
 		gso_ctx->gso_size = gso_max_segment_size;
 		for (i = 0; i < nb_rx; i++) {
-			int ret;
-
 			ret = rte_gso_segment(pkts_burst[i], gso_ctx,
 					&gso_segments[nb_segments],
 					GSO_MAX_PKT_BURST - nb_segments);
-			if (ret >= 1) {
-				/* pkts_burst[i] can be freed safely here. */
-				rte_pktmbuf_free(pkts_burst[i]);
+			if (ret >= 0)
 				nb_segments += ret;
-			} else if (ret == 0) {
-				/* 0 means it can be transmitted directly
-				 * without gso.
-				 */
-				gso_segments[nb_segments] = pkts_burst[i];
-				nb_segments += 1;
-			} else {
+			else {
 				TESTPMD_LOG(DEBUG, "Unable to segment packet");
 				rte_pktmbuf_free(pkts_burst[i]);
 			}
@@ -1160,21 +1059,13 @@
 
 		tx_pkts_burst = gso_segments;
 		nb_rx = nb_segments;
-
-		pkts_ip_csum_recalc(tx_pkts_burst, nb_rx, tx_offloads);
-	} else
-#endif
-		tx_pkts_burst = pkts_burst;
+	}
 
 	nb_prep = rte_eth_tx_prepare(fs->tx_port, fs->tx_queue,
 			tx_pkts_burst, nb_rx);
-	if (nb_prep != nb_rx) {
-		fprintf(stderr,
-			"Preparing packet burst to transmit failed: %s\n",
-			rte_strerror(rte_errno));
-		fs->fwd_dropped += (nb_rx - nb_prep);
-		rte_pktmbuf_free_bulk(&tx_pkts_burst[nb_prep], nb_rx - nb_prep);
-	}
+	if (nb_prep != nb_rx)
+		printf("Preparing packet burst to transmit failed: %s\n",
+				rte_strerror(rte_errno));
 
 	nb_tx = rte_eth_tx_burst(fs->tx_port, fs->tx_queue, tx_pkts_burst,
 			nb_prep);
@@ -1182,47 +1073,39 @@
 	/*
 	 * Retry if necessary
 	 */
-	if (unlikely(nb_tx < nb_prep) && fs->retry_enabled) {
+	if (unlikely(nb_tx < nb_rx) && fs->retry_enabled) {
 		retry = 0;
-		while (nb_tx < nb_prep && retry++ < burst_tx_retry_num) {
+		while (nb_tx < nb_rx && retry++ < burst_tx_retry_num) {
 			rte_delay_us(burst_tx_delay_time);
 			nb_tx += rte_eth_tx_burst(fs->tx_port, fs->tx_queue,
-					&tx_pkts_burst[nb_tx], nb_prep - nb_tx);
+					&tx_pkts_burst[nb_tx], nb_rx - nb_tx);
 		}
 	}
 	fs->tx_packets += nb_tx;
 	fs->rx_bad_ip_csum += rx_bad_ip_csum;
 	fs->rx_bad_l4_csum += rx_bad_l4_csum;
 	fs->rx_bad_outer_l4_csum += rx_bad_outer_l4_csum;
-	fs->rx_bad_outer_ip_csum += rx_bad_outer_ip_csum;
 
-	inc_tx_burst_stats(fs, nb_tx);
-	if (unlikely(nb_tx < nb_prep)) {
-		fs->fwd_dropped += (nb_prep - nb_tx);
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+#endif
+	if (unlikely(nb_tx < nb_rx)) {
+		fs->fwd_dropped += (nb_rx - nb_tx);
 		do {
 			rte_pktmbuf_free(tx_pkts_burst[nb_tx]);
-		} while (++nb_tx < nb_prep);
+		} while (++nb_tx < nb_rx);
 	}
 
-	get_end_cycles(fs, start_tsc);
-}
-
-static void
-stream_init_checksum_forward(struct fwd_stream *fs)
-{
-	bool rx_stopped, tx_stopped;
-
-	rx_stopped = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	tx_stopped = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	fs->disabled = rx_stopped || tx_stopped;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
 }
 
 struct fwd_engine csum_fwd_engine = {
 	.fwd_mode_name  = "csum",
 	.port_fwd_begin = NULL,
 	.port_fwd_end   = NULL,
-	.stream_init    = stream_init_checksum_forward,
 	.packet_fwd     = pkt_burst_checksum_forward,
 };
diff -urN dpdk/app/test-pmd/flowgen.c testpmd-as-load-balancer/v19.11/test-pmd/flowgen.c
--- dpdk/app/test-pmd/flowgen.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/flowgen.c	2023-12-15 15:26:37.090199134 +0100
@@ -1,5 +1,35 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright 2014-2020 Mellanox Technologies, Ltd
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2010-2013 Tilera Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Tilera Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
  */
 
 #include <stdarg.h>
@@ -24,10 +54,12 @@
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_mempool.h>
 #include <rte_mbuf.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_ip.h>
@@ -38,6 +70,8 @@
 
 #include "testpmd.h"
 
+/* hardcoded configuration (for now) */
+static unsigned cfg_n_flows	= 1024;
 static uint32_t cfg_ip_src	= RTE_IPV4(10, 254, 0, 0);
 static uint32_t cfg_ip_dst	= RTE_IPV4(10, 253, 0, 0);
 static uint16_t cfg_udp_src	= 1000;
@@ -49,7 +83,24 @@
 
 #define IP_DEFTTL  64   /* from RFC 1340. */
 
-RTE_DEFINE_PER_LCORE(int, _next_flow);
+static inline uint16_t
+ip_sum(const unaligned_uint16_t *hdr, int hdr_len)
+{
+	uint32_t sum = 0;
+
+	while (hdr_len > 1)
+	{
+		sum += *hdr++;
+		if (sum & 0x80000000)
+			sum = (sum & 0xFFFF) + (sum >> 16);
+		hdr_len -= 2;
+	}
+
+	while (sum >> 16)
+		sum = (sum & 0xFFFF) + (sum >> 16);
+
+	return ~sum;
+}
 
 /*
  * Multi-flow generation mode.
@@ -64,7 +115,7 @@
 	unsigned pkt_size = tx_pkt_length - 4;	/* Adjust FCS */
 	struct rte_mbuf  *pkts_burst[MAX_PKT_BURST];
 	struct rte_mempool *mbp;
-	struct rte_mbuf  *pkt = NULL;
+	struct rte_mbuf  *pkt;
 	struct rte_ether_hdr *eth_hdr;
 	struct rte_ipv4_hdr *ip_hdr;
 	struct rte_udp_hdr *udp_hdr;
@@ -72,21 +123,24 @@
 	uint64_t ol_flags = 0;
 	uint16_t nb_rx;
 	uint16_t nb_tx;
-	uint16_t nb_dropped;
 	uint16_t nb_pkt;
-	uint16_t nb_clones = nb_pkt_flowgen_clones;
 	uint16_t i;
 	uint32_t retry;
 	uint64_t tx_offloads;
-	uint64_t start_tsc = 0;
-	int next_flow = RTE_PER_LCORE(_next_flow);
-
-	get_start_cycles(&start_tsc);
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+#endif
+	static int next_flow = 0;
+
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	start_tsc = rte_rdtsc();
+#endif
 
 	/* Receive a burst of packets and discard them. */
 	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue, pkts_burst,
 				 nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
 	fs->rx_packets += nb_rx;
 
 	for (i = 0; i < nb_rx; i++)
@@ -97,131 +151,101 @@
 	vlan_tci_outer = ports[fs->tx_port].tx_vlan_id_outer;
 
 	tx_offloads = ports[fs->tx_port].dev_conf.txmode.offloads;
-	if (tx_offloads	& RTE_ETH_TX_OFFLOAD_VLAN_INSERT)
-		ol_flags |= RTE_MBUF_F_TX_VLAN;
-	if (tx_offloads & RTE_ETH_TX_OFFLOAD_QINQ_INSERT)
-		ol_flags |= RTE_MBUF_F_TX_QINQ;
-	if (tx_offloads	& RTE_ETH_TX_OFFLOAD_MACSEC_INSERT)
-		ol_flags |= RTE_MBUF_F_TX_MACSEC;
+	if (tx_offloads	& DEV_TX_OFFLOAD_VLAN_INSERT)
+		ol_flags |= PKT_TX_VLAN_PKT;
+	if (tx_offloads & DEV_TX_OFFLOAD_QINQ_INSERT)
+		ol_flags |= PKT_TX_QINQ_PKT;
+	if (tx_offloads	& DEV_TX_OFFLOAD_MACSEC_INSERT)
+		ol_flags |= PKT_TX_MACSEC;
 
 	for (nb_pkt = 0; nb_pkt < nb_pkt_per_burst; nb_pkt++) {
-		if (!nb_pkt || !nb_clones) {
-			nb_clones = nb_pkt_flowgen_clones;
-			/* Logic limitation */
-			if (nb_clones > nb_pkt_per_burst)
-				nb_clones = nb_pkt_per_burst;
-
-			pkt = rte_mbuf_raw_alloc(mbp);
-			if (!pkt)
-				break;
-
-			pkt->data_len = pkt_size;
-			pkt->next = NULL;
-
-			/* Initialize Ethernet header. */
-			eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
-			rte_ether_addr_copy(&cfg_ether_dst, &eth_hdr->dst_addr);
-			rte_ether_addr_copy(&cfg_ether_src, &eth_hdr->src_addr);
-			eth_hdr->ether_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4);
-
-			/* Initialize IP header. */
-			ip_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
-			memset(ip_hdr, 0, sizeof(*ip_hdr));
-			ip_hdr->version_ihl	= RTE_IPV4_VHL_DEF;
-			ip_hdr->type_of_service	= 0;
-			ip_hdr->fragment_offset	= 0;
-			ip_hdr->time_to_live	= IP_DEFTTL;
-			ip_hdr->next_proto_id	= IPPROTO_UDP;
-			ip_hdr->packet_id	= 0;
-			ip_hdr->src_addr	= rte_cpu_to_be_32(cfg_ip_src);
-			ip_hdr->dst_addr	= rte_cpu_to_be_32(cfg_ip_dst +
-								   next_flow);
-			ip_hdr->total_length	= RTE_CPU_TO_BE_16(pkt_size -
-								   sizeof(*eth_hdr));
-			ip_hdr->hdr_checksum	= rte_ipv4_cksum(ip_hdr);
-
-			/* Initialize UDP header. */
-			udp_hdr = (struct rte_udp_hdr *)(ip_hdr + 1);
-			udp_hdr->src_port	= rte_cpu_to_be_16(cfg_udp_src);
-			udp_hdr->dst_port	= rte_cpu_to_be_16(cfg_udp_dst);
-			udp_hdr->dgram_cksum	= 0; /* No UDP checksum. */
-			udp_hdr->dgram_len	= RTE_CPU_TO_BE_16(pkt_size -
-								   sizeof(*eth_hdr) -
-								   sizeof(*ip_hdr));
-			pkt->nb_segs		= 1;
-			pkt->pkt_len		= pkt_size;
-			pkt->ol_flags		&= RTE_MBUF_F_EXTERNAL;
-			pkt->ol_flags		|= ol_flags;
-			pkt->vlan_tci		= vlan_tci;
-			pkt->vlan_tci_outer	= vlan_tci_outer;
-			pkt->l2_len		= sizeof(struct rte_ether_hdr);
-			pkt->l3_len		= sizeof(struct rte_ipv4_hdr);
-		} else {
-			nb_clones--;
-			rte_mbuf_refcnt_update(pkt, 1);
-		}
-		pkts_burst[nb_pkt] = pkt;
+		pkt = rte_mbuf_raw_alloc(mbp);
+		if (!pkt)
+			break;
+
+		pkt->data_len = pkt_size;
+		pkt->next = NULL;
+
+		/* Initialize Ethernet header. */
+		eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
+		rte_ether_addr_copy(&cfg_ether_dst, &eth_hdr->d_addr);
+		rte_ether_addr_copy(&cfg_ether_src, &eth_hdr->s_addr);
+		eth_hdr->ether_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4);
+
+		/* Initialize IP header. */
+		ip_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
+		memset(ip_hdr, 0, sizeof(*ip_hdr));
+		ip_hdr->version_ihl	= RTE_IPV4_VHL_DEF;
+		ip_hdr->type_of_service	= 0;
+		ip_hdr->fragment_offset	= 0;
+		ip_hdr->time_to_live	= IP_DEFTTL;
+		ip_hdr->next_proto_id	= IPPROTO_UDP;
+		ip_hdr->packet_id	= 0;
+		ip_hdr->src_addr	= rte_cpu_to_be_32(cfg_ip_src);
+		ip_hdr->dst_addr	= rte_cpu_to_be_32(cfg_ip_dst +
+							   next_flow);
+		ip_hdr->total_length	= RTE_CPU_TO_BE_16(pkt_size -
+							   sizeof(*eth_hdr));
+		ip_hdr->hdr_checksum	= ip_sum((unaligned_uint16_t *)ip_hdr,
+						 sizeof(*ip_hdr));
+
+		/* Initialize UDP header. */
+		udp_hdr = (struct rte_udp_hdr *)(ip_hdr + 1);
+		udp_hdr->src_port	= rte_cpu_to_be_16(cfg_udp_src);
+		udp_hdr->dst_port	= rte_cpu_to_be_16(cfg_udp_dst);
+		udp_hdr->dgram_cksum	= 0; /* No UDP checksum. */
+		udp_hdr->dgram_len	= RTE_CPU_TO_BE_16(pkt_size -
+							   sizeof(*eth_hdr) -
+							   sizeof(*ip_hdr));
+		pkt->nb_segs		= 1;
+		pkt->pkt_len		= pkt_size;
+		pkt->ol_flags		= ol_flags;
+		pkt->vlan_tci		= vlan_tci;
+		pkt->vlan_tci_outer	= vlan_tci_outer;
+		pkt->l2_len		= sizeof(struct rte_ether_hdr);
+		pkt->l3_len		= sizeof(struct rte_ipv4_hdr);
+		pkts_burst[nb_pkt]	= pkt;
 
-		if (++next_flow >= nb_flows_flowgen)
-			next_flow = 0;
+		next_flow = (next_flow + 1) % cfg_n_flows;
 	}
 
 	nb_tx = rte_eth_tx_burst(fs->tx_port, fs->tx_queue, pkts_burst, nb_pkt);
 	/*
 	 * Retry if necessary
 	 */
-	if (unlikely(nb_tx < nb_pkt) && fs->retry_enabled) {
+	if (unlikely(nb_tx < nb_rx) && fs->retry_enabled) {
 		retry = 0;
-		while (nb_tx < nb_pkt && retry++ < burst_tx_retry_num) {
+		while (nb_tx < nb_rx && retry++ < burst_tx_retry_num) {
 			rte_delay_us(burst_tx_delay_time);
 			nb_tx += rte_eth_tx_burst(fs->tx_port, fs->tx_queue,
-					&pkts_burst[nb_tx], nb_pkt - nb_tx);
+					&pkts_burst[nb_tx], nb_rx - nb_tx);
 		}
 	}
 	fs->tx_packets += nb_tx;
 
-	inc_tx_burst_stats(fs, nb_tx);
-	nb_dropped = nb_pkt - nb_tx;
-	if (unlikely(nb_dropped > 0)) {
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+#endif
+	if (unlikely(nb_tx < nb_pkt)) {
 		/* Back out the flow counter. */
-		next_flow -= nb_dropped;
+		next_flow -= (nb_pkt - nb_tx);
 		while (next_flow < 0)
-			next_flow += nb_flows_flowgen;
+			next_flow += cfg_n_flows;
 
-		fs->fwd_dropped += nb_dropped;
 		do {
 			rte_pktmbuf_free(pkts_burst[nb_tx]);
 		} while (++nb_tx < nb_pkt);
 	}
-
-	RTE_PER_LCORE(_next_flow) = next_flow;
-
-	get_end_cycles(fs, start_tsc);
-}
-
-static int
-flowgen_begin(portid_t pi)
-{
-	printf("  number of flows for port %u: %d\n", pi, nb_flows_flowgen);
-	return 0;
-}
-
-static void
-flowgen_stream_init(struct fwd_stream *fs)
-{
-	bool rx_stopped, tx_stopped;
-
-	rx_stopped = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	tx_stopped = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	fs->disabled = rx_stopped || tx_stopped;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
 }
 
 struct fwd_engine flow_gen_engine = {
 	.fwd_mode_name  = "flowgen",
-	.port_fwd_begin = flowgen_begin,
+	.port_fwd_begin = NULL,
 	.port_fwd_end   = NULL,
-	.stream_init    = flowgen_stream_init,
 	.packet_fwd     = pkt_burst_flow_gen,
 };
diff -urN dpdk/app/test-pmd/hashget.c testpmd-as-load-balancer/v19.11/test-pmd/hashget.c
--- dpdk/app/test-pmd/hashget.c	1970-01-01 01:00:00.000000000 +0100
+++ testpmd-as-load-balancer/v19.11/test-pmd/hashget.c	2023-12-15 15:26:37.090199134 +0100
@@ -0,0 +1,138 @@
+#include "hashget.h"
+#include "hashring.h"
+
+#define MAC_LEN (6)
+#define HASH_CLONE_MARK_SWEEP_MAX (16)
+
+volatile struct hash_ring_clone_t *hash_clone_new;
+struct hash_ring_clone_t *hash_clone_mark_sweep[HASH_CLONE_MARK_SWEEP_MAX];
+struct hash_ring_clone_t **hash_clone_list;
+uint32_t nb_hash_clone_list;
+
+/////////////////// hashget - TestPMD Main Thread operations///////////////////
+
+/* Called from TestPMD main thread before starting PMD (withing start hook)
+ * Stores the list of clones to be used by different PMD threads.
+ * It is used to identify used clone instances by PMD threads to free the
+ * unused clones.
+ */
+void
+hash_ring_clone_init(struct hash_ring_clone_t **clone_list, uint32_t nb)
+{
+	hash_clone_list = clone_list;
+	nb_hash_clone_list = nb;
+}
+
+// Called from TestPMD LB Listen Thread when DUT is added/removed
+void
+hash_ring_clone_trigger(struct hash_ring_clone_t *new_clone)
+{
+	struct hash_ring_clone_t *old_clone;
+	uint32_t i, j, found;
+
+	if (new_clone == NULL)
+		return;
+
+
+	/* Update the volatile pointer to be accessed by PMD threads */
+	old_clone = (struct hash_ring_clone_t *)(uintptr_t)hash_clone_new;
+	hash_clone_new = new_clone;
+
+	for (i = 0; i < HASH_CLONE_MARK_SWEEP_MAX; i++)
+	{
+		if (hash_clone_mark_sweep[i] == NULL)
+		{
+			hash_clone_mark_sweep[i] = old_clone;
+			break;
+		}
+	}
+
+	for (i = 0; i < HASH_CLONE_MARK_SWEEP_MAX; i++)
+	{
+		found = 0;
+		if (hash_clone_mark_sweep[i] == NULL)
+			continue;
+		for (j = 0; j < nb_hash_clone_list; j++)
+		{
+			if (hash_clone_list[j] == NULL)
+				continue;
+			if (hash_clone_mark_sweep[i] == hash_clone_list[j])
+			{
+				found = 1;
+			}
+		}
+
+		if (found == 0)
+		{
+			hash_ring_clone_destroy(hash_clone_mark_sweep[i]);
+			hash_clone_mark_sweep[i] = NULL;
+		}
+	}
+}
+
+/////////////////// hashget - PMD Thread operations///////////////////
+
+// Called from the PMD thread
+uint32_t
+hash_tuple(uint8_t *smac, uint8_t *dmac, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport)
+{
+	uint32_t idx = 0;
+	uint32_t hash_val = 0;
+	uint32_t i;
+	uint8_t buffer[32];
+
+	memcpy(&buffer[idx], smac, MAC_LEN);
+	idx += MAC_LEN;
+	memcpy(&buffer[idx], dmac, MAC_LEN);
+	idx += MAC_LEN;
+	memcpy(&buffer[idx], &sip, 4);
+	idx += 4;
+	memcpy(&buffer[idx], &dip, 4);
+	idx += 4;
+	memcpy(&buffer[idx], &sport, 2);
+	idx += 2;
+	memcpy(&buffer[idx], &dport, 2);
+	idx += 2;
+
+        hash_val = rte_jhash(buffer, idx, 0);
+/*
+        for (i = 0; i < idx; i++)
+                hash_val += (buffer[i] * 353535);
+*/
+                /*hash_val += (buffer[i] * 365365365);*/
+
+	return hash_val;
+}
+
+// Called from the PMD Thread
+int
+hash_ring_clone_get_mac(struct hash_ring_clone_t *clone, uint32_t key, uint8_t *mac)
+{
+	uint32_t i;
+
+        if (clone == NULL)
+        {
+                return -2;
+        }
+
+        if (mac == NULL)
+        {
+                return -3;
+        }
+
+        if (clone->length == 0)
+        {
+                return -4;
+        }
+
+        for (i = 0; i < clone->length; i++)
+        {
+                if (key < clone->list[i].key)
+                {
+                        memcpy(mac, clone->list[i].mac, MAC_LEN);
+                        return 0;
+                }
+        }
+        memcpy(mac, clone->list[clone->length - 1].mac, MAC_LEN);
+        return 0;
+}
diff -urN dpdk/app/test-pmd/hashget.h testpmd-as-load-balancer/v19.11/test-pmd/hashget.h
--- dpdk/app/test-pmd/hashget.h	1970-01-01 01:00:00.000000000 +0100
+++ testpmd-as-load-balancer/v19.11/test-pmd/hashget.h	2023-12-15 15:26:37.090199134 +0100
@@ -0,0 +1,56 @@
+#ifndef _HASHGET_H_
+#define _HASHGET_H_
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#include <sys/queue.h>
+#include <sys/stat.h>
+
+#include <rte_common.h>
+#include <rte_byteorder.h>
+#include <rte_log.h>
+#include <rte_debug.h>
+#include <rte_cycles.h>
+#include <rte_memory.h>
+#include <rte_memcpy.h>
+#include <rte_launch.h>
+#include <rte_eal.h>
+#include <rte_per_lcore.h>
+#include <rte_lcore.h>
+#include <rte_jhash.h>
+#include <rte_ether.h>
+
+struct hash_ring_clone_t
+{
+    uint32_t length;
+    struct hash_ring_key_map_t *list;
+};
+
+struct hash_ring_key_map_t
+{
+    uint32_t key;
+    uint8_t mac[RTE_ETHER_ADDR_LEN];
+};
+
+extern volatile struct hash_ring_clone_t *hash_clone_new;
+
+void
+hash_ring_clone_init(struct hash_ring_clone_t **clone_holders, uint32_t nb);
+
+int
+hash_ring_clone_get_mac(struct hash_ring_clone_t *clone, uint32_t key, uint8_t *mac);
+
+void
+hash_ring_clone_trigger(struct hash_ring_clone_t *new_clone);
+
+uint32_t
+hash_tuple(uint8_t *smac, uint8_t *dmac, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport);
+
+#endif /* _HASHGET_H_ */
diff -urN dpdk/app/test-pmd/hashring.c testpmd-as-load-balancer/v19.11/test-pmd/hashring.c
--- dpdk/app/test-pmd/hashring.c	1970-01-01 01:00:00.000000000 +0100
+++ testpmd-as-load-balancer/v19.11/test-pmd/hashring.c	2023-12-15 15:26:37.090199134 +0100
@@ -0,0 +1,434 @@
+#include "hashring.h"
+#include "hashget.h"
+
+
+/////////////////// hashring ///////////////////
+struct hash_ring_t *
+hash_ring_create(uint32_t replicas)
+{
+    struct hash_ring_t *ring = malloc(sizeof(struct hash_ring_t));
+
+    if (ring != NULL)
+    {
+        ring->node_replicas = replicas;
+        ring->node_length = 0;
+        ring->nodes = NULL;
+        ring->items = NULL;
+        ring->item_length = 0;
+    }
+    return ring;
+}
+
+void
+hash_ring_destroy(struct hash_ring_t *ring)
+{
+    uint32_t i;
+    struct hash_ring_node_ll_t *ll_entry;
+
+    if (ring != NULL)
+    {
+        ll_entry = ring->nodes;
+        while (ring->nodes != NULL)
+        {
+            ll_entry = ring->nodes;
+            ring->nodes = ll_entry->next;
+            free(ll_entry);
+        }
+
+        if (ring->items != NULL)
+        {
+            for (i = 0; i < ring->item_length; i++)
+            {
+                if (ring->items[i] != NULL)
+                    free(ring->items[i]);
+            }
+            free(ring->items);
+        }
+
+        free(ring);
+    }
+}
+
+static struct hash_ring_node_t *
+hash_ring_ll_add_node(struct hash_ring_t *ring, struct hash_ring_node_t *node_in)
+{
+    struct hash_ring_node_t *new_node;
+    struct hash_ring_node_ll_t *entry;
+
+    new_node = malloc(sizeof(struct hash_ring_node_t));
+    if (new_node == NULL)
+    {
+        perror("failed to allocate memory for node");
+        return NULL;
+    }
+
+    new_node->name = malloc(sizeof(uint8_t) * node_in->name_length);
+    if (new_node->name == NULL)
+    {
+        perror("failed to allocate memory for node name");
+        free(new_node);
+        return NULL;
+    }
+    memcpy(new_node->name, node_in->name, node_in->name_length);
+    new_node->name_length = node_in->name_length;
+    memcpy(new_node->mac, node_in->mac, MAC_LEN);
+
+    entry = malloc(sizeof(struct hash_ring_node_ll_t));
+    if (entry == NULL)
+    {
+        free(new_node->name);
+        free(new_node);
+        perror("failed to allocat memory for ll node");
+        return NULL;
+    }
+
+    entry->next = ring->nodes;
+    entry->node = new_node;
+    ring->nodes = entry;
+    ring->node_length++;
+    return new_node;
+}
+
+static int
+hash_ring_compare_node(struct hash_ring_node_t *node_a, struct hash_ring_node_t *node_b)
+{
+    int cmp_value = 0;
+
+    if (node_a->name_length != node_b->name_length)
+    {
+        return -1;
+    }
+
+    cmp_value |= memcmp(node_a->name, node_b->name, node_a->name_length);
+    cmp_value |= memcmp(node_a->mac, node_b->mac, MAC_LEN);
+    return cmp_value;
+}
+
+static void
+hash_ring_ll_remove_node(struct hash_ring_t *ring, struct hash_ring_node_t *node)
+{
+    struct hash_ring_node_ll_t *ll_entry;
+    struct hash_ring_node_ll_t *ll_prev = NULL;
+    int cmp_value;
+
+    ll_entry = ring->nodes;
+    while (ll_entry != NULL)
+    {
+        cmp_value = hash_ring_compare_node(node, ll_entry->node);
+        if (cmp_value == 0)
+        {
+            if (ll_prev != NULL)
+                ll_prev->next = ll_entry->next;
+            else
+                ring->nodes = ll_entry->next;
+
+            free(ll_entry->node->name);
+            free(ll_entry->node);
+            free(ll_entry);
+            ring->node_length--;
+            return;
+
+        }
+        ll_prev = ll_entry;
+        ll_entry = ll_entry->next;
+    }
+}
+
+static uint32_t
+hash_ring_create_node_hash(struct hash_ring_node_t *node, uint32_t round)
+{
+    uint8_t *buffer;
+    uint32_t length = 0;
+    uint32_t start = 0;
+
+    length += (node->name_length * sizeof(uint8_t));
+    length += (MAC_LEN * sizeof(uint8_t));
+    length += sizeof(uint32_t);
+
+    buffer = malloc(length);
+    if (buffer != NULL)
+    {
+        start = 0;
+        memcpy(buffer + start, node->name, node->name_length);
+        start += node->name_length;
+        memcpy(buffer + start, node->mac, MAC_LEN);
+        start += MAC_LEN;
+        memcpy(buffer + start, &round, sizeof(uint32_t));
+        start += sizeof(uint32_t);
+        return rte_jhash(buffer, length, 0);
+    }
+    return 0;
+}
+
+static int
+item_sort(const void *a, const void *b)
+{
+    const struct hash_ring_item_t *item_a = *(const struct hash_ring_item_t**)(uintptr_t)a;
+    const struct hash_ring_item_t *item_b = *(const struct hash_ring_item_t**)(uintptr_t)b;
+
+    if (item_a == NULL)
+       return 1;
+    if (item_b == NULL)
+       return -1;
+
+    if(item_a->key < item_b->key)
+        return -1;
+    else if(item_a->key > item_b->key)
+        return 1;
+    else
+        return 0;
+}
+
+static int
+hash_ring_add_items(struct hash_ring_t *ring, struct hash_ring_node_t *node)
+{
+    uint32_t item_length = ring->node_replicas * ring->node_length;
+    uint32_t item_start, i;
+    struct hash_ring_item_t **resized;
+    struct hash_ring_item_t *item_entry;
+
+    resized = realloc(ring->items, item_length * sizeof(struct hash_ring_item_t*));
+    if (resized == NULL)
+    {
+        perror("failed to allocate memory for items");
+        return -1;
+    }
+
+    ring->items = resized;
+    item_start = item_length - ring->node_replicas;
+    for (i = item_start; i < item_length; i++)
+    {
+        item_entry = malloc(sizeof(struct hash_ring_item_t));
+        if (item_entry == NULL)
+        {
+            perror("failed to allocate memory for an item");
+            return -1;
+        }
+        item_entry->node = node;
+        item_entry->key = hash_ring_create_node_hash(node, i);
+        if (item_entry->key == 0)
+        {
+            free(item_entry);
+            perror("failed to create hash for node item");
+            return -1;
+        }
+        ring->items[i] = item_entry;
+    }
+    ring->item_length = item_length;
+
+    qsort((void**)ring->items, ring->item_length, sizeof(struct hash_ring_item_t*), item_sort);
+    return 0;
+}
+
+static void
+hash_ring_remove_items(struct hash_ring_t *ring, struct hash_ring_node_t *node)
+{
+    uint32_t i;
+
+    for (i = 0; i < ring->item_length; i++)
+    {
+        if (ring->items[i]->node == node)
+        {
+            free(ring->items[i]);
+            ring->items[i] = NULL;
+        }
+    }
+
+    qsort((void**)ring->items, ring->item_length, sizeof(struct hash_ring_item_t*), item_sort);
+    ring->item_length -= ring->node_replicas;
+}
+
+static struct hash_ring_node_t *
+hash_ring_find_node(struct hash_ring_t *ring, struct hash_ring_node_t *node_in)
+{
+    struct hash_ring_node_ll_t *ll_entry;
+    int cmp_value;
+
+    ll_entry = ring->nodes;
+    while (ll_entry != NULL)
+    {
+        cmp_value = hash_ring_compare_node(node_in, ll_entry->node);
+        if (cmp_value == 0)
+            return ll_entry->node;
+
+        ll_entry = ll_entry->next;
+    }
+    return NULL;
+}
+
+void
+hash_ring_remove_node(struct hash_ring_t *ring, struct hash_ring_node_t *node_in)
+{
+    struct hash_ring_node_t* node;
+
+    node = hash_ring_find_node(ring, node_in);
+    if (node != NULL)
+    {
+        hash_ring_remove_items(ring,node);
+        hash_ring_ll_remove_node(ring, node);
+    }
+}
+
+void
+hash_ring_add_node(struct hash_ring_t *ring, struct hash_ring_node_t *node_in)
+{
+    struct hash_ring_node_t *node;
+    int ret;
+
+    node = hash_ring_find_node(ring, node_in);
+    if (node != NULL)
+    {
+        return;
+    }
+
+    // Add new node to the linked list of ring
+    node = hash_ring_ll_add_node(ring, node_in);
+    if (node == NULL)
+    {
+        perror("failed to allocate node");
+        return;
+    }
+
+    // Re-alloc items array of struct hash_ring_item_t with new node
+    // Create hash key for new node items
+    ret = hash_ring_add_items(ring, node);
+    if (ret != 0)
+    {
+        perror("failed to add items");
+        hash_ring_remove_node(ring, node);
+        return;
+    }
+}
+
+void
+hash_ring_updated(struct hash_ring_t *ring)
+{
+	struct hash_ring_clone_t *new_clone;
+
+	new_clone = hash_ring_clone_create(ring);
+	if (new_clone == NULL)
+	{
+		perror("failed to create a new clone\n");
+		return;
+	}
+	hash_ring_clone_trigger(new_clone);
+}
+
+/*
+static struct hash_ring_node_t *
+hash_ring_get_node(struct hash_ring_t *ring, uint32_t key)
+{
+    int i;
+
+    for (i = 0; i < ring->item_length; i++)
+    {
+        if (key < ring->items[i]->key)
+        {
+            return ring->items[i]->node;
+        }
+    }
+    return ring->items[ring->item_length - 1]->node;
+}
+*/
+
+void
+hash_ring_dump(struct hash_ring_t *ring)
+{
+    struct hash_ring_node_ll_t *entry;
+    uint8_t buffer[128];
+    uint8_t *mac;
+    uint32_t i;
+
+    printf("----------------------------------------------\n");
+    printf("Nodes Count: %u\n", ring->node_length);
+    printf("Items Count: %u\n", ring->item_length);
+    printf("Replicas   : %u\n", ring->node_replicas);
+
+    entry = ring->nodes;
+    if (entry != NULL)
+    {
+        while (entry != NULL)
+        {
+            memset(buffer, 0, 128);
+            memcpy(buffer, entry->node->name, entry->node->name_length);
+            mac = entry->node->mac;
+            printf("Name(%s) Mac(%02x:%02x:%02x:%02x:%02x:%02x)\n", buffer, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+            entry = entry->next;
+        }
+        printf("\n");
+        for (i = 0; i < ring->item_length; i++)
+        {
+            memset(buffer, 0, 128);
+            memcpy(buffer, ring->items[i]->node->name, ring->items[i]->node->name_length);
+            printf("Item(%03d) key(%010u) Node(%s)\n", i, ring->items[i]->key, buffer);
+        }
+    }
+    else
+    {
+        printf("No nodes available\n");
+    }
+    printf("----------------------------------------------\n");
+}
+
+/////////////////// hasget ///////////////////
+struct hash_ring_clone_t *
+hash_ring_clone_create(struct hash_ring_t *ring)
+{
+    void *alloc;
+    uint32_t array_mem, items_mem, i;
+    struct hash_ring_clone_t *clone;
+
+    if (ring->item_length == 0)
+    {
+	    printf("no items to clone\n");
+	    return NULL;
+    }
+
+    // Array
+    array_mem = ring->item_length * sizeof(struct hash_ring_item_t*);
+    // Actual Items
+    items_mem = ring->item_length * sizeof(struct hash_ring_item_t);
+
+    alloc = malloc(array_mem + items_mem);
+    if (alloc == NULL)
+    {
+        perror("failed to clone the items");
+        return NULL;
+    }
+    memset(alloc, 0, array_mem + items_mem);
+    clone = alloc;
+    clone->length = ring->item_length;
+    clone->list = (struct hash_ring_key_map_t *)((uint8_t *)alloc + sizeof(struct hash_ring_clone_t));
+
+    for (i = 0; i < ring->item_length; i++)
+    {
+        clone->list[i].key = ring->items[i]->key;
+        memcpy(clone->list[i].mac, ring->items[i]->node->mac, MAC_LEN);
+    }
+    return clone;
+}
+
+void
+hash_ring_clone_destroy(struct hash_ring_clone_t *clone)
+{
+    if (clone != NULL)
+        free(clone);
+}
+
+void
+hash_ring_clone_dump(struct hash_ring_clone_t *clone)
+{
+    uint32_t i;
+    uint8_t *mac;
+
+    printf("----------------------------------------------\n");
+    printf("Count: %u\n", clone->length);
+
+    for (i = 0; i < clone->length; i++)
+    {
+        mac = clone->list[i].mac;
+        printf("Item(%03d) key(%010u) Mac(%02x:%02x:%02x:%02x:%02x:%02x)\n",
+                i, clone->list[i].key, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+    }
+    printf("----------------------------------------------\n");
+}
diff -urN dpdk/app/test-pmd/hashring.h testpmd-as-load-balancer/v19.11/test-pmd/hashring.h
--- dpdk/app/test-pmd/hashring.h	1970-01-01 01:00:00.000000000 +0100
+++ testpmd-as-load-balancer/v19.11/test-pmd/hashring.h	2023-12-15 15:26:37.090199134 +0100
@@ -0,0 +1,89 @@
+#ifndef _HASHRING_H_
+#define _HASHRING_H_
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#include <sys/queue.h>
+#include <sys/stat.h>
+
+#include <rte_common.h>
+#include <rte_byteorder.h>
+#include <rte_log.h>
+#include <rte_debug.h>
+#include <rte_cycles.h>
+#include <rte_memory.h>
+#include <rte_memcpy.h>
+#include <rte_launch.h>
+#include <rte_eal.h>
+#include <rte_per_lcore.h>
+#include <rte_lcore.h>
+#include <rte_jhash.h>
+
+#define MAC_LEN (6)
+
+struct hash_ring_node_t
+{
+    uint8_t *name;
+    uint32_t name_length;
+    uint8_t mac[MAC_LEN];
+    // possibility to add IP
+};
+
+struct hash_ring_node_ll_t
+{
+    struct hash_ring_node_t *node;
+    struct hash_ring_node_ll_t *next;
+};
+
+struct hash_ring_item_t
+{
+    uint32_t key;
+    struct hash_ring_node_t *node;
+};
+
+struct hash_ring_t
+{
+    uint32_t node_replicas;
+    uint32_t node_length;
+    struct hash_ring_node_ll_t *nodes;
+    struct hash_ring_item_t **items;
+    uint32_t item_length;
+};
+
+struct hash_ring_clone_t;
+
+struct hash_ring_t *
+hash_ring_create(uint32_t replicas);
+
+void
+hash_ring_destroy(struct hash_ring_t *ring);
+
+void
+hash_ring_remove_node(struct hash_ring_t *ring, struct hash_ring_node_t *node_in);
+
+void
+hash_ring_add_node(struct hash_ring_t *ring, struct hash_ring_node_t *node_in);
+
+void
+hash_ring_updated(struct hash_ring_t *ring);
+
+void
+hash_ring_dump(struct hash_ring_t *ring);
+
+struct hash_ring_clone_t *
+hash_ring_clone_create(struct hash_ring_t *ring);
+
+void
+hash_ring_clone_destroy(struct hash_ring_clone_t *clone);
+
+void
+hash_ring_clone_dump(struct hash_ring_clone_t *clone);
+
+#endif /* _HASHRING_H_ */
diff -urN dpdk/app/test-pmd/icmpecho.c testpmd-as-load-balancer/v19.11/test-pmd/icmpecho.c
--- dpdk/app/test-pmd/icmpecho.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/icmpecho.c	2023-12-15 15:26:37.090199134 +0100
@@ -20,6 +20,7 @@
 #include <rte_cycles.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_memory.h>
 #include <rte_mempool.h>
@@ -53,7 +54,7 @@
 	default:
 		break;
 	}
-	return "Unknown ARP op";
+	return "Unkwown ARP op";
 }
 
 static const char *
@@ -187,7 +188,7 @@
 		"PIM",        /**< Protocol Independent Mcast */
 	};
 
-	if (ip_proto < RTE_DIM(ip_proto_names))
+	if (ip_proto < sizeof(ip_proto_names) / sizeof(ip_proto_names[0]))
 		return ip_proto_names[ip_proto];
 	switch (ip_proto) {
 #ifdef IPPROTO_PGM
@@ -292,19 +293,27 @@
 	uint32_t cksum;
 	uint8_t  i;
 	int l2_len;
-	uint64_t start_tsc = 0;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+#endif
 
-	get_start_cycles(&start_tsc);
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	start_tsc = rte_rdtsc();
+#endif
 
 	/*
 	 * First, receive a burst of packets.
 	 */
 	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue, pkts_burst,
 				 nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
 	if (unlikely(nb_rx == 0))
 		return;
 
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->rx_burst_stats.pkt_burst_spread[nb_rx]++;
+#endif
 	fs->rx_packets += nb_rx;
 	nb_replies = 0;
 	for (i = 0; i < nb_rx; i++) {
@@ -318,8 +327,8 @@
 		if (verbose_level > 0) {
 			printf("\nPort %d pkt-len=%u nb-segs=%u\n",
 			       fs->rx_port, pkt->pkt_len, pkt->nb_segs);
-			ether_addr_dump("  ETH:  src=", &eth_h->src_addr);
-			ether_addr_dump(" dst=", &eth_h->dst_addr);
+			ether_addr_dump("  ETH:  src=", &eth_h->s_addr);
+			ether_addr_dump(" dst=", &eth_h->d_addr);
 		}
 		if (eth_type == RTE_ETHER_TYPE_VLAN) {
 			vlan_h = (struct rte_vlan_hdr *)
@@ -384,17 +393,17 @@
 			 */
 
 			/* Use source MAC address as destination MAC address. */
-			rte_ether_addr_copy(&eth_h->src_addr, &eth_h->dst_addr);
+			rte_ether_addr_copy(&eth_h->s_addr, &eth_h->d_addr);
 			/* Set source MAC address with MAC address of TX port */
 			rte_ether_addr_copy(&ports[fs->tx_port].eth_addr,
-					&eth_h->src_addr);
+					&eth_h->s_addr);
 
 			arp_h->arp_opcode = rte_cpu_to_be_16(RTE_ARP_OP_REPLY);
 			rte_ether_addr_copy(&arp_h->arp_data.arp_tha,
 					&eth_addr);
 			rte_ether_addr_copy(&arp_h->arp_data.arp_sha,
 					&arp_h->arp_data.arp_tha);
-			rte_ether_addr_copy(&eth_h->src_addr,
+			rte_ether_addr_copy(&eth_h->s_addr,
 					&arp_h->arp_data.arp_sha);
 
 			/* Swap IP addresses in ARP payload */
@@ -452,9 +461,9 @@
 		 * ICMP checksum is computed by assuming it is valid in the
 		 * echo request and not verified.
 		 */
-		rte_ether_addr_copy(&eth_h->src_addr, &eth_addr);
-		rte_ether_addr_copy(&eth_h->dst_addr, &eth_h->src_addr);
-		rte_ether_addr_copy(&eth_addr, &eth_h->dst_addr);
+		rte_ether_addr_copy(&eth_h->s_addr, &eth_addr);
+		rte_ether_addr_copy(&eth_h->d_addr, &eth_h->s_addr);
+		rte_ether_addr_copy(&eth_addr, &eth_h->d_addr);
 		ip_addr = ip_h->src_addr;
 		if (is_multicast_ipv4_addr(ip_h->dst_addr)) {
 			uint32_t ip_src;
@@ -473,8 +482,8 @@
 		}
 		icmp_h->icmp_type = RTE_IP_ICMP_ECHO_REPLY;
 		cksum = ~icmp_h->icmp_cksum & 0xffff;
-		cksum += ~RTE_BE16(RTE_IP_ICMP_ECHO_REQUEST << 8) & 0xffff;
-		cksum += RTE_BE16(RTE_IP_ICMP_ECHO_REPLY << 8);
+		cksum += ~htons(RTE_IP_ICMP_ECHO_REQUEST << 8) & 0xffff;
+		cksum += htons(RTE_IP_ICMP_ECHO_REPLY << 8);
 		cksum = (cksum & 0xffff) + (cksum >> 16);
 		cksum = (cksum & 0xffff) + (cksum >> 16);
 		icmp_h->icmp_cksum = ~cksum;
@@ -500,7 +509,9 @@
 			}
 		}
 		fs->tx_packets += nb_tx;
-		inc_tx_burst_stats(fs, nb_tx);
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+		fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+#endif
 		if (unlikely(nb_tx < nb_replies)) {
 			fs->fwd_dropped += (nb_replies - nb_tx);
 			do {
@@ -509,25 +520,16 @@
 		}
 	}
 
-	get_end_cycles(fs, start_tsc);
-}
-
-static void
-icmpecho_stream_init(struct fwd_stream *fs)
-{
-	bool rx_stopped, tx_stopped;
-
-	rx_stopped = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	tx_stopped = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	fs->disabled = rx_stopped || tx_stopped;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
 }
 
 struct fwd_engine icmp_echo_engine = {
 	.fwd_mode_name  = "icmpecho",
 	.port_fwd_begin = NULL,
 	.port_fwd_end   = NULL,
-	.stream_init    = icmpecho_stream_init,
 	.packet_fwd     = reply_to_icmp_echo_rqsts,
 };
diff -urN dpdk/app/test-pmd/ieee1588fwd.c testpmd-as-load-balancer/v19.11/test-pmd/ieee1588fwd.c
--- dpdk/app/test-pmd/ieee1588fwd.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/ieee1588fwd.c	2023-12-15 15:26:37.090199134 +0100
@@ -60,8 +60,8 @@
 		printf("Port %u RX timestamp registers not valid\n", pi);
 		return;
 	}
-	printf("Port %u RX timestamp value %ju s %lu ns\n",
-		pi, (uintmax_t)timestamp.tv_sec, timestamp.tv_nsec);
+	printf("Port %u RX timestamp value %lu s %lu ns\n",
+		pi, timestamp.tv_sec, timestamp.tv_nsec);
 }
 
 #define MAX_TX_TMST_WAIT_MICROSECS 1000 /**< 1 milli-second */
@@ -83,9 +83,9 @@
 		       pi, MAX_TX_TMST_WAIT_MICROSECS);
 		return;
 	}
-	printf("Port %u TX timestamp value %ju s %lu ns validated after "
+	printf("Port %u TX timestamp value %lu s %lu ns validated after "
 	       "%u micro-second%s\n",
-	       pi, (uintmax_t)timestamp.tv_sec, timestamp.tv_nsec, wait_us,
+	       pi, timestamp.tv_sec, timestamp.tv_nsec, wait_us,
 	       (wait_us == 1) ? "" : "s");
 }
 
@@ -114,7 +114,7 @@
 	eth_hdr = rte_pktmbuf_mtod(mb, struct rte_ether_hdr *);
 	eth_type = rte_be_to_cpu_16(eth_hdr->ether_type);
 
-	if (!(mb->ol_flags & RTE_MBUF_F_RX_IEEE1588_PTP)) {
+	if (! (mb->ol_flags & PKT_RX_IEEE1588_PTP)) {
 		if (eth_type == RTE_ETHER_TYPE_1588) {
 			printf("Port %u Received PTP packet not filtered"
 			       " by hardware\n",
@@ -163,7 +163,7 @@
 	 * Check that the received PTP packet has been timestamped by the
 	 * hardware.
 	 */
-	if (!(mb->ol_flags & RTE_MBUF_F_RX_IEEE1588_TMST)) {
+	if (! (mb->ol_flags & PKT_RX_IEEE1588_TMST)) {
 		printf("Port %u Received PTP packet not timestamped"
 		       " by hardware\n",
 		       fs->rx_port);
@@ -178,19 +178,19 @@
 	port_ieee1588_rx_timestamp_check(fs->rx_port, timesync_index);
 
 	/* Swap dest and src mac addresses. */
-	rte_ether_addr_copy(&eth_hdr->dst_addr, &addr);
-	rte_ether_addr_copy(&eth_hdr->src_addr, &eth_hdr->dst_addr);
-	rte_ether_addr_copy(&addr, &eth_hdr->src_addr);
+	rte_ether_addr_copy(&eth_hdr->d_addr, &addr);
+	rte_ether_addr_copy(&eth_hdr->s_addr, &eth_hdr->d_addr);
+	rte_ether_addr_copy(&addr, &eth_hdr->s_addr);
 
 	/* Forward PTP packet with hardware TX timestamp */
-	mb->ol_flags |= RTE_MBUF_F_TX_IEEE1588_TMST;
+	mb->ol_flags |= PKT_TX_IEEE1588_TMST;
+	fs->tx_packets += 1;
 	if (rte_eth_tx_burst(fs->rx_port, fs->tx_queue, &mb, 1) == 0) {
 		printf("Port %u sent PTP packet dropped\n", fs->rx_port);
 		fs->fwd_dropped += 1;
 		rte_pktmbuf_free(mb);
 		return;
 	}
-	fs->tx_packets += 1;
 
 	/*
 	 * Check the TX timestamp.
@@ -198,11 +198,10 @@
 	port_ieee1588_tx_timestamp_check(fs->rx_port);
 }
 
-static int
+static void
 port_ieee1588_fwd_begin(portid_t pi)
 {
 	rte_eth_timesync_enable(pi);
-	return 0;
 }
 
 static void
@@ -211,22 +210,9 @@
 	rte_eth_timesync_disable(pi);
 }
 
-static void
-port_ieee1588_stream_init(struct fwd_stream *fs)
-{
-	bool rx_stopped, tx_stopped;
-
-	rx_stopped = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	tx_stopped = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	fs->disabled = rx_stopped || tx_stopped;
-}
-
 struct fwd_engine ieee1588_fwd_engine = {
 	.fwd_mode_name  = "ieee1588",
 	.port_fwd_begin = port_ieee1588_fwd_begin,
 	.port_fwd_end   = port_ieee1588_fwd_end,
-	.stream_init    = port_ieee1588_stream_init,
 	.packet_fwd     = ieee1588_packet_fwd,
 };
diff -urN dpdk/app/test-pmd/iofwd.c testpmd-as-load-balancer/v19.11/test-pmd/iofwd.c
--- dpdk/app/test-pmd/iofwd.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/iofwd.c	2023-12-15 15:26:37.090199134 +0100
@@ -23,11 +23,13 @@
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_memcpy.h>
 #include <rte_mempool.h>
 #include <rte_mbuf.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_string_fns.h>
@@ -48,20 +50,29 @@
 	uint16_t nb_rx;
 	uint16_t nb_tx;
 	uint32_t retry;
-	uint64_t start_tsc = 0;
 
-	get_start_cycles(&start_tsc);
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+#endif
+
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	start_tsc = rte_rdtsc();
+#endif
 
 	/*
 	 * Receive a burst of packets and forward them.
 	 */
 	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue,
 			pkts_burst, nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
 	if (unlikely(nb_rx == 0))
 		return;
 	fs->rx_packets += nb_rx;
 
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->rx_burst_stats.pkt_burst_spread[nb_rx]++;
+#endif
 	nb_tx = rte_eth_tx_burst(fs->tx_port, fs->tx_queue,
 			pkts_burst, nb_rx);
 	/*
@@ -76,33 +87,25 @@
 		}
 	}
 	fs->tx_packets += nb_tx;
-	inc_tx_burst_stats(fs, nb_tx);
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+#endif
 	if (unlikely(nb_tx < nb_rx)) {
 		fs->fwd_dropped += (nb_rx - nb_tx);
 		do {
 			rte_pktmbuf_free(pkts_burst[nb_tx]);
 		} while (++nb_tx < nb_rx);
 	}
-
-	get_end_cycles(fs, start_tsc);
-}
-
-static void
-stream_init_forward(struct fwd_stream *fs)
-{
-	bool rx_stopped, tx_stopped;
-
-	rx_stopped = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	tx_stopped = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	fs->disabled = rx_stopped || tx_stopped;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
 }
 
 struct fwd_engine io_fwd_engine = {
 	.fwd_mode_name  = "io",
 	.port_fwd_begin = NULL,
 	.port_fwd_end   = NULL,
-	.stream_init    = stream_init_forward,
 	.packet_fwd     = pkt_burst_io_forward,
 };
diff -urN dpdk/app/test-pmd/lbfwd.c testpmd-as-load-balancer/v19.11/test-pmd/lbfwd.c
--- dpdk/app/test-pmd/lbfwd.c	1970-01-01 01:00:00.000000000 +0100
+++ testpmd-as-load-balancer/v19.11/test-pmd/lbfwd.c	2023-12-15 15:26:37.090199134 +0100
@@ -0,0 +1,397 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2010-2014 Intel Corporation
+ */
+
+#include <stdarg.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#include <sys/queue.h>
+#include <sys/stat.h>
+
+#include <rte_common.h>
+#include <rte_byteorder.h>
+#include <rte_log.h>
+#include <rte_debug.h>
+#include <rte_cycles.h>
+#include <rte_memory.h>
+#include <rte_memcpy.h>
+#include <rte_launch.h>
+#include <rte_eal.h>
+#include <rte_per_lcore.h>
+#include <rte_lcore.h>
+#include <rte_atomic.h>
+#include <rte_branch_prediction.h>
+#include <rte_mempool.h>
+#include <rte_mbuf.h>
+#include <rte_interrupts.h>
+#include <rte_pci.h>
+#include <rte_ether.h>
+#include <rte_ethdev.h>
+#include <rte_ip.h>
+#include <rte_string_fns.h>
+#include <rte_flow.h>
+
+#include "testpmd.h"
+#include "hashget.h"
+
+#define uint32_t_to_char(ip, a, b, c, d) do {\
+                *a = (unsigned char)(ip >> 24 & 0xff);\
+                *b = (unsigned char)(ip >> 16 & 0xff);\
+                *c = (unsigned char)(ip >> 8 & 0xff);\
+                *d = (unsigned char)(ip & 0xff);\
+        } while (0)
+#define UNUSED(x)	(void)(x)
+#define MAC_FOR_EACH_PACKET
+
+struct hash_ring_clone_t *hash_clone[RTE_MAX_LCORE];
+uint32_t nb_hash_clone;
+
+extern void
+lb_listen_init(void);
+extern void
+lb_listen_deinit(void);
+
+static void
+pkt_burst_lb_forward_begin(portid_t pi)
+{
+	UNUSED(pi);
+	nb_hash_clone = RTE_MAX_LCORE;
+	hash_ring_clone_init(hash_clone, nb_hash_clone);
+	lb_listen_init();
+}
+
+static void
+pkt_burst_lb_forward_end(portid_t pi)
+{
+	UNUSED(pi);
+	lb_listen_deinit();
+}
+
+static uint32_t
+generate_hash_key(struct rte_ether_hdr *eth_hdr)
+{
+	uint32_t key;
+	uint8_t *smac, *dmac;
+	uint16_t ethertype;
+	struct rte_ipv4_hdr *ipv4_hdr;
+	struct rte_ipv6_hdr *ipv6_hdr;
+	struct rte_vlan_hdr *vlan_hdr;
+	struct rte_tcp_hdr *tcp_hdr;
+	struct rte_udp_hdr *udp_hdr;
+	uint32_t offset = 0;
+        uint16_t sport, dport;
+        uint8_t l4_proto;
+        uint32_t dip, sip;
+
+	offset += sizeof(struct rte_ether_hdr);
+	smac = eth_hdr->s_addr.addr_bytes;
+	dmac = eth_hdr->d_addr.addr_bytes;
+	ethertype = eth_hdr->ether_type;
+
+	// L2 (VLAN Header)
+	if (ethertype == htons(RTE_ETHER_TYPE_VLAN))
+	{
+		vlan_hdr = (struct rte_vlan_hdr *)(eth_hdr + 1);
+		offset += sizeof(struct rte_vlan_hdr);
+		ethertype = vlan_hdr->eth_proto;
+	}
+
+	// L3 (IP Header)
+	if (ethertype == htons(RTE_ETHER_TYPE_IPV4))
+	{
+		ipv4_hdr = (struct rte_ipv4_hdr *)((char *)eth_hdr + offset);
+		offset += (ipv4_hdr->version_ihl & 0x0f) * 4;
+		sip = ipv4_hdr->src_addr;
+		dip = ipv4_hdr->dst_addr;
+
+		// L4 (TCP/UDP Port Header)
+		l4_proto = ipv4_hdr->next_proto_id;
+		if (l4_proto == IPPROTO_TCP)
+		{
+			tcp_hdr = (struct rte_tcp_hdr *)((char *)eth_hdr + offset);
+			sport = tcp_hdr->src_port;
+			dport = tcp_hdr->dst_port;
+		}
+		else if (l4_proto == IPPROTO_UDP)
+		{
+			udp_hdr = (struct rte_udp_hdr *)((char *)eth_hdr + offset);
+			sport = udp_hdr->src_port;
+			dport = udp_hdr->dst_port;
+		}
+		else
+		{
+			sport = 0;
+			dport = 0;
+		}
+	}
+	else if (ethertype == htons(RTE_ETHER_TYPE_IPV6))
+	{
+		// Not implemented
+		//printf("ipv6 ethertype (0x%x) is not supported\n", ethertype);
+		ipv6_hdr = (struct rte_ipv6_hdr *)((char *)eth_hdr + offset);
+                offset += ipv6_hdr->proto;
+		return 0;
+	}
+	else
+	{
+		return 0;
+	}
+
+	key = hash_tuple(smac, dmac, sip, dip, sport, dport);
+	return key;
+}
+
+#ifdef PACKET_DUMP
+static void
+pkt_dump(struct rte_mbuf *mb, portid_t port, int inout)
+{
+	// Logging
+	char smac_str[32];
+	char dmac_str[32];
+	unsigned char a, b, c, d;
+	char sip_str[32];
+	char dip_str[32];
+
+	uint8_t *smac, *dmac;
+	uint16_t ethertype;
+	struct rte_ether_hdr *eth_hdr;
+	struct rte_ipv4_hdr *ipv4_hdr;
+	struct rte_ipv6_hdr *ipv6_hdr;
+	struct rte_vlan_hdr *vlan_hdr;
+	struct rte_tcp_hdr *tcp_hdr;
+	struct rte_udp_hdr *udp_hdr;
+	uint32_t offset = 0;
+        uint16_t sport, dport;
+        uint8_t l4_proto;
+        uint32_t dip, sip;
+	char l4_proto_str[4];
+
+	// L2 (Ethernet Header)
+	eth_hdr = rte_pktmbuf_mtod(mb, struct rte_ether_hdr *);
+	offset += sizeof(struct rte_ether_hdr);
+	smac = eth_hdr->s_addr.addr_bytes;
+	dmac = eth_hdr->d_addr.addr_bytes;
+	sprintf(smac_str, "%02x:%02x:%02x:%02x:%02x:%02x", smac[0], smac[1], smac[2], smac[3], smac[4], smac[5]);
+	sprintf(dmac_str, "%02x:%02x:%02x:%02x:%02x:%02x", dmac[0], dmac[1], dmac[2], dmac[3], dmac[4], dmac[5]);
+	ethertype = eth_hdr->ether_type;
+
+	// L2 (VLAN Header)
+	if (ethertype == htons(RTE_ETHER_TYPE_VLAN))
+	{
+		vlan_hdr = (struct rte_vlan_hdr *)(eth_hdr + 1);
+		offset += sizeof(struct rte_vlan_hdr);
+		ethertype = vlan_hdr->eth_proto;
+	}
+
+	// L3 (IP Header)
+	if (ethertype == htons(RTE_ETHER_TYPE_IPV4))
+	{
+		ipv4_hdr = (struct rte_ipv4_hdr *)((char *)eth_hdr + offset);
+		offset += (ipv4_hdr->version_ihl & 0x0f) * 4;
+		sip = ipv4_hdr->src_addr;
+		dip = ipv4_hdr->dst_addr;
+
+		// L4 (TCP/UDP Port Header)
+		l4_proto = ipv4_hdr->next_proto_id;
+		if (l4_proto == IPPROTO_TCP)
+		{
+			strcpy(l4_proto_str, "TCP");
+			tcp_hdr = (struct rte_tcp_hdr *)((char *)eth_hdr + offset);
+			sport = tcp_hdr->src_port;
+			dport = tcp_hdr->dst_port;
+		}
+		else if (l4_proto == IPPROTO_UDP)
+		{
+			strcpy(l4_proto_str, "TCP");
+			udp_hdr = (struct rte_udp_hdr *)((char *)eth_hdr + offset);
+			sport = udp_hdr->src_port;
+			dport = udp_hdr->dst_port;
+		}
+		else
+		{
+			sport = 0;
+			dport = 0;
+		}
+	}
+	else if (ethertype == htons(RTE_ETHER_TYPE_IPV6))
+	{
+		// Not implemented
+		ipv6_hdr = (struct rte_ipv6_hdr *)((char *)eth_hdr + offset);
+                offset += ipv6_hdr->proto;
+		return;
+	}
+	else
+	{
+                if (inout == 0)
+                        printf("port(%u): %s->%s \n", port, smac_str, dmac_str);
+                else
+                        printf(">>> port(%u): %s->%s \n", port, smac_str, dmac_str);
+		return;
+	}
+
+	uint32_t_to_char(rte_bswap32(sip), &a, &b, &c, &d);
+	sprintf(sip_str, "%hhu.%hhu.%hhu.%hhu", a, b, c, d);
+	uint32_t_to_char(rte_bswap32(dip), &a, &b, &c, &d);
+	sprintf(dip_str, "%hhu.%hhu.%hhu.%hhu", a, b, c, d);
+	UNUSED(dport);
+	UNUSED(sport);
+	if (inout == 0)
+		printf("port(%u): %s->%s, %s->%s, %s:%u, %u\n", port, smac_str,
+			dmac_str, sip_str, dip_str, l4_proto_str, sport, dport);
+	else
+		printf(">>> port(%u): %s->%s, %s->%s, %s:%u, %u\n", port, smac_str,
+			dmac_str, sip_str, dip_str, l4_proto_str, sport, dport);
+
+}
+#endif /* PACKET_DUMP */
+
+/*
+ * Forwarding of packets in LB mode.
+ * Change the source and the destination Ethernet addressed of packets
+ * before forwarding them.
+ */
+static void
+pkt_burst_lb_forward(struct fwd_stream *fs)
+{
+	struct rte_mbuf  *pkts_burst[MAX_PKT_BURST];
+	struct rte_port  *txp;
+	struct rte_mbuf  *mb;
+	struct rte_ether_hdr *eth_hdr = NULL;
+	uint32_t retry;
+	uint16_t nb_rx;
+	uint16_t nb_tx;
+	uint16_t i;
+	uint64_t ol_flags = 0;
+	uint64_t tx_offloads;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+#endif
+        struct rte_ether_addr mac;
+        uint32_t key = 0;
+	lcoreid_t lcore;
+	int ret = -1;
+
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	start_tsc = rte_rdtsc();
+#endif
+
+	lcore = rte_lcore_id();
+	hash_clone[lcore] = (struct hash_ring_clone_t *)(uintptr_t)hash_clone_new;
+
+	/*
+	 * Receive a burst of packets and forward them.
+	 */
+	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue, pkts_burst,
+				 nb_pkt_per_burst);
+	if (unlikely(nb_rx == 0))
+		return;
+
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->rx_burst_stats.pkt_burst_spread[nb_rx]++;
+#endif
+	fs->rx_packets += nb_rx;
+	txp = &ports[fs->tx_port];
+	tx_offloads = txp->dev_conf.txmode.offloads;
+	if (tx_offloads	& DEV_TX_OFFLOAD_VLAN_INSERT)
+		ol_flags = PKT_TX_VLAN_PKT;
+	if (tx_offloads & DEV_TX_OFFLOAD_QINQ_INSERT)
+		ol_flags |= PKT_TX_QINQ_PKT;
+	if (tx_offloads & DEV_TX_OFFLOAD_MACSEC_INSERT)
+		ol_flags |= PKT_TX_MACSEC;
+	for (i = 0; i < nb_rx; i++) {
+		if (likely(i < nb_rx - 1))
+			rte_prefetch0(rte_pktmbuf_mtod(pkts_burst[i + 1],
+						       void *));
+		mb = pkts_burst[i];
+#ifdef PACKET_DUMP
+		pkt_dump(mb, fs->rx_port, 0);
+#endif
+		eth_hdr = rte_pktmbuf_mtod(mb, struct rte_ether_hdr *);
+		if (eth_hdr == NULL)
+		{
+			printf("eth_hdr of packet %u is NULL\n", i);
+			continue;
+		}
+		if (fs->generate == 1)
+		{
+#ifdef MAC_FOR_EACH_PACKET
+			/* Generate hash and find mac for each packet */
+			key = generate_hash_key(eth_hdr);
+			if (key != 0)
+				ret = hash_ring_clone_get_mac(hash_clone[lcore], key, mac.addr_bytes);
+#else
+			/* Generate hash and get mac once, and apply for all packets in a single read */
+                        if (key == 0)
+                        {
+                                key = generate_hash_key(mb);
+                                if (key != 0)
+                                        ret = hash_ring_clone_get_mac(hash_clone[lcore], key, mac.addr_bytes);
+                        }
+#endif
+                        if (ret == 0)
+                        {
+                                rte_ether_addr_copy(&ports[fs->tx_port].eth_addr,
+                                        &eth_hdr->s_addr);
+                                rte_ether_addr_copy(&mac, &eth_hdr->d_addr);
+                        }
+		}
+		else
+		{
+			rte_ether_addr_copy(&ports[fs->tx_port].eth_addr,
+				&eth_hdr->s_addr);
+			rte_ether_addr_copy(&peer_eth_addrs[fs->peer_addr],
+				&eth_hdr->d_addr);
+		}
+#ifdef PACKET_DUMP
+		pkt_dump(mb, fs->rx_port, 1);
+#endif
+		mb->ol_flags &= IND_ATTACHED_MBUF | EXT_ATTACHED_MBUF;
+		mb->ol_flags |= ol_flags;
+		mb->l2_len = sizeof(struct rte_ether_hdr);
+		mb->l3_len = sizeof(struct rte_ipv4_hdr);
+		mb->vlan_tci = txp->tx_vlan_id;
+		mb->vlan_tci_outer = txp->tx_vlan_id_outer;
+	}
+	nb_tx = rte_eth_tx_burst(fs->tx_port, fs->tx_queue, pkts_burst, nb_rx);
+	/*
+	 * Retry if necessary
+	 */
+	if (unlikely(nb_tx < nb_rx) && fs->retry_enabled) {
+		retry = 0;
+		while (nb_tx < nb_rx && retry++ < burst_tx_retry_num) {
+			rte_delay_us(burst_tx_delay_time);
+			nb_tx += rte_eth_tx_burst(fs->tx_port, fs->tx_queue,
+					&pkts_burst[nb_tx], nb_rx - nb_tx);
+		}
+	}
+
+	fs->tx_packets += nb_tx;
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+#endif
+	if (unlikely(nb_tx < nb_rx)) {
+		fs->fwd_dropped += (nb_rx - nb_tx);
+		do {
+			rte_pktmbuf_free(pkts_burst[nb_tx]);
+		} while (++nb_tx < nb_rx);
+	}
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
+}
+
+struct fwd_engine lb_fwd_engine = {
+	.fwd_mode_name  = "lb",
+	.port_fwd_begin = pkt_burst_lb_forward_begin,
+	.port_fwd_end   = pkt_burst_lb_forward_end,
+	.packet_fwd     = pkt_burst_lb_forward,
+};
diff -urN dpdk/app/test-pmd/lb_listen.c testpmd-as-load-balancer/v19.11/test-pmd/lb_listen.c
--- dpdk/app/test-pmd/lb_listen.c	1970-01-01 01:00:00.000000000 +0100
+++ testpmd-as-load-balancer/v19.11/test-pmd/lb_listen.c	2023-12-15 15:26:37.090199134 +0100
@@ -0,0 +1,277 @@
+#ifndef _LB_LISTEN_H_
+#define _LB_LISTEN_H_
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#include "hashring.h"
+#include "hashget.h"
+
+#define UNUSED(x)       (void)(x)
+#define SOCKET_NAME     "/var/lib/testpmd/lb.sock"
+#define DUT_REPLICAS    (4)
+#define DUT_MAC_ADDED   (1)
+#define DUT_MAC_REMOVED (2)
+
+void
+lb_listen_init(void);
+void
+lb_listen_deinit(void);
+static void *
+lb_listen(void *arg);
+static void
+process_data(char *data);
+
+static pthread_t lb_thread;
+static uint8_t lb_listen_flag = 0;
+static int sock_conn, sock_data;
+static struct hash_ring_t *ring;
+
+void
+lb_listen_init(void)
+{
+	if (lb_listen_flag == 1)
+		return;
+	pthread_create(&lb_thread, NULL, lb_listen, NULL);
+	pthread_setname_np(lb_thread, "lb_listen");
+	lb_listen_flag = 1;
+	ring = hash_ring_create(DUT_REPLICAS);
+}
+
+void
+lb_listen_deinit(void)
+{
+	if (lb_listen_flag == 0)
+		return;
+	lb_listen_flag = 0;
+	printf("shuttindown socket %s \n", SOCKET_NAME);
+	shutdown(sock_conn, SHUT_RD);
+	close(sock_conn);
+	// TODO(skarama): Cleanup all the clones
+	if (ring != NULL)
+		hash_ring_destroy(ring);
+}
+
+static void *
+lb_listen(void *arg)
+{
+	char *buffer = NULL;
+	char *tokbuf = NULL;
+	char *token_save = NULL;
+	uint32_t size = 512;
+	struct sockaddr_un server;
+	int ret;
+	int len, partial;
+
+	UNUSED(arg);
+	buffer = malloc(size + 1);
+	if (buffer == NULL)
+		return NULL;
+
+	tokbuf = malloc(size + 1);
+	if (buffer == NULL)
+	{
+		free(buffer);
+		return NULL;
+	}
+
+	memset(buffer, 0, size + 1);
+	sock_conn = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (sock_conn < 0)
+		return NULL;
+	server.sun_family = AF_UNIX;
+	strcpy(server.sun_path, SOCKET_NAME);
+
+	ret = bind(sock_conn, (struct sockaddr *) &server, sizeof(struct sockaddr_un));
+	if (ret < 0 )
+	{
+		printf("error in binding socket %s\n", SOCKET_NAME);
+		return NULL;
+	}
+
+	ret = listen(sock_conn, 32);
+	if (ret < 0 )
+		return NULL;
+
+	while (1)
+	{
+		sock_data = accept(sock_conn, NULL, NULL);
+		if (sock_data == -1 && lb_listen_flag == 0)
+		{
+			printf("exiting gracefully...\n");
+			break;
+		}
+		else if (sock_data == -1)
+		{
+			printf("exiting with socket accept error...\n");
+			exit(EXIT_FAILURE);
+		}
+
+		ret = 0;
+		while (1)
+		{
+			partial = 0;
+			len = 0;
+			memset(buffer, 0, size + 1);
+			ret = read(sock_data, buffer, size);
+			if (ret == -1)
+			{
+				printf("socket read error\n");
+				break;
+			}
+			else if (ret == 0)
+			{
+				printf("end of data\n");
+				break;
+			}
+
+			/* Parse Data */
+			len = strlen(buffer);
+			if (buffer[len - 1] != ';')
+				partial = 1;
+
+			printf("socket data received - len(%d) buffer(%s)\n", len, buffer);
+			char *token = strtok_r(buffer, ";", &token_save);
+			while (token != NULL)
+			{
+				strcpy(tokbuf, token);
+				process_data(tokbuf);
+				hash_ring_dump(ring);
+				token = strtok_r(NULL, ";", &token_save);
+			}
+
+			if (partial == 1)
+				printf("Pending Partial data implementation\n");
+
+		}
+		if (ret == -1)
+		{
+			printf("existing on failure to read socket data\n");
+			break;
+		}
+		close(sock_data);
+		hash_ring_updated(ring);
+
+	}
+	free(buffer);
+	free(tokbuf);
+	close(sock_conn);
+	unlink(SOCKET_NAME);
+	remove(SOCKET_NAME);
+	return NULL;
+}
+
+static void
+parse_mac(char *mac_str, uint8_t *mac)
+{
+	int offset = 0;
+	char *token = NULL;
+	char *token_save = NULL;
+
+	token = strtok_r(mac_str, ":", &token_save);
+	while (token != NULL)
+	{
+		mac[offset++] = strtol(token, NULL, 16);
+		token = strtok_r(NULL, ":", &token_save);
+	}
+}
+
+static void
+process_data(char *data)
+{
+	char *token = NULL;
+	char *token_save = NULL;
+	char *mac1_str = NULL;
+	char *mac2_str = NULL;
+	char *name = NULL;
+	int operation = 0;
+	struct hash_ring_node_t *node;
+
+	/* In the current data version, we are expecting only 1 comma (2 values) */
+	token = strtok_r(data, ",", &token_save);
+	if (token == NULL)
+		return;
+	operation = atoi(token);
+
+	token = strtok_r(NULL, ",", &token_save);
+	if (token != NULL)
+	{
+		mac1_str = malloc(strlen(token + 1));
+		if (mac1_str != NULL)
+			strcpy(mac1_str, token);
+	}
+	token = strtok_r(NULL, ",", &token_save);
+	if (token != NULL)
+	{
+		mac2_str = malloc(strlen(token + 1));
+		if (mac2_str != NULL)
+			strcpy(mac2_str, token);
+	}
+
+
+	token = strtok_r(NULL, ",", &token_save);
+	if (token != NULL)
+	{
+		name = malloc(strlen(token + 1));
+		if (name != NULL)
+			strcpy(name, token);
+	}
+
+	node = malloc(sizeof(struct hash_ring_node_t));
+	if (node != NULL && mac1_str != NULL && mac2_str != NULL)
+	{
+		node->name = (uint8_t*)name;
+		if (name != NULL)
+			node->name_length = strlen(name);
+		switch (operation)
+		{
+			case DUT_MAC_ADDED:
+				parse_mac(mac1_str, node->mac);
+				hash_ring_add_node(ring, node);
+				parse_mac(mac2_str, node->mac);
+				hash_ring_add_node(ring, node);
+				break;
+
+			case DUT_MAC_REMOVED:
+				parse_mac(mac1_str, node->mac);
+				hash_ring_remove_node(ring, node);
+				parse_mac(mac2_str, node->mac);
+				hash_ring_remove_node(ring, node);
+				break;
+
+			default:
+			{
+				printf("Operation(%d) is not handled\n", operation);
+				break;
+			}
+		}
+	}
+	else
+	{
+		if (node == NULL)
+			printf("ERROR: failed to allocate node memory\n");
+		if (mac1_str == NULL)
+			printf("ERROR: mac1 is not found\n");
+		if (mac2_str == NULL)
+			printf("ERROR: mac2 is not found\n");
+	}
+
+	if (node != NULL)
+		free(node);
+	if (name != NULL)
+		free(name);
+	if (mac1_str != NULL)
+		free(mac1_str);
+	if (mac2_str != NULL)
+		free(mac2_str);
+}
+
+#endif /* _LB_LISTEN_H */
diff -urN dpdk/app/test-pmd/macfwd.c testpmd-as-load-balancer/v19.11/test-pmd/macfwd.c
--- dpdk/app/test-pmd/macfwd.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/macfwd.c	2023-12-15 15:26:37.090199134 +0100
@@ -24,10 +24,12 @@
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_mempool.h>
 #include <rte_mbuf.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_ip.h>
@@ -54,28 +56,36 @@
 	uint16_t i;
 	uint64_t ol_flags = 0;
 	uint64_t tx_offloads;
-	uint64_t start_tsc = 0;
-
-	get_start_cycles(&start_tsc);
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+#endif
+
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	start_tsc = rte_rdtsc();
+#endif
 
 	/*
 	 * Receive a burst of packets and forward them.
 	 */
 	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue, pkts_burst,
 				 nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
 	if (unlikely(nb_rx == 0))
 		return;
 
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->rx_burst_stats.pkt_burst_spread[nb_rx]++;
+#endif
 	fs->rx_packets += nb_rx;
 	txp = &ports[fs->tx_port];
 	tx_offloads = txp->dev_conf.txmode.offloads;
-	if (tx_offloads	& RTE_ETH_TX_OFFLOAD_VLAN_INSERT)
-		ol_flags = RTE_MBUF_F_TX_VLAN;
-	if (tx_offloads & RTE_ETH_TX_OFFLOAD_QINQ_INSERT)
-		ol_flags |= RTE_MBUF_F_TX_QINQ;
-	if (tx_offloads & RTE_ETH_TX_OFFLOAD_MACSEC_INSERT)
-		ol_flags |= RTE_MBUF_F_TX_MACSEC;
+	if (tx_offloads	& DEV_TX_OFFLOAD_VLAN_INSERT)
+		ol_flags = PKT_TX_VLAN_PKT;
+	if (tx_offloads & DEV_TX_OFFLOAD_QINQ_INSERT)
+		ol_flags |= PKT_TX_QINQ_PKT;
+	if (tx_offloads & DEV_TX_OFFLOAD_MACSEC_INSERT)
+		ol_flags |= PKT_TX_MACSEC;
 	for (i = 0; i < nb_rx; i++) {
 		if (likely(i < nb_rx - 1))
 			rte_prefetch0(rte_pktmbuf_mtod(pkts_burst[i + 1],
@@ -83,10 +93,10 @@
 		mb = pkts_burst[i];
 		eth_hdr = rte_pktmbuf_mtod(mb, struct rte_ether_hdr *);
 		rte_ether_addr_copy(&peer_eth_addrs[fs->peer_addr],
-				&eth_hdr->dst_addr);
+				&eth_hdr->d_addr);
 		rte_ether_addr_copy(&ports[fs->tx_port].eth_addr,
-				&eth_hdr->src_addr);
-		mb->ol_flags &= RTE_MBUF_F_INDIRECT | RTE_MBUF_F_EXTERNAL;
+				&eth_hdr->s_addr);
+		mb->ol_flags &= IND_ATTACHED_MBUF | EXT_ATTACHED_MBUF;
 		mb->ol_flags |= ol_flags;
 		mb->l2_len = sizeof(struct rte_ether_hdr);
 		mb->l3_len = sizeof(struct rte_ipv4_hdr);
@@ -107,33 +117,25 @@
 	}
 
 	fs->tx_packets += nb_tx;
-	inc_tx_burst_stats(fs, nb_tx);
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+#endif
 	if (unlikely(nb_tx < nb_rx)) {
 		fs->fwd_dropped += (nb_rx - nb_tx);
 		do {
 			rte_pktmbuf_free(pkts_burst[nb_tx]);
 		} while (++nb_tx < nb_rx);
 	}
-
-	get_end_cycles(fs, start_tsc);
-}
-
-static void
-stream_init_mac_forward(struct fwd_stream *fs)
-{
-	bool rx_stopped, tx_stopped;
-
-	rx_stopped = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	tx_stopped = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	fs->disabled = rx_stopped || tx_stopped;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
 }
 
 struct fwd_engine mac_fwd_engine = {
 	.fwd_mode_name  = "mac",
 	.port_fwd_begin = NULL,
 	.port_fwd_end   = NULL,
-	.stream_init    = stream_init_mac_forward,
 	.packet_fwd     = pkt_burst_mac_forward,
 };
diff -urN dpdk/app/test-pmd/macswap.c testpmd-as-load-balancer/v19.11/test-pmd/macswap.c
--- dpdk/app/test-pmd/macswap.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/macswap.c	2023-12-15 15:26:37.090199134 +0100
@@ -1,5 +1,34 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright 2014-2020 Mellanox Technologies, Ltd
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2014 Tilera Corporation. All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Tilera Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
  */
 
 #include <stdarg.h>
@@ -24,10 +53,12 @@
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_mempool.h>
 #include <rte_mbuf.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_ip.h>
@@ -37,7 +68,7 @@
 #include "testpmd.h"
 #if defined(RTE_ARCH_X86)
 #include "macswap_sse.h"
-#elif defined(__ARM_NEON)
+#elif defined(RTE_MACHINE_CPUFLAG_NEON)
 #include "macswap_neon.h"
 #else
 #include "macswap.h"
@@ -55,19 +86,27 @@
 	uint16_t nb_rx;
 	uint16_t nb_tx;
 	uint32_t retry;
-	uint64_t start_tsc = 0;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+#endif
 
-	get_start_cycles(&start_tsc);
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	start_tsc = rte_rdtsc();
+#endif
 
 	/*
 	 * Receive a burst of packets and forward them.
 	 */
 	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue, pkts_burst,
 				 nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
 	if (unlikely(nb_rx == 0))
 		return;
 
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->rx_burst_stats.pkt_burst_spread[nb_rx]++;
+#endif
 	fs->rx_packets += nb_rx;
 	txp = &ports[fs->tx_port];
 
@@ -86,32 +125,25 @@
 		}
 	}
 	fs->tx_packets += nb_tx;
-	inc_tx_burst_stats(fs, nb_tx);
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+#endif
 	if (unlikely(nb_tx < nb_rx)) {
 		fs->fwd_dropped += (nb_rx - nb_tx);
 		do {
 			rte_pktmbuf_free(pkts_burst[nb_tx]);
 		} while (++nb_tx < nb_rx);
 	}
-	get_end_cycles(fs, start_tsc);
-}
-
-static void
-stream_init_mac_swap(struct fwd_stream *fs)
-{
-	bool rx_stopped, tx_stopped;
-
-	rx_stopped = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	tx_stopped = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	fs->disabled = rx_stopped || tx_stopped;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
 }
 
 struct fwd_engine mac_swap_engine = {
 	.fwd_mode_name  = "macswap",
 	.port_fwd_begin = NULL,
 	.port_fwd_end   = NULL,
-	.stream_init    = stream_init_mac_swap,
 	.packet_fwd     = pkt_burst_mac_swap,
 };
diff -urN dpdk/app/test-pmd/macswap_common.h testpmd-as-load-balancer/v19.11/test-pmd/macswap_common.h
--- dpdk/app/test-pmd/macswap_common.h	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/macswap_common.h	2023-12-15 15:26:37.090199134 +0100
@@ -10,12 +10,12 @@
 {
 	uint64_t ol_flags = 0;
 
-	ol_flags |= (tx_offload & RTE_ETH_TX_OFFLOAD_VLAN_INSERT) ?
-			RTE_MBUF_F_TX_VLAN : 0;
-	ol_flags |= (tx_offload & RTE_ETH_TX_OFFLOAD_QINQ_INSERT) ?
-			RTE_MBUF_F_TX_QINQ : 0;
-	ol_flags |= (tx_offload & RTE_ETH_TX_OFFLOAD_MACSEC_INSERT) ?
-			RTE_MBUF_F_TX_MACSEC : 0;
+	ol_flags |= (tx_offload & DEV_TX_OFFLOAD_VLAN_INSERT) ?
+			PKT_TX_VLAN : 0;
+	ol_flags |= (tx_offload & DEV_TX_OFFLOAD_QINQ_INSERT) ?
+			PKT_TX_QINQ : 0;
+	ol_flags |= (tx_offload & DEV_TX_OFFLOAD_MACSEC_INSERT) ?
+			PKT_TX_MACSEC : 0;
 
 	return ol_flags;
 }
@@ -26,10 +26,10 @@
 {
 	int i;
 
-	if (ol_flags & RTE_MBUF_F_TX_VLAN)
+	if (ol_flags & PKT_TX_VLAN)
 		for (i = 0; i < nb; i++)
 			pkts[i]->vlan_tci = vlan;
-	if (ol_flags & RTE_MBUF_F_TX_QINQ)
+	if (ol_flags & PKT_TX_QINQ)
 		for (i = 0; i < nb; i++)
 			pkts[i]->vlan_tci_outer = outer_vlan;
 }
@@ -37,7 +37,7 @@
 static inline void
 mbuf_field_set(struct rte_mbuf *mb, uint64_t ol_flags)
 {
-	mb->ol_flags &= RTE_MBUF_F_INDIRECT | RTE_MBUF_F_EXTERNAL;
+	mb->ol_flags &= IND_ATTACHED_MBUF | EXT_ATTACHED_MBUF;
 	mb->ol_flags |= ol_flags;
 	mb->l2_len = sizeof(struct rte_ether_hdr);
 	mb->l3_len = sizeof(struct rte_ipv4_hdr);
diff -urN dpdk/app/test-pmd/macswap.h testpmd-as-load-balancer/v19.11/test-pmd/macswap.h
--- dpdk/app/test-pmd/macswap.h	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/macswap.h	2023-12-15 15:26:37.090199134 +0100
@@ -29,9 +29,9 @@
 		eth_hdr = rte_pktmbuf_mtod(mb, struct rte_ether_hdr *);
 
 		/* Swap dest and src mac addresses. */
-		rte_ether_addr_copy(&eth_hdr->dst_addr, &addr);
-		rte_ether_addr_copy(&eth_hdr->src_addr, &eth_hdr->dst_addr);
-		rte_ether_addr_copy(&addr, &eth_hdr->src_addr);
+		rte_ether_addr_copy(&eth_hdr->d_addr, &addr);
+		rte_ether_addr_copy(&eth_hdr->s_addr, &eth_hdr->d_addr);
+		rte_ether_addr_copy(&addr, &eth_hdr->s_addr);
 
 		mbuf_field_set(mb, ol_flags);
 	}
diff -urN dpdk/app/test-pmd/Makefile testpmd-as-load-balancer/v19.11/test-pmd/Makefile
--- dpdk/app/test-pmd/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ testpmd-as-load-balancer/v19.11/test-pmd/Makefile	2023-12-15 15:26:37.088199112 +0100
@@ -0,0 +1,81 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2010-2015 Intel Corporation
+
+include $(RTE_SDK)/mk/rte.vars.mk
+
+ifeq ($(CONFIG_RTE_TEST_PMD),y)
+
+#
+# library name
+#
+APP = testpmd
+
+CFLAGS += -DALLOW_EXPERIMENTAL_API
+CFLAGS += -O3
+CFLAGS += $(WERROR_FLAGS)
+CFLAGS += -Wno-deprecated-declarations
+
+#
+# all source are stored in SRCS-y
+#
+SRCS-y := testpmd.c
+SRCS-y += parameters.c
+SRCS-$(CONFIG_RTE_LIBRTE_CMDLINE) += cmdline.c
+SRCS-$(CONFIG_RTE_LIBRTE_CMDLINE) += cmdline_flow.c
+SRCS-$(CONFIG_RTE_LIBRTE_CMDLINE) += cmdline_mtr.c
+SRCS-$(CONFIG_RTE_LIBRTE_CMDLINE) += cmdline_tm.c
+SRCS-y += config.c
+SRCS-y += iofwd.c
+SRCS-y += macfwd.c
+SRCS-y += macswap.c
+SRCS-y += flowgen.c
+SRCS-y += rxonly.c
+SRCS-y += txonly.c
+SRCS-y += csumonly.c
+SRCS-y += icmpecho.c
+SRCS-y += noisy_vnf.c
+SRCS-y += hashring.c
+SRCS-y += hashget.c
+SRCS-y += lbfwd.c
+SRCS-y += lb_listen.c
+SRCS-$(CONFIG_RTE_LIBRTE_IEEE1588) += ieee1588fwd.c
+SRCS-$(CONFIG_RTE_LIBRTE_BPF) += bpf_cmd.c
+SRCS-y += util.c
+
+ifeq ($(CONFIG_RTE_LIBRTE_PMD_SOFTNIC), y)
+SRCS-y += softnicfwd.c
+endif
+
+ifeq ($(CONFIG_RTE_BUILD_SHARED_LIB),y)
+
+ifeq ($(CONFIG_RTE_LIBRTE_PMD_BOND),y)
+LDLIBS += -lrte_pmd_bond
+endif
+
+ifeq ($(CONFIG_RTE_LIBRTE_DPAA_BUS)$(CONFIG_RTE_LIBRTE_DPAA_PMD),yy)
+LDLIBS += -lrte_pmd_dpaa
+LDLIBS += -lrte_bus_dpaa
+LDLIBS += -lrte_mempool_dpaa
+endif
+
+ifeq ($(CONFIG_RTE_LIBRTE_IXGBE_PMD),y)
+LDLIBS += -lrte_pmd_ixgbe
+endif
+
+ifeq ($(CONFIG_RTE_LIBRTE_I40E_PMD),y)
+LDLIBS += -lrte_pmd_i40e
+endif
+
+ifeq ($(CONFIG_RTE_LIBRTE_BNXT_PMD),y)
+LDLIBS += -lrte_pmd_bnxt
+endif
+
+ifeq ($(CONFIG_RTE_LIBRTE_PMD_SOFTNIC),y)
+LDLIBS += -lrte_pmd_softnic
+endif
+
+endif
+
+include $(RTE_SDK)/mk/rte.app.mk
+
+endif
diff -urN dpdk/app/test-pmd/meson.build testpmd-as-load-balancer/v19.11/test-pmd/meson.build
--- dpdk/app/test-pmd/meson.build	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/meson.build	2023-12-15 15:26:37.090199134 +0100
@@ -3,75 +3,48 @@
 
 # override default name to drop the hyphen
 name = 'testpmd'
+allow_experimental_apis = true
 cflags += '-Wno-deprecated-declarations'
-sources = files(
-        '5tswap.c',
-        'cmdline.c',
-        'cmdline_flow.c',
-        'cmdline_mtr.c',
-        'cmdline_tm.c',
-        'cmd_flex_item.c',
-        'config.c',
-        'csumonly.c',
-        'flowgen.c',
-        'icmpecho.c',
-        'ieee1588fwd.c',
-        'iofwd.c',
-        'macfwd.c',
-        'macswap.c',
-        'noisy_vnf.c',
-        'parameters.c',
-        'rxonly.c',
-        'shared_rxq_fwd.c',
-        'testpmd.c',
-        'txonly.c',
-        'util.c',
-)
+sources = files('cmdline.c',
+	'cmdline_flow.c',
+	'cmdline_mtr.c',
+	'cmdline_tm.c',
+	'config.c',
+	'csumonly.c',
+	'flowgen.c',
+	'icmpecho.c',
+	'ieee1588fwd.c',
+	'iofwd.c',
+	'macfwd.c',
+	'macswap.c',
+	'noisy_vnf.c',
+	'parameters.c',
+	'rxonly.c',
+	'testpmd.c',
+	'txonly.c',
+	'util.c')
 
-if dpdk_conf.has('RTE_HAS_JANSSON')
-    ext_deps += jansson_dep
+deps += ['ethdev', 'gro', 'gso', 'cmdline', 'metrics', 'meter', 'bus_pci']
+if dpdk_conf.has('RTE_LIBRTE_PDUMP')
+	deps += 'pdump'
 endif
-
-deps += ['ethdev', 'cmdline']
-if dpdk_conf.has('RTE_CRYPTO_SCHEDULER')
-    deps += 'crypto_scheduler'
-endif
-if dpdk_conf.has('RTE_LIB_BITRATESTATS')
-    deps += 'bitratestats'
-endif
-if dpdk_conf.has('RTE_LIB_BPF')
-    sources += files('bpf_cmd.c')
-    deps += 'bpf'
-endif
-if dpdk_conf.has('RTE_LIB_GRO')
-    deps += 'gro'
+if dpdk_conf.has('RTE_LIBRTE_BNXT_PMD')
+	deps += 'pmd_bnxt'
 endif
-if dpdk_conf.has('RTE_LIB_GSO')
-    deps += 'gso'
+if dpdk_conf.has('RTE_LIBRTE_I40E_PMD')
+	deps += 'pmd_i40e'
 endif
-if dpdk_conf.has('RTE_LIB_LATENCYSTATS')
-    deps += 'latencystats'
+if dpdk_conf.has('RTE_LIBRTE_IXGBE_PMD')
+	deps += 'pmd_ixgbe'
 endif
-if dpdk_conf.has('RTE_LIB_METRICS')
-    deps += 'metrics'
+if dpdk_conf.has('RTE_LIBRTE_SOFTNIC_PMD')
+	sources += files('softnicfwd.c')
+	deps += 'pmd_softnic'
 endif
-if dpdk_conf.has('RTE_LIB_PDUMP')
-    deps += 'pdump'
+if dpdk_conf.has('RTE_LIBRTE_DPAA_PMD')
+	deps += ['bus_dpaa', 'mempool_dpaa', 'pmd_dpaa']
 endif
-if dpdk_conf.has('RTE_NET_BNXT')
-    deps += 'net_bnxt'
+if dpdk_conf.has('RTE_LIBRTE_BPF')
+	sources += files('bpf_cmd.c')
+	deps += 'bpf'
 endif
-if dpdk_conf.has('RTE_NET_I40E')
-    deps += 'net_i40e'
-endif
-if dpdk_conf.has('RTE_NET_IXGBE')
-    deps += 'net_ixgbe'
-endif
-if dpdk_conf.has('RTE_NET_DPAA')
-    deps += ['bus_dpaa', 'mempool_dpaa', 'net_dpaa']
-endif
-
-# Driver-specific commands are located in driver directories.
-includes = include_directories('.')
-sources += testpmd_drivers_sources
-deps += testpmd_drivers_deps
diff -urN dpdk/app/test-pmd/noisy_vnf.c testpmd-as-load-balancer/v19.11/test-pmd/noisy_vnf.c
--- dpdk/app/test-pmd/noisy_vnf.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/noisy_vnf.c	2023-12-15 15:26:37.090199134 +0100
@@ -4,7 +4,6 @@
 
 #include <stdarg.h>
 #include <stdio.h>
-#include <stdlib.h>
 #include <stdbool.h>
 #include <string.h>
 #include <errno.h>
@@ -57,8 +56,8 @@
 static inline void
 do_read(char *vnf_mem)
 {
-	uint64_t r __rte_unused;
 	uint64_t i = rte_rand();
+	uint64_t r;
 
 	r = vnf_mem[i % ((noisy_lkup_mem_sz * 1024 * 1024) /
 			RTE_CACHE_LINE_SIZE)];
@@ -155,7 +154,6 @@
 
 	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue,
 			pkts_burst, nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
 	if (unlikely(nb_rx == 0))
 		goto flush;
 	fs->rx_packets += nb_rx;
@@ -166,7 +164,6 @@
 				pkts_burst, nb_rx);
 		if (unlikely(nb_tx < nb_rx) && fs->retry_enabled)
 			nb_tx += do_retry(nb_rx, nb_tx, pkts_burst, fs);
-		inc_tx_burst_stats(fs, nb_tx);
 		fs->tx_packets += nb_tx;
 		fs->fwd_dropped += drop_pkts(pkts_burst, nb_rx, nb_tx);
 		return;
@@ -190,7 +187,6 @@
 					nb_deqd);
 			if (unlikely(nb_tx < nb_rx) && fs->retry_enabled)
 				nb_tx += do_retry(nb_rx, nb_tx, tmp_pkts, fs);
-			inc_tx_burst_stats(fs, nb_tx);
 			fs->fwd_dropped += drop_pkts(tmp_pkts, nb_deqd, nb_tx);
 		}
 	}
@@ -214,10 +210,8 @@
 		sent = rte_eth_tx_burst(fs->tx_port, fs->tx_queue,
 					 tmp_pkts, nb_deqd);
 		if (unlikely(sent < nb_deqd) && fs->retry_enabled)
-			sent += do_retry(nb_deqd, sent, tmp_pkts, fs);
-		inc_tx_burst_stats(fs, sent);
+			nb_tx += do_retry(nb_rx, nb_tx, tmp_pkts, fs);
 		fs->fwd_dropped += drop_pkts(tmp_pkts, nb_deqd, sent);
-		nb_tx += sent;
 		ncf->prev_time = rte_get_timer_cycles();
 	}
 }
@@ -233,7 +227,7 @@
 	rte_free(noisy_cfg[pi]);
 }
 
-static int
+static void
 noisy_fwd_begin(portid_t pi)
 {
 	struct noisy_config *n;
@@ -275,26 +269,11 @@
 		rte_exit(EXIT_FAILURE,
 			 "--noisy-lkup-memory-size must be > 0\n");
 	}
-
-	return 0;
-}
-
-static void
-stream_init_noisy_vnf(struct fwd_stream *fs)
-{
-	bool rx_stopped, tx_stopped;
-
-	rx_stopped = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	tx_stopped = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-	fs->disabled = rx_stopped || tx_stopped;
 }
 
 struct fwd_engine noisy_vnf_engine = {
 	.fwd_mode_name  = "noisy",
 	.port_fwd_begin = noisy_fwd_begin,
 	.port_fwd_end   = noisy_fwd_end,
-	.stream_init    = stream_init_noisy_vnf,
 	.packet_fwd     = pkt_burst_noisy_vnf,
 };
diff -urN dpdk/app/test-pmd/parameters.c testpmd-as-load-balancer/v19.11/test-pmd/parameters.c
--- dpdk/app/test-pmd/parameters.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/parameters.c	2023-12-15 15:26:37.090199134 +0100
@@ -19,6 +19,7 @@
 #include <stdint.h>
 #include <unistd.h>
 #include <inttypes.h>
+#include <arpa/inet.h>
 
 #include <rte_common.h>
 #include <rte_byteorder.h>
@@ -30,12 +31,17 @@
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_mempool.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_string_fns.h>
+#ifdef RTE_LIBRTE_PMD_BOND
+#include <rte_eth_bond.h>
+#endif
 #include <rte_flow.h>
 
 #include "testpmd.h"
@@ -43,9 +49,29 @@
 static void
 usage(char* progname)
 {
-	printf("\nUsage: %s [EAL options] -- [testpmd options]\n\n",
+	printf("usage: %s "
+#ifdef RTE_LIBRTE_CMDLINE
+	       "[--interactive|-i] "
+	       "[--cmdline-file=FILENAME] "
+#endif
+	       "[--help|-h] | [--auto-start|-a] | ["
+	       "--tx-first | --stats-period=PERIOD | "
+	       "--coremask=COREMASK --portmask=PORTMASK --numa "
+	       "--mbuf-size= | --total-num-mbufs= | "
+	       "--nb-cores= | --nb-ports= | "
+#ifdef RTE_LIBRTE_CMDLINE
+	       "--eth-peers-configfile= | "
+	       "--eth-peer=X,M:M:M:M:M:M | "
+	       "--tx-ip=SRC,DST | --tx-udp=PORT | "
+#endif
+	       "--pkt-filter-mode= |"
+	       "--rss-ip | --rss-udp | "
+	       "--rxpt= | --rxht= | --rxwt= | --rxfreet= | "
+	       "--txpt= | --txht= | --txwt= | --txfreet= | "
+	       "--txrst= | --tx-offloads= | | --rx-offloads= | "
+	       "--vxlan-gpe-port= ]\n",
 	       progname);
-#ifdef RTE_LIB_CMDLINE
+#ifdef RTE_LIBRTE_CMDLINE
 	printf("  --interactive: run in interactive mode.\n");
 	printf("  --cmdline-file: execute cli commands before startup.\n");
 #endif
@@ -56,27 +82,18 @@
 	       "(only if interactive is disabled).\n");
 	printf("  --stats-period=PERIOD: statistics will be shown "
 	       "every PERIOD seconds (only if interactive is disabled).\n");
-	printf("  --display-xstats xstat_name1[,...]: comma-separated list of "
-	       "extended statistics to show. Used with --stats-period "
-	       "specified or interactive commands that show Rx/Tx statistics "
-	       "(i.e. 'show port stats').\n");
-	printf("  --num-procs=N: set the total number of multi-process instances.\n");
-	printf("  --proc-id=id: set the id of the current process from "
-	       "multi-process instances (0 <= id < num-procs).\n");
 	printf("  --nb-cores=N: set the number of forwarding cores "
 	       "(1 <= N <= %d).\n", nb_lcores);
 	printf("  --nb-ports=N: set the number of forwarding ports "
 	       "(1 <= N <= %d).\n", nb_ports);
 	printf("  --coremask=COREMASK: hexadecimal bitmask of cores running "
-	       "the packet forwarding test. The main lcore is reserved for "
+	       "the packet forwarding test. The master lcore is reserved for "
 	       "command line parsing only, and cannot be masked on for "
 	       "packet forwarding.\n");
 	printf("  --portmask=PORTMASK: hexadecimal bitmask of ports used "
 	       "by the packet forwarding test.\n");
-	printf("  --portlist=PORTLIST: list of forwarding ports\n");
 	printf("  --numa: enable NUMA-aware allocation of RX/TX rings and of "
 	       "RX memory buffers (mbufs).\n");
-	printf("  --no-numa: disable NUMA-aware allocation.\n");
 	printf("  --port-numa-config=(port,socket)[,(port,socket)]: "
 	       "specify the socket on which the memory pool "
 	       "used by the port will be allocated.\n");
@@ -86,27 +103,34 @@
 	       "(flag: 1 for RX; 2 for TX; 3 for RX and TX).\n");
 	printf("  --socket-num=N: set socket from which all memory is allocated "
 	       "in NUMA mode.\n");
-	printf("  --mbuf-size=N,[N1[,..Nn]: set the data size of mbuf to "
-	       "N bytes. If multiple numbers are specified the extra pools "
-	       "will be created to receive packets based on the features "
-	       "supported, like packet split, multi-rx-mempool.\n");
+	printf("  --mbuf-size=N: set the data size of mbuf to N bytes.\n");
 	printf("  --total-num-mbufs=N: set the number of mbufs to be allocated "
 	       "in mbuf pools.\n");
 	printf("  --max-pkt-len=N: set the maximum size of packet to N bytes.\n");
 	printf("  --max-lro-pkt-size=N: set the maximum LRO aggregated packet "
 	       "size to N bytes.\n");
-#ifdef RTE_LIB_CMDLINE
+#ifdef RTE_LIBRTE_CMDLINE
 	printf("  --eth-peers-configfile=name: config file with ethernet addresses "
 	       "of peer ports.\n");
 	printf("  --eth-peer=X,M:M:M:M:M:M: set the MAC address of the X peer "
 	       "port (0 <= X < %d).\n", RTE_MAX_ETHPORTS);
 #endif
-#ifdef RTE_LIB_LATENCYSTATS
-	printf("  --latencystats=N: enable latency and jitter statistics "
+	printf("  --pkt-filter-mode=N: set Flow Director mode "
+	       "(N: none (default mode) or signature or perfect).\n");
+	printf("  --pkt-filter-report-hash=N: set Flow Director report mode "
+	       "(N: none  or match (default) or always).\n");
+	printf("  --pkt-filter-size=N: set Flow Director mode "
+	       "(N: 64K (default mode) or 128K or 256K).\n");
+	printf("  --pkt-filter-drop-queue=N: set drop-queue. "
+	       "In perfect mode, when you add a rule with queue = -1 "
+	       "the packet will be enqueued into the rx drop-queue. "
+	       "If the drop-queue doesn't exist, the packet is dropped. "
+	       "By default drop-queue=127.\n");
+#ifdef RTE_LIBRTE_LATENCY_STATS
+	printf("  --latencystats=N: enable latency and jitter statistcs "
 	       "monitoring on forwarding lcore id N.\n");
 #endif
 	printf("  --disable-crc-strip: disable CRC stripping by hardware.\n");
-	printf("  --enable-scatter: enable scattered Rx.\n");
 	printf("  --enable-lro: enable large receive offload.\n");
 	printf("  --enable-rx-cksum: enable rx hardware checksum offload.\n");
 	printf("  --enable-rx-timestamp: enable rx hardware timestamp offload.\n");
@@ -121,12 +145,8 @@
 	       "is default).\n");
 	printf("  --forward-mode=N: set forwarding mode (N: %s).\n",
 	       list_pkt_forwarding_modes());
-	printf("  --forward-mode=5tswap: set forwarding mode to "
-			"swap L2,L3,L4 for MAC, IPv4/IPv6 and TCP/UDP only.\n");
 	printf("  --rss-ip: set RSS functions to IPv4/IPv6 only .\n");
 	printf("  --rss-udp: set RSS functions to IPv4/IPv6 + UDP.\n");
-	printf("  --rss-level-inner: set RSS hash level to innermost\n");
-	printf("  --rss-level-outer: set RSS hash level to outermost\n");
 	printf("  --rxq=N: set the number of RX queues per port to N.\n");
 	printf("  --rxd=N: set the number of descriptors in RX rings to N.\n");
 	printf("  --txq=N: set the number of TX queues per port to N.\n");
@@ -134,8 +154,6 @@
 	printf("  --hairpinq=N: set the number of hairpin queues per port to "
 	       "N.\n");
 	printf("  --burst=N: set the number of packets per burst to N.\n");
-	printf("  --flowgen-clones=N: set the number of single packet clones to send in flowgen mode. Should be less than burst value.\n");
-	printf("  --flowgen-flows=N: set the number of flows in flowgen mode to N (1 <= N <= INT32_MAX).\n");
 	printf("  --mbcache=N: set the cache of mbuf memory pool to N.\n");
 	printf("  --rxpt=N: set prefetch threshold register of RX rings to N.\n");
 	printf("  --rxht=N: set the host threshold register of RX rings to N.\n");
@@ -149,19 +167,17 @@
 	       "(0 <= N <= value of txd).\n");
 	printf("  --txrst=N: set the transmit RS bit threshold of TX rings to N "
 	       "(0 <= N <= value of txd).\n");
+	printf("  --tx-queue-stats-mapping=(port,queue,mapping)[,(port,queue,mapping]: "
+	       "tx queues statistics counters mapping "
+	       "(0 <= mapping <= %d).\n", RTE_ETHDEV_QUEUE_STAT_CNTRS - 1);
+	printf("  --rx-queue-stats-mapping=(port,queue,mapping)[,(port,queue,mapping]: "
+	       "rx queues statistics counters mapping "
+	       "(0 <= mapping <= %d).\n", RTE_ETHDEV_QUEUE_STAT_CNTRS - 1);
 	printf("  --no-flush-rx: Don't flush RX streams before forwarding."
 	       " Used mainly with PCAP drivers.\n");
-	printf("  --rxoffs=X[,Y]*: set RX segment offsets for split.\n");
-	printf("  --rxpkts=X[,Y]*: set RX segment sizes to split.\n");
-	printf("  --rxhdrs=eth[,ipv4]*: set RX segment protocol to split.\n");
 	printf("  --txpkts=X[,Y]*: set TX segment sizes"
 		" or total packet length.\n");
-	printf("  --multi-rx-mempool: enable multi-rx-mempool support\n");
 	printf("  --txonly-multi-flow: generate multiple flows in txonly mode\n");
-	printf("  --tx-ip=src,dst: IP addresses in Tx-only mode\n");
-	printf("  --tx-udp=src[,dst]: UDP ports in Tx-only mode\n");
-	printf("  --eth-link-speed: force link speed.\n");
-	printf("  --rxq-share=X: number of ports per shared Rx queue groups, defaults to UINT32_MAX (1 group)\n");
 	printf("  --disable-link-check: disable check on link status when "
 	       "starting/stopping ports.\n");
 	printf("  --disable-device-start: do not automatically start port\n");
@@ -169,9 +185,9 @@
 	printf("  --no-rmv-interrupt: disable device removal interrupt.\n");
 	printf("  --bitrate-stats=N: set the logical core N to perform "
 		"bit-rate calculation.\n");
-	printf("  --print-event <unknown|intr_lsc|queue_state|intr_reset|vf_mbox|macsec|intr_rmv|flow_aged|err_recovering|recovery_success|recovery_failed|all>: "
+	printf("  --print-event <unknown|intr_lsc|queue_state|intr_reset|vf_mbox|macsec|intr_rmv|all>: "
 	       "enable print of designated event or all of them.\n");
-	printf("  --mask-event <unknown|intr_lsc|queue_state|intr_reset|vf_mbox|macsec|intr_rmv|flow_aged|err_recovering|recovery_success|recovery_failed||all>: "
+	printf("  --mask-event <unknown|intr_lsc|queue_state|intr_reset|vf_mbox|macsec|intr_rmv|all>: "
 	       "disable print of designated event or all of them.\n");
 	printf("  --flow-isolate-all: "
 	       "requests flow API isolated mode on all ports at initialization time.\n");
@@ -179,11 +195,8 @@
 	printf("  --rx-offloads=0xXXXXXXXX: hexadecimal bitmask of RX queue offloads\n");
 	printf("  --hot-plug: enable hot plug for device.\n");
 	printf("  --vxlan-gpe-port=N: UPD port of tunnel VXLAN-GPE\n");
-	printf("  --geneve-parsed-port=N: UPD port to parse GENEVE tunnel protocol\n");
-#ifndef RTE_EXEC_ENV_WINDOWS
 	printf("  --mlockall: lock all memory\n");
 	printf("  --no-mlockall: do not lock all memory\n");
-#endif
 	printf("  --mp-alloc <native|anon|xmem|xmemhuge>: mempool allocation method.\n"
 	       "    native: use regular DPDK memory to create and populate mempool\n"
 	       "    anon: use regular DPDK memory to create and anonymous memory to populate mempool\n"
@@ -194,21 +207,16 @@
 	printf("  --noisy-lkup-memory=N: allocate N MB of VNF memory\n");
 	printf("  --noisy-lkup-num-writes=N: do N random writes per packet\n");
 	printf("  --noisy-lkup-num-reads=N: do N random reads per packet\n");
-	printf("  --noisy-lkup-num-reads-writes=N: do N random reads and writes per packet\n");
+	printf("  --noisy-lkup-num-writes=N: do N random reads and writes per packet\n");
 	printf("  --no-iova-contig: mempool memory can be IOVA non contiguous. "
 	       "valid only with --mp-alloc=anon\n");
-	printf("  --rx-mq-mode=0xX: hexadecimal bitmask of RX mq mode can be "
-	       "enabled\n");
-	printf("  --record-core-cycles: enable measurement of CPU cycles.\n");
-	printf("  --record-burst-stats: enable display of RX and TX bursts.\n");
-	printf("  --hairpin-mode=0xXX: bitmask set the hairpin port mode.\n"
-	       "    0x10 - explicit Tx rule, 0x02 - hairpin ports paired\n"
-	       "    0x01 - hairpin ports loop, 0x00 - hairpin port self\n");
+	printf("  --enable-lb: enable load balancer mode\n");
+	printf("  --dut-pci: PCI address of ports attached to DUT\n");
 }
 
-#ifdef RTE_LIB_CMDLINE
+#ifdef RTE_LIBRTE_CMDLINE
 static int
-init_peer_eth_addrs(const char *config_filename)
+init_peer_eth_addrs(char *config_filename)
 {
 	FILE *config_file;
 	portid_t i;
@@ -226,8 +234,7 @@
 			break;
 
 		if (rte_ether_unformat_addr(buf, &peer_eth_addrs[i]) < 0) {
-			fprintf(stderr, "Bad MAC address format on line %d\n",
-				i + 1);
+			printf("Bad MAC address format on line %d\n", i+1);
 			fclose(config_file);
 			return -1;
 		}
@@ -276,15 +283,102 @@
 		set_fwd_ports_mask((uint64_t) pm);
 }
 
+
+static int
+parse_queue_stats_mapping_config(const char *q_arg, int is_rx)
+{
+	char s[256];
+	const char *p, *p0 = q_arg;
+	char *end;
+	enum fieldnames {
+		FLD_PORT = 0,
+		FLD_QUEUE,
+		FLD_STATS_COUNTER,
+		_NUM_FLD
+	};
+	unsigned long int_fld[_NUM_FLD];
+	char *str_fld[_NUM_FLD];
+	int i;
+	unsigned size;
+
+	/* reset from value set at definition */
+	is_rx ? (nb_rx_queue_stats_mappings = 0) : (nb_tx_queue_stats_mappings = 0);
+
+	while ((p = strchr(p0,'(')) != NULL) {
+		++p;
+		if((p0 = strchr(p,')')) == NULL)
+			return -1;
+
+		size = p0 - p;
+		if(size >= sizeof(s))
+			return -1;
+
+		snprintf(s, sizeof(s), "%.*s", size, p);
+		if (rte_strsplit(s, sizeof(s), str_fld, _NUM_FLD, ',') != _NUM_FLD)
+			return -1;
+		for (i = 0; i < _NUM_FLD; i++){
+			errno = 0;
+			int_fld[i] = strtoul(str_fld[i], &end, 0);
+			if (errno != 0 || end == str_fld[i] || int_fld[i] > 255)
+				return -1;
+		}
+		/* Check mapping field is in correct range (0..RTE_ETHDEV_QUEUE_STAT_CNTRS-1) */
+		if (int_fld[FLD_STATS_COUNTER] >= RTE_ETHDEV_QUEUE_STAT_CNTRS) {
+			printf("Stats counter not in the correct range 0..%d\n",
+					RTE_ETHDEV_QUEUE_STAT_CNTRS - 1);
+			return -1;
+		}
+
+		if (!is_rx) {
+			if ((nb_tx_queue_stats_mappings >=
+						MAX_TX_QUEUE_STATS_MAPPINGS)) {
+				printf("exceeded max number of TX queue "
+						"statistics mappings: %hu\n",
+						nb_tx_queue_stats_mappings);
+				return -1;
+			}
+			tx_queue_stats_mappings_array[nb_tx_queue_stats_mappings].port_id =
+				(uint8_t)int_fld[FLD_PORT];
+			tx_queue_stats_mappings_array[nb_tx_queue_stats_mappings].queue_id =
+				(uint8_t)int_fld[FLD_QUEUE];
+			tx_queue_stats_mappings_array[nb_tx_queue_stats_mappings].stats_counter_id =
+				(uint8_t)int_fld[FLD_STATS_COUNTER];
+			++nb_tx_queue_stats_mappings;
+		}
+		else {
+			if ((nb_rx_queue_stats_mappings >=
+						MAX_RX_QUEUE_STATS_MAPPINGS)) {
+				printf("exceeded max number of RX queue "
+						"statistics mappings: %hu\n",
+						nb_rx_queue_stats_mappings);
+				return -1;
+			}
+			rx_queue_stats_mappings_array[nb_rx_queue_stats_mappings].port_id =
+				(uint8_t)int_fld[FLD_PORT];
+			rx_queue_stats_mappings_array[nb_rx_queue_stats_mappings].queue_id =
+				(uint8_t)int_fld[FLD_QUEUE];
+			rx_queue_stats_mappings_array[nb_rx_queue_stats_mappings].stats_counter_id =
+				(uint8_t)int_fld[FLD_STATS_COUNTER];
+			++nb_rx_queue_stats_mappings;
+		}
+
+	}
+/* Reassign the rx/tx_queue_stats_mappings pointer to point to this newly populated array rather */
+/* than to the default array (that was set at its definition) */
+	is_rx ? (rx_queue_stats_mappings = rx_queue_stats_mappings_array) :
+		(tx_queue_stats_mappings = tx_queue_stats_mappings_array);
+	return 0;
+}
+
 static void
 print_invalid_socket_id_error(void)
 {
 	unsigned int i = 0;
 
-	fprintf(stderr, "Invalid socket id, options are: ");
+	printf("Invalid socket id, options are: ");
 	for (i = 0; i < num_sockets; i++) {
-		fprintf(stderr, "%u%s", socket_ids[i],
-			(i == num_sockets - 1) ? "\n" : ",");
+		printf("%u%s", socket_ids[i],
+		      (i == num_sockets - 1) ? "\n" : ",");
 	}
 }
 
@@ -400,8 +494,7 @@
 		}
 		ring_flag = (uint8_t)int_fld[FLD_FLAG];
 		if ((ring_flag < RX_RING_ONLY) || (ring_flag > RXTX_RING)) {
-			fprintf(stderr,
-				"Invalid ring-flag=%d config for port =%d\n",
+			printf("Invalid ring-flag=%d config for port =%d\n",
 				ring_flag,port_id);
 			return -1;
 		}
@@ -418,8 +511,7 @@
 			txring_numa[port_id] = socket_id;
 			break;
 		default:
-			fprintf(stderr,
-				"Invalid ring-flag=%d config for port=%d\n",
+			printf("Invalid ring-flag=%d config for port=%d\n",
 				ring_flag,port_id);
 			break;
 		}
@@ -453,14 +545,6 @@
 		mask = UINT32_C(1) << RTE_ETH_EVENT_NEW;
 	else if (!strcmp(optarg, "dev_released"))
 		mask = UINT32_C(1) << RTE_ETH_EVENT_DESTROY;
-	else if (!strcmp(optarg, "flow_aged"))
-		mask = UINT32_C(1) << RTE_ETH_EVENT_FLOW_AGED;
-	else if (!strcmp(optarg, "err_recovering"))
-		mask = UINT32_C(1) << RTE_ETH_EVENT_ERR_RECOVERING;
-	else if (!strcmp(optarg, "recovery_success"))
-		mask = UINT32_C(1) << RTE_ETH_EVENT_RECOVERY_SUCCESS;
-	else if (!strcmp(optarg, "recovery_failed"))
-		mask = UINT32_C(1) << RTE_ETH_EVENT_RECOVERY_FAILED;
 	else if (!strcmp(optarg, "all"))
 		mask = ~UINT32_C(0);
 	else {
@@ -474,115 +558,9 @@
 	return 0;
 }
 
-static int
-parse_xstats_list(const char *in_str, struct rte_eth_xstat_name **xstats,
-		  unsigned int *xstats_num)
-{
-	int max_names_nb, names_nb, nonempty_names_nb;
-	int name, nonempty_name;
-	int stringlen;
-	char **names;
-	char *str;
-	int ret;
-	int i;
-
-	names = NULL;
-	str = strdup(in_str);
-	if (str == NULL) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	stringlen = strlen(str);
-
-	for (i = 0, max_names_nb = 1; str[i] != '\0'; i++) {
-		if (str[i] == ',')
-			max_names_nb++;
-	}
-
-	names = calloc(max_names_nb, sizeof(*names));
-	if (names == NULL) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	names_nb = rte_strsplit(str, stringlen, names, max_names_nb, ',');
-	if (names_nb < 0) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	nonempty_names_nb = 0;
-	for (i = 0; i < names_nb; i++) {
-		if (names[i][0] == '\0')
-			continue;
-		nonempty_names_nb++;
-	}
-	*xstats = calloc(nonempty_names_nb, sizeof(**xstats));
-	if (*xstats == NULL) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	for (name = nonempty_name = 0; name < names_nb; name++) {
-		if (names[name][0] == '\0')
-			continue;
-		rte_strscpy((*xstats)[nonempty_name].name, names[name],
-			    sizeof((*xstats)[nonempty_name].name));
-		nonempty_name++;
-	}
-
-	*xstats_num = nonempty_names_nb;
-	ret = 0;
-
-out:
-	free(names);
-	free(str);
-	return ret;
-}
-
-static int
-parse_link_speed(int n)
-{
-	uint32_t speed = RTE_ETH_LINK_SPEED_FIXED;
-
-	switch (n) {
-	case 1000:
-		speed |= RTE_ETH_LINK_SPEED_1G;
-		break;
-	case 10000:
-		speed |= RTE_ETH_LINK_SPEED_10G;
-		break;
-	case 25000:
-		speed |= RTE_ETH_LINK_SPEED_25G;
-		break;
-	case 40000:
-		speed |= RTE_ETH_LINK_SPEED_40G;
-		break;
-	case 50000:
-		speed |= RTE_ETH_LINK_SPEED_50G;
-		break;
-	case 100000:
-		speed |= RTE_ETH_LINK_SPEED_100G;
-		break;
-	case 200000:
-		speed |= RTE_ETH_LINK_SPEED_200G;
-		break;
-	case 100:
-	case 10:
-	default:
-		fprintf(stderr, "Unsupported fixed speed\n");
-		return 0;
-	}
-
-	return speed;
-}
-
 void
 launch_args_parse(int argc, char** argv)
 {
-#define PARAM_PROC_ID "proc-id"
-#define PARAM_NUM_PROCS "num-procs"
-
 	int n, opt;
 	char **argvopt;
 	int opt_idx;
@@ -597,7 +575,7 @@
 
 	static struct option lgopts[] = {
 		{ "help",			0, 0, 0 },
-#ifdef RTE_LIB_CMDLINE
+#ifdef RTE_LIBRTE_CMDLINE
 		{ "interactive",		0, 0, 0 },
 		{ "cmdline-file",		1, 0, 0 },
 		{ "auto-start",			0, 0, 0 },
@@ -606,15 +584,14 @@
 #endif
 		{ "tx-first",			0, 0, 0 },
 		{ "stats-period",		1, 0, 0 },
-		{ "display-xstats",		1, 0, 0 },
+		{ "ports",			1, 0, 0 },
 		{ "nb-cores",			1, 0, 0 },
 		{ "nb-ports",			1, 0, 0 },
 		{ "coremask",			1, 0, 0 },
 		{ "portmask",			1, 0, 0 },
-		{ "portlist",			1, 0, 0 },
 		{ "numa",			0, 0, 0 },
 		{ "no-numa",			0, 0, 0 },
-		{ "mp-anon",			0, 0, 0 }, /* deprecated */
+		{ "mp-anon",			0, 0, 0 },
 		{ "port-numa-config",           1, 0, 0 },
 		{ "ring-numa-config",           1, 0, 0 },
 		{ "socket-num",			1, 0, 0 },
@@ -622,10 +599,14 @@
 		{ "total-num-mbufs",		1, 0, 0 },
 		{ "max-pkt-len",		1, 0, 0 },
 		{ "max-lro-pkt-size",		1, 0, 0 },
-#ifdef RTE_LIB_LATENCYSTATS
+		{ "pkt-filter-mode",            1, 0, 0 },
+		{ "pkt-filter-report-hash",     1, 0, 0 },
+		{ "pkt-filter-size",            1, 0, 0 },
+		{ "pkt-filter-drop-queue",      1, 0, 0 },
+#ifdef RTE_LIBRTE_LATENCY_STATS
 		{ "latencystats",               1, 0, 0 },
 #endif
-#ifdef RTE_LIB_BITRATESTATS
+#ifdef RTE_LIBRTE_BITRATE
 		{ "bitrate-stats",              1, 0, 0 },
 #endif
 		{ "disable-crc-strip",          0, 0, 0 },
@@ -644,17 +625,12 @@
 		{ "forward-mode",               1, 0, 0 },
 		{ "rss-ip",			0, 0, 0 },
 		{ "rss-udp",			0, 0, 0 },
-		{ "rss-level-outer",		0, 0, 0 },
-		{ "rss-level-inner",		0, 0, 0 },
 		{ "rxq",			1, 0, 0 },
 		{ "txq",			1, 0, 0 },
 		{ "rxd",			1, 0, 0 },
 		{ "txd",			1, 0, 0 },
 		{ "hairpinq",			1, 0, 0 },
-		{ "hairpin-mode",		1, 0, 0 },
 		{ "burst",			1, 0, 0 },
-		{ "flowgen-clones",		1, 0, 0 },
-		{ "flowgen-flows",		1, 0, 0 },
 		{ "mbcache",			1, 0, 0 },
 		{ "txpt",			1, 0, 0 },
 		{ "txht",			1, 0, 0 },
@@ -665,16 +641,12 @@
 		{ "rxht",			1, 0, 0 },
 		{ "rxwt",			1, 0, 0 },
 		{ "rxfreet",                    1, 0, 0 },
+		{ "tx-queue-stats-mapping",	1, 0, 0 },
+		{ "rx-queue-stats-mapping",	1, 0, 0 },
 		{ "no-flush-rx",	0, 0, 0 },
 		{ "flow-isolate-all",	        0, 0, 0 },
-		{ "rxoffs",			1, 0, 0 },
-		{ "rxpkts",			1, 0, 0 },
-		{ "rxhdrs",			1, 0, 0 },
 		{ "txpkts",			1, 0, 0 },
-		{ "multi-rx-mempool",           0, 0, 0 },
 		{ "txonly-multi-flow",		0, 0, 0 },
-		{ "rxq-share",			2, 0, 0 },
-		{ "eth-link-speed",		1, 0, 0 },
 		{ "disable-link-check",		0, 0, 0 },
 		{ "disable-device-start",	0, 0, 0 },
 		{ "no-lsc-interrupt",		0, 0, 0 },
@@ -685,11 +657,8 @@
 		{ "rx-offloads",		1, 0, 0 },
 		{ "hot-plug",			0, 0, 0 },
 		{ "vxlan-gpe-port",		1, 0, 0 },
-		{ "geneve-parsed-port",		1, 0, 0 },
-#ifndef RTE_EXEC_ENV_WINDOWS
 		{ "mlockall",			0, 0, 0 },
 		{ "no-mlockall",		0, 0, 0 },
-#endif
 		{ "mp-alloc",			1, 0, 0 },
 		{ "tx-ip",			1, 0, 0 },
 		{ "tx-udp",			1, 0, 0 },
@@ -700,17 +669,14 @@
 		{ "noisy-lkup-num-reads",	1, 0, 0 },
 		{ "noisy-lkup-num-reads-writes", 1, 0, 0 },
 		{ "no-iova-contig",             0, 0, 0 },
-		{ "rx-mq-mode",                 1, 0, 0 },
-		{ "record-core-cycles",         0, 0, 0 },
-		{ "record-burst-stats",         0, 0, 0 },
-		{ PARAM_NUM_PROCS,              1, 0, 0 },
-		{ PARAM_PROC_ID,                1, 0, 0 },
+		{ "enable-lb",                  0, 0, 0 },
+		{ "dut-pci",                    1, 0, 0 },
 		{ 0, 0, 0, 0 },
 	};
 
 	argvopt = argv;
 
-#ifdef RTE_LIB_CMDLINE
+#ifdef RTE_LIBRTE_CMDLINE
 #define SHORTOPTS "i"
 #else
 #define SHORTOPTS ""
@@ -718,7 +684,7 @@
 	while ((opt = getopt_long(argc, argvopt, SHORTOPTS "ah",
 				 lgopts, &opt_idx)) != EOF) {
 		switch (opt) {
-#ifdef RTE_LIB_CMDLINE
+#ifdef RTE_LIBRTE_CMDLINE
 		case 'i':
 			printf("Interactive-mode selected\n");
 			interactive = 1;
@@ -732,9 +698,9 @@
 		case 0: /*long options */
 			if (!strcmp(lgopts[opt_idx].name, "help")) {
 				usage(argv[0]);
-				exit(EXIT_SUCCESS);
+				rte_exit(EXIT_SUCCESS, "Displayed help\n");
 			}
-#ifdef RTE_LIB_CMDLINE
+#ifdef RTE_LIBRTE_CMDLINE
 			if (!strcmp(lgopts[opt_idx].name, "interactive")) {
 				printf("Interactive-mode selected\n");
 				interactive = 1;
@@ -766,16 +732,6 @@
 				stats_period = n;
 				break;
 			}
-			if (!strcmp(lgopts[opt_idx].name, "display-xstats")) {
-				char rc;
-
-				rc = parse_xstats_list(optarg, &xstats_display,
-						       &xstats_display_num);
-				if (rc != 0)
-					rte_exit(EXIT_FAILURE,
-						 "Failed to parse display-xstats argument: %d\n",
-						 rc);
-			}
 			if (!strcmp(lgopts[opt_idx].name,
 				    "eth-peers-configfile")) {
 				if (init_peer_eth_addrs(optarg) != 0)
@@ -813,13 +769,13 @@
 						 "Invalid tx-ip: %s", optarg);
 
 				*end++ = 0;
-				if (inet_pton(AF_INET, optarg, &in) == 0)
+				if (inet_aton(optarg, &in) == 0)
 					rte_exit(EXIT_FAILURE,
 						 "Invalid source IP address: %s\n",
 						 optarg);
 				tx_ip_src_addr = rte_be_to_cpu_32(in.s_addr);
 
-				if (inet_pton(AF_INET, end, &in) == 0)
+				if (inet_aton(end, &in) == 0)
 					rte_exit(EXIT_FAILURE,
 						 "Invalid destination IP address: %s\n",
 						 optarg);
@@ -873,8 +829,6 @@
 				parse_fwd_coremask(optarg);
 			if (!strcmp(lgopts[opt_idx].name, "portmask"))
 				parse_fwd_portmask(optarg);
-			if (!strcmp(lgopts[opt_idx].name, "portlist"))
-				parse_fwd_portlist(optarg);
 			if (!strcmp(lgopts[opt_idx].name, "no-numa"))
 				numa_support = 0;
 			if (!strcmp(lgopts[opt_idx].name, "numa"))
@@ -891,8 +845,6 @@
 					mp_alloc_type = MP_ALLOC_XMEM;
 				else if (!strcmp(optarg, "xmemhuge"))
 					mp_alloc_type = MP_ALLOC_XMEM_HUGE;
-				else if (!strcmp(optarg, "xbuf"))
-					mp_alloc_type = MP_ALLOC_XBUF;
 				else
 					rte_exit(EXIT_FAILURE,
 						"mp-alloc %s invalid - must be: "
@@ -919,37 +871,29 @@
 				}
 			}
 			if (!strcmp(lgopts[opt_idx].name, "mbuf-size")) {
-				unsigned int mb_sz[MAX_SEGS_BUFFER_SPLIT];
-				unsigned int nb_segs, i;
-
-				nb_segs = parse_item_list(optarg, "mbuf-size",
-					MAX_SEGS_BUFFER_SPLIT, mb_sz, 0);
-				if (nb_segs <= 0)
-					rte_exit(EXIT_FAILURE,
-						 "bad mbuf-size\n");
-				for (i = 0; i < nb_segs; i++) {
-					if (mb_sz[i] <= 0 || mb_sz[i] > 0xFFFF)
-						rte_exit(EXIT_FAILURE,
-							 "mbuf-size should be "
-							 "> 0 and < 65536\n");
-					mbuf_data_size[i] = (uint16_t) mb_sz[i];
-				}
-				mbuf_data_size_n = nb_segs;
+				n = atoi(optarg);
+				if (n > 0 && n <= 0xFFFF)
+					mbuf_data_size = (uint16_t) n;
+				else
+					rte_exit(EXIT_FAILURE,
+						 "mbuf-size should be > 0 and < 65536\n");
 			}
 			if (!strcmp(lgopts[opt_idx].name, "total-num-mbufs")) {
 				n = atoi(optarg);
-				if (n > MIN_TOTAL_NUM_MBUFS)
+				if (n > 1024)
 					param_total_num_mbufs = (unsigned)n;
 				else
 					rte_exit(EXIT_FAILURE,
-						 "total-num-mbufs should be > %d\n",
-						 MIN_TOTAL_NUM_MBUFS);
+						 "total-num-mbufs should be > 1024\n");
 			}
 			if (!strcmp(lgopts[opt_idx].name, "max-pkt-len")) {
 				n = atoi(optarg);
-				if (n >= RTE_ETHER_MIN_LEN)
-					max_rx_pkt_len = n;
-				else
+				if (n >= RTE_ETHER_MIN_LEN) {
+					rx_mode.max_rx_pkt_len = (uint32_t) n;
+					if (n > RTE_ETHER_MAX_LEN)
+						rx_offloads |=
+							DEV_RX_OFFLOAD_JUMBO_FRAME;
+				} else
 					rte_exit(EXIT_FAILURE,
 						 "Invalid max-pkt-len=%d - should be > %d\n",
 						 n, RTE_ETHER_MIN_LEN);
@@ -958,7 +902,68 @@
 				n = atoi(optarg);
 				rx_mode.max_lro_pkt_size = (uint32_t) n;
 			}
-#ifdef RTE_LIB_LATENCYSTATS
+			if (!strcmp(lgopts[opt_idx].name, "pkt-filter-mode")) {
+				if (!strcmp(optarg, "signature"))
+					fdir_conf.mode =
+						RTE_FDIR_MODE_SIGNATURE;
+				else if (!strcmp(optarg, "perfect"))
+					fdir_conf.mode = RTE_FDIR_MODE_PERFECT;
+				else if (!strcmp(optarg, "perfect-mac-vlan"))
+					fdir_conf.mode = RTE_FDIR_MODE_PERFECT_MAC_VLAN;
+				else if (!strcmp(optarg, "perfect-tunnel"))
+					fdir_conf.mode = RTE_FDIR_MODE_PERFECT_TUNNEL;
+				else if (!strcmp(optarg, "none"))
+					fdir_conf.mode = RTE_FDIR_MODE_NONE;
+				else
+					rte_exit(EXIT_FAILURE,
+						 "pkt-mode-invalid %s invalid - must be: "
+						 "none, signature, perfect, perfect-mac-vlan"
+						 " or perfect-tunnel\n",
+						 optarg);
+			}
+			if (!strcmp(lgopts[opt_idx].name,
+				    "pkt-filter-report-hash")) {
+				if (!strcmp(optarg, "none"))
+					fdir_conf.status =
+						RTE_FDIR_NO_REPORT_STATUS;
+				else if (!strcmp(optarg, "match"))
+					fdir_conf.status =
+						RTE_FDIR_REPORT_STATUS;
+				else if (!strcmp(optarg, "always"))
+					fdir_conf.status =
+						RTE_FDIR_REPORT_STATUS_ALWAYS;
+				else
+					rte_exit(EXIT_FAILURE,
+						 "pkt-filter-report-hash %s invalid "
+						 "- must be: none or match or always\n",
+						 optarg);
+			}
+			if (!strcmp(lgopts[opt_idx].name, "pkt-filter-size")) {
+				if (!strcmp(optarg, "64K"))
+					fdir_conf.pballoc =
+						RTE_FDIR_PBALLOC_64K;
+				else if (!strcmp(optarg, "128K"))
+					fdir_conf.pballoc =
+						RTE_FDIR_PBALLOC_128K;
+				else if (!strcmp(optarg, "256K"))
+					fdir_conf.pballoc =
+						RTE_FDIR_PBALLOC_256K;
+				else
+					rte_exit(EXIT_FAILURE, "pkt-filter-size %s invalid -"
+						 " must be: 64K or 128K or 256K\n",
+						 optarg);
+			}
+			if (!strcmp(lgopts[opt_idx].name,
+				    "pkt-filter-drop-queue")) {
+				n = atoi(optarg);
+				if (n >= 0)
+					fdir_conf.drop_queue = (uint8_t) n;
+				else
+					rte_exit(EXIT_FAILURE,
+						 "drop queue %d invalid - must"
+						 "be >= 0 \n", n);
+			}
+#ifdef RTE_LIBRTE_LATENCY_STATS
 			if (!strcmp(lgopts[opt_idx].name,
 				    "latencystats")) {
 				n = atoi(optarg);
@@ -971,7 +976,7 @@
 						 " must be >= 0\n", n);
 			}
 #endif
-#ifdef RTE_LIB_BITRATESTATS
+#ifdef RTE_LIBRTE_BITRATE
 			if (!strcmp(lgopts[opt_idx].name, "bitrate-stats")) {
 				n = atoi(optarg);
 				if (n >= 0) {
@@ -984,34 +989,34 @@
 			}
 #endif
 			if (!strcmp(lgopts[opt_idx].name, "disable-crc-strip"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_KEEP_CRC;
+				rx_offloads |= DEV_RX_OFFLOAD_KEEP_CRC;
 			if (!strcmp(lgopts[opt_idx].name, "enable-lro"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_TCP_LRO;
+				rx_offloads |= DEV_RX_OFFLOAD_TCP_LRO;
 			if (!strcmp(lgopts[opt_idx].name, "enable-scatter"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_SCATTER;
+				rx_offloads |= DEV_RX_OFFLOAD_SCATTER;
 			if (!strcmp(lgopts[opt_idx].name, "enable-rx-cksum"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_CHECKSUM;
+				rx_offloads |= DEV_RX_OFFLOAD_CHECKSUM;
 			if (!strcmp(lgopts[opt_idx].name,
 					"enable-rx-timestamp"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_TIMESTAMP;
+				rx_offloads |= DEV_RX_OFFLOAD_TIMESTAMP;
 			if (!strcmp(lgopts[opt_idx].name, "enable-hw-vlan"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_VLAN;
+				rx_offloads |= DEV_RX_OFFLOAD_VLAN;
 
 			if (!strcmp(lgopts[opt_idx].name,
 					"enable-hw-vlan-filter"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_VLAN_FILTER;
+				rx_offloads |= DEV_RX_OFFLOAD_VLAN_FILTER;
 
 			if (!strcmp(lgopts[opt_idx].name,
 					"enable-hw-vlan-strip"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_VLAN_STRIP;
+				rx_offloads |= DEV_RX_OFFLOAD_VLAN_STRIP;
 
 			if (!strcmp(lgopts[opt_idx].name,
 					"enable-hw-vlan-extend"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_VLAN_EXTEND;
+				rx_offloads |= DEV_RX_OFFLOAD_VLAN_EXTEND;
 
 			if (!strcmp(lgopts[opt_idx].name,
 					"enable-hw-qinq-strip"))
-				rx_offloads |= RTE_ETH_RX_OFFLOAD_QINQ_STRIP;
+				rx_offloads |= DEV_RX_OFFLOAD_QINQ_STRIP;
 
 			if (!strcmp(lgopts[opt_idx].name, "enable-drop-en"))
 				rx_drop_en = 1;
@@ -1033,13 +1038,9 @@
 			if (!strcmp(lgopts[opt_idx].name, "forward-mode"))
 				set_pkt_forwarding_mode(optarg);
 			if (!strcmp(lgopts[opt_idx].name, "rss-ip"))
-				rss_hf = RTE_ETH_RSS_IP;
+				rss_hf = ETH_RSS_IP;
 			if (!strcmp(lgopts[opt_idx].name, "rss-udp"))
-				rss_hf = RTE_ETH_RSS_UDP;
-			if (!strcmp(lgopts[opt_idx].name, "rss-level-inner"))
-				rss_hf |= RTE_ETH_RSS_LEVEL_INNERMOST;
-			if (!strcmp(lgopts[opt_idx].name, "rss-level-outer"))
-				rss_hf |= RTE_ETH_RSS_LEVEL_OUTERMOST;
+				rss_hf = ETH_RSS_UDP;
 			if (!strcmp(lgopts[opt_idx].name, "rxq")) {
 				n = atoi(optarg);
 				if (n >= 0 && check_nb_rxq((queueid_t)n) == 0)
@@ -1087,17 +1088,6 @@
 				rte_exit(EXIT_FAILURE, "Either rx or tx queues should "
 						"be non-zero\n");
 			}
-			if (!strcmp(lgopts[opt_idx].name, "hairpin-mode")) {
-				char *end = NULL;
-				unsigned int n;
-
-				errno = 0;
-				n = strtoul(optarg, &end, 0);
-				if (errno != 0 || end == optarg)
-					rte_exit(EXIT_FAILURE, "hairpin mode invalid\n");
-				else
-					hairpin_mode = (uint32_t)n;
-			}
 			if (!strcmp(lgopts[opt_idx].name, "burst")) {
 				n = atoi(optarg);
 				if (n == 0) {
@@ -1138,22 +1128,6 @@
 				else
 					nb_pkt_per_burst = (uint16_t) n;
 			}
-			if (!strcmp(lgopts[opt_idx].name, "flowgen-clones")) {
-				n = atoi(optarg);
-				if (n >= 0)
-					nb_pkt_flowgen_clones = (uint16_t) n;
-				else
-					rte_exit(EXIT_FAILURE,
-						 "clones must be >= 0 and <= current burst\n");
-			}
-			if (!strcmp(lgopts[opt_idx].name, "flowgen-flows")) {
-				n = atoi(optarg);
-				if (n > 0)
-					nb_flows_flowgen = (int) n;
-				else
-					rte_exit(EXIT_FAILURE,
-						 "flows must be >= 1\n");
-			}
 			if (!strcmp(lgopts[opt_idx].name, "mbcache")) {
 				n = atoi(optarg);
 				if ((n >= 0) &&
@@ -1249,43 +1223,17 @@
 				else
 					rte_exit(EXIT_FAILURE, "rxfreet must be >= 0\n");
 			}
-			if (!strcmp(lgopts[opt_idx].name, "rxoffs")) {
-				unsigned int seg_off[MAX_SEGS_BUFFER_SPLIT];
-				unsigned int nb_offs;
-
-				nb_offs = parse_item_list
-						(optarg, "rxpkt offsets",
-						 MAX_SEGS_BUFFER_SPLIT,
-						 seg_off, 0);
-				if (nb_offs > 0)
-					set_rx_pkt_offsets(seg_off, nb_offs);
-				else
-					rte_exit(EXIT_FAILURE, "bad rxoffs\n");
-			}
-			if (!strcmp(lgopts[opt_idx].name, "rxpkts")) {
-				unsigned int seg_len[MAX_SEGS_BUFFER_SPLIT];
-				unsigned int nb_segs;
-				nb_segs = parse_item_list
-						(optarg, "rxpkt segments",
-						 MAX_SEGS_BUFFER_SPLIT,
-						 seg_len, 0);
-				if (nb_segs > 0)
-					set_rx_pkt_segments(seg_len, nb_segs);
-				else
-					rte_exit(EXIT_FAILURE, "bad rxpkts\n");
+			if (!strcmp(lgopts[opt_idx].name, "tx-queue-stats-mapping")) {
+				if (parse_queue_stats_mapping_config(optarg, TX)) {
+					rte_exit(EXIT_FAILURE,
+						 "invalid TX queue statistics mapping config entered\n");
+				}
 			}
-			if (!strcmp(lgopts[opt_idx].name, "rxhdrs")) {
-				unsigned int seg_hdrs[MAX_SEGS_BUFFER_SPLIT];
-				unsigned int nb_segs;
-
-				nb_segs = parse_hdrs_list
-						(optarg, "rxpkt segments",
-						MAX_SEGS_BUFFER_SPLIT,
-						seg_hdrs);
-				if (nb_segs > 0)
-					set_rx_pkt_hdrs(seg_hdrs, nb_segs);
-				else
-					rte_exit(EXIT_FAILURE, "bad rxpkts\n");
+			if (!strcmp(lgopts[opt_idx].name, "rx-queue-stats-mapping")) {
+				if (parse_queue_stats_mapping_config(optarg, RX)) {
+					rte_exit(EXIT_FAILURE,
+						 "invalid RX queue statistics mapping config entered\n");
+				}
 			}
 			if (!strcmp(lgopts[opt_idx].name, "txpkts")) {
 				unsigned seg_lengths[RTE_MAX_SEGS_PER_PKT];
@@ -1298,28 +1246,10 @@
 				else
 					rte_exit(EXIT_FAILURE, "bad txpkts\n");
 			}
-			if (!strcmp(lgopts[opt_idx].name, "multi-rx-mempool"))
-				multi_rx_mempool = 1;
 			if (!strcmp(lgopts[opt_idx].name, "txonly-multi-flow"))
 				txonly_multi_flow = 1;
-			if (!strcmp(lgopts[opt_idx].name, "rxq-share")) {
-				if (optarg == NULL) {
-					rxq_share = UINT32_MAX;
-				} else {
-					n = atoi(optarg);
-					if (n >= 0)
-						rxq_share = (uint32_t)n;
-					else
-						rte_exit(EXIT_FAILURE, "rxq-share must be >= 0\n");
-				}
-			}
 			if (!strcmp(lgopts[opt_idx].name, "no-flush-rx"))
 				no_flush_rx = 1;
-			if (!strcmp(lgopts[opt_idx].name, "eth-link-speed")) {
-				n = atoi(optarg);
-				if (n >= 0 && parse_link_speed(n) > 0)
-					eth_link_speed = parse_link_speed(n);
-			}
 			if (!strcmp(lgopts[opt_idx].name, "disable-link-check"))
 				no_link_check = 1;
 			if (!strcmp(lgopts[opt_idx].name, "disable-device-start"))
@@ -1358,15 +1288,6 @@
 					rte_exit(EXIT_FAILURE,
 						 "vxlan-gpe-port must be >= 0\n");
 			}
-			if (!strcmp(lgopts[opt_idx].name,
-				    "geneve-parsed-port")) {
-				n = atoi(optarg);
-				if (n >= 0)
-					geneve_udp_port = (uint16_t)n;
-				else
-					rte_exit(EXIT_FAILURE,
-						 "geneve-parsed-port must be >= 0\n");
-			}
 			if (!strcmp(lgopts[opt_idx].name, "print-event"))
 				if (parse_event_printing_config(optarg, 1)) {
 					rte_exit(EXIT_FAILURE,
@@ -1438,34 +1359,22 @@
 						 "noisy-lkup-num-reads-writes must be >= 0\n");
 			}
 			if (!strcmp(lgopts[opt_idx].name, "no-iova-contig"))
-				mempool_flags = RTE_MEMPOOL_F_NO_IOVA_CONTIG;
-
-			if (!strcmp(lgopts[opt_idx].name, "rx-mq-mode")) {
-				char *end = NULL;
-				n = strtoul(optarg, &end, 16);
-				if (n >= 0 && n <= RTE_ETH_MQ_RX_VMDQ_DCB_RSS)
-					rx_mq_mode = (enum rte_eth_rx_mq_mode)n;
-				else
-					rte_exit(EXIT_FAILURE,
-						 "rx-mq-mode must be >= 0 and <= %d\n",
-						 RTE_ETH_MQ_RX_VMDQ_DCB_RSS);
-			}
-			if (!strcmp(lgopts[opt_idx].name, "record-core-cycles"))
-				record_core_cycles = 1;
-			if (!strcmp(lgopts[opt_idx].name, "record-burst-stats"))
-				record_burst_stats = 1;
-			if (!strcmp(lgopts[opt_idx].name, PARAM_NUM_PROCS))
-				num_procs = atoi(optarg);
-			if (!strcmp(lgopts[opt_idx].name, PARAM_PROC_ID))
-				proc_id = atoi(optarg);
+				mempool_flags = MEMPOOL_F_NO_IOVA_CONTIG;
+			if (!strcmp(lgopts[opt_idx].name, "enable-lb"))
+				lb_enabled = 1;
+			if (!strcmp(lgopts[opt_idx].name, "dut-pci")) {
+				nb_lb_dut_pcis++;
+				lb_dut_pcis = realloc(lb_dut_pcis, nb_lb_dut_pcis * sizeof(struct rte_pci_addr));
+				rte_pci_addr_parse(optarg, &lb_dut_pcis[nb_lb_dut_pcis - 1]);
+			}
 			break;
 		case 'h':
 			usage(argv[0]);
-			exit(EXIT_SUCCESS);
+			rte_exit(EXIT_SUCCESS, "Displayed help\n");
 			break;
 		default:
 			usage(argv[0]);
-			fprintf(stderr, "Invalid option: %s\n", argv[optind]);
+			printf("Invalid option: %s\n", argv[optind]);
 			rte_exit(EXIT_FAILURE,
 				 "Command line is incomplete or incorrect\n");
 			break;
@@ -1474,21 +1383,15 @@
 
 	if (optind != argc) {
 		usage(argv[0]);
-		fprintf(stderr, "Invalid parameter: %s\n", argv[optind]);
+		printf("Invalid parameter: %s\n", argv[optind]);
 		rte_exit(EXIT_FAILURE, "Command line is incorrect\n");
 	}
 
-	if (proc_id >= (int)num_procs)
-		rte_exit(EXIT_FAILURE,
-			 "The multi-process option '%s(%d)' should be less than '%s(%u)'\n",
-			 PARAM_PROC_ID, proc_id,
-			 PARAM_NUM_PROCS, num_procs);
-
 	/* Set offload configuration from command line parameters. */
 	rx_mode.offloads = rx_offloads;
 	tx_mode.offloads = tx_offloads;
 
-	if (mempool_flags & RTE_MEMPOOL_F_NO_IOVA_CONTIG &&
+	if (mempool_flags & MEMPOOL_F_NO_IOVA_CONTIG &&
 	    mp_alloc_type != MP_ALLOC_ANON) {
 		TESTPMD_LOG(WARNING, "cannot use no-iova-contig without "
 				  "mp-alloc=anon. mempool no-iova-contig is "
diff -urN dpdk/app/test-pmd/rxonly.c testpmd-as-load-balancer/v19.11/test-pmd/rxonly.c
--- dpdk/app/test-pmd/rxonly.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/rxonly.c	2023-12-15 15:26:37.091199145 +0100
@@ -24,10 +24,12 @@
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_mempool.h>
 #include <rte_mbuf.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_string_fns.h>
@@ -47,37 +49,40 @@
 	struct rte_mbuf  *pkts_burst[MAX_PKT_BURST];
 	uint16_t nb_rx;
 	uint16_t i;
-	uint64_t start_tsc = 0;
 
-	get_start_cycles(&start_tsc);
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+
+	start_tsc = rte_rdtsc();
+#endif
 
 	/*
 	 * Receive a burst of packets.
 	 */
 	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue, pkts_burst,
 				 nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
 	if (unlikely(nb_rx == 0))
 		return;
 
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->rx_burst_stats.pkt_burst_spread[nb_rx]++;
+#endif
 	fs->rx_packets += nb_rx;
 	for (i = 0; i < nb_rx; i++)
 		rte_pktmbuf_free(pkts_burst[i]);
 
-	get_end_cycles(fs, start_tsc);
-}
-
-static void
-stream_init_receive(struct fwd_stream *fs)
-{
-	fs->disabled = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
 }
 
 struct fwd_engine rx_only_engine = {
 	.fwd_mode_name  = "rxonly",
 	.port_fwd_begin = NULL,
 	.port_fwd_end   = NULL,
-	.stream_init    = stream_init_receive,
 	.packet_fwd     = pkt_burst_receive,
 };
diff -urN dpdk/app/test-pmd/shared_rxq_fwd.c testpmd-as-load-balancer/v19.11/test-pmd/shared_rxq_fwd.c
--- dpdk/app/test-pmd/shared_rxq_fwd.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/shared_rxq_fwd.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,123 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright (c) 2021 NVIDIA Corporation & Affiliates
- */
-
-#include <rte_ethdev.h>
-
-#include "testpmd.h"
-
-/*
- * Rx only sub-burst forwarding.
- */
-static void
-forward_rx_only(uint16_t nb_rx, struct rte_mbuf **pkts_burst)
-{
-	rte_pktmbuf_free_bulk(pkts_burst, nb_rx);
-}
-
-/**
- * Get packet source stream by source port and queue.
- * All streams of same shared Rx queue locates on same core.
- */
-static struct fwd_stream *
-forward_stream_get(struct fwd_stream *fs, uint16_t port)
-{
-	streamid_t sm_id;
-	struct fwd_lcore *fc;
-	struct fwd_stream **fsm;
-	streamid_t nb_fs;
-
-	fc = fs->lcore;
-	fsm = &fwd_streams[fc->stream_idx];
-	nb_fs = fc->stream_nb;
-	for (sm_id = 0; sm_id < nb_fs; sm_id++) {
-		if (fsm[sm_id]->rx_port == port &&
-		    fsm[sm_id]->rx_queue == fs->rx_queue)
-			return fsm[sm_id];
-	}
-	return NULL;
-}
-
-/**
- * Forward packet by source port and queue.
- */
-static void
-forward_sub_burst(struct fwd_stream *src_fs, uint16_t port, uint16_t nb_rx,
-		  struct rte_mbuf **pkts)
-{
-	struct fwd_stream *fs = forward_stream_get(src_fs, port);
-
-	if (fs != NULL) {
-		fs->rx_packets += nb_rx;
-		forward_rx_only(nb_rx, pkts);
-	} else {
-		/* Source stream not found, drop all packets. */
-		src_fs->fwd_dropped += nb_rx;
-		while (nb_rx > 0)
-			rte_pktmbuf_free(pkts[--nb_rx]);
-	}
-}
-
-/**
- * Forward packets from shared Rx queue.
- *
- * Source port of packets are identified by mbuf->port.
- */
-static void
-forward_shared_rxq(struct fwd_stream *fs, uint16_t nb_rx,
-		   struct rte_mbuf **pkts_burst)
-{
-	uint16_t i, nb_sub_burst, port, last_port;
-
-	nb_sub_burst = 0;
-	last_port = pkts_burst[0]->port;
-	/* Locate sub-burst according to mbuf->port. */
-	for (i = 0; i < nb_rx - 1; ++i) {
-		rte_prefetch0(pkts_burst[i + 1]);
-		port = pkts_burst[i]->port;
-		if (i > 0 && last_port != port) {
-			/* Forward packets with same source port. */
-			forward_sub_burst(fs, last_port, nb_sub_burst,
-					  &pkts_burst[i - nb_sub_burst]);
-			nb_sub_burst = 0;
-			last_port = port;
-		}
-		nb_sub_burst++;
-	}
-	/* Last sub-burst. */
-	nb_sub_burst++;
-	forward_sub_burst(fs, last_port, nb_sub_burst,
-			  &pkts_burst[nb_rx - nb_sub_burst]);
-}
-
-static void
-shared_rxq_fwd(struct fwd_stream *fs)
-{
-	struct rte_mbuf *pkts_burst[nb_pkt_per_burst];
-	uint16_t nb_rx;
-	uint64_t start_tsc = 0;
-
-	get_start_cycles(&start_tsc);
-	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue, pkts_burst,
-				 nb_pkt_per_burst);
-	inc_rx_burst_stats(fs, nb_rx);
-	if (unlikely(nb_rx == 0))
-		return;
-	forward_shared_rxq(fs, nb_rx, pkts_burst);
-	get_end_cycles(fs, start_tsc);
-}
-
-static void
-shared_rxq_stream_init(struct fwd_stream *fs)
-{
-	fs->disabled = ports[fs->rx_port].rxq[fs->rx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
-}
-
-struct fwd_engine shared_rxq_engine = {
-	.fwd_mode_name  = "shared_rxq",
-	.port_fwd_begin = NULL,
-	.port_fwd_end   = NULL,
-	.stream_init    = shared_rxq_stream_init,
-	.packet_fwd     = shared_rxq_fwd,
-};
diff -urN dpdk/app/test-pmd/softnicfwd.c testpmd-as-load-balancer/v19.11/test-pmd/softnicfwd.c
--- dpdk/app/test-pmd/softnicfwd.c	1970-01-01 01:00:00.000000000 +0100
+++ testpmd-as-load-balancer/v19.11/test-pmd/softnicfwd.c	2023-12-15 15:26:37.091199145 +0100
@@ -0,0 +1,686 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2017 Intel Corporation
+ */
+#include <stdio.h>
+#include <sys/stat.h>
+
+#include <rte_cycles.h>
+#include <rte_mbuf.h>
+#include <rte_malloc.h>
+#include <rte_ethdev.h>
+#include <rte_flow.h>
+#include <rte_meter.h>
+#include <rte_eth_softnic.h>
+#include <rte_tm.h>
+
+#include "testpmd.h"
+
+#define SUBPORT_NODES_PER_PORT		1
+#define PIPE_NODES_PER_SUBPORT		4096
+#define TC_NODES_PER_PIPE			4
+#define QUEUE_NODES_PER_TC			4
+
+#define NUM_PIPE_NODES						\
+	(SUBPORT_NODES_PER_PORT * PIPE_NODES_PER_SUBPORT)
+
+#define NUM_TC_NODES						\
+	(NUM_PIPE_NODES * TC_NODES_PER_PIPE)
+
+#define ROOT_NODE_ID				1000000
+#define SUBPORT_NODES_START_ID		900000
+#define PIPE_NODES_START_ID			800000
+#define TC_NODES_START_ID			700000
+
+#define STATS_MASK_DEFAULT					\
+	(RTE_TM_STATS_N_PKTS |					\
+	RTE_TM_STATS_N_BYTES |					\
+	RTE_TM_STATS_N_PKTS_GREEN_DROPPED |			\
+	RTE_TM_STATS_N_BYTES_GREEN_DROPPED)
+
+#define STATS_MASK_QUEUE					\
+	(STATS_MASK_DEFAULT |					\
+	RTE_TM_STATS_N_PKTS_QUEUED)
+
+#define BYTES_IN_MBPS				(1000 * 1000 / 8)
+#define TOKEN_BUCKET_SIZE			1000000
+
+/* TM Hierarchy Levels */
+enum tm_hierarchy_level {
+	TM_NODE_LEVEL_PORT = 0,
+	TM_NODE_LEVEL_SUBPORT,
+	TM_NODE_LEVEL_PIPE,
+	TM_NODE_LEVEL_TC,
+	TM_NODE_LEVEL_QUEUE,
+	TM_NODE_LEVEL_MAX,
+};
+
+struct tm_hierarchy {
+	/* TM Nodes */
+	uint32_t root_node_id;
+	uint32_t subport_node_id[SUBPORT_NODES_PER_PORT];
+	uint32_t pipe_node_id[SUBPORT_NODES_PER_PORT][PIPE_NODES_PER_SUBPORT];
+	uint32_t tc_node_id[NUM_PIPE_NODES][TC_NODES_PER_PIPE];
+	uint32_t queue_node_id[NUM_TC_NODES][QUEUE_NODES_PER_TC];
+
+	/* TM Hierarchy Nodes Shaper Rates */
+	uint32_t root_node_shaper_rate;
+	uint32_t subport_node_shaper_rate;
+	uint32_t pipe_node_shaper_rate;
+	uint32_t tc_node_shaper_rate;
+	uint32_t tc_node_shared_shaper_rate;
+
+	uint32_t n_shapers;
+};
+
+static struct fwd_lcore *softnic_fwd_lcore;
+static uint16_t softnic_port_id;
+struct fwd_engine softnic_fwd_engine;
+
+/*
+ * Softnic packet forward
+ */
+static void
+softnic_fwd(struct fwd_stream *fs)
+{
+	struct rte_mbuf *pkts_burst[MAX_PKT_BURST];
+	uint16_t nb_rx;
+	uint16_t nb_tx;
+	uint32_t retry;
+
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+#endif
+
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	start_tsc = rte_rdtsc();
+#endif
+
+	/*  Packets Receive */
+	nb_rx = rte_eth_rx_burst(fs->rx_port, fs->rx_queue,
+			pkts_burst, nb_pkt_per_burst);
+	fs->rx_packets += nb_rx;
+
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->rx_burst_stats.pkt_burst_spread[nb_rx]++;
+#endif
+
+	nb_tx = rte_eth_tx_burst(fs->tx_port, fs->tx_queue,
+			pkts_burst, nb_rx);
+
+	/* Retry if necessary */
+	if (unlikely(nb_tx < nb_rx) && fs->retry_enabled) {
+		retry = 0;
+		while (nb_tx < nb_rx && retry++ < burst_tx_retry_num) {
+			rte_delay_us(burst_tx_delay_time);
+			nb_tx += rte_eth_tx_burst(fs->tx_port, fs->tx_queue,
+					&pkts_burst[nb_tx], nb_rx - nb_tx);
+		}
+	}
+	fs->tx_packets += nb_tx;
+
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+#endif
+
+	if (unlikely(nb_tx < nb_rx)) {
+		fs->fwd_dropped += (nb_rx - nb_tx);
+		do {
+			rte_pktmbuf_free(pkts_burst[nb_tx]);
+		} while (++nb_tx < nb_rx);
+	}
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
+}
+
+static void
+softnic_fwd_run(struct fwd_stream *fs)
+{
+	rte_pmd_softnic_run(softnic_port_id);
+	softnic_fwd(fs);
+}
+
+/**
+ * Softnic init
+ */
+static int
+softnic_begin(void *arg __rte_unused)
+{
+	for (;;) {
+		if (!softnic_fwd_lcore->stopped)
+			break;
+	}
+
+	do {
+		/* Run softnic */
+		rte_pmd_softnic_run(softnic_port_id);
+	} while (!softnic_fwd_lcore->stopped);
+
+	return 0;
+}
+
+static int
+set_tm_hiearchy_nodes_shaper_rate(portid_t port_id,
+	struct tm_hierarchy *h)
+{
+	struct rte_eth_link link_params;
+	uint64_t tm_port_rate;
+	int ret;
+
+	memset(&link_params, 0, sizeof(link_params));
+
+	ret = rte_eth_link_get(port_id, &link_params);
+	if (ret < 0) {
+		printf("Error during getting device (port %u) link info: %s\n",
+			port_id, rte_strerror(-ret));
+		return ret;
+	}
+	tm_port_rate = (uint64_t)ETH_SPEED_NUM_10G * BYTES_IN_MBPS;
+
+	/* Set tm hierarchy shapers rate */
+	h->root_node_shaper_rate = tm_port_rate;
+	h->subport_node_shaper_rate =
+		tm_port_rate / SUBPORT_NODES_PER_PORT;
+	h->pipe_node_shaper_rate
+		= h->subport_node_shaper_rate / PIPE_NODES_PER_SUBPORT;
+	h->tc_node_shaper_rate = h->pipe_node_shaper_rate;
+	h->tc_node_shared_shaper_rate = h->subport_node_shaper_rate;
+
+	return 0;
+}
+
+static int
+softport_tm_root_node_add(portid_t port_id, struct tm_hierarchy *h,
+	struct rte_tm_error *error)
+{
+	struct rte_tm_node_params rnp;
+	struct rte_tm_shaper_params rsp;
+	uint32_t priority, weight, level_id, shaper_profile_id;
+
+	memset(&rsp, 0, sizeof(struct rte_tm_shaper_params));
+	memset(&rnp, 0, sizeof(struct rte_tm_node_params));
+
+	/* Shaper profile Parameters */
+	rsp.peak.rate = h->root_node_shaper_rate;
+	rsp.peak.size = TOKEN_BUCKET_SIZE;
+	rsp.pkt_length_adjust = RTE_TM_ETH_FRAMING_OVERHEAD_FCS;
+	shaper_profile_id = 0;
+
+	if (rte_tm_shaper_profile_add(port_id, shaper_profile_id,
+		&rsp, error)) {
+		printf("%s ERROR(%d)-%s!(shaper_id %u)\n ",
+			__func__, error->type, error->message,
+			shaper_profile_id);
+		return -1;
+	}
+
+	/* Root Node Parameters */
+	h->root_node_id = ROOT_NODE_ID;
+	weight = 1;
+	priority = 0;
+	level_id = TM_NODE_LEVEL_PORT;
+	rnp.shaper_profile_id = shaper_profile_id;
+	rnp.nonleaf.n_sp_priorities = 1;
+	rnp.stats_mask = STATS_MASK_DEFAULT;
+
+	/* Add Node to TM Hierarchy */
+	if (rte_tm_node_add(port_id, h->root_node_id, RTE_TM_NODE_ID_NULL,
+		priority, weight, level_id, &rnp, error)) {
+		printf("%s ERROR(%d)-%s!(node_id %u, parent_id %u, level %u)\n",
+			__func__, error->type, error->message,
+			h->root_node_id, RTE_TM_NODE_ID_NULL,
+			level_id);
+		return -1;
+	}
+	/* Update */
+	h->n_shapers++;
+
+	printf("  Root node added (Start id %u, Count %u, level %u)\n",
+		h->root_node_id, 1, level_id);
+
+	return 0;
+}
+
+static int
+softport_tm_subport_node_add(portid_t port_id,
+	struct tm_hierarchy *h,
+	struct rte_tm_error *error)
+{
+	uint32_t subport_parent_node_id, subport_node_id = 0;
+	struct rte_tm_node_params snp;
+	struct rte_tm_shaper_params ssp;
+	uint32_t priority, weight, level_id, shaper_profile_id;
+	uint32_t i;
+
+	memset(&ssp, 0, sizeof(struct rte_tm_shaper_params));
+	memset(&snp, 0, sizeof(struct rte_tm_node_params));
+
+	shaper_profile_id = h->n_shapers;
+
+	/* Add Shaper Profile to TM Hierarchy */
+	for (i = 0; i < SUBPORT_NODES_PER_PORT; i++) {
+		ssp.peak.rate = h->subport_node_shaper_rate;
+		ssp.peak.size = TOKEN_BUCKET_SIZE;
+		ssp.pkt_length_adjust = RTE_TM_ETH_FRAMING_OVERHEAD_FCS;
+
+		if (rte_tm_shaper_profile_add(port_id, shaper_profile_id,
+			&ssp, error)) {
+			printf("%s ERROR(%d)-%s!(shaper_id %u)\n ",
+				__func__, error->type, error->message,
+				shaper_profile_id);
+			return -1;
+		}
+
+		/* Node Parameters */
+		h->subport_node_id[i] = SUBPORT_NODES_START_ID + i;
+		subport_parent_node_id = h->root_node_id;
+		weight = 1;
+		priority = 0;
+		level_id = TM_NODE_LEVEL_SUBPORT;
+		snp.shaper_profile_id = shaper_profile_id;
+		snp.nonleaf.n_sp_priorities = 1;
+		snp.stats_mask = STATS_MASK_DEFAULT;
+
+		/* Add Node to TM Hiearchy */
+		if (rte_tm_node_add(port_id,
+				h->subport_node_id[i],
+				subport_parent_node_id,
+				priority, weight,
+				level_id,
+				&snp,
+				error)) {
+			printf("%s ERROR(%d)-%s!(node %u,parent %u,level %u)\n",
+					__func__,
+					error->type,
+					error->message,
+					h->subport_node_id[i],
+					subport_parent_node_id,
+					level_id);
+			return -1;
+		}
+		shaper_profile_id++;
+		subport_node_id++;
+	}
+	/* Update */
+	h->n_shapers = shaper_profile_id;
+
+	printf("  Subport nodes added (Start id %u, Count %u, level %u)\n",
+		h->subport_node_id[0], SUBPORT_NODES_PER_PORT, level_id);
+
+	return 0;
+}
+
+static int
+softport_tm_pipe_node_add(portid_t port_id,
+	struct tm_hierarchy *h,
+	struct rte_tm_error *error)
+{
+	uint32_t pipe_parent_node_id;
+	struct rte_tm_node_params pnp;
+	struct rte_tm_shaper_params psp;
+	uint32_t priority, weight, level_id, shaper_profile_id;
+	uint32_t i, j;
+
+	memset(&psp, 0, sizeof(struct rte_tm_shaper_params));
+	memset(&pnp, 0, sizeof(struct rte_tm_node_params));
+
+	shaper_profile_id = h->n_shapers;
+
+	/* Shaper Profile Parameters */
+	psp.peak.rate = h->pipe_node_shaper_rate;
+	psp.peak.size = TOKEN_BUCKET_SIZE;
+	psp.pkt_length_adjust = RTE_TM_ETH_FRAMING_OVERHEAD_FCS;
+
+	/* Pipe Node Parameters */
+	weight = 1;
+	priority = 0;
+	level_id = TM_NODE_LEVEL_PIPE;
+	pnp.nonleaf.n_sp_priorities = 4;
+	pnp.stats_mask = STATS_MASK_DEFAULT;
+
+	/* Add Shaper Profiles and Nodes to TM Hierarchy */
+	for (i = 0; i < SUBPORT_NODES_PER_PORT; i++) {
+		for (j = 0; j < PIPE_NODES_PER_SUBPORT; j++) {
+			if (rte_tm_shaper_profile_add(port_id,
+				shaper_profile_id, &psp, error)) {
+				printf("%s ERROR(%d)-%s!(shaper_id %u)\n ",
+					__func__, error->type, error->message,
+					shaper_profile_id);
+				return -1;
+			}
+			pnp.shaper_profile_id = shaper_profile_id;
+			pipe_parent_node_id = h->subport_node_id[i];
+			h->pipe_node_id[i][j] = PIPE_NODES_START_ID +
+				(i * PIPE_NODES_PER_SUBPORT) + j;
+
+			if (rte_tm_node_add(port_id,
+					h->pipe_node_id[i][j],
+					pipe_parent_node_id,
+					priority, weight, level_id,
+					&pnp,
+					error)) {
+				printf("%s ERROR(%d)-%s!(node %u,parent %u )\n",
+					__func__,
+					error->type,
+					error->message,
+					h->pipe_node_id[i][j],
+					pipe_parent_node_id);
+
+				return -1;
+			}
+			shaper_profile_id++;
+		}
+	}
+	/* Update */
+	h->n_shapers = shaper_profile_id;
+
+	printf("  Pipe nodes added (Start id %u, Count %u, level %u)\n",
+		h->pipe_node_id[0][0], NUM_PIPE_NODES, level_id);
+
+	return 0;
+}
+
+static int
+softport_tm_tc_node_add(portid_t port_id,
+	struct tm_hierarchy *h,
+	struct rte_tm_error *error)
+{
+	uint32_t tc_parent_node_id;
+	struct rte_tm_node_params tnp;
+	struct rte_tm_shaper_params tsp, tssp;
+	uint32_t shared_shaper_profile_id[TC_NODES_PER_PIPE];
+	uint32_t priority, weight, level_id, shaper_profile_id;
+	uint32_t pos, n_tc_nodes, i, j, k;
+
+	memset(&tsp, 0, sizeof(struct rte_tm_shaper_params));
+	memset(&tssp, 0, sizeof(struct rte_tm_shaper_params));
+	memset(&tnp, 0, sizeof(struct rte_tm_node_params));
+
+	shaper_profile_id = h->n_shapers;
+
+	/* Private Shaper Profile (TC) Parameters */
+	tsp.peak.rate = h->tc_node_shaper_rate;
+	tsp.peak.size = TOKEN_BUCKET_SIZE;
+	tsp.pkt_length_adjust = RTE_TM_ETH_FRAMING_OVERHEAD_FCS;
+
+	/* Shared Shaper Profile (TC) Parameters */
+	tssp.peak.rate = h->tc_node_shared_shaper_rate;
+	tssp.peak.size = TOKEN_BUCKET_SIZE;
+	tssp.pkt_length_adjust = RTE_TM_ETH_FRAMING_OVERHEAD_FCS;
+
+	/* TC Node Parameters */
+	weight = 1;
+	level_id = TM_NODE_LEVEL_TC;
+	tnp.n_shared_shapers = 1;
+	tnp.nonleaf.n_sp_priorities = 1;
+	tnp.stats_mask = STATS_MASK_DEFAULT;
+
+	/* Add Shared Shaper Profiles to TM Hierarchy */
+	for (i = 0; i < TC_NODES_PER_PIPE; i++) {
+		shared_shaper_profile_id[i] = shaper_profile_id;
+
+		if (rte_tm_shaper_profile_add(port_id,
+			shared_shaper_profile_id[i], &tssp, error)) {
+			printf("%s ERROR(%d)-%s!(Shared shaper profileid %u)\n",
+				__func__, error->type, error->message,
+				shared_shaper_profile_id[i]);
+
+			return -1;
+		}
+		if (rte_tm_shared_shaper_add_update(port_id,  i,
+			shared_shaper_profile_id[i], error)) {
+			printf("%s ERROR(%d)-%s!(Shared shaper id %u)\n",
+				__func__, error->type, error->message, i);
+
+			return -1;
+		}
+		shaper_profile_id++;
+	}
+
+	/* Add Shaper Profiles and Nodes to TM Hierarchy */
+	n_tc_nodes = 0;
+	for (i = 0; i < SUBPORT_NODES_PER_PORT; i++) {
+		for (j = 0; j < PIPE_NODES_PER_SUBPORT; j++) {
+			for (k = 0; k < TC_NODES_PER_PIPE ; k++) {
+				priority = k;
+				tc_parent_node_id = h->pipe_node_id[i][j];
+				tnp.shared_shaper_id =
+					(uint32_t *)calloc(1, sizeof(uint32_t));
+				if (tnp.shared_shaper_id == NULL) {
+					printf("Shared shaper mem alloc err\n");
+					return -1;
+				}
+				tnp.shared_shaper_id[0] = k;
+				pos = j + (i * PIPE_NODES_PER_SUBPORT);
+				h->tc_node_id[pos][k] =
+					TC_NODES_START_ID + n_tc_nodes;
+
+				if (rte_tm_shaper_profile_add(port_id,
+					shaper_profile_id, &tsp, error)) {
+					printf("%s ERROR(%d)-%s!(shaper %u)\n",
+						__func__, error->type,
+						error->message,
+						shaper_profile_id);
+
+					free(tnp.shared_shaper_id);
+					return -1;
+				}
+				tnp.shaper_profile_id = shaper_profile_id;
+				if (rte_tm_node_add(port_id,
+						h->tc_node_id[pos][k],
+						tc_parent_node_id,
+						priority, weight,
+						level_id,
+						&tnp, error)) {
+					printf("%s ERROR(%d)-%s!(node id %u)\n",
+						__func__,
+						error->type,
+						error->message,
+						h->tc_node_id[pos][k]);
+
+					free(tnp.shared_shaper_id);
+					return -1;
+				}
+				shaper_profile_id++;
+				n_tc_nodes++;
+			}
+		}
+	}
+	/* Update */
+	h->n_shapers = shaper_profile_id;
+
+	printf("  TC nodes added (Start id %u, Count %u, level %u)\n",
+		h->tc_node_id[0][0], n_tc_nodes, level_id);
+
+	return 0;
+}
+
+static int
+softport_tm_queue_node_add(portid_t port_id, struct tm_hierarchy *h,
+	struct rte_tm_error *error)
+{
+	uint32_t queue_parent_node_id;
+	struct rte_tm_node_params qnp;
+	uint32_t priority, weight, level_id, pos;
+	uint32_t n_queue_nodes, i, j, k;
+
+	memset(&qnp, 0, sizeof(struct rte_tm_node_params));
+
+	/* Queue Node Parameters */
+	priority = 0;
+	weight = 1;
+	level_id = TM_NODE_LEVEL_QUEUE;
+	qnp.shaper_profile_id = RTE_TM_SHAPER_PROFILE_ID_NONE;
+	qnp.leaf.cman = RTE_TM_CMAN_TAIL_DROP;
+	qnp.stats_mask = STATS_MASK_QUEUE;
+
+	/* Add Queue Nodes to TM Hierarchy */
+	n_queue_nodes = 0;
+	for (i = 0; i < NUM_PIPE_NODES; i++) {
+		for (j = 0; j < TC_NODES_PER_PIPE; j++) {
+			queue_parent_node_id = h->tc_node_id[i][j];
+			for (k = 0; k < QUEUE_NODES_PER_TC; k++) {
+				pos = j + (i * TC_NODES_PER_PIPE);
+				h->queue_node_id[pos][k] = n_queue_nodes;
+				if (rte_tm_node_add(port_id,
+						h->queue_node_id[pos][k],
+						queue_parent_node_id,
+						priority,
+						weight,
+						level_id,
+						&qnp, error)) {
+					printf("%s ERROR(%d)-%s!(node %u)\n",
+						__func__,
+						error->type,
+						error->message,
+						h->queue_node_id[pos][k]);
+
+					return -1;
+				}
+				n_queue_nodes++;
+			}
+		}
+	}
+	printf("  Queue nodes added (Start id %u, Count %u, level %u)\n",
+		h->queue_node_id[0][0], n_queue_nodes, level_id);
+
+	return 0;
+}
+
+static int
+softport_tm_hierarchy_specify(portid_t port_id,
+	struct rte_tm_error *error)
+{
+
+	struct tm_hierarchy h;
+	int status;
+
+	memset(&h, 0, sizeof(struct tm_hierarchy));
+
+	/* TM hierarchy shapers rate */
+	status = set_tm_hiearchy_nodes_shaper_rate(port_id, &h);
+	if (status)
+		return status;
+
+	/* Add root node (level 0) */
+	status = softport_tm_root_node_add(port_id, &h, error);
+	if (status)
+		return status;
+
+	/* Add subport node (level 1) */
+	status = softport_tm_subport_node_add(port_id, &h, error);
+	if (status)
+		return status;
+
+	/* Add pipe nodes (level 2) */
+	status = softport_tm_pipe_node_add(port_id, &h, error);
+	if (status)
+		return status;
+
+	/* Add traffic class nodes (level 3) */
+	status = softport_tm_tc_node_add(port_id, &h, error);
+	if (status)
+		return status;
+
+	/* Add queue nodes (level 4) */
+	status = softport_tm_queue_node_add(port_id, &h, error);
+	if (status)
+		return status;
+
+	return 0;
+}
+
+/*
+ * Softnic TM default configuration
+ */
+static void
+softnic_tm_default_config(portid_t pi)
+{
+	struct rte_port *port = &ports[pi];
+	struct rte_tm_error error;
+	int status;
+
+	/* Stop port */
+	rte_eth_dev_stop(pi);
+
+	/* TM hierarchy specification */
+	status = softport_tm_hierarchy_specify(pi, &error);
+	if (status) {
+		printf("  TM Hierarchy built error(%d) - %s\n",
+			error.type, error.message);
+		return;
+	}
+	printf("\n  TM Hierarchy Specified!\n");
+
+	/* TM hierarchy commit */
+	status = rte_tm_hierarchy_commit(pi, 0, &error);
+	if (status) {
+		printf("  Hierarchy commit error(%d) - %s\n",
+			error.type, error.message);
+		return;
+	}
+	printf("  Hierarchy Committed (port %u)!\n", pi);
+
+	/* Start port */
+	status = rte_eth_dev_start(pi);
+	if (status) {
+		printf("\n  Port %u start error!\n", pi);
+		return;
+	}
+
+	/* Reset the default hierarchy flag */
+	port->softport.default_tm_hierarchy_enable = 0;
+}
+
+/*
+ * Softnic forwarding init
+ */
+static void
+softnic_fwd_begin(portid_t pi)
+{
+	struct rte_port *port = &ports[pi];
+	uint32_t lcore, fwd_core_present = 0, softnic_run_launch = 0;
+	int	status;
+
+	softnic_fwd_lcore = port->softport.fwd_lcore_arg[0];
+	softnic_port_id = pi;
+
+	/* Launch softnic_run function on lcores */
+	for (lcore = 0; lcore < RTE_MAX_LCORE; lcore++) {
+		if (!rte_lcore_is_enabled(lcore))
+			continue;
+
+		if (lcore == rte_get_master_lcore())
+			continue;
+
+		if (fwd_core_present == 0) {
+			fwd_core_present++;
+			continue;
+		}
+
+		status = rte_eal_remote_launch(softnic_begin, NULL, lcore);
+		if (status)
+			printf("softnic launch on lcore %u failed (%d)\n",
+				       lcore, status);
+
+		softnic_run_launch = 1;
+	}
+
+	if (!softnic_run_launch)
+		softnic_fwd_engine.packet_fwd = softnic_fwd_run;
+
+	/* Softnic TM default configuration */
+	if (port->softport.default_tm_hierarchy_enable == 1)
+		softnic_tm_default_config(pi);
+}
+
+struct fwd_engine softnic_fwd_engine = {
+	.fwd_mode_name  = "softnic",
+	.port_fwd_begin = softnic_fwd_begin,
+	.port_fwd_end   = NULL,
+	.packet_fwd     = softnic_fwd,
+};
diff -urN dpdk/app/test-pmd/testpmd.c testpmd-as-load-balancer/v19.11/test-pmd/testpmd.c
--- dpdk/app/test-pmd/testpmd.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/testpmd.c	2023-12-15 15:26:37.091199145 +0100
@@ -9,10 +9,7 @@
 #include <string.h>
 #include <time.h>
 #include <fcntl.h>
-#ifndef RTE_EXEC_ENV_WINDOWS
 #include <sys/mman.h>
-#include <sys/select.h>
-#endif
 #include <sys/types.h>
 #include <errno.h>
 #include <stdbool.h>
@@ -33,46 +30,36 @@
 #include <rte_memory.h>
 #include <rte_memcpy.h>
 #include <rte_launch.h>
-#include <rte_bus.h>
 #include <rte_eal.h>
 #include <rte_alarm.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_mempool.h>
 #include <rte_malloc.h>
 #include <rte_mbuf.h>
 #include <rte_mbuf_pool_ops.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_dev.h>
 #include <rte_string_fns.h>
-#ifdef RTE_NET_IXGBE
+#ifdef RTE_LIBRTE_IXGBE_PMD
 #include <rte_pmd_ixgbe.h>
 #endif
-#ifdef RTE_LIB_PDUMP
+#ifdef RTE_LIBRTE_PDUMP
 #include <rte_pdump.h>
 #endif
 #include <rte_flow.h>
-#ifdef RTE_LIB_METRICS
 #include <rte_metrics.h>
-#endif
-#ifdef RTE_LIB_BITRATESTATS
+#ifdef RTE_LIBRTE_BITRATE
 #include <rte_bitrate.h>
 #endif
-#ifdef RTE_LIB_LATENCYSTATS
+#ifdef RTE_LIBRTE_LATENCY_STATS
 #include <rte_latencystats.h>
 #endif
-#ifdef RTE_EXEC_ENV_WINDOWS
-#include <process.h>
-#endif
-#ifdef RTE_NET_BOND
-#include <rte_eth_bond.h>
-#endif
-#ifdef RTE_NET_MLX5
-#include "mlx5_testpmd.h"
-#endif
 
 #include "testpmd.h"
 
@@ -91,18 +78,11 @@
 #endif
 
 #define EXTMEM_HEAP_NAME "extmem"
-/*
- * Zone size with the malloc overhead (max of debug and release variants)
- * must fit into the smallest supported hugepage size (2M),
- * so that an IOVA-contiguous zone of this size can always be allocated
- * if there are free 2M hugepages.
- */
-#define EXTBUF_ZONE_SIZE (RTE_PGSIZE_2M - 4 * RTE_CACHE_LINE_SIZE)
 
 uint16_t verbose_level = 0; /**< Silent by default. */
 int testpmd_logtype; /**< Log type for testpmd logs */
 
-/* use main core for command line ? */
+/* use master core for command line ? */
 uint8_t interactive = 0;
 uint8_t auto_start = 0;
 uint8_t tx_first;
@@ -198,15 +178,17 @@
 	&csum_fwd_engine,
 	&icmp_echo_engine,
 	&noisy_vnf_engine,
-	&five_tuple_swap_fwd_engine,
+#if defined RTE_LIBRTE_PMD_SOFTNIC
+	&softnic_fwd_engine,
+#endif
 #ifdef RTE_LIBRTE_IEEE1588
 	&ieee1588_fwd_engine,
 #endif
-	&shared_rxq_engine,
+	&lb_fwd_engine,
 	NULL,
 };
 
-struct rte_mempool *mempools[RTE_MAX_NUMA_NODES * MAX_SEGS_BUFFER_SPLIT];
+struct rte_mempool *mempools[RTE_MAX_NUMA_NODES];
 uint16_t mempool_flags;
 
 struct fwd_config cur_fwd_config;
@@ -215,42 +197,16 @@
 uint32_t burst_tx_delay_time = BURST_TX_WAIT_US;
 uint32_t burst_tx_retry_num = BURST_TX_RETRIES;
 
-uint32_t mbuf_data_size_n = 1; /* Number of specified mbuf sizes. */
-uint16_t mbuf_data_size[MAX_SEGS_BUFFER_SPLIT] = {
-	DEFAULT_MBUF_DATA_SIZE
-}; /**< Mbuf data space size. */
+uint16_t mbuf_data_size = DEFAULT_MBUF_DATA_SIZE; /**< Mbuf data space size. */
 uint32_t param_total_num_mbufs = 0;  /**< number of mbufs in all pools - if
                                       * specified on command-line. */
 uint16_t stats_period; /**< Period to show statistics (disabled by default) */
 
-/** Extended statistics to show. */
-struct rte_eth_xstat_name *xstats_display;
-
-unsigned int xstats_display_num; /**< Size of extended statistics to show */
-
 /*
  * In container, it cannot terminate the process which running with 'stats-period'
  * option. Set flag to exit stats period loop after received SIGINT/SIGTERM.
  */
-volatile uint8_t f_quit;
-uint8_t cl_quit; /* Quit testpmd from cmdline. */
-
-/*
- * Max Rx frame size, set by '--max-pkt-len' parameter.
- */
-uint32_t max_rx_pkt_len;
-
-/*
- * Configuration of packet segments used to scatter received packets
- * if some of split features is configured.
- */
-uint16_t rx_pkt_seg_lengths[MAX_SEGS_BUFFER_SPLIT];
-uint8_t  rx_pkt_nb_segs; /**< Number of segments to split */
-uint16_t rx_pkt_seg_offsets[MAX_SEGS_BUFFER_SPLIT];
-uint8_t  rx_pkt_nb_offs; /**< Number of specified offsets */
-uint32_t rx_pkt_hdr_protos[MAX_SEGS_BUFFER_SPLIT];
-
-uint8_t multi_rx_mempool; /**< Enables multi-rx-mempool feature */
+uint8_t f_quit;
 
 /*
  * Configuration of packet segments used by the "txonly" processing engine.
@@ -267,20 +223,15 @@
 uint8_t txonly_multi_flow;
 /**< Whether multiple flows are generated in TXONLY mode. */
 
-uint32_t tx_pkt_times_inter;
-/**< Timings for send scheduling in TXONLY mode, time between bursts. */
-
-uint32_t tx_pkt_times_intra;
-/**< Timings for send scheduling in TXONLY mode, time between packets. */
-
 uint16_t nb_pkt_per_burst = DEF_PKT_BURST; /**< Number of packets per burst. */
-uint16_t nb_pkt_flowgen_clones; /**< Number of Tx packet clones to send in flowgen mode. */
-int nb_flows_flowgen = 1024; /**< Number of flows in flowgen mode. */
 uint16_t mb_mempool_cache = DEF_MBUF_CACHE; /**< Size of mbuf mempool cache. */
 
 /* current configuration is in DCB or not,0 means it is not in DCB mode */
 uint8_t dcb_config = 0;
 
+/* Whether the dcb is in testing status */
+uint8_t dcb_test = 0;
+
 /*
  * Configurable number of RX/TX queues.
  */
@@ -292,10 +243,10 @@
  * Configurable number of RX/TX ring descriptors.
  * Defaults are supplied by drivers via ethdev.
  */
-#define RX_DESC_DEFAULT 0
-#define TX_DESC_DEFAULT 0
-uint16_t nb_rxd = RX_DESC_DEFAULT; /**< Number of RX descriptors. */
-uint16_t nb_txd = TX_DESC_DEFAULT; /**< Number of TX descriptors. */
+#define RTE_TEST_RX_DESC_DEFAULT 0
+#define RTE_TEST_TX_DESC_DEFAULT 0
+uint16_t nb_rxd = RTE_TEST_RX_DESC_DEFAULT; /**< Number of RX descriptors. */
+uint16_t nb_txd = RTE_TEST_TX_DESC_DEFAULT; /**< Number of TX descriptors. */
 
 #define RTE_PMD_PARAM_UNSET -1
 /*
@@ -367,7 +318,7 @@
 /*
  * Receive Side Scaling (RSS) configuration.
  */
-uint64_t rss_hf = RTE_ETH_RSS_IP; /* RSS IP by default. */
+uint64_t rss_hf = ETH_RSS_IP; /* RSS IP by default. */
 
 /*
  * Port topology configuration
@@ -412,9 +363,6 @@
 /* Clear ptypes on port initialization. */
 uint8_t clear_ptypes = true;
 
-/* Hairpin ports configuration mode. */
-uint32_t hairpin_mode;
-
 /* Pretty printing of ethdev events */
 static const char * const eth_event_desc[] = {
 	[RTE_ETH_EVENT_UNKNOWN] = "unknown",
@@ -427,11 +375,6 @@
 	[RTE_ETH_EVENT_INTR_RMV] = "device removal",
 	[RTE_ETH_EVENT_NEW] = "device probed",
 	[RTE_ETH_EVENT_DESTROY] = "device released",
-	[RTE_ETH_EVENT_FLOW_AGED] = "flow aged",
-	[RTE_ETH_EVENT_RX_AVAIL_THRESH] = "RxQ available descriptors threshold reached",
-	[RTE_ETH_EVENT_ERR_RECOVERING] = "error recovering",
-	[RTE_ETH_EVENT_RECOVERY_SUCCESS] = "error recovery successful",
-	[RTE_ETH_EVENT_RECOVERY_FAILED] = "error recovery failed",
 	[RTE_ETH_EVENT_MAX] = NULL,
 };
 
@@ -445,17 +388,23 @@
 			    (UINT32_C(1) << RTE_ETH_EVENT_INTR_RESET) |
 			    (UINT32_C(1) << RTE_ETH_EVENT_IPSEC) |
 			    (UINT32_C(1) << RTE_ETH_EVENT_MACSEC) |
-			    (UINT32_C(1) << RTE_ETH_EVENT_INTR_RMV) |
-			    (UINT32_C(1) << RTE_ETH_EVENT_FLOW_AGED) |
-			    (UINT32_C(1) << RTE_ETH_EVENT_ERR_RECOVERING) |
-			    (UINT32_C(1) << RTE_ETH_EVENT_RECOVERY_SUCCESS) |
-			    (UINT32_C(1) << RTE_ETH_EVENT_RECOVERY_FAILED);
+			    (UINT32_C(1) << RTE_ETH_EVENT_INTR_RMV);
 /*
  * Decide if all memory are locked for performance.
  */
 int do_mlockall = 0;
 
-#ifdef RTE_LIB_LATENCYSTATS
+/*
+ * NIC bypass mode configuration options.
+ */
+
+#if defined RTE_LIBRTE_IXGBE_PMD && defined RTE_LIBRTE_IXGBE_BYPASS
+/* The NIC bypass watchdog timeout. */
+uint32_t bypass_timeout = RTE_PMD_IXGBE_BYPASS_TMT_OFF;
+#endif
+
+
+#ifdef RTE_LIBRTE_LATENCY_STATS
 
 /*
  * Set when latency stats is enabled in the commandline
@@ -463,223 +412,87 @@
 uint8_t latencystats_enabled;
 
 /*
- * Lcore ID to service latency statistics.
+ * Lcore ID to serive latency statistics.
  */
 lcoreid_t latencystats_lcore_id = -1;
 
 #endif
 
 /*
+ * TestPMD as Load Balancer is enabled in the commandline
+ */
+uint8_t lb_enabled;
+struct rte_pci_addr * lb_dut_pcis;
+uint32_t nb_lb_dut_pcis;
+
+/*
  * Ethernet device configuration.
  */
-struct rte_eth_rxmode rx_mode;
+struct rte_eth_rxmode rx_mode = {
+	.max_rx_pkt_len = RTE_ETHER_MAX_LEN,
+		/**< Default maximum frame length. */
+};
 
 struct rte_eth_txmode tx_mode = {
-	.offloads = RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE,
+	.offloads = DEV_TX_OFFLOAD_MBUF_FAST_FREE,
+};
+
+struct rte_fdir_conf fdir_conf = {
+	.mode = RTE_FDIR_MODE_NONE,
+	.pballoc = RTE_FDIR_PBALLOC_64K,
+	.status = RTE_FDIR_REPORT_STATUS,
+	.mask = {
+		.vlan_tci_mask = 0xFFEF,
+		.ipv4_mask     = {
+			.src_ip = 0xFFFFFFFF,
+			.dst_ip = 0xFFFFFFFF,
+		},
+		.ipv6_mask     = {
+			.src_ip = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},
+			.dst_ip = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},
+		},
+		.src_port_mask = 0xFFFF,
+		.dst_port_mask = 0xFFFF,
+		.mac_addr_byte_mask = 0xFF,
+		.tunnel_type_mask = 1,
+		.tunnel_id_mask = 0xFFFFFFFF,
+	},
+	.drop_queue = 127,
 };
 
 volatile int test_done = 1; /* stop packet forwarding when set to 1. */
 
-/*
- * Display zero values by default for xstats
- */
-uint8_t xstats_hide_zero;
+struct queue_stats_mappings tx_queue_stats_mappings_array[MAX_TX_QUEUE_STATS_MAPPINGS];
+struct queue_stats_mappings rx_queue_stats_mappings_array[MAX_RX_QUEUE_STATS_MAPPINGS];
 
-/*
- * Measure of CPU cycles disabled by default
- */
-uint8_t record_core_cycles;
+struct queue_stats_mappings *tx_queue_stats_mappings = tx_queue_stats_mappings_array;
+struct queue_stats_mappings *rx_queue_stats_mappings = rx_queue_stats_mappings_array;
 
-/*
- * Display of RX and TX bursts disabled by default
- */
-uint8_t record_burst_stats;
+uint16_t nb_tx_queue_stats_mappings = 0;
+uint16_t nb_rx_queue_stats_mappings = 0;
 
 /*
- * Number of ports per shared Rx queue group, 0 disable.
+ * Display zero values by default for xstats
  */
-uint32_t rxq_share;
+uint8_t xstats_hide_zero;
 
 unsigned int num_sockets = 0;
 unsigned int socket_ids[RTE_MAX_NUMA_NODES];
 
-#ifdef RTE_LIB_BITRATESTATS
+#ifdef RTE_LIBRTE_BITRATE
 /* Bitrate statistics */
 struct rte_stats_bitrates *bitrate_data;
 lcoreid_t bitrate_lcore_id;
 uint8_t bitrate_enabled;
 #endif
 
-#ifdef RTE_LIB_GRO
 struct gro_status gro_ports[RTE_MAX_ETHPORTS];
 uint8_t gro_flush_cycles = GRO_DEFAULT_FLUSH_CYCLES;
-#endif
-
-/*
- * hexadecimal bitmask of RX mq mode can be enabled.
- */
-enum rte_eth_rx_mq_mode rx_mq_mode = RTE_ETH_MQ_RX_VMDQ_DCB_RSS;
-
-/*
- * Used to set forced link speed
- */
-uint32_t eth_link_speed;
-
-/*
- * ID of the current process in multi-process, used to
- * configure the queues to be polled.
- */
-int proc_id;
-
-/*
- * Number of processes in multi-process, used to
- * configure the queues to be polled.
- */
-unsigned int num_procs = 1;
-
-static void
-eth_rx_metadata_negotiate_mp(uint16_t port_id)
-{
-	uint64_t rx_meta_features = 0;
-	int ret;
-
-	if (!is_proc_primary())
-		return;
-
-	rx_meta_features |= RTE_ETH_RX_METADATA_USER_FLAG;
-	rx_meta_features |= RTE_ETH_RX_METADATA_USER_MARK;
-	rx_meta_features |= RTE_ETH_RX_METADATA_TUNNEL_ID;
-
-	ret = rte_eth_rx_metadata_negotiate(port_id, &rx_meta_features);
-	if (ret == 0) {
-		if (!(rx_meta_features & RTE_ETH_RX_METADATA_USER_FLAG)) {
-			TESTPMD_LOG(DEBUG, "Flow action FLAG will not affect Rx mbufs on port %u\n",
-				    port_id);
-		}
-
-		if (!(rx_meta_features & RTE_ETH_RX_METADATA_USER_MARK)) {
-			TESTPMD_LOG(DEBUG, "Flow action MARK will not affect Rx mbufs on port %u\n",
-				    port_id);
-		}
-
-		if (!(rx_meta_features & RTE_ETH_RX_METADATA_TUNNEL_ID)) {
-			TESTPMD_LOG(DEBUG, "Flow tunnel offload support might be limited or unavailable on port %u\n",
-				    port_id);
-		}
-	} else if (ret != -ENOTSUP) {
-		rte_exit(EXIT_FAILURE, "Error when negotiating Rx meta features on port %u: %s\n",
-			 port_id, rte_strerror(-ret));
-	}
-}
-
-static int
-eth_dev_configure_mp(uint16_t port_id, uint16_t nb_rx_q, uint16_t nb_tx_q,
-		      const struct rte_eth_conf *dev_conf)
-{
-	if (is_proc_primary())
-		return rte_eth_dev_configure(port_id, nb_rx_q, nb_tx_q,
-					dev_conf);
-	return 0;
-}
-
-static int
-change_bonding_slave_port_status(portid_t bond_pid, bool is_stop)
-{
-#ifdef RTE_NET_BOND
-
-	portid_t slave_pids[RTE_MAX_ETHPORTS];
-	struct rte_port *port;
-	int num_slaves;
-	portid_t slave_pid;
-	int i;
-
-	num_slaves = rte_eth_bond_slaves_get(bond_pid, slave_pids,
-						RTE_MAX_ETHPORTS);
-	if (num_slaves < 0) {
-		fprintf(stderr, "Failed to get slave list for port = %u\n",
-			bond_pid);
-		return num_slaves;
-	}
-
-	for (i = 0; i < num_slaves; i++) {
-		slave_pid = slave_pids[i];
-		port = &ports[slave_pid];
-		port->port_status =
-			is_stop ? RTE_PORT_STOPPED : RTE_PORT_STARTED;
-	}
-#else
-	RTE_SET_USED(bond_pid);
-	RTE_SET_USED(is_stop);
-#endif
-	return 0;
-}
-
-static int
-eth_dev_start_mp(uint16_t port_id)
-{
-	int ret;
-
-	if (is_proc_primary()) {
-		ret = rte_eth_dev_start(port_id);
-		if (ret != 0)
-			return ret;
-
-		struct rte_port *port = &ports[port_id];
-
-		/*
-		 * Starting a bonded port also starts all slaves under the bonded
-		 * device. So if this port is bond device, we need to modify the
-		 * port status of these slaves.
-		 */
-		if (port->bond_flag == 1)
-			return change_bonding_slave_port_status(port_id, false);
-	}
-
-	return 0;
-}
-
-static int
-eth_dev_stop_mp(uint16_t port_id)
-{
-	int ret;
-
-	if (is_proc_primary()) {
-		ret = rte_eth_dev_stop(port_id);
-		if (ret != 0)
-			return ret;
-
-		struct rte_port *port = &ports[port_id];
-
-		/*
-		 * Stopping a bonded port also stops all slaves under the bonded
-		 * device. So if this port is bond device, we need to modify the
-		 * port status of these slaves.
-		 */
-		if (port->bond_flag == 1)
-			return change_bonding_slave_port_status(port_id, true);
-	}
-
-	return 0;
-}
-
-static void
-mempool_free_mp(struct rte_mempool *mp)
-{
-	if (is_proc_primary())
-		rte_mempool_free(mp);
-}
-
-static int
-eth_dev_set_mtu_mp(uint16_t port_id, uint16_t mtu)
-{
-	if (is_proc_primary())
-		return rte_eth_dev_set_mtu(port_id, mtu);
-
-	return 0;
-}
 
 /* Forward function declarations */
 static void setup_attached_port(portid_t pi);
+static void map_port_queue_stats_mapping_registers(portid_t pi,
+						   struct rte_port *port);
 static void check_all_ports_link_status(uint32_t port_mask);
 static int eth_event_callback(portid_t port_id,
 			      enum rte_eth_event_type type,
@@ -687,7 +500,6 @@
 static void dev_event_callback(const char *device_name,
 				enum rte_dev_event_type type,
 				void *param);
-static void fill_xstats_display_info(void);
 
 /*
  * Check if all the ports are started.
@@ -695,14 +507,8 @@
  */
 static int all_ports_started(void);
 
-#ifdef RTE_LIB_GSO
 struct gso_status gso_ports[RTE_MAX_ETHPORTS];
 uint16_t gso_max_segment_size = RTE_ETHER_MAX_LEN - RTE_ETHER_CRC_LEN;
-#endif
-
-/* Holds the registered mbuf dynamic flags names. */
-char dynf_names[64][RTE_MBUF_DYN_NAMESIZE];
-
 
 /*
  * Helper function to check if socket is already discovered.
@@ -743,7 +549,7 @@
 			}
 			socket_ids[num_sockets++] = sock_num;
 		}
-		if (i == rte_get_main_lcore())
+		if (i == rte_get_master_lcore())
 			continue;
 		fwd_lcores_cpuids[nb_lc++] = i;
 	}
@@ -796,7 +602,6 @@
 	set_default_fwd_ports_config();
 }
 
-#ifndef RTE_EXEC_ENV_WINDOWS
 /* extremely pessimistic estimation of memory required to create a mempool */
 static int
 calc_mem_size(uint32_t nb_mbufs, uint32_t mbuf_sz, size_t pgsz, size_t *out)
@@ -955,7 +760,8 @@
 
 	return 0;
 fail:
-	free(iovas);
+	if (iovas)
+		free(iovas);
 	if (addr)
 		munmap(addr, mem_sz);
 
@@ -1018,23 +824,16 @@
 	int ret;
 
 	RTE_ETH_FOREACH_DEV(pid) {
-		struct rte_eth_dev_info dev_info;
-
-		ret = eth_dev_info_get_print_err(pid, &dev_info);
-		if (ret != 0) {
-			TESTPMD_LOG(DEBUG,
-				    "unable to get device info for port %d on addr 0x%p,"
-				    "mempool unmapping will not be performed\n",
-				    pid, memhdr->addr);
-			continue;
-		}
+		struct rte_eth_dev *dev =
+			&rte_eth_devices[pid];
 
-		ret = rte_dev_dma_unmap(dev_info.device, memhdr->addr, 0, memhdr->len);
+		ret = rte_dev_dma_unmap(dev->device, memhdr->addr, 0,
+					memhdr->len);
 		if (ret) {
 			TESTPMD_LOG(DEBUG,
 				    "unable to DMA unmap addr 0x%p "
 				    "for device %s\n",
-				    memhdr->addr, rte_dev_name(dev_info.device));
+				    memhdr->addr, dev->data->name);
 		}
 	}
 	ret = rte_extmem_unregister(memhdr->addr, memhdr->len);
@@ -1060,109 +859,33 @@
 		return;
 	}
 	RTE_ETH_FOREACH_DEV(pid) {
-		struct rte_eth_dev_info dev_info;
+		struct rte_eth_dev *dev =
+			&rte_eth_devices[pid];
 
-		ret = eth_dev_info_get_print_err(pid, &dev_info);
-		if (ret != 0) {
-			TESTPMD_LOG(DEBUG,
-				    "unable to get device info for port %d on addr 0x%p,"
-				    "mempool mapping will not be performed\n",
-				    pid, memhdr->addr);
-			continue;
-		}
-		ret = rte_dev_dma_map(dev_info.device, memhdr->addr, 0, memhdr->len);
+		ret = rte_dev_dma_map(dev->device, memhdr->addr, 0,
+				      memhdr->len);
 		if (ret) {
 			TESTPMD_LOG(DEBUG,
 				    "unable to DMA map addr 0x%p "
 				    "for device %s\n",
-				    memhdr->addr, rte_dev_name(dev_info.device));
+				    memhdr->addr, dev->data->name);
 		}
 	}
 }
-#endif
-
-static unsigned int
-setup_extbuf(uint32_t nb_mbufs, uint16_t mbuf_sz, unsigned int socket_id,
-	    char *pool_name, struct rte_pktmbuf_extmem **ext_mem)
-{
-	struct rte_pktmbuf_extmem *xmem;
-	unsigned int ext_num, zone_num, elt_num;
-	uint16_t elt_size;
-
-	elt_size = RTE_ALIGN_CEIL(mbuf_sz, RTE_CACHE_LINE_SIZE);
-	elt_num = EXTBUF_ZONE_SIZE / elt_size;
-	zone_num = (nb_mbufs + elt_num - 1) / elt_num;
-
-	xmem = malloc(sizeof(struct rte_pktmbuf_extmem) * zone_num);
-	if (xmem == NULL) {
-		TESTPMD_LOG(ERR, "Cannot allocate memory for "
-				 "external buffer descriptors\n");
-		*ext_mem = NULL;
-		return 0;
-	}
-	for (ext_num = 0; ext_num < zone_num; ext_num++) {
-		struct rte_pktmbuf_extmem *xseg = xmem + ext_num;
-		const struct rte_memzone *mz;
-		char mz_name[RTE_MEMZONE_NAMESIZE];
-		int ret;
-
-		ret = snprintf(mz_name, sizeof(mz_name),
-			RTE_MEMPOOL_MZ_FORMAT "_xb_%u", pool_name, ext_num);
-		if (ret < 0 || ret >= (int)sizeof(mz_name)) {
-			errno = ENAMETOOLONG;
-			ext_num = 0;
-			break;
-		}
-		mz = rte_memzone_reserve(mz_name, EXTBUF_ZONE_SIZE,
-					 socket_id,
-					 RTE_MEMZONE_IOVA_CONTIG |
-					 RTE_MEMZONE_1GB |
-					 RTE_MEMZONE_SIZE_HINT_ONLY);
-		if (mz == NULL) {
-			/*
-			 * The caller exits on external buffer creation
-			 * error, so there is no need to free memzones.
-			 */
-			errno = ENOMEM;
-			ext_num = 0;
-			break;
-		}
-		xseg->buf_ptr = mz->addr;
-		xseg->buf_iova = mz->iova;
-		xseg->buf_len = EXTBUF_ZONE_SIZE;
-		xseg->elt_size = elt_size;
-	}
-	if (ext_num == 0 && xmem != NULL) {
-		free(xmem);
-		xmem = NULL;
-	}
-	*ext_mem = xmem;
-	return ext_num;
-}
 
 /*
  * Configuration initialisation done once at init time.
  */
 static struct rte_mempool *
 mbuf_pool_create(uint16_t mbuf_seg_size, unsigned nb_mbuf,
-		 unsigned int socket_id, uint16_t size_idx)
+		 unsigned int socket_id)
 {
 	char pool_name[RTE_MEMPOOL_NAMESIZE];
 	struct rte_mempool *rte_mp = NULL;
-#ifndef RTE_EXEC_ENV_WINDOWS
 	uint32_t mb_size;
 
 	mb_size = sizeof(struct rte_mbuf) + mbuf_seg_size;
-#endif
-	mbuf_poolname_build(socket_id, pool_name, sizeof(pool_name), size_idx);
-	if (!is_proc_primary()) {
-		rte_mp = rte_mempool_lookup(pool_name);
-		if (rte_mp == NULL)
-			rte_exit(EXIT_FAILURE,
-				"Get mbuf pool for socket %u failed: %s\n",
-				socket_id, rte_strerror(rte_errno));
-		return rte_mp;
-	}
+	mbuf_poolname_build(socket_id, pool_name, sizeof(pool_name));
 
 	TESTPMD_LOG(INFO,
 		"create a new mbuf pool <%s>: n=%u, size=%u, socket=%u\n",
@@ -1178,7 +901,6 @@
 				mb_mempool_cache, 0, mbuf_seg_size, socket_id);
 			break;
 		}
-#ifndef RTE_EXEC_ENV_WINDOWS
 	case MP_ALLOC_ANON:
 		{
 			rte_mp = rte_mempool_create_empty(pool_name, nb_mbuf,
@@ -1219,36 +941,13 @@
 					heap_socket);
 			break;
 		}
-#endif
-	case MP_ALLOC_XBUF:
-		{
-			struct rte_pktmbuf_extmem *ext_mem;
-			unsigned int ext_num;
-
-			ext_num = setup_extbuf(nb_mbuf,	mbuf_seg_size,
-					       socket_id, pool_name, &ext_mem);
-			if (ext_num == 0)
-				rte_exit(EXIT_FAILURE,
-					 "Can't create pinned data buffers\n");
-
-			TESTPMD_LOG(INFO, "preferred mempool ops selected: %s\n",
-					rte_mbuf_best_mempool_ops());
-			rte_mp = rte_pktmbuf_pool_create_extbuf
-					(pool_name, nb_mbuf, mb_mempool_cache,
-					 0, mbuf_seg_size, socket_id,
-					 ext_mem, ext_num);
-			free(ext_mem);
-			break;
-		}
 	default:
 		{
 			rte_exit(EXIT_FAILURE, "Invalid mempool creation mode\n");
 		}
 	}
 
-#ifndef RTE_EXEC_ENV_WINDOWS
 err:
-#endif
 	if (rte_mp == NULL) {
 		rte_exit(EXIT_FAILURE,
 			"Creation of mbuf pool for socket %u failed: %s\n",
@@ -1270,8 +969,10 @@
 
 	if (new_socket_id(socket_id)) {
 		if (!warning_once && numa_support)
-			fprintf(stderr,
-				"Warning: NUMA should be configured manually by using --port-numa-config and --ring-numa-config parameters along with --numa.\n");
+			printf("Warning: NUMA should be configured manually by"
+			       " using --port-numa-config and"
+			       " --ring-numa-config parameters along with"
+			       " --numa.\n");
 		warning_once = 1;
 		return -1;
 	}
@@ -1318,9 +1019,11 @@
 
 	allowed_max_rxq = get_allowed_max_nb_rxq(&pid);
 	if (rxq > allowed_max_rxq) {
-		fprintf(stderr,
-			"Fail: input rxq (%u) can't be greater than max_rx_queues (%u) of port %u\n",
-			rxq, allowed_max_rxq, pid);
+		printf("Fail: input rxq (%u) can't be greater "
+		       "than max_rx_queues (%u) of port %u\n",
+		       rxq,
+		       allowed_max_rxq,
+		       pid);
 		return -1;
 	}
 	return 0;
@@ -1366,178 +1069,17 @@
 
 	allowed_max_txq = get_allowed_max_nb_txq(&pid);
 	if (txq > allowed_max_txq) {
-		fprintf(stderr,
-			"Fail: input txq (%u) can't be greater than max_tx_queues (%u) of port %u\n",
-			txq, allowed_max_txq, pid);
+		printf("Fail: input txq (%u) can't be greater "
+		       "than max_tx_queues (%u) of port %u\n",
+		       txq,
+		       allowed_max_txq,
+		       pid);
 		return -1;
 	}
 	return 0;
 }
 
 /*
- * Get the allowed maximum number of RXDs of every rx queue.
- * *pid return the port id which has minimal value of
- * max_rxd in all queues of all ports.
- */
-static uint16_t
-get_allowed_max_nb_rxd(portid_t *pid)
-{
-	uint16_t allowed_max_rxd = UINT16_MAX;
-	portid_t pi;
-	struct rte_eth_dev_info dev_info;
-
-	RTE_ETH_FOREACH_DEV(pi) {
-		if (eth_dev_info_get_print_err(pi, &dev_info) != 0)
-			continue;
-
-		if (dev_info.rx_desc_lim.nb_max < allowed_max_rxd) {
-			allowed_max_rxd = dev_info.rx_desc_lim.nb_max;
-			*pid = pi;
-		}
-	}
-	return allowed_max_rxd;
-}
-
-/*
- * Get the allowed minimal number of RXDs of every rx queue.
- * *pid return the port id which has minimal value of
- * min_rxd in all queues of all ports.
- */
-static uint16_t
-get_allowed_min_nb_rxd(portid_t *pid)
-{
-	uint16_t allowed_min_rxd = 0;
-	portid_t pi;
-	struct rte_eth_dev_info dev_info;
-
-	RTE_ETH_FOREACH_DEV(pi) {
-		if (eth_dev_info_get_print_err(pi, &dev_info) != 0)
-			continue;
-
-		if (dev_info.rx_desc_lim.nb_min > allowed_min_rxd) {
-			allowed_min_rxd = dev_info.rx_desc_lim.nb_min;
-			*pid = pi;
-		}
-	}
-
-	return allowed_min_rxd;
-}
-
-/*
- * Check input rxd is valid or not.
- * If input rxd is not greater than any of maximum number
- * of RXDs of every Rx queues and is not less than any of
- * minimal number of RXDs of every Rx queues, it is valid.
- * if valid, return 0, else return -1
- */
-int
-check_nb_rxd(queueid_t rxd)
-{
-	uint16_t allowed_max_rxd;
-	uint16_t allowed_min_rxd;
-	portid_t pid = 0;
-
-	allowed_max_rxd = get_allowed_max_nb_rxd(&pid);
-	if (rxd > allowed_max_rxd) {
-		fprintf(stderr,
-			"Fail: input rxd (%u) can't be greater than max_rxds (%u) of port %u\n",
-			rxd, allowed_max_rxd, pid);
-		return -1;
-	}
-
-	allowed_min_rxd = get_allowed_min_nb_rxd(&pid);
-	if (rxd < allowed_min_rxd) {
-		fprintf(stderr,
-			"Fail: input rxd (%u) can't be less than min_rxds (%u) of port %u\n",
-			rxd, allowed_min_rxd, pid);
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
- * Get the allowed maximum number of TXDs of every rx queues.
- * *pid return the port id which has minimal value of
- * max_txd in every tx queue.
- */
-static uint16_t
-get_allowed_max_nb_txd(portid_t *pid)
-{
-	uint16_t allowed_max_txd = UINT16_MAX;
-	portid_t pi;
-	struct rte_eth_dev_info dev_info;
-
-	RTE_ETH_FOREACH_DEV(pi) {
-		if (eth_dev_info_get_print_err(pi, &dev_info) != 0)
-			continue;
-
-		if (dev_info.tx_desc_lim.nb_max < allowed_max_txd) {
-			allowed_max_txd = dev_info.tx_desc_lim.nb_max;
-			*pid = pi;
-		}
-	}
-	return allowed_max_txd;
-}
-
-/*
- * Get the allowed maximum number of TXDs of every tx queues.
- * *pid return the port id which has minimal value of
- * min_txd in every tx queue.
- */
-static uint16_t
-get_allowed_min_nb_txd(portid_t *pid)
-{
-	uint16_t allowed_min_txd = 0;
-	portid_t pi;
-	struct rte_eth_dev_info dev_info;
-
-	RTE_ETH_FOREACH_DEV(pi) {
-		if (eth_dev_info_get_print_err(pi, &dev_info) != 0)
-			continue;
-
-		if (dev_info.tx_desc_lim.nb_min > allowed_min_txd) {
-			allowed_min_txd = dev_info.tx_desc_lim.nb_min;
-			*pid = pi;
-		}
-	}
-
-	return allowed_min_txd;
-}
-
-/*
- * Check input txd is valid or not.
- * If input txd is not greater than any of maximum number
- * of TXDs of every Rx queues, it is valid.
- * if valid, return 0, else return -1
- */
-int
-check_nb_txd(queueid_t txd)
-{
-	uint16_t allowed_max_txd;
-	uint16_t allowed_min_txd;
-	portid_t pid = 0;
-
-	allowed_max_txd = get_allowed_max_nb_txd(&pid);
-	if (txd > allowed_max_txd) {
-		fprintf(stderr,
-			"Fail: input txd (%u) can't be greater than max_txds (%u) of port %u\n",
-			txd, allowed_max_txd, pid);
-		return -1;
-	}
-
-	allowed_min_txd = get_allowed_min_nb_txd(&pid);
-	if (txd < allowed_min_txd) {
-		fprintf(stderr,
-			"Fail: input txd (%u) can't be less than min_txds (%u) of port %u\n",
-			txd, allowed_min_txd, pid);
-		return -1;
-	}
-	return 0;
-}
-
-
-/*
  * Get the allowed maximum number of hairpin queues.
  * *pid return the port id which has minimal value of
  * max_hairpin_queues in all ports.
@@ -1576,105 +1118,31 @@
 
 	allowed_max_hairpinq = get_allowed_max_nb_hairpinq(&pid);
 	if (hairpinq > allowed_max_hairpinq) {
-		fprintf(stderr,
-			"Fail: input hairpin (%u) can't be greater than max_hairpin_queues (%u) of port %u\n",
-			hairpinq, allowed_max_hairpinq, pid);
+		printf("Fail: input hairpin (%u) can't be greater "
+		       "than max_hairpin_queues (%u) of port %u\n",
+		       hairpinq, allowed_max_hairpinq, pid);
 		return -1;
 	}
 	return 0;
 }
 
-static int
-get_eth_overhead(struct rte_eth_dev_info *dev_info)
-{
-	uint32_t eth_overhead;
-
-	if (dev_info->max_mtu != UINT16_MAX &&
-	    dev_info->max_rx_pktlen > dev_info->max_mtu)
-		eth_overhead = dev_info->max_rx_pktlen - dev_info->max_mtu;
-	else
-		eth_overhead = RTE_ETHER_HDR_LEN + RTE_ETHER_CRC_LEN;
-
-	return eth_overhead;
-}
-
-static void
-init_config_port_offloads(portid_t pid, uint32_t socket_id)
-{
-	struct rte_port *port = &ports[pid];
-	int ret;
-	int i;
-
-	eth_rx_metadata_negotiate_mp(pid);
-
-	port->dev_conf.txmode = tx_mode;
-	port->dev_conf.rxmode = rx_mode;
-
-	ret = eth_dev_info_get_print_err(pid, &port->dev_info);
-	if (ret != 0)
-		rte_exit(EXIT_FAILURE, "rte_eth_dev_info_get() failed\n");
-
-	if (!(port->dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE))
-		port->dev_conf.txmode.offloads &=
-			~RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE;
-
-	/* Apply Rx offloads configuration */
-	for (i = 0; i < port->dev_info.max_rx_queues; i++)
-		port->rxq[i].conf.offloads = port->dev_conf.rxmode.offloads;
-	/* Apply Tx offloads configuration */
-	for (i = 0; i < port->dev_info.max_tx_queues; i++)
-		port->txq[i].conf.offloads = port->dev_conf.txmode.offloads;
-
-	if (eth_link_speed)
-		port->dev_conf.link_speeds = eth_link_speed;
-
-	if (max_rx_pkt_len)
-		port->dev_conf.rxmode.mtu = max_rx_pkt_len -
-			get_eth_overhead(&port->dev_info);
-
-	/* set flag to initialize port/queue */
-	port->need_reconfig = 1;
-	port->need_reconfig_queues = 1;
-	port->socket_id = socket_id;
-	port->tx_metadata = 0;
-
-	/*
-	 * Check for maximum number of segments per MTU.
-	 * Accordingly update the mbuf data size.
-	 */
-	if (port->dev_info.rx_desc_lim.nb_mtu_seg_max != UINT16_MAX &&
-	    port->dev_info.rx_desc_lim.nb_mtu_seg_max != 0) {
-		uint32_t eth_overhead = get_eth_overhead(&port->dev_info);
-		uint16_t mtu;
-
-		if (rte_eth_dev_get_mtu(pid, &mtu) == 0) {
-			uint16_t data_size = (mtu + eth_overhead) /
-				port->dev_info.rx_desc_lim.nb_mtu_seg_max;
-			uint16_t buffer_size = data_size + RTE_PKTMBUF_HEADROOM;
-
-			if (buffer_size > mbuf_data_size[0]) {
-				mbuf_data_size[0] = buffer_size;
-				TESTPMD_LOG(WARNING,
-					"Configured mbuf size of the first segment %hu\n",
-					mbuf_data_size[0]);
-			}
-		}
-	}
-}
-
 static void
 init_config(void)
 {
 	portid_t pid;
+	struct rte_port *port;
 	struct rte_mempool *mbp;
 	unsigned int nb_mbuf_per_pool;
 	lcoreid_t  lc_id;
-#ifdef RTE_LIB_GRO
+	uint8_t port_per_socket[RTE_MAX_NUMA_NODES];
 	struct rte_gro_param gro_param;
-#endif
-#ifdef RTE_LIB_GSO
 	uint32_t gso_types;
-#endif
+	uint16_t data_size;
+	bool warning = 0;
+	int k;
+	int ret;
+
+	memset(port_per_socket,0,RTE_MAX_NUMA_NODES);
 
 	/* Configuration of logical cores. */
 	fwd_lcores = rte_zmalloc("testpmd: fwd_lcores",
@@ -1696,12 +1164,25 @@
 	}
 
 	RTE_ETH_FOREACH_DEV(pid) {
-		uint32_t socket_id;
+		port = &ports[pid];
+		/* Apply default TxRx configuration for all ports */
+		port->dev_conf.txmode = tx_mode;
+		port->dev_conf.rxmode = rx_mode;
+
+		ret = eth_dev_info_get_print_err(pid, &port->dev_info);
+		if (ret != 0)
+			rte_exit(EXIT_FAILURE,
+				 "rte_eth_dev_info_get() failed\n");
 
+		if (!(port->dev_info.tx_offload_capa &
+		      DEV_TX_OFFLOAD_MBUF_FAST_FREE))
+			port->dev_conf.txmode.offloads &=
+				~DEV_TX_OFFLOAD_MBUF_FAST_FREE;
 		if (numa_support) {
-			socket_id = port_numa[pid];
-			if (port_numa[pid] == NUMA_NO_CONFIG) {
-				socket_id = rte_eth_dev_socket_id(pid);
+			if (port_numa[pid] != NUMA_NO_CONFIG)
+				port_per_socket[port_numa[pid]]++;
+			else {
+				uint32_t socket_id = rte_eth_dev_socket_id(pid);
 
 				/*
 				 * if socket_id is invalid,
@@ -1709,14 +1190,45 @@
 				 */
 				if (check_socket_id(socket_id) < 0)
 					socket_id = socket_ids[0];
+				port_per_socket[socket_id]++;
+			}
+		}
+
+		/* Apply Rx offloads configuration */
+		for (k = 0; k < port->dev_info.max_rx_queues; k++)
+			port->rx_conf[k].offloads =
+				port->dev_conf.rxmode.offloads;
+		/* Apply Tx offloads configuration */
+		for (k = 0; k < port->dev_info.max_tx_queues; k++)
+			port->tx_conf[k].offloads =
+				port->dev_conf.txmode.offloads;
+
+		/* set flag to initialize port/queue */
+		port->need_reconfig = 1;
+		port->need_reconfig_queues = 1;
+		port->tx_metadata = 0;
+
+		/* Check for maximum number of segments per MTU. Accordingly
+		 * update the mbuf data size.
+		 */
+		if (port->dev_info.rx_desc_lim.nb_mtu_seg_max != UINT16_MAX &&
+				port->dev_info.rx_desc_lim.nb_mtu_seg_max != 0) {
+			data_size = rx_mode.max_rx_pkt_len /
+				port->dev_info.rx_desc_lim.nb_mtu_seg_max;
+
+			if ((data_size + RTE_PKTMBUF_HEADROOM) >
+							mbuf_data_size) {
+				mbuf_data_size = data_size +
+						 RTE_PKTMBUF_HEADROOM;
+				warning = 1;
 			}
-		} else {
-			socket_id = (socket_num == UMA_NO_CONFIG) ?
-				    0 : socket_num;
 		}
-		/* Apply default TxRx configuration for all ports */
-		init_config_port_offloads(pid, socket_id);
 	}
+
+	if (warning)
+		TESTPMD_LOG(WARNING, "Configured mbuf size %hu\n",
+			    mbuf_data_size);
+
 	/*
 	 * Create pools of mbuf.
 	 * If NUMA support is disabled, create a single pool of mbuf in
@@ -1729,49 +1241,44 @@
 	if (param_total_num_mbufs)
 		nb_mbuf_per_pool = param_total_num_mbufs;
 	else {
-		nb_mbuf_per_pool = RX_DESC_MAX +
+		nb_mbuf_per_pool = RTE_TEST_RX_DESC_MAX +
 			(nb_lcores * mb_mempool_cache) +
-			TX_DESC_MAX + MAX_PKT_BURST;
+			RTE_TEST_TX_DESC_MAX + MAX_PKT_BURST;
 		nb_mbuf_per_pool *= RTE_MAX_ETHPORTS;
 	}
 
 	if (numa_support) {
-		uint8_t i, j;
+		uint8_t i;
 
 		for (i = 0; i < num_sockets; i++)
-			for (j = 0; j < mbuf_data_size_n; j++)
-				mempools[i * MAX_SEGS_BUFFER_SPLIT + j] =
-					mbuf_pool_create(mbuf_data_size[j],
-							  nb_mbuf_per_pool,
-							  socket_ids[i], j);
+			mempools[i] = mbuf_pool_create(mbuf_data_size,
+						       nb_mbuf_per_pool,
+						       socket_ids[i]);
 	} else {
-		uint8_t i;
-
-		for (i = 0; i < mbuf_data_size_n; i++)
-			mempools[i] = mbuf_pool_create
-					(mbuf_data_size[i],
-					 nb_mbuf_per_pool,
-					 socket_num == UMA_NO_CONFIG ?
-					 0 : socket_num, i);
+		if (socket_num == UMA_NO_CONFIG)
+			mempools[0] = mbuf_pool_create(mbuf_data_size,
+						       nb_mbuf_per_pool, 0);
+		else
+			mempools[socket_num] = mbuf_pool_create
+							(mbuf_data_size,
+							 nb_mbuf_per_pool,
+							 socket_num);
 	}
 
 	init_port_config();
 
-#ifdef RTE_LIB_GSO
-	gso_types = RTE_ETH_TX_OFFLOAD_TCP_TSO | RTE_ETH_TX_OFFLOAD_VXLAN_TNL_TSO |
-		RTE_ETH_TX_OFFLOAD_GRE_TNL_TSO | RTE_ETH_TX_OFFLOAD_UDP_TSO;
-#endif
+	gso_types = DEV_TX_OFFLOAD_TCP_TSO | DEV_TX_OFFLOAD_VXLAN_TNL_TSO |
+		DEV_TX_OFFLOAD_GRE_TNL_TSO | DEV_TX_OFFLOAD_UDP_TSO;
 	/*
 	 * Records which Mbuf pool to use by each logical core, if needed.
 	 */
 	for (lc_id = 0; lc_id < nb_lcores; lc_id++) {
 		mbp = mbuf_pool_find(
-			rte_lcore_to_socket_id(fwd_lcores_cpuids[lc_id]), 0);
+			rte_lcore_to_socket_id(fwd_lcores_cpuids[lc_id]));
 
 		if (mbp == NULL)
-			mbp = mbuf_pool_find(0, 0);
+			mbp = mbuf_pool_find(0);
 		fwd_lcores[lc_id]->mbp = mbp;
-#ifdef RTE_LIB_GSO
 		/* initialize GSO context */
 		fwd_lcores[lc_id]->gso_ctx.direct_pool = mbp;
 		fwd_lcores[lc_id]->gso_ctx.indirect_pool = mbp;
@@ -1779,12 +1286,14 @@
 		fwd_lcores[lc_id]->gso_ctx.gso_size = RTE_ETHER_MAX_LEN -
 			RTE_ETHER_CRC_LEN;
 		fwd_lcores[lc_id]->gso_ctx.flag = 0;
-#endif
 	}
 
+	/* Configuration of packet forwarding streams. */
+	if (init_fwd_streams() < 0)
+		rte_exit(EXIT_FAILURE, "FAIL from init_fwd_streams()\n");
+
 	fwd_config_setup();
 
-#ifdef RTE_LIB_GRO
 	/* create a gro context for each lcore */
 	gro_param.gro_types = RTE_GRO_TCP_IPV4;
 	gro_param.max_flow_num = GRO_MAX_FLUSH_CYCLES;
@@ -1798,18 +1307,44 @@
 					"rte_gro_ctx_create() failed\n");
 		}
 	}
+
+#if defined RTE_LIBRTE_PMD_SOFTNIC
+	if (strcmp(cur_fwd_eng->fwd_mode_name, "softnic") == 0) {
+		RTE_ETH_FOREACH_DEV(pid) {
+			port = &ports[pid];
+			const char *driver = port->dev_info.driver_name;
+
+			if (strcmp(driver, "net_softnic") == 0)
+				port->softport.fwd_lcore_arg = fwd_lcores;
+		}
+	}
 #endif
+
 }
 
 
 void
 reconfig(portid_t new_port_id, unsigned socket_id)
 {
+	struct rte_port *port;
+	int ret;
+
 	/* Reconfiguration of Ethernet ports. */
-	init_config_port_offloads(new_port_id, socket_id);
+	port = &ports[new_port_id];
+
+	ret = eth_dev_info_get_print_err(new_port_id, &port->dev_info);
+	if (ret != 0)
+		return;
+
+	/* set flag to initialize port/queue */
+	port->need_reconfig = 1;
+	port->need_reconfig_queues = 1;
+	port->socket_id = socket_id;
+
 	init_port_config();
 }
 
+
 int
 init_fwd_streams(void)
 {
@@ -1822,15 +1357,15 @@
 	RTE_ETH_FOREACH_DEV(pid) {
 		port = &ports[pid];
 		if (nb_rxq > port->dev_info.max_rx_queues) {
-			fprintf(stderr,
-				"Fail: nb_rxq(%d) is greater than max_rx_queues(%d)\n",
-				nb_rxq, port->dev_info.max_rx_queues);
+			printf("Fail: nb_rxq(%d) is greater than "
+				"max_rx_queues(%d)\n", nb_rxq,
+				port->dev_info.max_rx_queues);
 			return -1;
 		}
 		if (nb_txq > port->dev_info.max_tx_queues) {
-			fprintf(stderr,
-				"Fail: nb_txq(%d) is greater than max_tx_queues(%d)\n",
-				nb_txq, port->dev_info.max_tx_queues);
+			printf("Fail: nb_txq(%d) is greater than "
+				"max_tx_queues(%d)\n", nb_txq,
+				port->dev_info.max_tx_queues);
 			return -1;
 		}
 		if (numa_support) {
@@ -1857,8 +1392,7 @@
 
 	q = RTE_MAX(nb_rxq, nb_txq);
 	if (q == 0) {
-		fprintf(stderr,
-			"Fail: Cannot allocate fwd streams as number of queues is 0\n");
+		printf("Fail: Cannot allocate fwd streams as number of queues is 0\n");
 		return -1;
 	}
 	nb_fwd_streams_new = (streamid_t)(nb_ports * q);
@@ -1900,72 +1434,63 @@
 	return 0;
 }
 
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
 static void
 pkt_burst_stats_display(const char *rx_tx, struct pkt_burst_stats *pbs)
 {
-	uint64_t total_burst, sburst;
-	uint64_t nb_burst;
-	uint64_t burst_stats[4];
-	uint16_t pktnb_stats[4];
+	unsigned int total_burst;
+	unsigned int nb_burst;
+	unsigned int burst_stats[3];
+	uint16_t pktnb_stats[3];
 	uint16_t nb_pkt;
-	int burst_percent[4], sburstp;
-	int i;
+	int burst_percent[3];
 
 	/*
 	 * First compute the total number of packet bursts and the
 	 * two highest numbers of bursts of the same number of packets.
 	 */
-	memset(&burst_stats, 0x0, sizeof(burst_stats));
-	memset(&pktnb_stats, 0x0, sizeof(pktnb_stats));
-
-	/* Show stats for 0 burst size always */
-	total_burst = pbs->pkt_burst_spread[0];
-	burst_stats[0] = pbs->pkt_burst_spread[0];
-	pktnb_stats[0] = 0;
-
-	/* Find the next 2 burst sizes with highest occurrences. */
-	for (nb_pkt = 1; nb_pkt < MAX_PKT_BURST + 1; nb_pkt++) {
+	total_burst = 0;
+	burst_stats[0] = burst_stats[1] = burst_stats[2] = 0;
+	pktnb_stats[0] = pktnb_stats[1] = pktnb_stats[2] = 0;
+	for (nb_pkt = 0; nb_pkt < MAX_PKT_BURST; nb_pkt++) {
 		nb_burst = pbs->pkt_burst_spread[nb_pkt];
-
 		if (nb_burst == 0)
 			continue;
-
 		total_burst += nb_burst;
-
-		if (nb_burst > burst_stats[1]) {
-			burst_stats[2] = burst_stats[1];
-			pktnb_stats[2] = pktnb_stats[1];
+		if (nb_burst > burst_stats[0]) {
+			burst_stats[1] = burst_stats[0];
+			pktnb_stats[1] = pktnb_stats[0];
+			burst_stats[0] = nb_burst;
+			pktnb_stats[0] = nb_pkt;
+		} else if (nb_burst > burst_stats[1]) {
 			burst_stats[1] = nb_burst;
 			pktnb_stats[1] = nb_pkt;
-		} else if (nb_burst > burst_stats[2]) {
-			burst_stats[2] = nb_burst;
-			pktnb_stats[2] = nb_pkt;
 		}
 	}
 	if (total_burst == 0)
 		return;
-
-	printf("  %s-bursts : %"PRIu64" [", rx_tx, total_burst);
-	for (i = 0, sburst = 0, sburstp = 0; i < 4; i++) {
-		if (i == 3) {
-			printf("%d%% of other]\n", 100 - sburstp);
-			return;
-		}
-
-		sburst += burst_stats[i];
-		if (sburst == total_burst) {
-			printf("%d%% of %d pkts]\n",
-				100 - sburstp, (int) pktnb_stats[i]);
-			return;
-		}
-
-		burst_percent[i] =
-			(double)burst_stats[i] / total_burst * 100;
-		printf("%d%% of %d pkts + ",
-			burst_percent[i], (int) pktnb_stats[i]);
-		sburstp += burst_percent[i];
+	burst_percent[0] = (burst_stats[0] * 100) / total_burst;
+	printf("  %s-bursts : %u [%d%% of %d pkts", rx_tx, total_burst,
+	       burst_percent[0], (int) pktnb_stats[0]);
+	if (burst_stats[0] == total_burst) {
+		printf("]\n");
+		return;
 	}
+	if (burst_stats[0] + burst_stats[1] == total_burst) {
+		printf(" + %d%% of %d pkts]\n",
+		       100 - burst_percent[0], pktnb_stats[1]);
+		return;
+	}
+	burst_percent[1] = (burst_stats[1] * 100) / total_burst;
+	burst_percent[2] = 100 - (burst_percent[0] + burst_percent[1]);
+	if ((burst_percent[1] == 0) || (burst_percent[2] == 0)) {
+		printf(" + %d%% of others]\n", 100 - burst_percent[0]);
+		return;
+	}
+	printf(" + %d%% of %d pkts + %d%% of others]\n",
+	       burst_percent[1], (int) pktnb_stats[1], burst_percent[2]);
 }
+#endif /* RTE_TEST_PMD_RECORD_BURST_STATS */
 
 static void
 fwd_stream_stats_display(streamid_t stream_id)
@@ -1992,16 +1517,14 @@
 		       " Rx- bad outer L4 checksum: %-14"PRIu64"\n",
 			fs->rx_bad_ip_csum, fs->rx_bad_l4_csum,
 			fs->rx_bad_outer_l4_csum);
-		printf(" RX- bad outer IP checksum: %-14"PRIu64"\n",
-			fs->rx_bad_outer_ip_csum);
 	} else {
 		printf("\n");
 	}
 
-	if (record_burst_stats) {
-		pkt_burst_stats_display("RX", &fs->rx_burst_stats);
-		pkt_burst_stats_display("TX", &fs->tx_burst_stats);
-	}
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	pkt_burst_stats_display("RX", &fs->rx_burst_stats);
+	pkt_burst_stats_display("TX", &fs->tx_burst_stats);
+#endif
 }
 
 void
@@ -2016,19 +1539,19 @@
 		uint64_t rx_bad_ip_csum;
 		uint64_t rx_bad_l4_csum;
 		uint64_t rx_bad_outer_l4_csum;
-		uint64_t rx_bad_outer_ip_csum;
 	} ports_stats[RTE_MAX_ETHPORTS];
 	uint64_t total_rx_dropped = 0;
 	uint64_t total_tx_dropped = 0;
 	uint64_t total_rx_nombuf = 0;
 	struct rte_eth_stats stats;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
 	uint64_t fwd_cycles = 0;
+#endif
 	uint64_t total_recv = 0;
 	uint64_t total_xmit = 0;
 	struct rte_port *port;
 	streamid_t sm_id;
 	portid_t pt_id;
-	int ret;
 	int i;
 
 	memset(ports_stats, 0, sizeof(ports_stats));
@@ -2050,25 +1573,18 @@
 		ports_stats[fs->rx_port].rx_bad_l4_csum += fs->rx_bad_l4_csum;
 		ports_stats[fs->rx_port].rx_bad_outer_l4_csum +=
 				fs->rx_bad_outer_l4_csum;
-		ports_stats[fs->rx_port].rx_bad_outer_ip_csum +=
-				fs->rx_bad_outer_ip_csum;
 
-		if (record_core_cycles)
-			fwd_cycles += fs->core_cycles;
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+		fwd_cycles += fs->core_cycles;
+#endif
 	}
 	for (i = 0; i < cur_fwd_config.nb_fwd_ports; i++) {
-		uint64_t tx_dropped = 0;
+		uint8_t j;
 
 		pt_id = fwd_ports_ids[i];
 		port = &ports[pt_id];
 
-		ret = rte_eth_stats_get(pt_id, &stats);
-		if (ret != 0) {
-			fprintf(stderr,
-				"%s: Error: failed to get stats (port %u): %d",
-				__func__, pt_id, ret);
-			continue;
-		}
+		rte_eth_stats_get(pt_id, &stats);
 		stats.ipackets -= port->stats.ipackets;
 		stats.opackets -= port->stats.opackets;
 		stats.ibytes -= port->stats.ibytes;
@@ -2080,45 +1596,95 @@
 		total_recv += stats.ipackets;
 		total_xmit += stats.opackets;
 		total_rx_dropped += stats.imissed;
-		tx_dropped += ports_stats[pt_id].tx_dropped;
-		tx_dropped += stats.oerrors;
-		total_tx_dropped += tx_dropped;
+		total_tx_dropped += ports_stats[pt_id].tx_dropped;
+		total_tx_dropped += stats.oerrors;
 		total_rx_nombuf  += stats.rx_nombuf;
 
 		printf("\n  %s Forward statistics for port %-2d %s\n",
 		       fwd_stats_border, pt_id, fwd_stats_border);
 
-		printf("  RX-packets: %-14"PRIu64" RX-dropped: %-14"PRIu64
-		       "RX-total: %-"PRIu64"\n", stats.ipackets, stats.imissed,
-		       stats.ipackets + stats.imissed);
-
-		if (cur_fwd_eng == &csum_fwd_engine) {
-			printf("  Bad-ipcsum: %-14"PRIu64
-			       " Bad-l4csum: %-14"PRIu64
-			       "Bad-outer-l4csum: %-14"PRIu64"\n",
-			       ports_stats[pt_id].rx_bad_ip_csum,
-			       ports_stats[pt_id].rx_bad_l4_csum,
-			       ports_stats[pt_id].rx_bad_outer_l4_csum);
-			printf("  Bad-outer-ipcsum: %-14"PRIu64"\n",
-			       ports_stats[pt_id].rx_bad_outer_ip_csum);
-		}
-		if (stats.ierrors + stats.rx_nombuf > 0) {
-			printf("  RX-error: %-"PRIu64"\n", stats.ierrors);
-			printf("  RX-nombufs: %-14"PRIu64"\n", stats.rx_nombuf);
-		}
-
-		printf("  TX-packets: %-14"PRIu64" TX-dropped: %-14"PRIu64
-		       "TX-total: %-"PRIu64"\n",
-		       stats.opackets, tx_dropped,
-		       stats.opackets + tx_dropped);
-
-		if (record_burst_stats) {
-			if (ports_stats[pt_id].rx_stream)
-				pkt_burst_stats_display("RX",
-					&ports_stats[pt_id].rx_stream->rx_burst_stats);
-			if (ports_stats[pt_id].tx_stream)
-				pkt_burst_stats_display("TX",
+		if (!port->rx_queue_stats_mapping_enabled &&
+		    !port->tx_queue_stats_mapping_enabled) {
+			printf("  RX-packets: %-14"PRIu64
+			       " RX-dropped: %-14"PRIu64
+			       "RX-total: %-"PRIu64"\n",
+			       stats.ipackets, stats.imissed,
+			       stats.ipackets + stats.imissed);
+
+			if (cur_fwd_eng == &csum_fwd_engine)
+				printf("  Bad-ipcsum: %-14"PRIu64
+				       " Bad-l4csum: %-14"PRIu64
+				       "Bad-outer-l4csum: %-14"PRIu64"\n",
+				       ports_stats[pt_id].rx_bad_ip_csum,
+				       ports_stats[pt_id].rx_bad_l4_csum,
+				       ports_stats[pt_id].rx_bad_outer_l4_csum);
+			if (stats.ierrors + stats.rx_nombuf > 0) {
+				printf("  RX-error: %-"PRIu64"\n",
+				       stats.ierrors);
+				printf("  RX-nombufs: %-14"PRIu64"\n",
+				       stats.rx_nombuf);
+			}
+
+			printf("  TX-packets: %-14"PRIu64
+			       " TX-dropped: %-14"PRIu64
+			       "TX-total: %-"PRIu64"\n",
+			       stats.opackets, ports_stats[pt_id].tx_dropped,
+			       stats.opackets + ports_stats[pt_id].tx_dropped);
+		} else {
+			printf("  RX-packets:             %14"PRIu64
+			       "    RX-dropped:%14"PRIu64
+			       "    RX-total:%14"PRIu64"\n",
+			       stats.ipackets, stats.imissed,
+			       stats.ipackets + stats.imissed);
+
+			if (cur_fwd_eng == &csum_fwd_engine)
+				printf("  Bad-ipcsum:%14"PRIu64
+				       "    Bad-l4csum:%14"PRIu64
+				       "    Bad-outer-l4csum: %-14"PRIu64"\n",
+				       ports_stats[pt_id].rx_bad_ip_csum,
+				       ports_stats[pt_id].rx_bad_l4_csum,
+				       ports_stats[pt_id].rx_bad_outer_l4_csum);
+			if ((stats.ierrors + stats.rx_nombuf) > 0) {
+				printf("  RX-error:%"PRIu64"\n", stats.ierrors);
+				printf("  RX-nombufs:             %14"PRIu64"\n",
+				       stats.rx_nombuf);
+			}
+
+			printf("  TX-packets:             %14"PRIu64
+			       "    TX-dropped:%14"PRIu64
+			       "    TX-total:%14"PRIu64"\n",
+			       stats.opackets, ports_stats[pt_id].tx_dropped,
+			       stats.opackets + ports_stats[pt_id].tx_dropped);
+		}
+
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+		if (ports_stats[pt_id].rx_stream)
+			pkt_burst_stats_display("RX",
+				&ports_stats[pt_id].rx_stream->rx_burst_stats);
+		if (ports_stats[pt_id].tx_stream)
+			pkt_burst_stats_display("TX",
 				&ports_stats[pt_id].tx_stream->tx_burst_stats);
+#endif
+
+		if (port->rx_queue_stats_mapping_enabled) {
+			printf("\n");
+			for (j = 0; j < RTE_ETHDEV_QUEUE_STAT_CNTRS; j++) {
+				printf("  Stats reg %2d RX-packets:%14"PRIu64
+				       "     RX-errors:%14"PRIu64
+				       "    RX-bytes:%14"PRIu64"\n",
+				       j, stats.q_ipackets[j],
+				       stats.q_errors[j], stats.q_ibytes[j]);
+			}
+			printf("\n");
+		}
+		if (port->tx_queue_stats_mapping_enabled) {
+			for (j = 0; j < RTE_ETHDEV_QUEUE_STAT_CNTRS; j++) {
+				printf("  Stats reg %2d TX-packets:%14"PRIu64
+				       "                                 TX-bytes:%14"
+				       PRIu64"\n",
+				       j, stats.q_opackets[j],
+				       stats.q_obytes[j]);
+			}
 		}
 
 		printf("  %s--------------------------------%s\n",
@@ -2139,24 +1705,13 @@
 	printf("  %s++++++++++++++++++++++++++++++++++++++++++++++"
 	       "%s\n",
 	       acc_stats_border, acc_stats_border);
-	if (record_core_cycles) {
-#define CYC_PER_MHZ 1E6
-		if (total_recv > 0 || total_xmit > 0) {
-			uint64_t total_pkts = 0;
-			if (strcmp(cur_fwd_eng->fwd_mode_name, "txonly") == 0 ||
-			    strcmp(cur_fwd_eng->fwd_mode_name, "flowgen") == 0)
-				total_pkts = total_xmit;
-			else
-				total_pkts = total_recv;
-
-			printf("\n  CPU cycles/packet=%.2F (total cycles="
-			       "%"PRIu64" / total %s packets=%"PRIu64") at %"PRIu64
-			       " MHz Clock\n",
-			       (double) fwd_cycles / total_pkts,
-			       fwd_cycles, cur_fwd_eng->fwd_mode_name, total_pkts,
-			       (uint64_t)(rte_get_tsc_hz() / CYC_PER_MHZ));
-		}
-	}
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	if (total_recv > 0)
+		printf("\n  CPU cycles/packet=%u (total cycles="
+		       "%"PRIu64" / total RX packets=%"PRIu64")\n",
+		       (unsigned int)(fwd_cycles / total_recv),
+		       fwd_cycles, total_recv);
+#endif
 }
 
 void
@@ -2164,16 +1719,11 @@
 {
 	streamid_t sm_id;
 	portid_t pt_id;
-	int ret;
 	int i;
 
 	for (i = 0; i < cur_fwd_config.nb_fwd_ports; i++) {
 		pt_id = fwd_ports_ids[i];
-		ret = rte_eth_stats_get(pt_id, &ports[pt_id].stats);
-		if (ret != 0)
-			fprintf(stderr,
-				"%s: Error: failed to clear stats (port %u):%d",
-				__func__, pt_id, ret);
+		rte_eth_stats_get(pt_id, &ports[pt_id].stats);
 	}
 	for (sm_id = 0; sm_id < cur_fwd_config.nb_fwd_streams; sm_id++) {
 		struct fwd_stream *fs = fwd_streams[sm_id];
@@ -2184,11 +1734,14 @@
 		fs->rx_bad_ip_csum = 0;
 		fs->rx_bad_l4_csum = 0;
 		fs->rx_bad_outer_l4_csum = 0;
-		fs->rx_bad_outer_ip_csum = 0;
 
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
 		memset(&fs->rx_burst_stats, 0, sizeof(fs->rx_burst_stats));
 		memset(&fs->tx_burst_stats, 0, sizeof(fs->tx_burst_stats));
+#endif
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
 		fs->core_cycles = 0;
+#endif
 	}
 }
 
@@ -2205,11 +1758,6 @@
 	uint64_t prev_tsc = 0, diff_tsc, cur_tsc, timer_tsc = 0;
 	uint64_t timer_period;
 
-	if (num_procs > 1) {
-		printf("multi-process not support for flushing fwd Rx queues, skip the below lines and return.\n");
-		return;
-	}
-
 	/* convert to number of cycles */
 	timer_period = rte_get_timer_hz(); /* 1 second timeout */
 
@@ -2217,12 +1765,6 @@
 		for (rxp = 0; rxp < cur_fwd_config.nb_fwd_ports; rxp++) {
 			for (rxq = 0; rxq < nb_rxq; rxq++) {
 				port_id = fwd_ports_ids[rxp];
-
-				/* Polling stopped queues is prohibited. */
-				if (ports[port_id].rxq[rxq].state ==
-				    RTE_ETH_QUEUE_STATE_STOPPED)
-					continue;
-
 				/**
 				* testpmd can stuck in the below do while loop
 				* if rte_eth_rx_burst() always returns nonzero
@@ -2254,7 +1796,7 @@
 	struct fwd_stream **fsm;
 	streamid_t nb_fs;
 	streamid_t sm_id;
-#ifdef RTE_LIB_BITRATESTATS
+#ifdef RTE_LIBRTE_BITRATE
 	uint64_t tics_per_1sec;
 	uint64_t tics_datum;
 	uint64_t tics_current;
@@ -2268,9 +1810,8 @@
 	nb_fs = fc->stream_nb;
 	do {
 		for (sm_id = 0; sm_id < nb_fs; sm_id++)
-			if (!fsm[sm_id]->disabled)
-				(*pkt_fwd)(fsm[sm_id]);
-#ifdef RTE_LIB_BITRATESTATS
+			(*pkt_fwd)(fsm[sm_id]);
+#ifdef RTE_LIBRTE_BITRATE
 		if (bitrate_enabled != 0 &&
 				bitrate_lcore_id == rte_lcore_id()) {
 			tics_current = rte_rdtsc();
@@ -2283,7 +1824,7 @@
 			}
 		}
 #endif
-#ifdef RTE_LIB_LATENCYSTATS
+#ifdef RTE_LIBRTE_LATENCY_STATS
 		if (latencystats_enabled != 0 &&
 				latencystats_lcore_id == rte_lcore_id())
 			rte_latencystats_update();
@@ -2325,10 +1866,16 @@
 static void
 launch_packet_forwarding(lcore_function_t *pkt_fwd_on_lcore)
 {
+	port_fwd_begin_t port_fwd_begin;
 	unsigned int i;
 	unsigned int lc_id;
 	int diag;
 
+	port_fwd_begin = cur_fwd_config.fwd_eng->port_fwd_begin;
+	if (port_fwd_begin != NULL) {
+		for (i = 0; i < cur_fwd_config.nb_fwd_ports; i++)
+			(*port_fwd_begin)(fwd_ports_ids[i]);
+	}
 	for (i = 0; i < cur_fwd_config.nb_fwd_lcores; i++) {
 		lc_id = fwd_lcores_cpuids[i];
 		if ((interactive == 0) || (lc_id != rte_lcore_id())) {
@@ -2336,77 +1883,12 @@
 			diag = rte_eal_remote_launch(pkt_fwd_on_lcore,
 						     fwd_lcores[i], lc_id);
 			if (diag != 0)
-				fprintf(stderr,
-					"launch lcore %u failed - diag=%d\n",
-					lc_id, diag);
+				printf("launch lcore %u failed - diag=%d\n",
+				       lc_id, diag);
 		}
 	}
 }
 
-static void
-update_rx_queue_state(uint16_t port_id, uint16_t queue_id)
-{
-	struct rte_eth_rxq_info rx_qinfo;
-	int32_t rc;
-
-	rc = rte_eth_rx_queue_info_get(port_id,
-			queue_id, &rx_qinfo);
-	if (rc == 0) {
-		ports[port_id].rxq[queue_id].state =
-			rx_qinfo.queue_state;
-	} else if (rc == -ENOTSUP) {
-		/*
-		 * Set the rxq state to RTE_ETH_QUEUE_STATE_STARTED
-		 * to ensure that the PMDs do not implement
-		 * rte_eth_rx_queue_info_get can forward.
-		 */
-		ports[port_id].rxq[queue_id].state =
-			RTE_ETH_QUEUE_STATE_STARTED;
-	} else {
-		TESTPMD_LOG(WARNING,
-			"Failed to get rx queue info\n");
-	}
-}
-
-static void
-update_tx_queue_state(uint16_t port_id, uint16_t queue_id)
-{
-	struct rte_eth_txq_info tx_qinfo;
-	int32_t rc;
-
-	rc = rte_eth_tx_queue_info_get(port_id,
-			queue_id, &tx_qinfo);
-	if (rc == 0) {
-		ports[port_id].txq[queue_id].state =
-			tx_qinfo.queue_state;
-	} else if (rc == -ENOTSUP) {
-		/*
-		 * Set the txq state to RTE_ETH_QUEUE_STATE_STARTED
-		 * to ensure that the PMDs do not implement
-		 * rte_eth_tx_queue_info_get can forward.
-		 */
-		ports[port_id].txq[queue_id].state =
-			RTE_ETH_QUEUE_STATE_STARTED;
-	} else {
-		TESTPMD_LOG(WARNING,
-			"Failed to get tx queue info\n");
-	}
-}
-
-static void
-update_queue_state(void)
-{
-	portid_t pi;
-	queueid_t qi;
-
-	RTE_ETH_FOREACH_DEV(pi) {
-		for (qi = 0; qi < nb_rxq; qi++)
-			update_rx_queue_state(pi, qi);
-		for (qi = 0; qi < nb_txq; qi++)
-			update_tx_queue_state(pi, qi);
-	}
-}
-
 /*
  * Launch packet forwarding configuration.
  */
@@ -2415,8 +1897,9 @@
 {
 	port_fwd_begin_t port_fwd_begin;
 	port_fwd_end_t  port_fwd_end;
-	stream_init_t stream_init = cur_fwd_eng->stream_init;
+	struct rte_port *port;
 	unsigned int i;
+	portid_t   pt_id;
 
 	if (strcmp(cur_fwd_eng->fwd_mode_name, "rxonly") == 0 && !nb_rxq)
 		rte_exit(EXIT_FAILURE, "rxq are 0, cannot use rxonly fwd mode\n");
@@ -2432,60 +1915,53 @@
 			cur_fwd_eng->fwd_mode_name);
 
 	if (all_ports_started() == 0) {
-		fprintf(stderr, "Not all ports were started\n");
+		printf("Not all ports were started\n");
 		return;
 	}
 	if (test_done == 0) {
-		fprintf(stderr, "Packet forwarding already started\n");
+		printf("Packet forwarding already started\n");
 		return;
 	}
 
-	fwd_config_setup();
-
-	pkt_fwd_config_display(&cur_fwd_config);
-	if (!pkt_fwd_shared_rxq_check())
-		return;
-
-	if (stream_init != NULL) {
-		if (rte_eal_process_type() == RTE_PROC_SECONDARY)
-			update_queue_state();
-		for (i = 0; i < cur_fwd_config.nb_fwd_streams; i++)
-			stream_init(fwd_streams[i]);
-	}
 
-	port_fwd_begin = cur_fwd_config.fwd_eng->port_fwd_begin;
-	if (port_fwd_begin != NULL) {
-		for (i = 0; i < cur_fwd_config.nb_fwd_ports; i++) {
-			if (port_fwd_begin(fwd_ports_ids[i])) {
-				fprintf(stderr,
-					"Packet forwarding is not ready\n");
+	if(dcb_test) {
+		for (i = 0; i < nb_fwd_ports; i++) {
+			pt_id = fwd_ports_ids[i];
+			port = &ports[pt_id];
+			if (!port->dcb_flag) {
+				printf("In DCB mode, all forwarding ports must "
+                                       "be configured in this mode.\n");
 				return;
 			}
 		}
-	}
-
-	if (with_tx_first) {
-		port_fwd_begin = tx_only_engine.port_fwd_begin;
-		if (port_fwd_begin != NULL) {
-			for (i = 0; i < cur_fwd_config.nb_fwd_ports; i++) {
-				if (port_fwd_begin(fwd_ports_ids[i])) {
-					fprintf(stderr,
-						"Packet forwarding is not ready\n");
-					return;
-				}
-			}
+		if (nb_fwd_lcores == 1) {
+			printf("In DCB mode,the nb forwarding cores "
+                               "should be larger than 1.\n");
+			return;
 		}
 	}
-
 	test_done = 0;
 
+	fwd_config_setup();
+
 	if(!no_flush_rx)
 		flush_fwd_rx_queues();
 
+	pkt_fwd_config_display(&cur_fwd_config);
 	rxtx_config_display();
 
 	fwd_stats_reset();
+	for (i = 0; i < cur_fwd_config.nb_fwd_ports; i++) {
+		pt_id = fwd_ports_ids[i];
+		port = &ports[pt_id];
+		map_port_queue_stats_mapping_registers(pt_id, port);
+	}
 	if (with_tx_first) {
+		port_fwd_begin = tx_only_engine.port_fwd_begin;
+		if (port_fwd_begin != NULL) {
+			for (i = 0; i < cur_fwd_config.nb_fwd_ports; i++)
+				(*port_fwd_begin)(fwd_ports_ids[i]);
+		}
 		while (with_tx_first--) {
 			launch_packet_forwarding(
 					run_one_txonly_burst_on_core);
@@ -2509,7 +1985,7 @@
 	int i;
 
 	if (test_done) {
-		fprintf(stderr, "Packet forwarding not started\n");
+		printf("Packet forwarding not started\n");
 		return;
 	}
 	printf("Telling cores to stop...");
@@ -2535,14 +2011,14 @@
 dev_set_link_up(portid_t pid)
 {
 	if (rte_eth_dev_set_link_up(pid) < 0)
-		fprintf(stderr, "\nSet link up fail.\n");
+		printf("\nSet link up fail.\n");
 }
 
 void
 dev_set_link_down(portid_t pid)
 {
 	if (rte_eth_dev_set_link_down(pid) < 0)
-		fprintf(stderr, "\nSet link down fail.\n");
+		printf("\nSet link down fail.\n");
 }
 
 static int
@@ -2599,19 +2075,9 @@
 	return 1;
 }
 
-#define HAIRPIN_MODE_RX_FORCE_MEMORY RTE_BIT32(8)
-#define HAIRPIN_MODE_TX_FORCE_MEMORY RTE_BIT32(9)
-
-#define HAIRPIN_MODE_RX_LOCKED_MEMORY RTE_BIT32(12)
-#define HAIRPIN_MODE_RX_RTE_MEMORY RTE_BIT32(13)
-
-#define HAIRPIN_MODE_TX_LOCKED_MEMORY RTE_BIT32(16)
-#define HAIRPIN_MODE_TX_RTE_MEMORY RTE_BIT32(17)
-
-
 /* Configure the Rx and Tx hairpin queues for the selected port. */
 static int
-setup_hairpin_queues(portid_t pi, portid_t p_pi, uint16_t cnt_pi)
+setup_hairpin_queues(portid_t pi)
 {
 	queueid_t qi;
 	struct rte_eth_hairpin_conf hairpin_conf = {
@@ -2620,58 +2086,10 @@
 	int i;
 	int diag;
 	struct rte_port *port = &ports[pi];
-	uint16_t peer_rx_port = pi;
-	uint16_t peer_tx_port = pi;
-	uint32_t manual = 1;
-	uint32_t tx_exp = hairpin_mode & 0x10;
-	uint32_t rx_force_memory = hairpin_mode & HAIRPIN_MODE_RX_FORCE_MEMORY;
-	uint32_t rx_locked_memory = hairpin_mode & HAIRPIN_MODE_RX_LOCKED_MEMORY;
-	uint32_t rx_rte_memory = hairpin_mode & HAIRPIN_MODE_RX_RTE_MEMORY;
-	uint32_t tx_force_memory = hairpin_mode & HAIRPIN_MODE_TX_FORCE_MEMORY;
-	uint32_t tx_locked_memory = hairpin_mode & HAIRPIN_MODE_TX_LOCKED_MEMORY;
-	uint32_t tx_rte_memory = hairpin_mode & HAIRPIN_MODE_TX_RTE_MEMORY;
-
-	if (!(hairpin_mode & 0xf)) {
-		peer_rx_port = pi;
-		peer_tx_port = pi;
-		manual = 0;
-	} else if (hairpin_mode & 0x1) {
-		peer_tx_port = rte_eth_find_next_owned_by(pi + 1,
-						       RTE_ETH_DEV_NO_OWNER);
-		if (peer_tx_port >= RTE_MAX_ETHPORTS)
-			peer_tx_port = rte_eth_find_next_owned_by(0,
-						RTE_ETH_DEV_NO_OWNER);
-		if (p_pi != RTE_MAX_ETHPORTS) {
-			peer_rx_port = p_pi;
-		} else {
-			uint16_t next_pi;
-
-			/* Last port will be the peer RX port of the first. */
-			RTE_ETH_FOREACH_DEV(next_pi)
-				peer_rx_port = next_pi;
-		}
-		manual = 1;
-	} else if (hairpin_mode & 0x2) {
-		if (cnt_pi & 0x1) {
-			peer_rx_port = p_pi;
-		} else {
-			peer_rx_port = rte_eth_find_next_owned_by(pi + 1,
-						RTE_ETH_DEV_NO_OWNER);
-			if (peer_rx_port >= RTE_MAX_ETHPORTS)
-				peer_rx_port = pi;
-		}
-		peer_tx_port = peer_rx_port;
-		manual = 1;
-	}
 
 	for (qi = nb_txq, i = 0; qi < nb_hairpinq + nb_txq; qi++) {
-		hairpin_conf.peers[0].port = peer_rx_port;
+		hairpin_conf.peers[0].port = pi;
 		hairpin_conf.peers[0].queue = i + nb_rxq;
-		hairpin_conf.manual_bind = !!manual;
-		hairpin_conf.tx_explicit = !!tx_exp;
-		hairpin_conf.force_memory = !!tx_force_memory;
-		hairpin_conf.use_locked_device_memory = !!tx_locked_memory;
-		hairpin_conf.use_rte_memory = !!tx_rte_memory;
 		diag = rte_eth_tx_hairpin_queue_setup
 			(pi, qi, nb_txd, &hairpin_conf);
 		i++;
@@ -2679,25 +2097,20 @@
 			continue;
 
 		/* Fail to setup rx queue, return */
-		if (port->port_status == RTE_PORT_HANDLING)
-			port->port_status = RTE_PORT_STOPPED;
-		else
-			fprintf(stderr,
-				"Port %d can not be set back to stopped\n", pi);
-		fprintf(stderr, "Fail to configure port %d hairpin queues\n",
-			pi);
+		if (rte_atomic16_cmpset(&(port->port_status),
+					RTE_PORT_HANDLING,
+					RTE_PORT_STOPPED) == 0)
+			printf("Port %d can not be set back "
+					"to stopped\n", pi);
+		printf("Fail to configure port %d hairpin "
+				"queues\n", pi);
 		/* try to reconfigure queues next time */
 		port->need_reconfig_queues = 1;
 		return -1;
 	}
 	for (qi = nb_rxq, i = 0; qi < nb_hairpinq + nb_rxq; qi++) {
-		hairpin_conf.peers[0].port = peer_tx_port;
+		hairpin_conf.peers[0].port = pi;
 		hairpin_conf.peers[0].queue = i + nb_txq;
-		hairpin_conf.manual_bind = !!manual;
-		hairpin_conf.tx_explicit = !!tx_exp;
-		hairpin_conf.force_memory = !!rx_force_memory;
-		hairpin_conf.use_locked_device_memory = !!rx_locked_memory;
-		hairpin_conf.use_rte_memory = !!rx_rte_memory;
 		diag = rte_eth_rx_hairpin_queue_setup
 			(pi, qi, nb_rxd, &hairpin_conf);
 		i++;
@@ -2705,13 +2118,13 @@
 			continue;
 
 		/* Fail to setup rx queue, return */
-		if (port->port_status == RTE_PORT_HANDLING)
-			port->port_status = RTE_PORT_STOPPED;
-		else
-			fprintf(stderr,
-				"Port %d can not be set back to stopped\n", pi);
-		fprintf(stderr, "Fail to configure port %d hairpin queues\n",
-			pi);
+		if (rte_atomic16_cmpset(&(port->port_status),
+					RTE_PORT_HANDLING,
+					RTE_PORT_STOPPED) == 0)
+			printf("Port %d can not be set back "
+					"to stopped\n", pi);
+		printf("Fail to configure port %d hairpin "
+				"queues\n", pi);
 		/* try to reconfigure queues next time */
 		port->need_reconfig_queues = 1;
 		return -1;
@@ -2719,290 +2132,41 @@
 	return 0;
 }
 
-/* Configure the Rx with optional split. */
-int
-rx_queue_setup(uint16_t port_id, uint16_t rx_queue_id,
-	       uint16_t nb_rx_desc, unsigned int socket_id,
-	       struct rte_eth_rxconf *rx_conf, struct rte_mempool *mp)
-{
-	union rte_eth_rxseg rx_useg[MAX_SEGS_BUFFER_SPLIT] = {};
-	struct rte_mempool *rx_mempool[MAX_MEMPOOL] = {};
-	struct rte_mempool *mpx;
-	unsigned int i, mp_n;
-	uint32_t prev_hdrs = 0;
-	int ret;
-
-
-	if ((rx_pkt_nb_segs > 1) &&
-	    (rx_conf->offloads & RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT)) {
-		/* multi-segment configuration */
-		for (i = 0; i < rx_pkt_nb_segs; i++) {
-			struct rte_eth_rxseg_split *rx_seg = &rx_useg[i].split;
-			/*
-			 * Use last valid pool for the segments with number
-			 * exceeding the pool index.
-			 */
-			mp_n = (i >= mbuf_data_size_n) ? mbuf_data_size_n - 1 : i;
-			mpx = mbuf_pool_find(socket_id, mp_n);
-			/* Handle zero as mbuf data buffer size. */
-			rx_seg->offset = i < rx_pkt_nb_offs ?
-					   rx_pkt_seg_offsets[i] : 0;
-			rx_seg->mp = mpx ? mpx : mp;
-			if (rx_pkt_hdr_protos[i] != 0 && rx_pkt_seg_lengths[i] == 0) {
-				rx_seg->proto_hdr = rx_pkt_hdr_protos[i] & ~prev_hdrs;
-				prev_hdrs |= rx_seg->proto_hdr;
-			} else {
-				rx_seg->length = rx_pkt_seg_lengths[i] ?
-						rx_pkt_seg_lengths[i] :
-						mbuf_data_size[mp_n];
-			}
-		}
-		rx_conf->rx_nseg = rx_pkt_nb_segs;
-		rx_conf->rx_seg = rx_useg;
-		rx_conf->rx_mempools = NULL;
-		rx_conf->rx_nmempool = 0;
-		ret = rte_eth_rx_queue_setup(port_id, rx_queue_id, nb_rx_desc,
-				    socket_id, rx_conf, NULL);
-		rx_conf->rx_seg = NULL;
-		rx_conf->rx_nseg = 0;
-	} else if (multi_rx_mempool == 1) {
-		/* multi-pool configuration */
-		struct rte_eth_dev_info dev_info;
-
-		if (mbuf_data_size_n <= 1) {
-			fprintf(stderr, "Invalid number of mempools %u\n",
-				mbuf_data_size_n);
-			return -EINVAL;
-		}
-		ret = rte_eth_dev_info_get(port_id, &dev_info);
-		if (ret != 0)
-			return ret;
-		if (dev_info.max_rx_mempools == 0) {
-			fprintf(stderr,
-				"Port %u doesn't support requested multi-rx-mempool configuration.\n",
-				port_id);
-			return -ENOTSUP;
-		}
-		for (i = 0; i < mbuf_data_size_n; i++) {
-			mpx = mbuf_pool_find(socket_id, i);
-			rx_mempool[i] = mpx ? mpx : mp;
-		}
-		rx_conf->rx_mempools = rx_mempool;
-		rx_conf->rx_nmempool = mbuf_data_size_n;
-		rx_conf->rx_seg = NULL;
-		rx_conf->rx_nseg = 0;
-		ret = rte_eth_rx_queue_setup(port_id, rx_queue_id, nb_rx_desc,
-				    socket_id, rx_conf, NULL);
-		rx_conf->rx_mempools = NULL;
-		rx_conf->rx_nmempool = 0;
-	} else {
-		/* Single pool/segment configuration */
-		rx_conf->rx_seg = NULL;
-		rx_conf->rx_nseg = 0;
-		rx_conf->rx_mempools = NULL;
-		rx_conf->rx_nmempool = 0;
-		ret = rte_eth_rx_queue_setup(port_id, rx_queue_id, nb_rx_desc,
-				    socket_id, rx_conf, mp);
-	}
-
-	ports[port_id].rxq[rx_queue_id].state = rx_conf->rx_deferred_start ?
-						RTE_ETH_QUEUE_STATE_STOPPED :
-						RTE_ETH_QUEUE_STATE_STARTED;
-	return ret;
-}
-
-static int
-alloc_xstats_display_info(portid_t pi)
-{
-	uint64_t **ids_supp = &ports[pi].xstats_info.ids_supp;
-	uint64_t **prev_values = &ports[pi].xstats_info.prev_values;
-	uint64_t **curr_values = &ports[pi].xstats_info.curr_values;
-
-	if (xstats_display_num == 0)
-		return 0;
-
-	*ids_supp = calloc(xstats_display_num, sizeof(**ids_supp));
-	if (*ids_supp == NULL)
-		goto fail_ids_supp;
-
-	*prev_values = calloc(xstats_display_num,
-			      sizeof(**prev_values));
-	if (*prev_values == NULL)
-		goto fail_prev_values;
-
-	*curr_values = calloc(xstats_display_num,
-			      sizeof(**curr_values));
-	if (*curr_values == NULL)
-		goto fail_curr_values;
-
-	ports[pi].xstats_info.allocated = true;
-
-	return 0;
-
-fail_curr_values:
-	free(*prev_values);
-fail_prev_values:
-	free(*ids_supp);
-fail_ids_supp:
-	return -ENOMEM;
-}
-
-static void
-free_xstats_display_info(portid_t pi)
-{
-	if (!ports[pi].xstats_info.allocated)
-		return;
-	free(ports[pi].xstats_info.ids_supp);
-	free(ports[pi].xstats_info.prev_values);
-	free(ports[pi].xstats_info.curr_values);
-	ports[pi].xstats_info.allocated = false;
-}
-
-/** Fill helper structures for specified port to show extended statistics. */
-static void
-fill_xstats_display_info_for_port(portid_t pi)
-{
-	unsigned int stat, stat_supp;
-	const char *xstat_name;
-	struct rte_port *port;
-	uint64_t *ids_supp;
-	int rc;
-
-	if (xstats_display_num == 0)
-		return;
-
-	if (pi == (portid_t)RTE_PORT_ALL) {
-		fill_xstats_display_info();
-		return;
-	}
-
-	port = &ports[pi];
-	if (port->port_status != RTE_PORT_STARTED)
-		return;
-
-	if (!port->xstats_info.allocated && alloc_xstats_display_info(pi) != 0)
-		rte_exit(EXIT_FAILURE,
-			 "Failed to allocate xstats display memory\n");
-
-	ids_supp = port->xstats_info.ids_supp;
-	for (stat = stat_supp = 0; stat < xstats_display_num; stat++) {
-		xstat_name = xstats_display[stat].name;
-		rc = rte_eth_xstats_get_id_by_name(pi, xstat_name,
-						   ids_supp + stat_supp);
-		if (rc != 0) {
-			fprintf(stderr, "No xstat '%s' on port %u - skip it %u\n",
-				xstat_name, pi, stat);
-			continue;
-		}
-		stat_supp++;
-	}
-
-	port->xstats_info.ids_supp_sz = stat_supp;
-}
-
-/** Fill helper structures for all ports to show extended statistics. */
-static void
-fill_xstats_display_info(void)
-{
-	portid_t pi;
-
-	if (xstats_display_num == 0)
-		return;
-
-	RTE_ETH_FOREACH_DEV(pi)
-		fill_xstats_display_info_for_port(pi);
-}
-
-/*
- * Some capabilities (like, rx_offload_capa and tx_offload_capa) of bonding
- * device in dev_info is zero when no slave is added. And its capability
- * will be updated when add a new slave device. So adding a slave device need
- * to update the port configurations of bonding device.
- */
-static void
-update_bonding_port_dev_conf(portid_t bond_pid)
-{
-#ifdef RTE_NET_BOND
-	struct rte_port *port = &ports[bond_pid];
-	uint16_t i;
-	int ret;
-
-	ret = eth_dev_info_get_print_err(bond_pid, &port->dev_info);
-	if (ret != 0) {
-		fprintf(stderr, "Failed to get dev info for port = %u\n",
-			bond_pid);
-		return;
-	}
-
-	if (port->dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE)
-		port->dev_conf.txmode.offloads |=
-				RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE;
-	/* Apply Tx offloads configuration */
-	for (i = 0; i < port->dev_info.max_tx_queues; i++)
-		port->txq[i].conf.offloads = port->dev_conf.txmode.offloads;
-
-	port->dev_conf.rx_adv_conf.rss_conf.rss_hf &=
-				port->dev_info.flow_type_rss_offloads;
-#else
-	RTE_SET_USED(bond_pid);
-#endif
-}
-
 int
 start_port(portid_t pid)
 {
-	int diag;
+	int diag, need_check_link_status = -1;
 	portid_t pi;
-	portid_t p_pi = RTE_MAX_ETHPORTS;
-	portid_t pl[RTE_MAX_ETHPORTS];
-	portid_t peer_pl[RTE_MAX_ETHPORTS];
-	uint16_t cnt_pi = 0;
-	uint16_t cfg_pi = 0;
-	int peer_pi;
 	queueid_t qi;
 	struct rte_port *port;
+	struct rte_ether_addr mac_addr;
 	struct rte_eth_hairpin_cap cap;
-	bool at_least_one_port_exist = false;
-	bool all_ports_already_started = true;
-	bool at_least_one_port_successfully_started = false;
 
 	if (port_id_is_invalid(pid, ENABLED_WARN))
 		return 0;
 
+	if(dcb_config)
+		dcb_test = 1;
 	RTE_ETH_FOREACH_DEV(pi) {
 		if (pid != pi && pid != (portid_t)RTE_PORT_ALL)
 			continue;
 
-		if (port_is_bonding_slave(pi)) {
-			fprintf(stderr,
-				"Please remove port %d from bonded device.\n",
-				pi);
-			continue;
-		}
-
-		at_least_one_port_exist = true;
-
+		need_check_link_status = 0;
 		port = &ports[pi];
-		if (port->port_status == RTE_PORT_STOPPED) {
-			port->port_status = RTE_PORT_HANDLING;
-			all_ports_already_started = false;
-		} else {
-			fprintf(stderr, "Port %d is now not stopped\n", pi);
+		if (rte_atomic16_cmpset(&(port->port_status), RTE_PORT_STOPPED,
+						 RTE_PORT_HANDLING) == 0) {
+			printf("Port %d is now not stopped\n", pi);
 			continue;
 		}
 
 		if (port->need_reconfig > 0) {
-			struct rte_eth_conf dev_conf;
-			int k;
-
 			port->need_reconfig = 0;
 
 			if (flow_isolate_all) {
 				int ret = port_flow_isolate(pi, 1);
 				if (ret) {
-					fprintf(stderr,
-						"Failed to apply isolated mode on port %d\n",
-						pi);
+					printf("Failed to apply isolated"
+					       " mode on port %d\n", pi);
 					return -1;
 				}
 			}
@@ -3011,102 +2175,52 @@
 					port->socket_id);
 			if (nb_hairpinq > 0 &&
 			    rte_eth_dev_hairpin_capability_get(pi, &cap)) {
-				fprintf(stderr,
-					"Port %d doesn't support hairpin queues\n",
-					pi);
+				printf("Port %d doesn't support hairpin "
+				       "queues\n", pi);
 				return -1;
 			}
-
-			if (port->bond_flag == 1 && port->update_conf == 1) {
-				update_bonding_port_dev_conf(pi);
-				port->update_conf = 0;
-			}
-
 			/* configure port */
-			diag = eth_dev_configure_mp(pi, nb_rxq + nb_hairpinq,
+			diag = rte_eth_dev_configure(pi, nb_rxq + nb_hairpinq,
 						     nb_txq + nb_hairpinq,
 						     &(port->dev_conf));
 			if (diag != 0) {
-				if (port->port_status == RTE_PORT_HANDLING)
-					port->port_status = RTE_PORT_STOPPED;
-				else
-					fprintf(stderr,
-						"Port %d can not be set back to stopped\n",
-						pi);
-				fprintf(stderr, "Fail to configure port %d\n",
-					pi);
+				if (rte_atomic16_cmpset(&(port->port_status),
+				RTE_PORT_HANDLING, RTE_PORT_STOPPED) == 0)
+					printf("Port %d can not be set back "
+							"to stopped\n", pi);
+				printf("Fail to configure port %d\n", pi);
 				/* try to reconfigure port next time */
 				port->need_reconfig = 1;
 				return -1;
 			}
-			/* get device configuration*/
-			if (0 !=
-				eth_dev_conf_get_print_err(pi, &dev_conf)) {
-				fprintf(stderr,
-					"port %d can not get device configuration\n",
-					pi);
-				return -1;
-			}
-			/* Apply Rx offloads configuration */
-			if (dev_conf.rxmode.offloads !=
-			    port->dev_conf.rxmode.offloads) {
-				port->dev_conf.rxmode.offloads |=
-					dev_conf.rxmode.offloads;
-				for (k = 0;
-				     k < port->dev_info.max_rx_queues;
-				     k++)
-					port->rxq[k].conf.offloads |=
-						dev_conf.rxmode.offloads;
-			}
-			/* Apply Tx offloads configuration */
-			if (dev_conf.txmode.offloads !=
-			    port->dev_conf.txmode.offloads) {
-				port->dev_conf.txmode.offloads |=
-					dev_conf.txmode.offloads;
-				for (k = 0;
-				     k < port->dev_info.max_tx_queues;
-				     k++)
-					port->txq[k].conf.offloads |=
-						dev_conf.txmode.offloads;
-			}
 		}
-		if (port->need_reconfig_queues > 0 && is_proc_primary()) {
+		if (port->need_reconfig_queues > 0) {
 			port->need_reconfig_queues = 0;
 			/* setup tx queues */
 			for (qi = 0; qi < nb_txq; qi++) {
-				struct rte_eth_txconf *conf =
-							&port->txq[qi].conf;
-
 				if ((numa_support) &&
 					(txring_numa[pi] != NUMA_NO_CONFIG))
 					diag = rte_eth_tx_queue_setup(pi, qi,
 						port->nb_tx_desc[qi],
 						txring_numa[pi],
-						&(port->txq[qi].conf));
+						&(port->tx_conf[qi]));
 				else
 					diag = rte_eth_tx_queue_setup(pi, qi,
 						port->nb_tx_desc[qi],
 						port->socket_id,
-						&(port->txq[qi].conf));
+						&(port->tx_conf[qi]));
 
-				if (diag == 0) {
-					port->txq[qi].state =
-						conf->tx_deferred_start ?
-						RTE_ETH_QUEUE_STATE_STOPPED :
-						RTE_ETH_QUEUE_STATE_STARTED;
+				if (diag == 0)
 					continue;
-				}
 
 				/* Fail to setup tx queue, return */
-				if (port->port_status == RTE_PORT_HANDLING)
-					port->port_status = RTE_PORT_STOPPED;
-				else
-					fprintf(stderr,
-						"Port %d can not be set back to stopped\n",
-						pi);
-				fprintf(stderr,
-					"Fail to configure port %d tx queues\n",
-					pi);
+				if (rte_atomic16_cmpset(&(port->port_status),
+							RTE_PORT_HANDLING,
+							RTE_PORT_STOPPED) == 0)
+					printf("Port %d can not be set back "
+							"to stopped\n", pi);
+				printf("Fail to configure port %d tx queues\n",
+				       pi);
 				/* try to reconfigure queues next time */
 				port->need_reconfig_queues = 1;
 				return -1;
@@ -3116,55 +2230,53 @@
 				if ((numa_support) &&
 					(rxring_numa[pi] != NUMA_NO_CONFIG)) {
 					struct rte_mempool * mp =
-						mbuf_pool_find
-							(rxring_numa[pi], 0);
+						mbuf_pool_find(rxring_numa[pi]);
 					if (mp == NULL) {
-						fprintf(stderr,
-							"Failed to setup RX queue: No mempool allocation on the socket %d\n",
+						printf("Failed to setup RX queue:"
+							"No mempool allocation"
+							" on the socket %d\n",
 							rxring_numa[pi]);
 						return -1;
 					}
 
-					diag = rx_queue_setup(pi, qi,
+					diag = rte_eth_rx_queue_setup(pi, qi,
 					     port->nb_rx_desc[qi],
 					     rxring_numa[pi],
-					     &(port->rxq[qi].conf),
+					     &(port->rx_conf[qi]),
 					     mp);
 				} else {
 					struct rte_mempool *mp =
-						mbuf_pool_find
-							(port->socket_id, 0);
+						mbuf_pool_find(port->socket_id);
 					if (mp == NULL) {
-						fprintf(stderr,
-							"Failed to setup RX queue: No mempool allocation on the socket %d\n",
+						printf("Failed to setup RX queue:"
+							"No mempool allocation"
+							" on the socket %d\n",
 							port->socket_id);
 						return -1;
 					}
-					diag = rx_queue_setup(pi, qi,
+					diag = rte_eth_rx_queue_setup(pi, qi,
 					     port->nb_rx_desc[qi],
 					     port->socket_id,
-					     &(port->rxq[qi].conf),
+					     &(port->rx_conf[qi]),
 					     mp);
 				}
 				if (diag == 0)
 					continue;
 
 				/* Fail to setup rx queue, return */
-				if (port->port_status == RTE_PORT_HANDLING)
-					port->port_status = RTE_PORT_STOPPED;
-				else
-					fprintf(stderr,
-						"Port %d can not be set back to stopped\n",
-						pi);
-				fprintf(stderr,
-					"Fail to configure port %d rx queues\n",
-					pi);
+				if (rte_atomic16_cmpset(&(port->port_status),
+							RTE_PORT_HANDLING,
+							RTE_PORT_STOPPED) == 0)
+					printf("Port %d can not be set back "
+							"to stopped\n", pi);
+				printf("Fail to configure port %d rx queues\n",
+				       pi);
 				/* try to reconfigure queues next time */
 				port->need_reconfig_queues = 1;
 				return -1;
 			}
 			/* setup hairpin queues */
-			if (setup_hairpin_queues(pi, p_pi, cnt_pi) != 0)
+			if (setup_hairpin_queues(pi) != 0)
 				return -1;
 		}
 		configure_rxtx_dump_callbacks(verbose_level);
@@ -3172,98 +2284,41 @@
 			diag = rte_eth_dev_set_ptypes(pi, RTE_PTYPE_UNKNOWN,
 					NULL, 0);
 			if (diag < 0)
-				fprintf(stderr,
-					"Port %d: Failed to disable Ptype parsing\n",
-					pi);
+				printf(
+				"Port %d: Failed to disable Ptype parsing\n",
+				pi);
 		}
 
-		p_pi = pi;
-		cnt_pi++;
-
 		/* start port */
-		diag = eth_dev_start_mp(pi);
-		if (diag < 0) {
-			fprintf(stderr, "Fail to start port %d: %s\n",
-				pi, rte_strerror(-diag));
+		if (rte_eth_dev_start(pi) < 0) {
+			printf("Fail to start port %d\n", pi);
 
 			/* Fail to setup rx queue, return */
-			if (port->port_status == RTE_PORT_HANDLING)
-				port->port_status = RTE_PORT_STOPPED;
-			else
-				fprintf(stderr,
-					"Port %d can not be set back to stopped\n",
-					pi);
+			if (rte_atomic16_cmpset(&(port->port_status),
+				RTE_PORT_HANDLING, RTE_PORT_STOPPED) == 0)
+				printf("Port %d can not be set back to "
+							"stopped\n", pi);
 			continue;
 		}
 
-		if (port->port_status == RTE_PORT_HANDLING)
-			port->port_status = RTE_PORT_STARTED;
-		else
-			fprintf(stderr, "Port %d can not be set into started\n",
-				pi);
-
-		if (eth_macaddr_get_print_err(pi, &port->eth_addr) == 0)
-			printf("Port %d: " RTE_ETHER_ADDR_PRT_FMT "\n", pi,
-					RTE_ETHER_ADDR_BYTES(&port->eth_addr));
+		if (rte_atomic16_cmpset(&(port->port_status),
+			RTE_PORT_HANDLING, RTE_PORT_STARTED) == 0)
+			printf("Port %d can not be set into started\n", pi);
 
-		at_least_one_port_successfully_started = true;
+		if (eth_macaddr_get_print_err(pi, &mac_addr) == 0)
+			printf("Port %d: %02X:%02X:%02X:%02X:%02X:%02X\n", pi,
+				mac_addr.addr_bytes[0], mac_addr.addr_bytes[1],
+				mac_addr.addr_bytes[2], mac_addr.addr_bytes[3],
+				mac_addr.addr_bytes[4], mac_addr.addr_bytes[5]);
 
-		pl[cfg_pi++] = pi;
+		/* at least one port started, need checking link status */
+		need_check_link_status = 1;
 	}
 
-	if (rte_eal_process_type() == RTE_PROC_SECONDARY)
-		update_queue_state();
-
-	if (at_least_one_port_successfully_started && !no_link_check)
+	if (need_check_link_status == 1 && !no_link_check)
 		check_all_ports_link_status(RTE_PORT_ALL);
-	else if (at_least_one_port_exist & all_ports_already_started)
-		fprintf(stderr, "Please stop the ports first\n");
-
-	if (hairpin_mode & 0xf) {
-		uint16_t i;
-		int j;
-
-		/* bind all started hairpin ports */
-		for (i = 0; i < cfg_pi; i++) {
-			pi = pl[i];
-			/* bind current Tx to all peer Rx */
-			peer_pi = rte_eth_hairpin_get_peer_ports(pi, peer_pl,
-							RTE_MAX_ETHPORTS, 1);
-			if (peer_pi < 0)
-				return peer_pi;
-			for (j = 0; j < peer_pi; j++) {
-				if (!port_is_started(peer_pl[j]))
-					continue;
-				diag = rte_eth_hairpin_bind(pi, peer_pl[j]);
-				if (diag < 0) {
-					fprintf(stderr,
-						"Error during binding hairpin Tx port %u to %u: %s\n",
-						pi, peer_pl[j],
-						rte_strerror(-diag));
-					return -1;
-				}
-			}
-			/* bind all peer Tx to current Rx */
-			peer_pi = rte_eth_hairpin_get_peer_ports(pi, peer_pl,
-							RTE_MAX_ETHPORTS, 0);
-			if (peer_pi < 0)
-				return peer_pi;
-			for (j = 0; j < peer_pi; j++) {
-				if (!port_is_started(peer_pl[j]))
-					continue;
-				diag = rte_eth_hairpin_bind(peer_pl[j], pi);
-				if (diag < 0) {
-					fprintf(stderr,
-						"Error during binding hairpin Tx port %u to %u: %s\n",
-						peer_pl[j], pi,
-						rte_strerror(-diag));
-					return -1;
-				}
-			}
-		}
-	}
-
-	fill_xstats_display_info_for_port(pid);
+	else if (need_check_link_status == 0)
+		printf("Please stop the ports first\n");
 
 	printf("Done\n");
 	return 0;
@@ -3275,9 +2330,11 @@
 	portid_t pi;
 	struct rte_port *port;
 	int need_check_link_status = 0;
-	portid_t peer_pl[RTE_MAX_ETHPORTS];
-	int peer_pi;
-	int ret;
+
+	if (dcb_test) {
+		dcb_test = 0;
+		dcb_config = 0;
+	}
 
 	if (port_id_is_invalid(pid, ENABLED_WARN))
 		return;
@@ -3289,58 +2346,25 @@
 			continue;
 
 		if (port_is_forwarding(pi) != 0 && test_done == 0) {
-			fprintf(stderr,
-				"Please remove port %d from forwarding configuration.\n",
-				pi);
+			printf("Please remove port %d from forwarding configuration.\n", pi);
 			continue;
 		}
 
 		if (port_is_bonding_slave(pi)) {
-			fprintf(stderr,
-				"Please remove port %d from bonded device.\n",
-				pi);
+			printf("Please remove port %d from bonded device.\n", pi);
 			continue;
 		}
 
 		port = &ports[pi];
-		if (port->port_status == RTE_PORT_STARTED)
-			port->port_status = RTE_PORT_HANDLING;
-		else
+		if (rte_atomic16_cmpset(&(port->port_status), RTE_PORT_STARTED,
+						RTE_PORT_HANDLING) == 0)
 			continue;
 
-		if (hairpin_mode & 0xf) {
-			int j;
+		rte_eth_dev_stop(pi);
 
-			rte_eth_hairpin_unbind(pi, RTE_MAX_ETHPORTS);
-			/* unbind all peer Tx from current Rx */
-			peer_pi = rte_eth_hairpin_get_peer_ports(pi, peer_pl,
-							RTE_MAX_ETHPORTS, 0);
-			if (peer_pi < 0)
-				continue;
-			for (j = 0; j < peer_pi; j++) {
-				if (!port_is_started(peer_pl[j]))
-					continue;
-				rte_eth_hairpin_unbind(peer_pl[j], pi);
-			}
-		}
-
-		if (port->flow_list)
-			port_flow_flush(pi);
-
-		ret = eth_dev_stop_mp(pi);
-		if (ret != 0) {
-			RTE_LOG(ERR, EAL, "rte_eth_dev_stop failed for port %u\n",
-				pi);
-			/* Allow to retry stopping the port. */
-			port->port_status = RTE_PORT_STARTED;
-			continue;
-		}
-
-		if (port->port_status == RTE_PORT_HANDLING)
-			port->port_status = RTE_PORT_STOPPED;
-		else
-			fprintf(stderr, "Port %d can not be set into stopped\n",
-				pi);
+		if (rte_atomic16_cmpset(&(port->port_status),
+			RTE_PORT_HANDLING, RTE_PORT_STOPPED) == 0)
+			printf("Port %d can not be set into stopped\n", pi);
 		need_check_link_status = 1;
 	}
 	if (need_check_link_status && !no_link_check)
@@ -3371,51 +2395,11 @@
 	nb_cfg_ports = nb_fwd_ports;
 }
 
-static void
-flush_port_owned_resources(portid_t pi)
-{
-	mcast_addr_pool_destroy(pi);
-	port_flow_flush(pi);
-	port_flex_item_flush(pi);
-	port_flow_template_table_flush(pi);
-	port_flow_pattern_template_flush(pi);
-	port_flow_actions_template_flush(pi);
-	port_action_handle_flush(pi);
-}
-
-static void
-clear_bonding_slave_device(portid_t *slave_pids, uint16_t num_slaves)
-{
-	struct rte_port *port;
-	portid_t slave_pid;
-	uint16_t i;
-
-	for (i = 0; i < num_slaves; i++) {
-		slave_pid = slave_pids[i];
-		if (port_is_started(slave_pid) == 1) {
-			if (rte_eth_dev_stop(slave_pid) != 0)
-				fprintf(stderr, "rte_eth_dev_stop failed for port %u\n",
-					slave_pid);
-
-			port = &ports[slave_pid];
-			port->port_status = RTE_PORT_STOPPED;
-		}
-
-		clear_port_slave_flag(slave_pid);
-
-		/* Close slave device when testpmd quit or is killed. */
-		if (cl_quit == 1 || f_quit == 1)
-			rte_eth_dev_close(slave_pid);
-	}
-}
-
 void
 close_port(portid_t pid)
 {
 	portid_t pi;
 	struct rte_port *port;
-	portid_t slave_pids[RTE_MAX_ETHPORTS];
-	int num_slaves = 0;
 
 	if (port_id_is_invalid(pid, ENABLED_WARN))
 		return;
@@ -3427,46 +2411,39 @@
 			continue;
 
 		if (port_is_forwarding(pi) != 0 && test_done == 0) {
-			fprintf(stderr,
-				"Please remove port %d from forwarding configuration.\n",
-				pi);
+			printf("Please remove port %d from forwarding configuration.\n", pi);
 			continue;
 		}
 
 		if (port_is_bonding_slave(pi)) {
-			fprintf(stderr,
-				"Please remove port %d from bonded device.\n",
-				pi);
+			printf("Please remove port %d from bonded device.\n", pi);
 			continue;
 		}
 
 		port = &ports[pi];
-		if (port->port_status == RTE_PORT_CLOSED) {
-			fprintf(stderr, "Port %d is already closed\n", pi);
+		if (rte_atomic16_cmpset(&(port->port_status),
+			RTE_PORT_CLOSED, RTE_PORT_CLOSED) == 1) {
+			printf("Port %d is already closed\n", pi);
 			continue;
 		}
 
-		if (is_proc_primary()) {
-			flush_port_owned_resources(pi);
-#ifdef RTE_NET_BOND
-			if (port->bond_flag == 1)
-				num_slaves = rte_eth_bond_slaves_get(pi,
-						slave_pids, RTE_MAX_ETHPORTS);
-#endif
-			rte_eth_dev_close(pi);
-			/*
-			 * If this port is bonded device, all slaves under the
-			 * device need to be removed or closed.
-			 */
-			if (port->bond_flag == 1 && num_slaves > 0)
-				clear_bonding_slave_device(slave_pids,
-							num_slaves);
+		if (rte_atomic16_cmpset(&(port->port_status),
+			RTE_PORT_STOPPED, RTE_PORT_HANDLING) == 0) {
+			printf("Port %d is now not stopped\n", pi);
+			continue;
 		}
 
-		free_xstats_display_info(pi);
+		if (port->flow_list)
+			port_flow_flush(pi);
+		rte_eth_dev_close(pi);
+
+		remove_invalid_ports();
+
+		if (rte_atomic16_cmpset(&(port->port_status),
+			RTE_PORT_HANDLING, RTE_PORT_CLOSED) == 0)
+			printf("Port %d cannot be set to closed\n", pi);
 	}
 
-	remove_invalid_ports();
 	printf("Done\n");
 }
 
@@ -3482,8 +2459,7 @@
 
 	if ((pid == (portid_t)RTE_PORT_ALL && !all_ports_stopped()) ||
 		(pid != (portid_t)RTE_PORT_ALL && !port_is_stopped(pid))) {
-		fprintf(stderr,
-			"Can not reset port(s), please stop port(s) first.\n");
+		printf("Can not reset port(s), please stop port(s) first.\n");
 		return;
 	}
 
@@ -3494,29 +2470,24 @@
 			continue;
 
 		if (port_is_forwarding(pi) != 0 && test_done == 0) {
-			fprintf(stderr,
-				"Please remove port %d from forwarding configuration.\n",
-				pi);
+			printf("Please remove port %d from forwarding "
+			       "configuration.\n", pi);
 			continue;
 		}
 
 		if (port_is_bonding_slave(pi)) {
-			fprintf(stderr,
-				"Please remove port %d from bonded device.\n",
-				pi);
+			printf("Please remove port %d from bonded device.\n",
+			       pi);
 			continue;
 		}
 
-		if (is_proc_primary()) {
-			diag = rte_eth_dev_reset(pi);
-			if (diag == 0) {
-				port = &ports[pi];
-				port->need_reconfig = 1;
-				port->need_reconfig_queues = 1;
-			} else {
-				fprintf(stderr, "Failed to reset port %d. diag=%d\n",
-					pi, diag);
-			}
+		diag = rte_eth_dev_reset(pi);
+		if (diag == 0) {
+			port = &ports[pi];
+			port->need_reconfig = 1;
+			port->need_reconfig_queues = 1;
+		} else {
+			printf("Failed to reset port %d. diag=%d\n", pi, diag);
 		}
 	}
 
@@ -3532,7 +2503,7 @@
 	printf("Attaching a new port...\n");
 
 	if (identifier == NULL) {
-		fprintf(stderr, "Invalid parameters are specified\n");
+		printf("Invalid parameters are specified\n");
 		return;
 	}
 
@@ -3573,8 +2544,7 @@
 	reconfig(pi, socket_id);
 	ret = rte_eth_promiscuous_enable(pi);
 	if (ret != 0)
-		fprintf(stderr,
-			"Error during enabling promiscuous mode for port %u: %s - ignore\n",
+		printf("Error during enabling promiscuous mode for port %u: %s - ignore\n",
 			pi, rte_strerror(-ret));
 
 	ports_ids[nb_ports++] = pi;
@@ -3587,70 +2557,57 @@
 	printf("Done\n");
 }
 
-static void
-detach_device(struct rte_device *dev)
+void
+detach_port_device(portid_t port_id)
 {
+	struct rte_device *dev;
 	portid_t sibling;
 
+	printf("Removing a device...\n");
+
+	if (port_id_is_invalid(port_id, ENABLED_WARN))
+		return;
+
+	dev = rte_eth_devices[port_id].device;
 	if (dev == NULL) {
-		fprintf(stderr, "Device already removed\n");
+		printf("Device already removed\n");
 		return;
 	}
 
-	printf("Removing a device...\n");
-
-	RTE_ETH_FOREACH_DEV_OF(sibling, dev) {
-		if (ports[sibling].port_status != RTE_PORT_CLOSED) {
-			if (ports[sibling].port_status != RTE_PORT_STOPPED) {
-				fprintf(stderr, "Port %u not stopped\n",
-					sibling);
-				return;
-			}
-			flush_port_owned_resources(sibling);
+	if (ports[port_id].port_status != RTE_PORT_CLOSED) {
+		if (ports[port_id].port_status != RTE_PORT_STOPPED) {
+			printf("Port not stopped\n");
+			return;
 		}
+		printf("Port was not closed\n");
+		if (ports[port_id].flow_list)
+			port_flow_flush(port_id);
 	}
 
 	if (rte_dev_remove(dev) < 0) {
-		TESTPMD_LOG(ERR, "Failed to detach device %s\n", rte_dev_name(dev));
+		TESTPMD_LOG(ERR, "Failed to detach device %s\n", dev->name);
 		return;
 	}
+	RTE_ETH_FOREACH_DEV_OF(sibling, dev) {
+		/* reset mapping between old ports and removed device */
+		rte_eth_devices[sibling].device = NULL;
+		if (ports[sibling].port_status != RTE_PORT_CLOSED) {
+			/* sibling ports are forced to be closed */
+			ports[sibling].port_status = RTE_PORT_CLOSED;
+			printf("Port %u is closed\n", sibling);
+		}
+	}
+
 	remove_invalid_ports();
 
-	printf("Device is detached\n");
+	printf("Device of port %u is detached\n", port_id);
 	printf("Now total ports is %d\n", nb_ports);
 	printf("Done\n");
 	return;
 }
 
 void
-detach_port_device(portid_t port_id)
-{
-	int ret;
-	struct rte_eth_dev_info dev_info;
-
-	if (port_id_is_invalid(port_id, ENABLED_WARN))
-		return;
-
-	if (ports[port_id].port_status != RTE_PORT_CLOSED) {
-		if (ports[port_id].port_status != RTE_PORT_STOPPED) {
-			fprintf(stderr, "Port not stopped\n");
-			return;
-		}
-		fprintf(stderr, "Port was not closed\n");
-	}
-
-	ret = eth_dev_info_get_print_err(port_id, &dev_info);
-	if (ret != 0) {
-		TESTPMD_LOG(ERR,
-			"Failed to get device info for port %d, not detaching\n",
-			port_id);
-		return;
-	}
-	detach_device(dev_info.device);
-}
-
-void
-detach_devargs(char *identifier)
+detach_device(char *identifier)
 {
 	struct rte_dev_iterator iterator;
 	struct rte_devargs da;
@@ -3660,27 +2617,31 @@
 
 	memset(&da, 0, sizeof(da));
 	if (rte_devargs_parsef(&da, "%s", identifier)) {
-		fprintf(stderr, "cannot parse identifier\n");
+		printf("cannot parse identifier\n");
+		if (da.args)
+			free(da.args);
 		return;
 	}
 
 	RTE_ETH_FOREACH_MATCHING_DEV(port_id, identifier, &iterator) {
 		if (ports[port_id].port_status != RTE_PORT_CLOSED) {
 			if (ports[port_id].port_status != RTE_PORT_STOPPED) {
-				fprintf(stderr, "Port %u not stopped\n",
-					port_id);
+				printf("Port %u not stopped\n", port_id);
 				rte_eth_iterator_cleanup(&iterator);
-				rte_devargs_reset(&da);
 				return;
 			}
-			flush_port_owned_resources(port_id);
+
+			/* sibling ports are forced to be closed */
+			if (ports[port_id].flow_list)
+				port_flow_flush(port_id);
+			ports[port_id].port_status = RTE_PORT_CLOSED;
+			printf("Port %u is now closed\n", port_id);
 		}
 	}
 
-	if (rte_eal_hotplug_remove(rte_bus_name(da.bus), da.name) != 0) {
+	if (rte_eal_hotplug_remove(da.bus->name, da.name) != 0) {
 		TESTPMD_LOG(ERR, "Failed to detach device %s(%s)\n",
-			    da.name, rte_bus_name(da.bus));
-		rte_devargs_reset(&da);
+			    da.name, da.bus->name);
 		return;
 	}
 
@@ -3689,28 +2650,25 @@
 	printf("Device %s is detached\n", identifier);
 	printf("Now total ports is %d\n", nb_ports);
 	printf("Done\n");
-	rte_devargs_reset(&da);
 }
 
 void
 pmd_test_exit(void)
 {
 	portid_t pt_id;
-	unsigned int i;
 	int ret;
+	int i;
 
 	if (test_done == 0)
 		stop_packet_forwarding();
 
-#ifndef RTE_EXEC_ENV_WINDOWS
-	for (i = 0 ; i < RTE_DIM(mempools) ; i++) {
+	for (i = 0 ; i < RTE_MAX_NUMA_NODES ; i++) {
 		if (mempools[i]) {
 			if (mp_alloc_type == MP_ALLOC_ANON)
 				rte_mempool_mem_iter(mempools[i], dma_unmap_cb,
 						     NULL);
 		}
 	}
-#endif
 	if (ports != NULL) {
 		no_link_check = 1;
 		RTE_ETH_FOREACH_DEV(pt_id) {
@@ -3748,11 +2706,10 @@
 			return;
 		}
 	}
-	for (i = 0 ; i < RTE_DIM(mempools) ; i++) {
+	for (i = 0 ; i < RTE_MAX_NUMA_NODES ; i++) {
 		if (mempools[i])
-			mempool_free_mp(mempools[i]);
+			rte_mempool_free(mempools[i]);
 	}
-	free(xstats_display);
 
 	printf("\nBye...\n");
 }
@@ -3763,6 +2720,8 @@
 	cmd_func_t cmd_func;
 };
 
+#define PMD_TEST_CMD_NB (sizeof(pmd_test_menu) / sizeof(pmd_test_menu[0]))
+
 /* Check the link status of all ports in up to 9s, and print them finally */
 static void
 check_all_ports_link_status(uint32_t port_mask)
@@ -3773,7 +2732,6 @@
 	uint8_t count, all_ports_up, print_flag = 0;
 	struct rte_eth_link link;
 	int ret;
-	char link_status[RTE_ETH_LINK_MAX_STR_LEN];
 
 	printf("Checking link statuses...\n");
 	fflush(stdout);
@@ -3787,20 +2745,24 @@
 			if (ret < 0) {
 				all_ports_up = 0;
 				if (print_flag == 1)
-					fprintf(stderr,
-						"Port %u link get failed: %s\n",
+					printf("Port %u link get failed: %s\n",
 						portid, rte_strerror(-ret));
 				continue;
 			}
 			/* print link status if flag set */
 			if (print_flag == 1) {
-				rte_eth_link_to_str(link_status,
-					sizeof(link_status), &link);
-				printf("Port %d %s\n", portid, link_status);
+				if (link.link_status)
+					printf(
+					"Port%d Link Up. speed %u Mbps- %s\n",
+					portid, link.link_speed,
+				(link.link_duplex == ETH_LINK_FULL_DUPLEX) ?
+					("full-duplex") : ("half-duplex\n"));
+				else
+					printf("Port %d Link Down\n", portid);
 				continue;
 			}
 			/* clear all_ports_up flag if any link down */
-			if (link.link_status == RTE_ETH_LINK_DOWN) {
+			if (link.link_status == ETH_LINK_DOWN) {
 				all_ports_up = 0;
 				break;
 			}
@@ -3824,14 +2786,18 @@
 	}
 }
 
+/*
+ * This callback is for remove a port for a device. It has limitation because
+ * it is not for multiple port removal for a device.
+ * TODO: the device detach invoke will plan to be removed from user side to
+ * eal. And convert all PMDs to free port resources on ether device closing.
+ */
 static void
 rmv_port_callback(void *arg)
 {
 	int need_to_start = 0;
 	int org_no_link_check = no_link_check;
 	portid_t port_id = (intptr_t)arg;
-	struct rte_eth_dev_info dev_info;
-	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_RET(port_id);
 
@@ -3842,17 +2808,8 @@
 	no_link_check = 1;
 	stop_port(port_id);
 	no_link_check = org_no_link_check;
-
-	ret = eth_dev_info_get_print_err(port_id, &dev_info);
-	if (ret != 0)
-		TESTPMD_LOG(ERR,
-			"Failed to get device info for port %d, not detaching\n",
-			port_id);
-	else {
-		struct rte_device *device = dev_info.device;
-		close_port(port_id);
-		detach_device(device); /* might be already removed or have more ports */
-	}
+	close_port(port_id);
+	detach_port_device(port_id);
 	if (need_to_start)
 		start_packet_forwarding(0);
 }
@@ -3866,8 +2823,7 @@
 	RTE_SET_USED(ret_param);
 
 	if (type >= RTE_ETH_EVENT_MAX) {
-		fprintf(stderr,
-			"\nPort %" PRIu16 ": %s called upon invalid event %d\n",
+		fprintf(stderr, "\nPort %" PRIu16 ": %s called upon invalid event %d\n",
 			port_id, __func__, type);
 		fflush(stderr);
 	} else if (event_print_mask & (UINT32_C(1) << type)) {
@@ -3886,32 +2842,8 @@
 			break;
 		if (rte_eal_alarm_set(100000,
 				rmv_port_callback, (void *)(intptr_t)port_id))
-			fprintf(stderr,
-				"Could not set up deferred device removal\n");
-		break;
-	case RTE_ETH_EVENT_DESTROY:
-		ports[port_id].port_status = RTE_PORT_CLOSED;
-		printf("Port %u is closed\n", port_id);
+			fprintf(stderr, "Could not set up deferred device removal\n");
 		break;
-	case RTE_ETH_EVENT_RX_AVAIL_THRESH: {
-		uint16_t rxq_id;
-		int ret;
-
-		/* avail_thresh query API rewinds rxq_id, no need to check max RxQ num */
-		for (rxq_id = 0; ; rxq_id++) {
-			ret = rte_eth_rx_avail_thresh_query(port_id, &rxq_id,
-							    NULL);
-			if (ret <= 0)
-				break;
-			printf("Received avail_thresh event, port: %u, rxq_id: %u\n",
-			       port_id, rxq_id);
-
-#ifdef RTE_NET_MLX5
-			mlx5_test_avail_thresh_event_handler(port_id, rxq_id);
-#endif
-		}
-		break;
-	}
 	default:
 		break;
 	}
@@ -3990,119 +2922,151 @@
 	}
 }
 
+static int
+set_tx_queue_stats_mapping_registers(portid_t port_id, struct rte_port *port)
+{
+	uint16_t i;
+	int diag;
+	uint8_t mapping_found = 0;
+
+	for (i = 0; i < nb_tx_queue_stats_mappings; i++) {
+		if ((tx_queue_stats_mappings[i].port_id == port_id) &&
+				(tx_queue_stats_mappings[i].queue_id < nb_txq )) {
+			diag = rte_eth_dev_set_tx_queue_stats_mapping(port_id,
+					tx_queue_stats_mappings[i].queue_id,
+					tx_queue_stats_mappings[i].stats_counter_id);
+			if (diag != 0)
+				return diag;
+			mapping_found = 1;
+		}
+	}
+	if (mapping_found)
+		port->tx_queue_stats_mapping_enabled = 1;
+	return 0;
+}
+
+static int
+set_rx_queue_stats_mapping_registers(portid_t port_id, struct rte_port *port)
+{
+	uint16_t i;
+	int diag;
+	uint8_t mapping_found = 0;
+
+	for (i = 0; i < nb_rx_queue_stats_mappings; i++) {
+		if ((rx_queue_stats_mappings[i].port_id == port_id) &&
+				(rx_queue_stats_mappings[i].queue_id < nb_rxq )) {
+			diag = rte_eth_dev_set_rx_queue_stats_mapping(port_id,
+					rx_queue_stats_mappings[i].queue_id,
+					rx_queue_stats_mappings[i].stats_counter_id);
+			if (diag != 0)
+				return diag;
+			mapping_found = 1;
+		}
+	}
+	if (mapping_found)
+		port->rx_queue_stats_mapping_enabled = 1;
+	return 0;
+}
+
 static void
-rxtx_port_config(portid_t pid)
+map_port_queue_stats_mapping_registers(portid_t pi, struct rte_port *port)
 {
-	uint16_t qid;
-	uint64_t offloads;
-	struct rte_port *port = &ports[pid];
+	int diag = 0;
 
-	for (qid = 0; qid < nb_rxq; qid++) {
-		offloads = port->rxq[qid].conf.offloads;
-		port->rxq[qid].conf = port->dev_info.default_rxconf;
+	diag = set_tx_queue_stats_mapping_registers(pi, port);
+	if (diag != 0) {
+		if (diag == -ENOTSUP) {
+			port->tx_queue_stats_mapping_enabled = 0;
+			printf("TX queue stats mapping not supported port id=%d\n", pi);
+		}
+		else
+			rte_exit(EXIT_FAILURE,
+					"set_tx_queue_stats_mapping_registers "
+					"failed for port id=%d diag=%d\n",
+					pi, diag);
+	}
 
-		if (rxq_share > 0 &&
-		    (port->dev_info.dev_capa & RTE_ETH_DEV_CAPA_RXQ_SHARE)) {
-			/* Non-zero share group to enable RxQ share. */
-			port->rxq[qid].conf.share_group = pid / rxq_share + 1;
-			port->rxq[qid].conf.share_qid = qid; /* Equal mapping. */
+	diag = set_rx_queue_stats_mapping_registers(pi, port);
+	if (diag != 0) {
+		if (diag == -ENOTSUP) {
+			port->rx_queue_stats_mapping_enabled = 0;
+			printf("RX queue stats mapping not supported port id=%d\n", pi);
 		}
+		else
+			rte_exit(EXIT_FAILURE,
+					"set_rx_queue_stats_mapping_registers "
+					"failed for port id=%d diag=%d\n",
+					pi, diag);
+	}
+}
+
+static void
+rxtx_port_config(struct rte_port *port)
+{
+	uint16_t qid;
+	uint64_t offloads;
 
+	for (qid = 0; qid < nb_rxq; qid++) {
+		offloads = port->rx_conf[qid].offloads;
+		port->rx_conf[qid] = port->dev_info.default_rxconf;
 		if (offloads != 0)
-			port->rxq[qid].conf.offloads = offloads;
+			port->rx_conf[qid].offloads = offloads;
 
 		/* Check if any Rx parameters have been passed */
 		if (rx_pthresh != RTE_PMD_PARAM_UNSET)
-			port->rxq[qid].conf.rx_thresh.pthresh = rx_pthresh;
+			port->rx_conf[qid].rx_thresh.pthresh = rx_pthresh;
 
 		if (rx_hthresh != RTE_PMD_PARAM_UNSET)
-			port->rxq[qid].conf.rx_thresh.hthresh = rx_hthresh;
+			port->rx_conf[qid].rx_thresh.hthresh = rx_hthresh;
 
 		if (rx_wthresh != RTE_PMD_PARAM_UNSET)
-			port->rxq[qid].conf.rx_thresh.wthresh = rx_wthresh;
+			port->rx_conf[qid].rx_thresh.wthresh = rx_wthresh;
 
 		if (rx_free_thresh != RTE_PMD_PARAM_UNSET)
-			port->rxq[qid].conf.rx_free_thresh = rx_free_thresh;
+			port->rx_conf[qid].rx_free_thresh = rx_free_thresh;
 
 		if (rx_drop_en != RTE_PMD_PARAM_UNSET)
-			port->rxq[qid].conf.rx_drop_en = rx_drop_en;
+			port->rx_conf[qid].rx_drop_en = rx_drop_en;
 
 		port->nb_rx_desc[qid] = nb_rxd;
 	}
 
 	for (qid = 0; qid < nb_txq; qid++) {
-		offloads = port->txq[qid].conf.offloads;
-		port->txq[qid].conf = port->dev_info.default_txconf;
+		offloads = port->tx_conf[qid].offloads;
+		port->tx_conf[qid] = port->dev_info.default_txconf;
 		if (offloads != 0)
-			port->txq[qid].conf.offloads = offloads;
+			port->tx_conf[qid].offloads = offloads;
 
 		/* Check if any Tx parameters have been passed */
 		if (tx_pthresh != RTE_PMD_PARAM_UNSET)
-			port->txq[qid].conf.tx_thresh.pthresh = tx_pthresh;
+			port->tx_conf[qid].tx_thresh.pthresh = tx_pthresh;
 
 		if (tx_hthresh != RTE_PMD_PARAM_UNSET)
-			port->txq[qid].conf.tx_thresh.hthresh = tx_hthresh;
+			port->tx_conf[qid].tx_thresh.hthresh = tx_hthresh;
 
 		if (tx_wthresh != RTE_PMD_PARAM_UNSET)
-			port->txq[qid].conf.tx_thresh.wthresh = tx_wthresh;
+			port->tx_conf[qid].tx_thresh.wthresh = tx_wthresh;
 
 		if (tx_rs_thresh != RTE_PMD_PARAM_UNSET)
-			port->txq[qid].conf.tx_rs_thresh = tx_rs_thresh;
+			port->tx_conf[qid].tx_rs_thresh = tx_rs_thresh;
 
 		if (tx_free_thresh != RTE_PMD_PARAM_UNSET)
-			port->txq[qid].conf.tx_free_thresh = tx_free_thresh;
+			port->tx_conf[qid].tx_free_thresh = tx_free_thresh;
 
 		port->nb_tx_desc[qid] = nb_txd;
 	}
 }
 
-/*
- * Helper function to set MTU from frame size
- *
- * port->dev_info should be set before calling this function.
- *
- * return 0 on success, negative on error
- */
-int
-update_mtu_from_frame_size(portid_t portid, uint32_t max_rx_pktlen)
-{
-	struct rte_port *port = &ports[portid];
-	uint32_t eth_overhead;
-	uint16_t mtu, new_mtu;
-
-	eth_overhead = get_eth_overhead(&port->dev_info);
-
-	if (rte_eth_dev_get_mtu(portid, &mtu) != 0) {
-		printf("Failed to get MTU for port %u\n", portid);
-		return -1;
-	}
-
-	new_mtu = max_rx_pktlen - eth_overhead;
-
-	if (mtu == new_mtu)
-		return 0;
-
-	if (eth_dev_set_mtu_mp(portid, new_mtu) != 0) {
-		fprintf(stderr,
-			"Failed to set MTU to %u for port %u\n",
-			new_mtu, portid);
-		return -1;
-	}
-
-	port->dev_conf.rxmode.mtu = new_mtu;
-
-	return 0;
-}
-
 void
 init_port_config(void)
 {
 	portid_t pid;
 	struct rte_port *port;
-	int ret, i;
+	int ret;
 
 	RTE_ETH_FOREACH_DEV(pid) {
 		port = &ports[pid];
+		port->dev_conf.fdir_conf = fdir_conf;
 
 		ret = eth_dev_info_get_print_err(pid, &port->dev_info);
 		if (ret != 0)
@@ -4118,32 +3082,30 @@
 		}
 
 		if (port->dcb_flag == 0) {
-			if (port->dev_conf.rx_adv_conf.rss_conf.rss_hf != 0) {
-				port->dev_conf.rxmode.mq_mode =
-					(enum rte_eth_rx_mq_mode)
-						(rx_mq_mode & RTE_ETH_MQ_RX_RSS);
-			} else {
-				port->dev_conf.rxmode.mq_mode = RTE_ETH_MQ_RX_NONE;
-				port->dev_conf.rxmode.offloads &=
-						~RTE_ETH_RX_OFFLOAD_RSS_HASH;
-
-				for (i = 0;
-				     i < port->dev_info.nb_rx_queues;
-				     i++)
-					port->rxq[i].conf.offloads &=
-						~RTE_ETH_RX_OFFLOAD_RSS_HASH;
-			}
+			if( port->dev_conf.rx_adv_conf.rss_conf.rss_hf != 0)
+				port->dev_conf.rxmode.mq_mode = ETH_MQ_RX_RSS;
+			else
+				port->dev_conf.rxmode.mq_mode = ETH_MQ_RX_NONE;
 		}
 
-		rxtx_port_config(pid);
+		rxtx_port_config(port);
 
 		ret = eth_macaddr_get_print_err(pid, &port->eth_addr);
 		if (ret != 0)
 			return;
 
-		if (lsc_interrupt && (*port->dev_info.dev_flags & RTE_ETH_DEV_INTR_LSC))
+		map_port_queue_stats_mapping_registers(pid, port);
+#if defined RTE_LIBRTE_IXGBE_PMD && defined RTE_LIBRTE_IXGBE_BYPASS
+		rte_pmd_ixgbe_bypass_init(pid);
+#endif
+
+		if (lsc_interrupt &&
+		    (rte_eth_devices[pid].data->dev_flags &
+		     RTE_ETH_DEV_INTR_LSC))
 			port->dev_conf.intr_conf.lsc = 1;
-		if (rmv_interrupt && (*port->dev_info.dev_flags & RTE_ETH_DEV_INTR_RMV))
+		if (rmv_interrupt &&
+		    (rte_eth_devices[pid].data->dev_flags &
+		     RTE_ETH_DEV_INTR_RMV))
 			port->dev_conf.intr_conf.rmv = 1;
 	}
 }
@@ -4167,19 +3129,10 @@
 uint8_t port_is_bonding_slave(portid_t slave_pid)
 {
 	struct rte_port *port;
-	struct rte_eth_dev_info dev_info;
-	int ret;
 
 	port = &ports[slave_pid];
-	ret = eth_dev_info_get_print_err(slave_pid, &dev_info);
-	if (ret != 0) {
-		TESTPMD_LOG(ERR,
-			"Failed to get device info for port id %d,"
-			"cannot determine if the port is a bonded slave",
-			slave_pid);
-		return 0;
-	}
-	if ((*dev_info.dev_flags & RTE_ETH_DEV_BONDED_SLAVE) || (port->slave_flag == 1))
+	if ((rte_eth_devices[slave_pid].data->dev_flags &
+	    RTE_ETH_DEV_BONDED_SLAVE) || (port->slave_flag == 1))
 		return 1;
 	return 0;
 }
@@ -4215,9 +3168,9 @@
 		vmdq_rx_conf->enable_default_pool = 0;
 		vmdq_rx_conf->default_pool = 0;
 		vmdq_rx_conf->nb_queue_pools =
-			(num_tcs ==  RTE_ETH_4_TCS ? RTE_ETH_32_POOLS : RTE_ETH_16_POOLS);
+			(num_tcs ==  ETH_4_TCS ? ETH_32_POOLS : ETH_16_POOLS);
 		vmdq_tx_conf->nb_queue_pools =
-			(num_tcs ==  RTE_ETH_4_TCS ? RTE_ETH_32_POOLS : RTE_ETH_16_POOLS);
+			(num_tcs ==  ETH_4_TCS ? ETH_32_POOLS : ETH_16_POOLS);
 
 		vmdq_rx_conf->nb_pool_maps = vmdq_rx_conf->nb_queue_pools;
 		for (i = 0; i < vmdq_rx_conf->nb_pool_maps; i++) {
@@ -4225,24 +3178,20 @@
 			vmdq_rx_conf->pool_map[i].pools =
 				1 << (i % vmdq_rx_conf->nb_queue_pools);
 		}
-		for (i = 0; i < RTE_ETH_DCB_NUM_USER_PRIORITIES; i++) {
+		for (i = 0; i < ETH_DCB_NUM_USER_PRIORITIES; i++) {
 			vmdq_rx_conf->dcb_tc[i] = i % num_tcs;
 			vmdq_tx_conf->dcb_tc[i] = i % num_tcs;
 		}
 
 		/* set DCB mode of RX and TX of multiple queues */
-		eth_conf->rxmode.mq_mode =
-				(enum rte_eth_rx_mq_mode)
-					(rx_mq_mode & RTE_ETH_MQ_RX_VMDQ_DCB);
-		eth_conf->txmode.mq_mode = RTE_ETH_MQ_TX_VMDQ_DCB;
+		eth_conf->rxmode.mq_mode = ETH_MQ_RX_VMDQ_DCB;
+		eth_conf->txmode.mq_mode = ETH_MQ_TX_VMDQ_DCB;
 	} else {
 		struct rte_eth_dcb_rx_conf *rx_conf =
 				&eth_conf->rx_adv_conf.dcb_rx_conf;
 		struct rte_eth_dcb_tx_conf *tx_conf =
 				&eth_conf->tx_adv_conf.dcb_tx_conf;
 
-		memset(&rss_conf, 0, sizeof(struct rte_eth_rss_conf));
-
 		rc = rte_eth_dev_rss_hash_conf_get(pid, &rss_conf);
 		if (rc != 0)
 			return rc;
@@ -4250,23 +3199,21 @@
 		rx_conf->nb_tcs = num_tcs;
 		tx_conf->nb_tcs = num_tcs;
 
-		for (i = 0; i < RTE_ETH_DCB_NUM_USER_PRIORITIES; i++) {
+		for (i = 0; i < ETH_DCB_NUM_USER_PRIORITIES; i++) {
 			rx_conf->dcb_tc[i] = i % num_tcs;
 			tx_conf->dcb_tc[i] = i % num_tcs;
 		}
 
-		eth_conf->rxmode.mq_mode =
-				(enum rte_eth_rx_mq_mode)
-					(rx_mq_mode & RTE_ETH_MQ_RX_DCB_RSS);
+		eth_conf->rxmode.mq_mode = ETH_MQ_RX_DCB_RSS;
 		eth_conf->rx_adv_conf.rss_conf = rss_conf;
-		eth_conf->txmode.mq_mode = RTE_ETH_MQ_TX_DCB;
+		eth_conf->txmode.mq_mode = ETH_MQ_TX_DCB;
 	}
 
 	if (pfc_en)
 		eth_conf->dcb_capability_en =
-				RTE_ETH_DCB_PG_SUPPORT | RTE_ETH_DCB_PFC_SUPPORT;
+				ETH_DCB_PG_SUPPORT | ETH_DCB_PFC_SUPPORT;
 	else
-		eth_conf->dcb_capability_en = RTE_ETH_DCB_PG_SUPPORT;
+		eth_conf->dcb_capability_en = ETH_DCB_PG_SUPPORT;
 
 	return 0;
 }
@@ -4282,27 +3229,20 @@
 	int retval;
 	uint16_t i;
 
-	if (num_procs > 1) {
-		printf("The multi-process feature doesn't support dcb.\n");
-		return -ENOTSUP;
-	}
 	rte_port = &ports[pid];
 
-	/* retain the original device configuration. */
-	memcpy(&port_conf, &rte_port->dev_conf, sizeof(struct rte_eth_conf));
+	memset(&port_conf, 0, sizeof(struct rte_eth_conf));
+	/* Enter DCB configuration status */
+	dcb_config = 1;
+
+	port_conf.rxmode = rte_port->dev_conf.rxmode;
+	port_conf.txmode = rte_port->dev_conf.txmode;
 
 	/*set configuration of DCB in vt mode and DCB in non-vt mode*/
 	retval = get_eth_dcb_conf(pid, &port_conf, dcb_mode, num_tcs, pfc_en);
 	if (retval < 0)
 		return retval;
-	port_conf.rxmode.offloads |= RTE_ETH_RX_OFFLOAD_VLAN_FILTER;
-	/* remove RSS HASH offload for DCB in vt mode */
-	if (port_conf.rxmode.mq_mode == RTE_ETH_MQ_RX_VMDQ_DCB) {
-		port_conf.rxmode.offloads &= ~RTE_ETH_RX_OFFLOAD_RSS_HASH;
-		for (i = 0; i < nb_rxq; i++)
-			rte_port->rxq[i].conf.offloads &=
-				~RTE_ETH_RX_OFFLOAD_RSS_HASH;
-	}
+	port_conf.rxmode.offloads |= DEV_RX_OFFLOAD_VLAN_FILTER;
 
 	/* re-configure the device . */
 	retval = rte_eth_dev_configure(pid, nb_rxq, nb_rxq, &port_conf);
@@ -4318,9 +3258,8 @@
 	 */
 	if (dcb_mode == DCB_VT_ENABLED &&
 	    rte_port->dev_info.vmdq_pool_base > 0) {
-		fprintf(stderr,
-			"VMDQ_DCB multi-queue mode is nonsensical for port %d.\n",
-			pid);
+		printf("VMDQ_DCB multi-queue mode is nonsensical"
+			" for port %d.", pid);
 		return -1;
 	}
 
@@ -4350,9 +3289,9 @@
 
 	memcpy(&rte_port->dev_conf, &port_conf, sizeof(struct rte_eth_conf));
 
-	rxtx_port_config(pid);
+	rxtx_port_config(rte_port);
 	/* VLAN filter */
-	rte_port->dev_conf.rxmode.offloads |= RTE_ETH_RX_OFFLOAD_VLAN_FILTER;
+	rte_port->dev_conf.rxmode.offloads |= DEV_RX_OFFLOAD_VLAN_FILTER;
 	for (i = 0; i < RTE_DIM(vlan_tags); i++)
 		rx_vft_set(pid, vlan_tags[i], 1);
 
@@ -4360,10 +3299,9 @@
 	if (retval != 0)
 		return retval;
 
-	rte_port->dcb_flag = 1;
+	map_port_queue_stats_mapping_registers(pid, rte_port);
 
-	/* Enter DCB configuration status */
-	dcb_config = 1;
+	rte_port->dcb_flag = 1;
 
 	return 0;
 }
@@ -4371,8 +3309,6 @@
 static void
 init_port(void)
 {
-	int i;
-
 	/* Configuration of Ethernet ports. */
 	ports = rte_zmalloc("testpmd: ports",
 			    sizeof(struct rte_port) * RTE_MAX_ETHPORTS,
@@ -4382,11 +3318,7 @@
 				"rte_zmalloc(%d struct rte_port) failed\n",
 				RTE_MAX_ETHPORTS);
 	}
-	for (i = 0; i < RTE_MAX_ETHPORTS; i++) {
-		ports[i].fwd_mac_swap = 1;
-		ports[i].xstats_info.allocated = false;
-		LIST_INIT(&ports[i].flow_tunnel_list);
-	}
+
 	/* Initialize ports NUMA structures */
 	memset(port_numa, NUMA_NO_CONFIG, RTE_MAX_ETHPORTS);
 	memset(rxring_numa, NUMA_NO_CONFIG, RTE_MAX_ETHPORTS);
@@ -4394,6 +3326,13 @@
 }
 
 static void
+force_quit(void)
+{
+	pmd_test_exit();
+	prompt_exit();
+}
+
+static void
 print_stats(void)
 {
 	uint8_t i;
@@ -4411,10 +3350,26 @@
 }
 
 static void
-signal_handler(int signum __rte_unused)
+signal_handler(int signum)
 {
-	f_quit = 1;
-	prompt_exit();
+	if (signum == SIGINT || signum == SIGTERM) {
+		printf("\nSignal %d received, preparing to exit...\n",
+				signum);
+#ifdef RTE_LIBRTE_PDUMP
+		/* uninitialize packet capture framework */
+		rte_pdump_uninit();
+#endif
+#ifdef RTE_LIBRTE_LATENCY_STATS
+		if (latencystats_enabled != 0)
+			rte_latencystats_uninit();
+#endif
+		force_quit();
+		/* Set flag to indicate the force termination. */
+		f_quit = 1;
+		/* exit with the expected status */
+		signal(signum, SIG_DFL);
+		kill(getpid(), signum);
+	}
 }
 
 int
@@ -4425,18 +3380,8 @@
 	uint16_t count;
 	int ret;
 
-#ifdef RTE_EXEC_ENV_WINDOWS
 	signal(SIGINT, signal_handler);
 	signal(SIGTERM, signal_handler);
-#else
-	/* Want read() not to be restarted on signal */
-	struct sigaction action = {
-		.sa_handler = signal_handler,
-	};
-
-	sigaction(SIGINT, &action, NULL);
-	sigaction(SIGTERM, &action, NULL);
-#endif
 
 	testpmd_logtype = rte_log_register("testpmd");
 	if (testpmd_logtype < 0)
@@ -4448,14 +3393,15 @@
 		rte_exit(EXIT_FAILURE, "Cannot init EAL: %s\n",
 			 rte_strerror(rte_errno));
 
-	/* allocate port structures, and init them */
-	init_port();
+	if (rte_eal_process_type() == RTE_PROC_SECONDARY)
+		rte_exit(EXIT_FAILURE,
+			 "Secondary process type not supported.\n");
 
 	ret = register_eth_event_callback();
 	if (ret != 0)
 		rte_exit(EXIT_FAILURE, "Cannot register for ethdev events");
 
-#ifdef RTE_LIB_PDUMP
+#ifdef RTE_LIBRTE_PDUMP
 	/* initialize packet capture framework */
 	rte_pdump_init();
 #endif
@@ -4469,18 +3415,24 @@
 	if (nb_ports == 0)
 		TESTPMD_LOG(WARNING, "No probed ethernet devices\n");
 
+	/* allocate port structures, and init them */
+	init_port();
+
 	set_def_fwd_config();
 	if (nb_lcores == 0)
 		rte_exit(EXIT_FAILURE, "No cores defined for forwarding\n"
 			 "Check the core mask argument\n");
 
 	/* Bitrate/latency stats disabled by default */
-#ifdef RTE_LIB_BITRATESTATS
+#ifdef RTE_LIBRTE_BITRATE
 	bitrate_enabled = 0;
 #endif
-#ifdef RTE_LIB_LATENCYSTATS
+#ifdef RTE_LIBRTE_LATENCY_STATS
 	latencystats_enabled = 0;
 #endif
+	lb_enabled = 0;
+	lb_dut_pcis = NULL;
+	nb_lb_dut_pcis = 0;
 
 	/* on FreeBSD, mlockall() is disabled by default */
 #ifdef RTE_EXEC_ENV_FREEBSD
@@ -4494,31 +3446,28 @@
 	if (argc > 1)
 		launch_args_parse(argc, argv);
 
-#ifndef RTE_EXEC_ENV_WINDOWS
 	if (do_mlockall && mlockall(MCL_CURRENT | MCL_FUTURE)) {
 		TESTPMD_LOG(NOTICE, "mlockall() failed with error \"%s\"\n",
 			strerror(errno));
 	}
-#endif
 
 	if (tx_first && interactive)
 		rte_exit(EXIT_FAILURE, "--tx-first cannot be used on "
 				"interactive mode.\n");
 
 	if (tx_first && lsc_interrupt) {
-		fprintf(stderr,
-			"Warning: lsc_interrupt needs to be off when using tx_first. Disabling.\n");
+		printf("Warning: lsc_interrupt needs to be off when "
+				" using tx_first. Disabling.\n");
 		lsc_interrupt = 0;
 	}
 
 	if (!nb_rxq && !nb_txq)
-		fprintf(stderr,
-			"Warning: Either rx or tx queues should be non-zero\n");
+		printf("Warning: Either rx or tx queues should be non-zero\n");
 
 	if (nb_rxq > 1 && nb_rxq > nb_txq)
-		fprintf(stderr,
-			"Warning: nb_rxq=%d enables RSS configuration, but nb_txq=%d will prevent to fully test it.\n",
-			nb_rxq, nb_txq);
+		printf("Warning: nb_rxq=%d enables RSS configuration, "
+		       "but nb_txq=%d will prevent to fully test it.\n",
+		       nb_rxq, nb_txq);
 
 	init_config();
 
@@ -4546,42 +3495,33 @@
 		}
 	}
 
-	if (!no_device_start && start_port(RTE_PORT_ALL) != 0) {
-		if (!interactive) {
-			rte_eal_cleanup();
-			rte_exit(EXIT_FAILURE, "Start ports failed\n");
-		}
-		fprintf(stderr, "Start ports failed\n");
-	}
+	if (!no_device_start && start_port(RTE_PORT_ALL) != 0)
+		rte_exit(EXIT_FAILURE, "Start ports failed\n");
 
 	/* set all ports to promiscuous mode by default */
 	RTE_ETH_FOREACH_DEV(port_id) {
 		ret = rte_eth_promiscuous_enable(port_id);
 		if (ret != 0)
-			fprintf(stderr,
-				"Error during enabling promiscuous mode for port %u: %s - ignore\n",
+			printf("Error during enabling promiscuous mode for port %u: %s - ignore\n",
 				port_id, rte_strerror(-ret));
 	}
 
-#ifdef RTE_LIB_METRICS
 	/* Init metrics library */
 	rte_metrics_init(rte_socket_id());
-#endif
 
-#ifdef RTE_LIB_LATENCYSTATS
+#ifdef RTE_LIBRTE_LATENCY_STATS
 	if (latencystats_enabled != 0) {
 		int ret = rte_latencystats_init(1, NULL);
 		if (ret)
-			fprintf(stderr,
-				"Warning: latencystats init() returned error %d\n",
-				ret);
-		fprintf(stderr, "Latencystats running on lcore %d\n",
+			printf("Warning: latencystats init()"
+				" returned error %d\n",	ret);
+		printf("Latencystats running on lcore %d\n",
 			latencystats_lcore_id);
 	}
 #endif
 
 	/* Setup bitrate stats */
-#ifdef RTE_LIB_BITRATESTATS
+#ifdef RTE_LIBRTE_BITRATE
 	if (bitrate_enabled != 0) {
 		bitrate_data = rte_stats_bitrate_create();
 		if (bitrate_data == NULL)
@@ -4590,11 +3530,8 @@
 		rte_stats_bitrate_reg(bitrate_data);
 	}
 #endif
-#ifdef RTE_LIB_CMDLINE
-	if (init_cmdline() != 0)
-		rte_exit(EXIT_FAILURE,
-			"Could not initialise cmdline context.\n");
 
+#ifdef RTE_LIBRTE_CMDLINE
 	if (strlen(cmdline_filename) != 0)
 		cmdline_read_from_file(cmdline_filename);
 
@@ -4604,9 +3541,15 @@
 			start_packet_forwarding(0);
 		}
 		prompt();
+		pmd_test_exit();
 	} else
 #endif
 	{
+		char c;
+		int rc;
+
+		f_quit = 0;
+
 		printf("No commandline core given, start packet forwarding\n");
 		start_packet_forwarding(tx_first);
 		if (stats_period != 0) {
@@ -4627,47 +3570,16 @@
 				}
 				/* Sleep to avoid unnecessary checks */
 				prev_time = cur_time;
-				rte_delay_us_sleep(US_PER_S);
+				sleep(1);
 			}
-		} else {
-			char c;
-			fd_set fds;
-
-			printf("Press enter to exit\n");
-
-			FD_ZERO(&fds);
-			FD_SET(0, &fds);
-
-			/* wait for signal or enter */
-			ret = select(1, &fds, NULL, NULL, NULL);
-			if (ret < 0 && errno != EINTR)
-				rte_exit(EXIT_FAILURE,
-					 "Select failed: %s\n",
-					 strerror(errno));
-
-			/* if got enter then consume it */
-			if (ret == 1 && read(0, &c, 1) < 0)
-				rte_exit(EXIT_FAILURE,
-					 "Read failed: %s\n",
-					 strerror(errno));
 		}
-	}
-
-	pmd_test_exit();
-
-#ifdef RTE_LIB_PDUMP
-	/* uninitialize packet capture framework */
-	rte_pdump_uninit();
-#endif
-#ifdef RTE_LIB_LATENCYSTATS
-	if (latencystats_enabled != 0)
-		rte_latencystats_uninit();
-#endif
 
-	ret = rte_eal_cleanup();
-	if (ret != 0)
-		rte_exit(EXIT_FAILURE,
-			 "EAL cleanup failed: %s\n", strerror(-ret));
+		printf("Press enter to exit\n");
+		rc = read(0, &c, 1);
+		pmd_test_exit();
+		if (rc < 0)
+			return 1;
+	}
 
-	return EXIT_SUCCESS;
+	return 0;
 }
diff -urN dpdk/app/test-pmd/testpmd.h testpmd-as-load-balancer/v19.11/test-pmd/testpmd.h
--- dpdk/app/test-pmd/testpmd.h	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/testpmd.h	2023-12-15 15:26:37.091199145 +0100
@@ -7,35 +7,22 @@
 
 #include <stdbool.h>
 
-#ifdef RTE_LIB_GRO
+#include <rte_pci.h>
+#include <rte_bus_pci.h>
 #include <rte_gro.h>
-#endif
-#ifdef RTE_LIB_GSO
 #include <rte_gso.h>
-#endif
-#include <rte_os_shim.h>
-#include <rte_ethdev.h>
-#include <rte_flow.h>
-#include <rte_mbuf_dyn.h>
-
 #include <cmdline.h>
-#include <cmdline_parse.h>
-
-#include <sys/queue.h>
-#ifdef RTE_HAS_JANSSON
-#include <jansson.h>
-#endif
 
 #define RTE_PORT_ALL            (~(portid_t)0x0)
 
+#define RTE_TEST_RX_DESC_MAX    2048
+#define RTE_TEST_TX_DESC_MAX    2048
+
 #define RTE_PORT_STOPPED        (uint16_t)0
 #define RTE_PORT_STARTED        (uint16_t)1
 #define RTE_PORT_CLOSED         (uint16_t)2
 #define RTE_PORT_HANDLING       (uint16_t)3
 
-extern uint8_t cl_quit;
-extern volatile uint8_t f_quit;
-
 /*
  * It is used to allocate the memory for hash key.
  * The hash key size is NIC dependent.
@@ -55,19 +42,6 @@
  */
 #define RTE_MAX_SEGS_PER_PKT 255 /**< nb_segs is a 8-bit unsigned char. */
 
-/*
- * The maximum number of segments per packet is used to configure
- * buffer split feature, also specifies the maximum amount of
- * optional Rx pools to allocate mbufs to split.
- */
-#define MAX_SEGS_BUFFER_SPLIT 8 /**< nb_segs is a 8-bit unsigned char. */
-
-/* The prefix of the mbuf pool names created by the application. */
-#define MBUF_POOL_NAME_PFX "mb_pool"
-
-#define RX_DESC_MAX    2048
-#define TX_DESC_MAX    2048
-
 #define MAX_PKT_BURST 512
 #define DEF_PKT_BURST 32
 
@@ -79,16 +53,17 @@
 #define NUMA_NO_CONFIG 0xFF
 #define UMA_NO_CONFIG  0xFF
 
-#define MIN_TOTAL_NUM_MBUFS 1024
-
-/* Maximum number of pools supported per Rx queue */
-#define MAX_MEMPOOL 8
-
 typedef uint8_t  lcoreid_t;
 typedef uint16_t portid_t;
 typedef uint16_t queueid_t;
 typedef uint16_t streamid_t;
 
+#if defined RTE_LIBRTE_PMD_SOFTNIC
+#define SOFTNIC			1
+#else
+#define SOFTNIC			0
+#endif
+
 enum {
 	PORT_TOPOLOGY_PAIRED,
 	PORT_TOPOLOGY_CHAINED,
@@ -101,31 +76,20 @@
 	/**< allocate mempool natively, but populate using anonymous memory */
 	MP_ALLOC_XMEM,
 	/**< allocate and populate mempool using anonymous memory */
-	MP_ALLOC_XMEM_HUGE,
+	MP_ALLOC_XMEM_HUGE
 	/**< allocate and populate mempool using anonymous hugepage memory */
-	MP_ALLOC_XBUF
-	/**< allocate mempool natively, use rte_pktmbuf_pool_create_extbuf */
-};
-
-enum {
-	QUEUE_JOB_TYPE_FLOW_CREATE,
-	QUEUE_JOB_TYPE_FLOW_DESTROY,
-	QUEUE_JOB_TYPE_ACTION_CREATE,
-	QUEUE_JOB_TYPE_ACTION_DESTROY,
-	QUEUE_JOB_TYPE_ACTION_UPDATE,
-	QUEUE_JOB_TYPE_ACTION_QUERY,
 };
 
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
 /**
  * The data structure associated with RX and TX packet burst statistics
  * that are recorded for each forwarding stream.
  */
 struct pkt_burst_stats {
-	unsigned int pkt_burst_spread[MAX_PKT_BURST + 1];
+	unsigned int pkt_burst_spread[MAX_PKT_BURST];
 };
+#endif
 
-
-#define TESTPMD_RSS_TYPES_CHAR_NUM_PER_LINE 64
 /** Information for a given RSS type. */
 struct rss_type_info {
 	const char *str; /**< Type name. */
@@ -140,13 +104,6 @@
 extern const struct rss_type_info rss_type_table[];
 
 /**
- * Dynf name array.
- *
- * Array that holds the name for each dynf.
- */
-extern char dynf_names[64][RTE_MBUF_DYN_NAMESIZE];
-
-/**
  * The data structure associated with a forwarding stream between a receive
  * port/queue and a transmit port/queue.
  */
@@ -157,7 +114,7 @@
 	portid_t   tx_port;   /**< forwarding port of received packets */
 	queueid_t  tx_queue;  /**< TX queue to send forwarded packets */
 	streamid_t peer_addr; /**< index of peer ethernet address of packets */
-	bool       disabled;  /**< the stream is disabled and should not run */
+        uint8_t    generate;  /**< Generate the destination parameters (mac) */
 
 	unsigned int retry_enabled;
 
@@ -169,47 +126,14 @@
 	uint64_t rx_bad_l4_csum ; /**< received packets has bad l4 checksum */
 	uint64_t rx_bad_outer_l4_csum;
 	/**< received packets has bad outer l4 checksum */
-	uint64_t rx_bad_outer_ip_csum;
-	/**< received packets having bad outer ip checksum */
-	uint64_t ts_skew; /**< TX scheduling timestamp */
-#ifdef RTE_LIB_GRO
 	unsigned int gro_times;	/**< GRO operation times */
-#endif
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
 	uint64_t     core_cycles; /**< used for RX and TX processing */
+#endif
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
 	struct pkt_burst_stats rx_burst_stats;
 	struct pkt_burst_stats tx_burst_stats;
-	struct fwd_lcore *lcore; /**< Lcore being scheduled. */
-};
-
-/**
- * Age action context types, must be included inside the age action
- * context structure.
- */
-enum age_action_context_type {
-	ACTION_AGE_CONTEXT_TYPE_FLOW,
-	ACTION_AGE_CONTEXT_TYPE_INDIRECT_ACTION,
-};
-
-/** Descriptor for a template. */
-struct port_template {
-	struct port_template *next; /**< Next template in list. */
-	struct port_template *tmp; /**< Temporary linking. */
-	uint32_t id; /**< Template ID. */
-	union {
-		struct rte_flow_pattern_template *pattern_template;
-		struct rte_flow_actions_template *actions_template;
-	} template; /**< PMD opaque template object */
-};
-
-/** Descriptor for a flow table. */
-struct port_table {
-	struct port_table *next; /**< Next table in list. */
-	struct port_table *tmp; /**< Temporary linking. */
-	uint32_t id; /**< Table ID. */
-	uint32_t nb_pattern_templates; /**< Number of pattern templates. */
-	uint32_t nb_actions_templates; /**< Number of actions templates. */
-	struct rte_flow_attr flow_attr; /**< Flow attributes. */
-	struct rte_flow_template_table *table; /**< PMD opaque template object */
+#endif
 };
 
 /** Descriptor for a single flow. */
@@ -218,85 +142,25 @@
 	struct port_flow *tmp; /**< Temporary linking. */
 	uint32_t id; /**< Flow rule ID. */
 	struct rte_flow *flow; /**< Opaque flow object returned by PMD. */
-	struct rte_flow_conv_rule rule; /**< Saved flow rule description. */
-	enum age_action_context_type age_type; /**< Age action context type. */
+	struct rte_flow_conv_rule rule; /* Saved flow rule description. */
 	uint8_t data[]; /**< Storage for flow rule description */
 };
 
-/* Descriptor for indirect action */
-struct port_indirect_action {
-	struct port_indirect_action *next; /**< Next flow in list. */
-	uint32_t id; /**< Indirect action ID. */
-	enum rte_flow_action_type type; /**< Action type. */
-	struct rte_flow_action_handle *handle;	/**< Indirect action handle. */
-	enum age_action_context_type age_type; /**< Age action context type. */
-};
-
-/* Descriptor for action query data. */
-union port_action_query {
-	struct rte_flow_query_count count;
-	struct rte_flow_query_age age;
-	struct rte_flow_action_conntrack ct;
-};
-
-/* Descriptor for queue job. */
-struct queue_job {
-	uint32_t type; /**< Job type. */
-	union {
-		struct port_flow *pf;
-		struct port_indirect_action *pia;
-	};
-	union port_action_query query;
-};
-
-struct port_flow_tunnel {
-	LIST_ENTRY(port_flow_tunnel) chain;
-	struct rte_flow_action *pmd_actions;
-	struct rte_flow_item   *pmd_items;
-	uint32_t id;
-	uint32_t num_pmd_actions;
-	uint32_t num_pmd_items;
-	struct rte_flow_tunnel tunnel;
-	struct rte_flow_action *actions;
-	struct rte_flow_item *items;
-};
-
-struct tunnel_ops {
-	uint32_t id;
-	char type[16];
-	uint32_t enabled:1;
-	uint32_t actions:1;
-	uint32_t items:1;
-};
-
-/** Information for an extended statistics to show. */
-struct xstat_display_info {
-	/** Supported xstats IDs in the order of xstats_display */
-	uint64_t *ids_supp;
-	size_t   ids_supp_sz;
-	uint64_t *prev_values;
-	uint64_t *curr_values;
-	uint64_t prev_ns;
-	bool	 allocated;
-};
-
-/** RX queue configuration and state. */
-struct port_rxqueue {
-	struct rte_eth_rxconf conf;
-	uint8_t state; /**< RTE_ETH_QUEUE_STATE_* value. */
-};
-
-/** TX queue configuration and state. */
-struct port_txqueue {
-	struct rte_eth_txconf conf;
-	uint8_t state; /**< RTE_ETH_QUEUE_STATE_* value. */
+#ifdef SOFTNIC
+/**
+ * The data structure associate with softnic port
+ */
+struct softnic_port {
+	uint32_t default_tm_hierarchy_enable; /**< default tm hierarchy */
+	struct fwd_lcore **fwd_lcore_arg; /**< softnic fwd core parameters */
 };
+#endif
 
 /**
  * The data structure associated with each port.
  */
 struct rte_port {
-	struct rte_eth_dev_info dev_info;   /**< Device info + driver name */
+	struct rte_eth_dev_info dev_info;   /**< PCI info + driver name */
 	struct rte_eth_conf     dev_conf;   /**< Port configuration. */
 	struct rte_ether_addr       eth_addr;   /**< Port ethernet address */
 	struct rte_eth_stats    stats;      /**< Last port statistics */
@@ -306,6 +170,8 @@
 	uint16_t                tunnel_tso_segsz; /**< Segmentation offload MSS for tunneled pkts. */
 	uint16_t                tx_vlan_id;/**< The tag ID */
 	uint16_t                tx_vlan_id_outer;/**< The outer tag ID */
+	uint8_t                 tx_queue_stats_mapping_enabled;
+	uint8_t                 rx_queue_stats_mapping_enabled;
 	volatile uint16_t        port_status;    /**< port started or not */
 	uint8_t                 need_setup;     /**< port just attached */
 	uint8_t                 need_reconfig;  /**< need reconfiguring port or not */
@@ -314,32 +180,20 @@
 	uint8_t                 dcb_flag;   /**< enable dcb */
 	uint16_t                nb_rx_desc[RTE_MAX_QUEUES_PER_PORT+1]; /**< per queue rx desc number */
 	uint16_t                nb_tx_desc[RTE_MAX_QUEUES_PER_PORT+1]; /**< per queue tx desc number */
-	struct port_rxqueue     rxq[RTE_MAX_QUEUES_PER_PORT+1]; /**< per queue Rx config and state */
-	struct port_txqueue     txq[RTE_MAX_QUEUES_PER_PORT+1]; /**< per queue Tx config and state */
+	struct rte_eth_rxconf   rx_conf[RTE_MAX_QUEUES_PER_PORT+1]; /**< per queue rx configuration */
+	struct rte_eth_txconf   tx_conf[RTE_MAX_QUEUES_PER_PORT+1]; /**< per queue tx configuration */
 	struct rte_ether_addr   *mc_addr_pool; /**< pool of multicast addrs */
 	uint32_t                mc_addr_nb; /**< nb. of addr. in mc_addr_pool */
-	queueid_t               queue_nb; /**< nb. of queues for flow rules */
-	uint32_t                queue_sz; /**< size of a queue for flow rules */
-	uint8_t                 slave_flag : 1, /**< bonding slave port */
-				bond_flag : 1, /**< port is bond device */
-				fwd_mac_swap : 1, /**< swap packet MAC before forward */
-				update_conf : 1; /**< need to update bonding device configuration */
-	struct port_template    *pattern_templ_list; /**< Pattern templates. */
-	struct port_template    *actions_templ_list; /**< Actions templates. */
-	struct port_table       *table_list; /**< Flow tables. */
+	uint8_t                 slave_flag; /**< bonding slave port */
 	struct port_flow        *flow_list; /**< Associated flows. */
-	struct port_indirect_action *actions_list;
-	/**< Associated indirect actions. */
-	LIST_HEAD(, port_flow_tunnel) flow_tunnel_list;
 	const struct rte_eth_rxtx_callback *rx_dump_cb[RTE_MAX_QUEUES_PER_PORT+1];
 	const struct rte_eth_rxtx_callback *tx_dump_cb[RTE_MAX_QUEUES_PER_PORT+1];
+#ifdef SOFTNIC
+	struct softnic_port     softport;  /**< softnic params */
+#endif
 	/**< metadata value to insert in Tx packets. */
 	uint32_t		tx_metadata;
 	const struct rte_eth_rxtx_callback *tx_set_md_cb[RTE_MAX_QUEUES_PER_PORT+1];
-	/**< dynamic flags. */
-	uint64_t		mbuf_dynf;
-	const struct rte_eth_rxtx_callback *tx_set_dynf_cb[RTE_MAX_QUEUES_PER_PORT+1];
-	struct xstat_display_info xstats_info;
 };
 
 /**
@@ -350,16 +204,13 @@
  * CPU id. configuration table.
  */
 struct fwd_lcore {
-#ifdef RTE_LIB_GSO
 	struct rte_gso_ctx gso_ctx;     /**< GSO context */
-#endif
 	struct rte_mempool *mbp; /**< The mbuf pool to use by this core */
-#ifdef RTE_LIB_GRO
 	void *gro_ctx;		/**< GRO context */
-#endif
 	streamid_t stream_idx;   /**< index of 1st stream in "fwd_streams" */
 	streamid_t stream_nb;    /**< number of streams in "fwd_streams" */
 	lcoreid_t  cpuid_idx;    /**< index of logical core in CPU id table */
+	queueid_t  tx_queue;     /**< TX queue to send forwarded packets */
 	volatile char stopped;   /**< stop forwarding when set */
 };
 
@@ -378,40 +229,17 @@
  *     Forwards packets unchanged on the same port.
  *     Check that sent IEEE1588 PTP packets are timestamped by the hardware.
  */
-typedef int (*port_fwd_begin_t)(portid_t pi);
+typedef void (*port_fwd_begin_t)(portid_t pi);
 typedef void (*port_fwd_end_t)(portid_t pi);
-typedef void (*stream_init_t)(struct fwd_stream *fs);
 typedef void (*packet_fwd_t)(struct fwd_stream *fs);
 
 struct fwd_engine {
 	const char       *fwd_mode_name; /**< Forwarding mode name. */
 	port_fwd_begin_t port_fwd_begin; /**< NULL if nothing special to do. */
 	port_fwd_end_t   port_fwd_end;   /**< NULL if nothing special to do. */
-	stream_init_t    stream_init;    /**< NULL if nothing special to do. */
 	packet_fwd_t     packet_fwd;     /**< Mandatory. */
 };
 
-#define FLEX_ITEM_MAX_SAMPLES_NUM 16
-#define FLEX_ITEM_MAX_LINKS_NUM 16
-#define FLEX_MAX_FLOW_PATTERN_LENGTH 64
-#define FLEX_MAX_PARSERS_NUM 8
-#define FLEX_MAX_PATTERNS_NUM 64
-#define FLEX_PARSER_ERR ((struct flex_item *)-1)
-
-struct flex_item {
-	struct rte_flow_item_flex_conf flex_conf;
-	struct rte_flow_item_flex_handle *flex_handle;
-	uint32_t flex_id;
-};
-
-struct flex_pattern {
-	struct rte_flow_item_flex spec, mask;
-	uint8_t spec_pattern[FLEX_MAX_FLOW_PATTERN_LENGTH];
-	uint8_t mask_pattern[FLEX_MAX_FLOW_PATTERN_LENGTH];
-};
-extern struct flex_item *flex_items[RTE_MAX_ETHPORTS][FLEX_MAX_PARSERS_NUM];
-extern struct flex_pattern flex_patterns[FLEX_MAX_PATTERNS_NUM];
-
 #define BURST_TX_WAIT_US 1
 #define BURST_TX_RETRIES 64
 
@@ -427,18 +255,18 @@
 extern struct fwd_engine csum_fwd_engine;
 extern struct fwd_engine icmp_echo_engine;
 extern struct fwd_engine noisy_vnf_engine;
-extern struct fwd_engine five_tuple_swap_fwd_engine;
+#ifdef SOFTNIC
+extern struct fwd_engine softnic_fwd_engine;
+#endif
 #ifdef RTE_LIBRTE_IEEE1588
 extern struct fwd_engine ieee1588_fwd_engine;
 #endif
-extern struct fwd_engine shared_rxq_engine;
+extern struct fwd_engine lb_fwd_engine;
 
 extern struct fwd_engine * fwd_engines[]; /**< NULL terminated array. */
 extern cmdline_parse_inst_t cmd_set_raw;
 extern cmdline_parse_inst_t cmd_show_set_raw;
 extern cmdline_parse_inst_t cmd_show_set_raw_all;
-extern cmdline_parse_inst_t cmd_set_flex_is_pattern;
-extern cmdline_parse_inst_t cmd_set_flex_spec_pattern;
 
 extern uint16_t mempool_flags;
 
@@ -462,11 +290,28 @@
 	DCB_ENABLED
 };
 
+#define MAX_TX_QUEUE_STATS_MAPPINGS 1024 /* MAX_PORT of 32 @ 32 tx_queues/port */
+#define MAX_RX_QUEUE_STATS_MAPPINGS 4096 /* MAX_PORT of 32 @ 128 rx_queues/port */
+
+struct queue_stats_mappings {
+	portid_t port_id;
+	uint16_t queue_id;
+	uint8_t stats_counter_id;
+} __rte_cache_aligned;
+
+extern struct queue_stats_mappings tx_queue_stats_mappings_array[];
+extern struct queue_stats_mappings rx_queue_stats_mappings_array[];
+
+/* Assign both tx and rx queue stats mappings to the same default values */
+extern struct queue_stats_mappings *tx_queue_stats_mappings;
+extern struct queue_stats_mappings *rx_queue_stats_mappings;
+
+extern uint16_t nb_tx_queue_stats_mappings;
+extern uint16_t nb_rx_queue_stats_mappings;
+
 extern uint8_t xstats_hide_zero; /**< Hide zero values for xstats display */
 
 /* globals used for configuration */
-extern uint8_t record_core_cycles; /**< Enables measurement of CPU cycles */
-extern uint8_t record_burst_stats; /**< Enables display of RX and TX bursts */
 extern uint16_t verbose_level; /**< Drives messages being displayed, if any. */
 extern int testpmd_logtype; /**< Log type for testpmd logs */
 extern uint8_t  interactive;
@@ -479,7 +324,6 @@
 extern uint8_t flow_isolate_all; /**< set by "--flow-isolate-all */
 extern uint8_t  mp_alloc_type;
 /**< set by "--mp-anon" or "--mp-alloc" parameter */
-extern uint32_t eth_link_speed;
 extern uint8_t no_link_check; /**<set by "--disable-link-check" parameter */
 extern uint8_t no_device_start; /**<set by "--disable-device-start" parameter */
 extern volatile int test_done; /* stop packet forwarding when set to 1. */
@@ -492,6 +336,10 @@
 extern int do_mlockall; /**< set by "--mlockall" or "--no-mlockall" parameter */
 extern uint8_t clear_ptypes; /**< disabled by set ptype cmd */
 
+#ifdef RTE_LIBRTE_IXGBE_BYPASS
+extern uint32_t bypass_timeout; /**< Store the NIC bypass watchdog timeout */
+#endif
+
 /*
  * Store specified sockets on which memory pool to be used by ports
  * is allocated.
@@ -558,42 +406,28 @@
 extern uint64_t noisy_lkup_num_reads_writes;
 
 extern uint8_t dcb_config;
+extern uint8_t dcb_test;
 
-extern uint32_t mbuf_data_size_n;
-extern uint16_t mbuf_data_size[MAX_SEGS_BUFFER_SPLIT];
-/**< Mbuf data space size. */
+extern uint16_t mbuf_data_size; /**< Mbuf data space size. */
 extern uint32_t param_total_num_mbufs;
 
 extern uint16_t stats_period;
 
-extern struct rte_eth_xstat_name *xstats_display;
-extern unsigned int xstats_display_num;
-
-extern uint32_t hairpin_mode;
-
-#ifdef RTE_LIB_LATENCYSTATS
+#ifdef RTE_LIBRTE_LATENCY_STATS
 extern uint8_t latencystats_enabled;
 extern lcoreid_t latencystats_lcore_id;
 #endif
 
-#ifdef RTE_LIB_BITRATESTATS
+extern uint8_t lb_enabled;
+extern struct rte_pci_addr *lb_dut_pcis;
+extern uint32_t nb_lb_dut_pcis;
+
+#ifdef RTE_LIBRTE_BITRATE
 extern lcoreid_t bitrate_lcore_id;
 extern uint8_t bitrate_enabled;
 #endif
 
-extern uint32_t max_rx_pkt_len;
-
-/*
- * Configuration of packet segments used to scatter received packets
- * if some of split features is configured.
- */
-extern uint32_t rx_pkt_hdr_protos[MAX_SEGS_BUFFER_SPLIT];
-extern uint16_t rx_pkt_seg_lengths[MAX_SEGS_BUFFER_SPLIT];
-extern uint8_t  rx_pkt_nb_segs; /**< Number of segments to split */
-extern uint16_t rx_pkt_seg_offsets[MAX_SEGS_BUFFER_SPLIT];
-extern uint8_t  rx_pkt_nb_offs; /**< Number of specified offsets */
-
-extern uint8_t multi_rx_mempool; /**< Enables multi-rx-mempool feature. */
+extern struct rte_fdir_conf fdir_conf;
 
 /*
  * Configuration of packet segments used by the "txonly" processing engine.
@@ -602,8 +436,6 @@
 extern uint16_t tx_pkt_length; /**< Length of TXONLY packet */
 extern uint16_t tx_pkt_seg_lengths[RTE_MAX_SEGS_PER_PKT]; /**< Seg. lengths */
 extern uint8_t  tx_pkt_nb_segs; /**< Number of segments in TX packets */
-extern uint32_t tx_pkt_times_intra;
-extern uint32_t tx_pkt_times_inter;
 
 enum tx_pkt_split {
 	TX_PKT_SPLIT_OFF,
@@ -615,11 +447,7 @@
 
 extern uint8_t txonly_multi_flow;
 
-extern uint32_t rxq_share;
-
 extern uint16_t nb_pkt_per_burst;
-extern uint16_t nb_pkt_flowgen_clones;
-extern int nb_flows_flowgen;
 extern uint16_t mb_mempool_cache;
 extern int8_t rx_pthresh;
 extern int8_t rx_hthresh;
@@ -641,7 +469,6 @@
 extern struct fwd_stream **fwd_streams;
 
 extern uint16_t vxlan_gpe_udp_port; /**< UDP port of tunnel VXLAN-GPE. */
-extern uint16_t geneve_udp_port; /**< UDP port of tunnel GENEVE. */
 
 extern portid_t nb_peer_eth_addrs; /**< Number of peer ethernet addresses. */
 extern struct rte_ether_addr peer_eth_addrs[RTE_MAX_ETHPORTS];
@@ -649,7 +476,6 @@
 extern uint32_t burst_tx_delay_time; /**< Burst tx delay time(us) for mac-retry. */
 extern uint32_t burst_tx_retry_num;  /**< Burst tx retry number for mac-retry. */
 
-#ifdef RTE_LIB_GRO
 #define GRO_DEFAULT_ITEM_NUM_PER_FLOW 32
 #define GRO_DEFAULT_FLOW_NUM (RTE_GRO_MAX_BURST_ITEM_NUM / \
 		GRO_DEFAULT_ITEM_NUM_PER_FLOW)
@@ -663,16 +489,13 @@
 };
 extern struct gro_status gro_ports[RTE_MAX_ETHPORTS];
 extern uint8_t gro_flush_cycles;
-#endif /* RTE_LIB_GRO */
 
-#ifdef RTE_LIB_GSO
 #define GSO_MAX_PKT_BURST 2048
 struct gso_status {
 	uint8_t enable;
 };
 extern struct gso_status gso_ports[RTE_MAX_ETHPORTS];
 extern uint16_t gso_max_segment_size;
-#endif /* RTE_LIB_GSO */
 
 /* VXLAN encap/decap parameters. */
 struct vxlan_encap_conf {
@@ -773,19 +596,6 @@
 };
 extern struct mplsoudp_decap_conf mplsoudp_decap_conf;
 
-extern enum rte_eth_rx_mq_mode rx_mq_mode;
-
-extern struct rte_flow_action_conntrack conntrack_context;
-
-extern int proc_id;
-extern unsigned int num_procs;
-
-static inline bool
-is_proc_primary(void)
-{
-	return rte_eal_process_type() == RTE_PROC_PRIMARY;
-}
-
 static inline unsigned int
 lcore_num(void)
 {
@@ -798,9 +608,6 @@
 	rte_panic("lcore_id of current thread not found in fwd_lcores_cpuids\n");
 }
 
-void
-parse_fwd_portlist(const char *port);
-
 static inline struct fwd_lcore *
 current_fwd_lcore(void)
 {
@@ -809,81 +616,100 @@
 
 /* Mbuf Pools */
 static inline void
-mbuf_poolname_build(unsigned int sock_id, char *mp_name,
-		    int name_size, uint16_t idx)
+mbuf_poolname_build(unsigned int sock_id, char* mp_name, int name_size)
 {
-	if (!idx)
-		snprintf(mp_name, name_size,
-			 MBUF_POOL_NAME_PFX "_%u", sock_id);
-	else
-		snprintf(mp_name, name_size,
-			 MBUF_POOL_NAME_PFX "_%hu_%hu", (uint16_t)sock_id, idx);
+	snprintf(mp_name, name_size, "mbuf_pool_socket_%u", sock_id);
 }
 
 static inline struct rte_mempool *
-mbuf_pool_find(unsigned int sock_id, uint16_t idx)
+mbuf_pool_find(unsigned int sock_id)
 {
 	char pool_name[RTE_MEMPOOL_NAMESIZE];
 
-	mbuf_poolname_build(sock_id, pool_name, sizeof(pool_name), idx);
+	mbuf_poolname_build(sock_id, pool_name, sizeof(pool_name));
 	return rte_mempool_lookup((const char *)pool_name);
 }
 
-static inline void
-get_start_cycles(uint64_t *start_tsc)
+/**
+ * Read/Write operations on a PCI register of a port.
+ */
+static inline uint32_t
+port_pci_reg_read(struct rte_port *port, uint32_t reg_off)
 {
-	if (record_core_cycles)
-		*start_tsc = rte_rdtsc();
+	const struct rte_pci_device *pci_dev;
+	const struct rte_bus *bus;
+	void *reg_addr;
+	uint32_t reg_v;
+
+	if (!port->dev_info.device) {
+		printf("Invalid device\n");
+		return 0;
+	}
+
+	bus = rte_bus_find_by_device(port->dev_info.device);
+	if (bus && !strcmp(bus->name, "pci")) {
+		pci_dev = RTE_DEV_TO_PCI(port->dev_info.device);
+	} else {
+		printf("Not a PCI device\n");
+		return 0;
+	}
+
+	reg_addr = ((char *)pci_dev->mem_resource[0].addr + reg_off);
+	reg_v = *((volatile uint32_t *)reg_addr);
+	return rte_le_to_cpu_32(reg_v);
 }
 
-static inline void
-get_end_cycles(struct fwd_stream *fs, uint64_t start_tsc)
-{
-	if (record_core_cycles)
-		fs->core_cycles += rte_rdtsc() - start_tsc;
-}
+#define port_id_pci_reg_read(pt_id, reg_off) \
+	port_pci_reg_read(&ports[(pt_id)], (reg_off))
 
 static inline void
-inc_rx_burst_stats(struct fwd_stream *fs, uint16_t nb_rx)
+port_pci_reg_write(struct rte_port *port, uint32_t reg_off, uint32_t reg_v)
 {
-	if (record_burst_stats)
-		fs->rx_burst_stats.pkt_burst_spread[nb_rx]++;
-}
+	const struct rte_pci_device *pci_dev;
+	const struct rte_bus *bus;
+	void *reg_addr;
+
+	if (!port->dev_info.device) {
+		printf("Invalid device\n");
+		return;
+	}
+
+	bus = rte_bus_find_by_device(port->dev_info.device);
+	if (bus && !strcmp(bus->name, "pci")) {
+		pci_dev = RTE_DEV_TO_PCI(port->dev_info.device);
+	} else {
+		printf("Not a PCI device\n");
+		return;
+	}
 
-static inline void
-inc_tx_burst_stats(struct fwd_stream *fs, uint16_t nb_tx)
-{
-	if (record_burst_stats)
-		fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+	reg_addr = ((char *)pci_dev->mem_resource[0].addr + reg_off);
+	*((volatile uint32_t *)reg_addr) = rte_cpu_to_le_32(reg_v);
 }
 
+#define port_id_pci_reg_write(pt_id, reg_off, reg_value) \
+	port_pci_reg_write(&ports[(pt_id)], (reg_off), (reg_value))
+
 /* Prototypes */
-unsigned int parse_item_list(const char *str, const char *item_name,
+unsigned int parse_item_list(char* str, const char* item_name,
 			unsigned int max_items,
 			unsigned int *parsed_items, int check_unique_values);
-unsigned int parse_hdrs_list(const char *str, const char *item_name,
-			unsigned int max_item,
-			unsigned int *parsed_items);
 void launch_args_parse(int argc, char** argv);
-void cmd_reconfig_device_queue(portid_t id, uint8_t dev, uint8_t queue);
 void cmdline_read_from_file(const char *filename);
-int init_cmdline(void);
 void prompt(void);
 void prompt_exit(void);
 void nic_stats_display(portid_t port_id);
 void nic_stats_clear(portid_t port_id);
 void nic_xstats_display(portid_t port_id);
 void nic_xstats_clear(portid_t port_id);
+void nic_stats_mapping_display(portid_t port_id);
 void device_infos_display(const char *identifier);
 void port_infos_display(portid_t port_id);
 void port_summary_display(portid_t port_id);
-void port_eeprom_display(portid_t port_id);
-void port_module_eeprom_display(portid_t port_id);
 void port_summary_header_display(void);
+void port_offload_cap_display(portid_t port_id);
 void rx_queue_infos_display(portid_t port_idi, uint16_t queue_id);
 void tx_queue_infos_display(portid_t port_idi, uint16_t queue_id);
 void fwd_lcores_config_display(void);
-bool pkt_fwd_shared_rxq_check(void);
 void pkt_fwd_config_display(struct fwd_config *cfg);
 void rxtx_config_display(void);
 void fwd_config_setup(void);
@@ -895,98 +721,29 @@
 void set_fwd_eth_peer(portid_t port_id, char *peer_addr);
 
 void port_mtu_set(portid_t port_id, uint16_t mtu);
-int port_action_handle_create(portid_t port_id, uint32_t id,
-			      const struct rte_flow_indir_action_conf *conf,
-			      const struct rte_flow_action *action);
-int port_action_handle_destroy(portid_t port_id,
-			       uint32_t n, const uint32_t *action);
-int port_action_handle_flush(portid_t port_id);
-struct rte_flow_action_handle *port_action_handle_get_by_id(portid_t port_id,
-							    uint32_t id);
-int port_action_handle_update(portid_t port_id, uint32_t id,
-			      const struct rte_flow_action *action);
-int port_flow_get_info(portid_t port_id);
-int port_flow_configure(portid_t port_id,
-			const struct rte_flow_port_attr *port_attr,
-			uint16_t nb_queue,
-			const struct rte_flow_queue_attr *queue_attr);
-int port_flow_pattern_template_create(portid_t port_id, uint32_t id,
-				      const struct rte_flow_pattern_template_attr *attr,
-				      const struct rte_flow_item *pattern);
-int port_flow_pattern_template_destroy(portid_t port_id, uint32_t n,
-				       const uint32_t *template);
-int port_flow_pattern_template_flush(portid_t port_id);
-int port_flow_actions_template_create(portid_t port_id, uint32_t id,
-				      const struct rte_flow_actions_template_attr *attr,
-				      const struct rte_flow_action *actions,
-				      const struct rte_flow_action *masks);
-int port_flow_actions_template_destroy(portid_t port_id, uint32_t n,
-				       const uint32_t *template);
-int port_flow_actions_template_flush(portid_t port_id);
-int port_flow_template_table_create(portid_t port_id, uint32_t id,
-		   const struct rte_flow_template_table_attr *table_attr,
-		   uint32_t nb_pattern_templates, uint32_t *pattern_templates,
-		   uint32_t nb_actions_templates, uint32_t *actions_templates);
-int port_flow_template_table_destroy(portid_t port_id,
-			    uint32_t n, const uint32_t *table);
-int port_flow_template_table_flush(portid_t port_id);
-int port_queue_flow_create(portid_t port_id, queueid_t queue_id,
-			   bool postpone, uint32_t table_id,
-			   uint32_t pattern_idx, uint32_t actions_idx,
-			   const struct rte_flow_item *pattern,
-			   const struct rte_flow_action *actions);
-int port_queue_flow_destroy(portid_t port_id, queueid_t queue_id,
-			    bool postpone, uint32_t n, const uint32_t *rule);
-int port_queue_action_handle_create(portid_t port_id, uint32_t queue_id,
-			bool postpone, uint32_t id,
-			const struct rte_flow_indir_action_conf *conf,
-			const struct rte_flow_action *action);
-int port_queue_action_handle_destroy(portid_t port_id,
-				     uint32_t queue_id, bool postpone,
-				     uint32_t n, const uint32_t *action);
-int port_queue_action_handle_update(portid_t port_id, uint32_t queue_id,
-				    bool postpone, uint32_t id,
-				    const struct rte_flow_action *action);
-int port_queue_action_handle_query(portid_t port_id, uint32_t queue_id,
-				   bool postpone, uint32_t id);
-int port_queue_flow_push(portid_t port_id, queueid_t queue_id);
-int port_queue_flow_pull(portid_t port_id, queueid_t queue_id);
-void port_queue_flow_aged(portid_t port_id, uint32_t queue_id, uint8_t destroy);
+void port_reg_bit_display(portid_t port_id, uint32_t reg_off, uint8_t bit_pos);
+void port_reg_bit_set(portid_t port_id, uint32_t reg_off, uint8_t bit_pos,
+		      uint8_t bit_v);
+void port_reg_bit_field_display(portid_t port_id, uint32_t reg_off,
+				uint8_t bit1_pos, uint8_t bit2_pos);
+void port_reg_bit_field_set(portid_t port_id, uint32_t reg_off,
+			    uint8_t bit1_pos, uint8_t bit2_pos, uint32_t value);
+void port_reg_display(portid_t port_id, uint32_t reg_off);
+void port_reg_set(portid_t port_id, uint32_t reg_off, uint32_t value);
 int port_flow_validate(portid_t port_id,
 		       const struct rte_flow_attr *attr,
 		       const struct rte_flow_item *pattern,
-		       const struct rte_flow_action *actions,
-		       const struct tunnel_ops *tunnel_ops);
+		       const struct rte_flow_action *actions);
 int port_flow_create(portid_t port_id,
 		     const struct rte_flow_attr *attr,
 		     const struct rte_flow_item *pattern,
-		     const struct rte_flow_action *actions,
-		     const struct tunnel_ops *tunnel_ops);
-int port_action_handle_query(portid_t port_id, uint32_t id);
-void update_age_action_context(const struct rte_flow_action *actions,
-		     struct port_flow *pf);
-int mcast_addr_pool_destroy(portid_t port_id);
+		     const struct rte_flow_action *actions);
 int port_flow_destroy(portid_t port_id, uint32_t n, const uint32_t *rule);
 int port_flow_flush(portid_t port_id);
-int port_flow_dump(portid_t port_id, bool dump_all,
-			uint32_t rule, const char *file_name);
 int port_flow_query(portid_t port_id, uint32_t rule,
 		    const struct rte_flow_action *action);
 void port_flow_list(portid_t port_id, uint32_t n, const uint32_t *group);
-void port_flow_aged(portid_t port_id, uint8_t destroy);
-const char *port_flow_tunnel_type(struct rte_flow_tunnel *tunnel);
-struct port_flow_tunnel *
-port_flow_locate_tunnel(uint16_t port_id, struct rte_flow_tunnel *tun);
-void port_flow_tunnel_list(portid_t port_id);
-void port_flow_tunnel_destroy(portid_t port_id, uint32_t tunnel_id);
-void port_flow_tunnel_create(portid_t port_id, const struct tunnel_ops *ops);
 int port_flow_isolate(portid_t port_id, int set);
-int port_meter_policy_add(portid_t port_id, uint32_t policy_id,
-		const struct rte_flow_action *actions);
-struct rte_flow_meter_profile *port_meter_profile_get_by_id(portid_t port_id,
-							    uint32_t id);
-struct rte_flow_meter_policy *port_meter_policy_get_by_id(portid_t port_id,
-							  uint32_t id);
 
 void rx_ring_desc_display(portid_t port_id, queueid_t rxq_id, uint16_t rxd_id);
 void tx_ring_desc_display(portid_t port_id, queueid_t txq_id, uint16_t txd_id);
@@ -1019,22 +776,10 @@
 
 void set_xstats_hide_zero(uint8_t on_off);
 
-void set_record_core_cycles(uint8_t on_off);
-void set_record_burst_stats(uint8_t on_off);
 void set_verbose_level(uint16_t vb_level);
-void set_rx_pkt_segments(unsigned int *seg_lengths, unsigned int nb_segs);
-void set_rx_pkt_hdrs(unsigned int *seg_protos, unsigned int nb_segs);
-void show_rx_pkt_hdrs(void);
-void show_rx_pkt_segments(void);
-void set_rx_pkt_offsets(unsigned int *seg_offsets, unsigned int nb_offs);
-void show_rx_pkt_offsets(void);
-void set_tx_pkt_segments(unsigned int *seg_lengths, unsigned int nb_segs);
+void set_tx_pkt_segments(unsigned *seg_lengths, unsigned nb_segs);
 void show_tx_pkt_segments(void);
-void set_tx_pkt_times(unsigned int *tx_times);
-void show_tx_pkt_times(void);
 void set_tx_pkt_split(const char *name);
-int parse_fec_mode(const char *name, uint32_t *fec_capa);
-void show_fec_capability(uint32_t num, struct rte_eth_fec_capa *speed_fec_capa);
 void set_nb_pkt_per_burst(uint16_t pkt_burst);
 char *list_pkt_forwarding_modes(void);
 char *list_pkt_forwarding_retry_modes(void);
@@ -1058,59 +803,44 @@
 void close_port(portid_t pid);
 void reset_port(portid_t pid);
 void attach_port(char *identifier);
-void detach_devargs(char *identifier);
+void detach_device(char *identifier);
 void detach_port_device(portid_t port_id);
 int all_ports_stopped(void);
 int port_is_stopped(portid_t port_id);
 int port_is_started(portid_t port_id);
 void pmd_test_exit(void);
-#if defined(RTE_NET_I40E) || defined(RTE_NET_IXGBE)
 void fdir_get_infos(portid_t port_id);
-#endif
+void fdir_set_flex_mask(portid_t port_id,
+			   struct rte_eth_fdir_flex_mask *cfg);
+void fdir_set_flex_payload(portid_t port_id,
+			   struct rte_eth_flex_payload_cfg *cfg);
 void port_rss_reta_info(portid_t port_id,
 			struct rte_eth_rss_reta_entry64 *reta_conf,
 			uint16_t nb_entries);
 
 void set_vf_traffic(portid_t port_id, uint8_t is_rx, uint16_t vf, uint8_t on);
 
-int
-rx_queue_setup(uint16_t port_id, uint16_t rx_queue_id,
-	       uint16_t nb_rx_desc, unsigned int socket_id,
-	       struct rte_eth_rxconf *rx_conf, struct rte_mempool *mp);
-
-int set_queue_rate_limit(portid_t port_id, uint16_t queue_idx, uint32_t rate);
-int set_vf_rate_limit(portid_t port_id, uint16_t vf, uint32_t rate,
+int set_queue_rate_limit(portid_t port_id, uint16_t queue_idx, uint16_t rate);
+int set_vf_rate_limit(portid_t port_id, uint16_t vf, uint16_t rate,
 				uint64_t q_msk);
 
-int set_rxq_avail_thresh(portid_t port_id, uint16_t queue_id,
-			 uint8_t avail_thresh);
-
 void port_rss_hash_conf_show(portid_t port_id, int show_rss_key);
 void port_rss_hash_key_update(portid_t port_id, char rss_type[],
-			      uint8_t *hash_key, uint8_t hash_key_len);
+			      uint8_t *hash_key, uint hash_key_len);
 int rx_queue_id_is_invalid(queueid_t rxq_id);
 int tx_queue_id_is_invalid(queueid_t txq_id);
-#ifdef RTE_LIB_GRO
 void setup_gro(const char *onoff, portid_t port_id);
 void setup_gro_flush_cycles(uint8_t cycles);
 void show_gro(portid_t port_id);
-#endif
-#ifdef RTE_LIB_GSO
 void setup_gso(const char *mode, portid_t port_id);
-#endif
 int eth_dev_info_get_print_err(uint16_t port_id,
 			struct rte_eth_dev_info *dev_info);
-int eth_dev_conf_get_print_err(uint16_t port_id,
-			struct rte_eth_conf *dev_conf);
 void eth_set_promisc_mode(uint16_t port_id, int enable);
 void eth_set_allmulticast_mode(uint16_t port, int enable);
 int eth_link_get_nowait_print_err(uint16_t port_id, struct rte_eth_link *link);
 int eth_macaddr_get_print_err(uint16_t port_id,
 			struct rte_ether_addr *mac_addr);
 
-/* Functions to display the set of MAC addresses added to a port*/
-void show_macs(portid_t port_id);
-void show_mcast_macs(portid_t port_id);
 
 /* Functions to manage the set of filtered Multicast MAC addresses */
 void mcast_addr_add(portid_t port_id, struct rte_ether_addr *mc_addr);
@@ -1121,6 +851,8 @@
 int save_file(const char *file_path, uint8_t *buf, uint32_t size);
 int close_file(uint8_t *buf);
 
+void port_queue_region_info_display(portid_t port_id, void *buf);
+
 enum print_warning {
 	ENABLED_WARN = 0,
 	DISABLED_WARN
@@ -1133,8 +865,6 @@
 int check_nb_rxq(queueid_t rxq);
 queueid_t get_allowed_max_nb_txq(portid_t *pid);
 int check_nb_txq(queueid_t txq);
-int check_nb_rxd(queueid_t rxd);
-int check_nb_txd(queueid_t txd);
 queueid_t get_allowed_max_nb_hairpinq(portid_t *pid);
 int check_nb_hairpinq(queueid_t hairpinq);
 
@@ -1157,43 +887,6 @@
 void add_tx_md_callback(portid_t portid);
 void remove_tx_md_callback(portid_t portid);
 
-uint16_t tx_pkt_set_dynf(uint16_t port_id, __rte_unused uint16_t queue,
-			 struct rte_mbuf *pkts[], uint16_t nb_pkts,
-			 __rte_unused void *user_param);
-void add_tx_dynf_callback(portid_t portid);
-void remove_tx_dynf_callback(portid_t portid);
-int update_mtu_from_frame_size(portid_t portid, uint32_t max_rx_pktlen);
-void flex_item_create(portid_t port_id, uint16_t flex_id, const char *filename);
-void flex_item_destroy(portid_t port_id, uint16_t flex_id);
-void port_flex_item_flush(portid_t port_id);
-
-extern int flow_parse(const char *src, void *result, unsigned int size,
-		      struct rte_flow_attr **attr,
-		      struct rte_flow_item **pattern,
-		      struct rte_flow_action **actions);
-
-uint64_t str_to_rsstypes(const char *str);
-const char *rsstypes_to_str(uint64_t rss_type);
-
-uint16_t str_to_flowtype(const char *string);
-const char *flowtype_to_str(uint16_t flow_type);
-
-/* For registering driver specific testpmd commands. */
-struct testpmd_driver_commands {
-	TAILQ_ENTRY(testpmd_driver_commands) next;
-	struct {
-		cmdline_parse_inst_t *ctx;
-		const char *help;
-	} commands[];
-};
-
-void testpmd_add_driver_commands(struct testpmd_driver_commands *c);
-#define TESTPMD_ADD_DRIVER_COMMANDS(c) \
-RTE_INIT(__##c) \
-{ \
-	testpmd_add_driver_commands(&c); \
-}
-
 /*
  * Work-around of a compilation error with ICC on invocations of the
  * rte_be_to_cpu_16() function.
diff -urN dpdk/app/test-pmd/txonly.c testpmd-as-load-balancer/v19.11/test-pmd/txonly.c
--- dpdk/app/test-pmd/txonly.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/txonly.c	2023-12-15 15:26:37.091199145 +0100
@@ -24,10 +24,12 @@
 #include <rte_eal.h>
 #include <rte_per_lcore.h>
 #include <rte_lcore.h>
+#include <rte_atomic.h>
 #include <rte_branch_prediction.h>
 #include <rte_mempool.h>
 #include <rte_mbuf.h>
 #include <rte_interrupts.h>
+#include <rte_pci.h>
 #include <rte_ether.h>
 #include <rte_ethdev.h>
 #include <rte_ip.h>
@@ -38,20 +40,13 @@
 
 #include "testpmd.h"
 
-struct tx_timestamp {
-	rte_be32_t signature;
-	rte_be16_t pkt_idx;
-	rte_be16_t queue_idx;
-	rte_be64_t ts;
-};
-
 /* use RFC863 Discard Protocol */
 uint16_t tx_udp_src_port = 9;
 uint16_t tx_udp_dst_port = 9;
 
 /* use RFC5735 / RFC2544 reserved network test addresses */
-uint32_t tx_ip_src_addr = (198U << 24) | (18 << 16) | (0 << 8) | 1;
-uint32_t tx_ip_dst_addr = (198U << 24) | (18 << 16) | (0 << 8) | 2;
+uint32_t tx_ip_src_addr = (192U << 24) | (18 << 16) | (0 << 8) | 1;
+uint32_t tx_ip_dst_addr = (192U << 24) | (18 << 16) | (0 << 8) | 2;
 
 #define IP_DEFTTL  64   /* from RFC 1340. */
 
@@ -59,11 +54,6 @@
 RTE_DEFINE_PER_LCORE(uint8_t, _ip_var); /**< IP address variation */
 static struct rte_udp_hdr pkt_udp_hdr; /**< UDP header of tx packets. */
 
-static uint64_t timestamp_mask; /**< Timestamp dynamic flag mask */
-static int32_t timestamp_off; /**< Timestamp dynamic field offset */
-static bool timestamp_enable; /**< Timestamp enable */
-static uint64_t timestamp_initial[RTE_MAX_ETHPORTS];
-
 static void
 copy_buf_to_pkt_segs(void* buf, unsigned len, struct rte_mbuf *pkt,
 		     unsigned offset)
@@ -157,41 +147,13 @@
 	ip_hdr->hdr_checksum = (uint16_t) ip_cksum;
 }
 
-static inline void
-update_pkt_header(struct rte_mbuf *pkt, uint32_t total_pkt_len)
-{
-	struct rte_ipv4_hdr *ip_hdr;
-	struct rte_udp_hdr *udp_hdr;
-	uint16_t pkt_data_len;
-	uint16_t pkt_len;
-
-	pkt_data_len = (uint16_t) (total_pkt_len - (
-					sizeof(struct rte_ether_hdr) +
-					sizeof(struct rte_ipv4_hdr) +
-					sizeof(struct rte_udp_hdr)));
-	/* update UDP packet length */
-	udp_hdr = rte_pktmbuf_mtod_offset(pkt, struct rte_udp_hdr *,
-				sizeof(struct rte_ether_hdr) +
-				sizeof(struct rte_ipv4_hdr));
-	pkt_len = (uint16_t) (pkt_data_len + sizeof(struct rte_udp_hdr));
-	udp_hdr->dgram_len = RTE_CPU_TO_BE_16(pkt_len);
-
-	/* update IP packet length and checksum */
-	ip_hdr = rte_pktmbuf_mtod_offset(pkt, struct rte_ipv4_hdr *,
-				sizeof(struct rte_ether_hdr));
-	ip_hdr->hdr_checksum = 0;
-	pkt_len = (uint16_t) (pkt_len + sizeof(struct rte_ipv4_hdr));
-	ip_hdr->total_length = RTE_CPU_TO_BE_16(pkt_len);
-	ip_hdr->hdr_checksum = rte_ipv4_cksum(ip_hdr);
-}
-
 static inline bool
 pkt_burst_prepare(struct rte_mbuf *pkt, struct rte_mempool *mbp,
 		struct rte_ether_hdr *eth_hdr, const uint16_t vlan_tci,
-		const uint16_t vlan_tci_outer, const uint64_t ol_flags,
-		const uint16_t idx, struct fwd_stream *fs)
+		const uint16_t vlan_tci_outer, const uint64_t ol_flags)
 {
 	struct rte_mbuf *pkt_segs[RTE_MAX_SEGS_PER_PKT];
+	uint8_t  ip_var = RTE_PER_LCORE(_ip_var);
 	struct rte_mbuf *pkt_seg;
 	uint32_t nb_segs, pkt_len;
 	uint8_t i;
@@ -208,8 +170,7 @@
 
 	rte_pktmbuf_reset_headroom(pkt);
 	pkt->data_len = tx_pkt_seg_lengths[0];
-	pkt->ol_flags &= RTE_MBUF_F_EXTERNAL;
-	pkt->ol_flags |= ol_flags;
+	pkt->ol_flags = ol_flags;
 	pkt->vlan_tci = vlan_tci;
 	pkt->vlan_tci_outer = vlan_tci_outer;
 	pkt->l2_len = sizeof(struct rte_ether_hdr);
@@ -231,7 +192,6 @@
 	copy_buf_to_pkt(&pkt_ip_hdr, sizeof(pkt_ip_hdr), pkt,
 			sizeof(struct rte_ether_hdr));
 	if (txonly_multi_flow) {
-		uint8_t  ip_var = RTE_PER_LCORE(_ip_var);
 		struct rte_ipv4_hdr *ip_hdr;
 		uint32_t addr;
 
@@ -247,69 +207,10 @@
 		 */
 		addr = (tx_ip_dst_addr | (ip_var++ << 8)) + rte_lcore_id();
 		ip_hdr->src_addr = rte_cpu_to_be_32(addr);
-		RTE_PER_LCORE(_ip_var) = ip_var;
 	}
 	copy_buf_to_pkt(&pkt_udp_hdr, sizeof(pkt_udp_hdr), pkt,
 			sizeof(struct rte_ether_hdr) +
 			sizeof(struct rte_ipv4_hdr));
-
-	if (unlikely(tx_pkt_split == TX_PKT_SPLIT_RND) || txonly_multi_flow)
-		update_pkt_header(pkt, pkt_len);
-
-	if (unlikely(timestamp_enable)) {
-		uint64_t skew = fs->ts_skew;
-		struct tx_timestamp timestamp_mark;
-
-		if (unlikely(!skew)) {
-			struct rte_eth_dev_info dev_info;
-			unsigned int txqs_n;
-			uint64_t phase;
-			int ret;
-
-			ret = eth_dev_info_get_print_err(fs->tx_port, &dev_info);
-			if (ret != 0) {
-				TESTPMD_LOG(ERR,
-					"Failed to get device info for port %d,"
-					"could not finish timestamp init",
-					fs->tx_port);
-				return false;
-			}
-			txqs_n = dev_info.nb_tx_queues;
-			phase = tx_pkt_times_inter * fs->tx_queue /
-					 (txqs_n ? txqs_n : 1);
-			/*
-			 * Initialize the scheduling time phase shift
-			 * depending on queue index.
-			 */
-			skew = timestamp_initial[fs->tx_port] +
-			       tx_pkt_times_inter + phase;
-			fs->ts_skew = skew;
-		}
-		timestamp_mark.pkt_idx = rte_cpu_to_be_16(idx);
-		timestamp_mark.queue_idx = rte_cpu_to_be_16(fs->tx_queue);
-		timestamp_mark.signature = rte_cpu_to_be_32(0xBEEFC0DE);
-		if (unlikely(!idx)) {
-			skew +=	tx_pkt_times_inter;
-			pkt->ol_flags |= timestamp_mask;
-			*RTE_MBUF_DYNFIELD
-				(pkt, timestamp_off, uint64_t *) = skew;
-			fs->ts_skew = skew;
-			timestamp_mark.ts = rte_cpu_to_be_64(skew);
-		} else if (tx_pkt_times_intra) {
-			skew +=	tx_pkt_times_intra;
-			pkt->ol_flags |= timestamp_mask;
-			*RTE_MBUF_DYNFIELD
-				(pkt, timestamp_off, uint64_t *) = skew;
-			fs->ts_skew = skew;
-			timestamp_mark.ts = rte_cpu_to_be_64(skew);
-		} else {
-			timestamp_mark.ts = RTE_BE64(0);
-		}
-		copy_buf_to_pkt(&timestamp_mark, sizeof(timestamp_mark), pkt,
-			sizeof(struct rte_ether_hdr) +
-			sizeof(struct rte_ipv4_hdr) +
-			sizeof(pkt_udp_hdr));
-	}
 	/*
 	 * Complete first mbuf of packet and append it to the
 	 * burst of packets to be transmitted.
@@ -337,27 +238,33 @@
 	uint32_t retry;
 	uint64_t ol_flags = 0;
 	uint64_t tx_offloads;
-	uint64_t start_tsc = 0;
-
-	get_start_cycles(&start_tsc);
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	uint64_t start_tsc;
+	uint64_t end_tsc;
+	uint64_t core_cycles;
+#endif
+
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	start_tsc = rte_rdtsc();
+#endif
 
 	mbp = current_fwd_lcore()->mbp;
 	txp = &ports[fs->tx_port];
 	tx_offloads = txp->dev_conf.txmode.offloads;
 	vlan_tci = txp->tx_vlan_id;
 	vlan_tci_outer = txp->tx_vlan_id_outer;
-	if (tx_offloads	& RTE_ETH_TX_OFFLOAD_VLAN_INSERT)
-		ol_flags = RTE_MBUF_F_TX_VLAN;
-	if (tx_offloads & RTE_ETH_TX_OFFLOAD_QINQ_INSERT)
-		ol_flags |= RTE_MBUF_F_TX_QINQ;
-	if (tx_offloads & RTE_ETH_TX_OFFLOAD_MACSEC_INSERT)
-		ol_flags |= RTE_MBUF_F_TX_MACSEC;
+	if (tx_offloads	& DEV_TX_OFFLOAD_VLAN_INSERT)
+		ol_flags = PKT_TX_VLAN_PKT;
+	if (tx_offloads & DEV_TX_OFFLOAD_QINQ_INSERT)
+		ol_flags |= PKT_TX_QINQ_PKT;
+	if (tx_offloads & DEV_TX_OFFLOAD_MACSEC_INSERT)
+		ol_flags |= PKT_TX_MACSEC;
 
 	/*
 	 * Initialize Ethernet header.
 	 */
-	rte_ether_addr_copy(&peer_eth_addrs[fs->peer_addr], &eth_hdr.dst_addr);
-	rte_ether_addr_copy(&ports[fs->tx_port].eth_addr, &eth_hdr.src_addr);
+	rte_ether_addr_copy(&peer_eth_addrs[fs->peer_addr], &eth_hdr.d_addr);
+	rte_ether_addr_copy(&ports[fs->tx_port].eth_addr, &eth_hdr.s_addr);
 	eth_hdr.ether_type = rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4);
 
 	if (rte_mempool_get_bulk(mbp, (void **)pkts_burst,
@@ -366,8 +273,7 @@
 			if (unlikely(!pkt_burst_prepare(pkts_burst[nb_pkt], mbp,
 							&eth_hdr, vlan_tci,
 							vlan_tci_outer,
-							ol_flags,
-							nb_pkt, fs))) {
+							ol_flags))) {
 				rte_mempool_put_bulk(mbp,
 						(void **)&pkts_burst[nb_pkt],
 						nb_pkt_per_burst - nb_pkt);
@@ -382,8 +288,7 @@
 			if (unlikely(!pkt_burst_prepare(pkt, mbp, &eth_hdr,
 							vlan_tci,
 							vlan_tci_outer,
-							ol_flags,
-							nb_pkt, fs))) {
+							ol_flags))) {
 				rte_pktmbuf_free(pkt);
 				break;
 			}
@@ -395,7 +300,6 @@
 		return;
 
 	nb_tx = rte_eth_tx_burst(fs->tx_port, fs->tx_queue, pkts_burst, nb_pkt);
-
 	/*
 	 * Retry if necessary
 	 */
@@ -410,9 +314,11 @@
 	fs->tx_packets += nb_tx;
 
 	if (txonly_multi_flow)
-		RTE_PER_LCORE(_ip_var) -= nb_pkt - nb_tx;
+		RTE_PER_LCORE(_ip_var) += nb_tx;
 
-	inc_tx_burst_stats(fs, nb_tx);
+#ifdef RTE_TEST_PMD_RECORD_BURST_STATS
+	fs->tx_burst_stats.pkt_burst_spread[nb_tx]++;
+#endif
 	if (unlikely(nb_tx < nb_pkt)) {
 		if (verbose_level > 0 && fs->fwd_dropped == 0)
 			printf("port %d tx_queue %d - drop "
@@ -426,94 +332,28 @@
 		} while (++nb_tx < nb_pkt);
 	}
 
-	get_end_cycles(fs, start_tsc);
+#ifdef RTE_TEST_PMD_RECORD_CORE_CYCLES
+	end_tsc = rte_rdtsc();
+	core_cycles = (end_tsc - start_tsc);
+	fs->core_cycles = (uint64_t) (fs->core_cycles + core_cycles);
+#endif
 }
 
-static int
-tx_only_begin(portid_t pi)
+static void
+tx_only_begin(__attribute__((unused)) portid_t pi)
 {
-	uint16_t pkt_hdr_len, pkt_data_len;
-	int dynf;
-
-	pkt_hdr_len = (uint16_t)(sizeof(struct rte_ether_hdr) +
-				 sizeof(struct rte_ipv4_hdr) +
-				 sizeof(struct rte_udp_hdr));
-	pkt_data_len = tx_pkt_length - pkt_hdr_len;
-
-	if ((tx_pkt_split == TX_PKT_SPLIT_RND || txonly_multi_flow) &&
-	    tx_pkt_seg_lengths[0] < pkt_hdr_len) {
-		TESTPMD_LOG(ERR,
-			    "Random segment number or multiple flow is enabled, "
-			    "but tx_pkt_seg_lengths[0] %u < %u (needed)\n",
-			    tx_pkt_seg_lengths[0], pkt_hdr_len);
-		return -EINVAL;
-	}
+	uint16_t pkt_data_len;
 
+	pkt_data_len = (uint16_t) (tx_pkt_length - (
+					sizeof(struct rte_ether_hdr) +
+					sizeof(struct rte_ipv4_hdr) +
+					sizeof(struct rte_udp_hdr)));
 	setup_pkt_udp_ip_headers(&pkt_ip_hdr, &pkt_udp_hdr, pkt_data_len);
-
-	timestamp_enable = false;
-	timestamp_mask = 0;
-	timestamp_off = -1;
-	dynf = rte_mbuf_dynflag_lookup
-				(RTE_MBUF_DYNFLAG_TX_TIMESTAMP_NAME, NULL);
-	if (dynf >= 0)
-		timestamp_mask = 1ULL << dynf;
-	dynf = rte_mbuf_dynfield_lookup
-				(RTE_MBUF_DYNFIELD_TIMESTAMP_NAME, NULL);
-	if (dynf >= 0)
-		timestamp_off = dynf;
-	timestamp_enable = tx_pkt_times_inter &&
-			   timestamp_mask &&
-			   timestamp_off >= 0 &&
-			   !rte_eth_read_clock(pi, &timestamp_initial[pi]);
-
-	if (timestamp_enable) {
-		pkt_hdr_len += sizeof(struct tx_timestamp);
-
-		if (tx_pkt_split == TX_PKT_SPLIT_RND) {
-			if (tx_pkt_seg_lengths[0] < pkt_hdr_len) {
-				TESTPMD_LOG(ERR,
-					    "Time stamp and random segment number are enabled, "
-					    "but tx_pkt_seg_lengths[0] %u < %u (needed)\n",
-					    tx_pkt_seg_lengths[0], pkt_hdr_len);
-				return -EINVAL;
-			}
-		} else {
-			uint16_t total = 0;
-			uint8_t i;
-
-			for (i = 0; i < tx_pkt_nb_segs; i++) {
-				total += tx_pkt_seg_lengths[i];
-				if (total >= pkt_hdr_len)
-					break;
-			}
-
-			if (total < pkt_hdr_len) {
-				TESTPMD_LOG(ERR,
-					    "Not enough Tx segment space for time stamp info, "
-					    "total %u < %u (needed)\n",
-					    total, pkt_hdr_len);
-				return -EINVAL;
-			}
-		}
-	}
-
-	/* Make sure all settings are visible on forwarding cores.*/
-	rte_wmb();
-	return 0;
-}
-
-static void
-tx_only_stream_init(struct fwd_stream *fs)
-{
-	fs->disabled = ports[fs->tx_port].txq[fs->tx_queue].state ==
-						RTE_ETH_QUEUE_STATE_STOPPED;
 }
 
 struct fwd_engine tx_only_engine = {
 	.fwd_mode_name  = "txonly",
 	.port_fwd_begin = tx_only_begin,
 	.port_fwd_end   = NULL,
-	.stream_init    = tx_only_stream_init,
 	.packet_fwd     = pkt_burst_transmit,
 };
diff -urN dpdk/app/test-pmd/util.c testpmd-as-load-balancer/v19.11/test-pmd/util.c
--- dpdk/app/test-pmd/util.c	2023-09-11 10:19:02.000000000 +0200
+++ testpmd-as-load-balancer/v19.11/test-pmd/util.c	2023-12-15 15:26:37.091199145 +0100
@@ -1,11 +1,10 @@
 /* SPDX-License-Identifier: BSD-3-Clause
  * Copyright(c) 2010-2014 Intel Corporation
- * Copyright 2018 Mellanox Technologies, Ltd
+ * Copyright(c) 2018 Mellanox Technology
  */
 
 #include <stdio.h>
 
-#include <rte_bitops.h>
 #include <rte_net.h>
 #include <rte_mbuf.h>
 #include <rte_ether.h>
@@ -15,56 +14,12 @@
 
 #include "testpmd.h"
 
-#define MAX_STRING_LEN 8192
-
-#define MKDUMPSTR(buf, buf_size, cur_len, ...) \
-do { \
-	if (cur_len >= buf_size) \
-		break; \
-	cur_len += snprintf(buf + cur_len, buf_size - cur_len, __VA_ARGS__); \
-} while (0)
-
 static inline void
-print_ether_addr(const char *what, const struct rte_ether_addr *eth_addr,
-		 char print_buf[], size_t buf_size, size_t *cur_len)
+print_ether_addr(const char *what, const struct rte_ether_addr *eth_addr)
 {
 	char buf[RTE_ETHER_ADDR_FMT_SIZE];
-
 	rte_ether_format_addr(buf, RTE_ETHER_ADDR_FMT_SIZE, eth_addr);
-	MKDUMPSTR(print_buf, buf_size, *cur_len, "%s%s", what, buf);
-}
-
-static inline bool
-is_timestamp_enabled(const struct rte_mbuf *mbuf)
-{
-	static uint64_t timestamp_rx_dynflag;
-	int timestamp_rx_dynflag_offset;
-
-	if (timestamp_rx_dynflag == 0) {
-		timestamp_rx_dynflag_offset = rte_mbuf_dynflag_lookup(
-				RTE_MBUF_DYNFLAG_RX_TIMESTAMP_NAME, NULL);
-		if (timestamp_rx_dynflag_offset < 0)
-			return false;
-		timestamp_rx_dynflag = RTE_BIT64(timestamp_rx_dynflag_offset);
-	}
-
-	return (mbuf->ol_flags & timestamp_rx_dynflag) != 0;
-}
-
-static inline rte_mbuf_timestamp_t
-get_timestamp(const struct rte_mbuf *mbuf)
-{
-	static int timestamp_dynfield_offset = -1;
-
-	if (timestamp_dynfield_offset < 0) {
-		timestamp_dynfield_offset = rte_mbuf_dynfield_lookup(
-				RTE_MBUF_DYNFIELD_TIMESTAMP_NAME, NULL);
-		if (timestamp_dynfield_offset < 0)
-			return 0;
-	}
-
-	return *RTE_MBUF_DYNFIELD(mbuf,
-			timestamp_dynfield_offset, rte_mbuf_timestamp_t *);
+	printf("%s%s", what, buf);
 }
 
 static inline void
@@ -84,153 +39,77 @@
 	uint16_t udp_port;
 	uint32_t vx_vni;
 	const char *reason;
-	int dynf_index;
-	char print_buf[MAX_STRING_LEN];
-	size_t buf_size = MAX_STRING_LEN;
-	size_t cur_len = 0;
 
 	if (!nb_pkts)
 		return;
-	MKDUMPSTR(print_buf, buf_size, cur_len,
-		  "port %u/queue %u: %s %u packets\n", port_id, queue,
-		  is_rx ? "received" : "sent", (unsigned int) nb_pkts);
+	printf("port %u/queue %u: %s %u packets\n",
+		port_id, queue,
+	       is_rx ? "received" : "sent",
+	       (unsigned int) nb_pkts);
 	for (i = 0; i < nb_pkts; i++) {
-		int ret;
-		struct rte_flow_error error;
-		struct rte_flow_restore_info info = { 0, };
-
 		mb = pkts[i];
-		if (rxq_share > 0)
-			MKDUMPSTR(print_buf, buf_size, cur_len, "port %u, ",
-				  mb->port);
 		eth_hdr = rte_pktmbuf_read(mb, 0, sizeof(_eth_hdr), &_eth_hdr);
 		eth_type = RTE_BE_TO_CPU_16(eth_hdr->ether_type);
+		ol_flags = mb->ol_flags;
 		packet_type = mb->packet_type;
 		is_encapsulation = RTE_ETH_IS_TUNNEL_PKT(packet_type);
-		ret = rte_flow_get_restore_info(port_id, mb, &info, &error);
-		if (!ret) {
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  "restore info:");
-			if (info.flags & RTE_FLOW_RESTORE_INFO_TUNNEL) {
-				struct port_flow_tunnel *port_tunnel;
-
-				port_tunnel = port_flow_locate_tunnel
-					      (port_id, &info.tunnel);
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  " - tunnel");
-				if (port_tunnel)
-					MKDUMPSTR(print_buf, buf_size, cur_len,
-						  " #%u", port_tunnel->id);
-				else
-					MKDUMPSTR(print_buf, buf_size, cur_len,
-						  " %s", "-none-");
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  " type %s", port_flow_tunnel_type
-					  (&info.tunnel));
-			} else {
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  " - no tunnel info");
-			}
-			if (info.flags & RTE_FLOW_RESTORE_INFO_ENCAPSULATED)
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  " - outer header present");
-			else
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  " - no outer header");
-			if (info.flags & RTE_FLOW_RESTORE_INFO_GROUP_ID)
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  " - miss group %u", info.group_id);
-			else
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  " - no miss group");
-			MKDUMPSTR(print_buf, buf_size, cur_len, "\n");
-		}
-		print_ether_addr("  src=", &eth_hdr->src_addr,
-				 print_buf, buf_size, &cur_len);
-		print_ether_addr(" - dst=", &eth_hdr->dst_addr,
-				 print_buf, buf_size, &cur_len);
-		MKDUMPSTR(print_buf, buf_size, cur_len,
-			  " - pool=%s - type=0x%04x - length=%u - nb_segs=%d",
-			  mb->pool->name, eth_type, (unsigned int) mb->pkt_len,
-			  (int)mb->nb_segs);
-		ol_flags = mb->ol_flags;
-		if (ol_flags & RTE_MBUF_F_RX_RSS_HASH) {
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - RSS hash=0x%x",
-				  (unsigned int) mb->hash.rss);
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - RSS queue=0x%x", (unsigned int) queue);
+
+		print_ether_addr("  src=", &eth_hdr->s_addr);
+		print_ether_addr(" - dst=", &eth_hdr->d_addr);
+		printf(" - type=0x%04x - length=%u - nb_segs=%d",
+		       eth_type, (unsigned int) mb->pkt_len,
+		       (int)mb->nb_segs);
+		if (ol_flags & PKT_RX_RSS_HASH) {
+			printf(" - RSS hash=0x%x", (unsigned int) mb->hash.rss);
+			printf(" - RSS queue=0x%x", (unsigned int) queue);
 		}
-		if (ol_flags & RTE_MBUF_F_RX_FDIR) {
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - FDIR matched ");
-			if (ol_flags & RTE_MBUF_F_RX_FDIR_ID)
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  "ID=0x%x", mb->hash.fdir.hi);
-			else if (ol_flags & RTE_MBUF_F_RX_FDIR_FLX)
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  "flex bytes=0x%08x %08x",
-					  mb->hash.fdir.hi, mb->hash.fdir.lo);
+		if (ol_flags & PKT_RX_FDIR) {
+			printf(" - FDIR matched ");
+			if (ol_flags & PKT_RX_FDIR_ID)
+				printf("ID=0x%x",
+				       mb->hash.fdir.hi);
+			else if (ol_flags & PKT_RX_FDIR_FLX)
+				printf("flex bytes=0x%08x %08x",
+				       mb->hash.fdir.hi, mb->hash.fdir.lo);
 			else
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  "hash=0x%x ID=0x%x ",
-					  mb->hash.fdir.hash, mb->hash.fdir.id);
-		}
-		if (is_timestamp_enabled(mb))
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - timestamp %"PRIu64" ", get_timestamp(mb));
-		if (ol_flags & RTE_MBUF_F_RX_QINQ)
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - QinQ VLAN tci=0x%x, VLAN tci outer=0x%x",
-				  mb->vlan_tci, mb->vlan_tci_outer);
-		else if (ol_flags & RTE_MBUF_F_RX_VLAN)
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - VLAN tci=0x%x", mb->vlan_tci);
-		if (!is_rx && (ol_flags & RTE_MBUF_DYNFLAG_TX_METADATA))
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - Tx metadata: 0x%x",
-				  *RTE_FLOW_DYNF_METADATA(mb));
-		if (is_rx && (ol_flags & RTE_MBUF_DYNFLAG_RX_METADATA))
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - Rx metadata: 0x%x",
-				  *RTE_FLOW_DYNF_METADATA(mb));
-		for (dynf_index = 0; dynf_index < 64; dynf_index++) {
-			if (dynf_names[dynf_index][0] != '\0')
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  " - dynf %s: %d",
-					  dynf_names[dynf_index],
-					  !!(ol_flags & (1UL << dynf_index)));
+				printf("hash=0x%x ID=0x%x ",
+				       mb->hash.fdir.hash, mb->hash.fdir.id);
 		}
+		if (ol_flags & PKT_RX_TIMESTAMP)
+			printf(" - timestamp %"PRIu64" ", mb->timestamp);
+		if (ol_flags & PKT_RX_QINQ)
+			printf(" - QinQ VLAN tci=0x%x, VLAN tci outer=0x%x",
+			       mb->vlan_tci, mb->vlan_tci_outer);
+		else if (ol_flags & PKT_RX_VLAN)
+			printf(" - VLAN tci=0x%x", mb->vlan_tci);
+		if (!is_rx && (ol_flags & PKT_TX_DYNF_METADATA))
+			printf(" - Tx metadata: 0x%x",
+			       *RTE_FLOW_DYNF_METADATA(mb));
+		if (is_rx && (ol_flags & PKT_RX_DYNF_METADATA))
+			printf(" - Rx metadata: 0x%x",
+			       *RTE_FLOW_DYNF_METADATA(mb));
 		if (mb->packet_type) {
 			rte_get_ptype_name(mb->packet_type, buf, sizeof(buf));
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - hw ptype: %s", buf);
+			printf(" - hw ptype: %s", buf);
 		}
 		sw_packet_type = rte_net_get_ptype(mb, &hdr_lens,
 					RTE_PTYPE_ALL_MASK);
 		rte_get_ptype_name(sw_packet_type, buf, sizeof(buf));
-		MKDUMPSTR(print_buf, buf_size, cur_len, " - sw ptype: %s", buf);
+		printf(" - sw ptype: %s", buf);
 		if (sw_packet_type & RTE_PTYPE_L2_MASK)
-			MKDUMPSTR(print_buf, buf_size, cur_len, " - l2_len=%d",
-				  hdr_lens.l2_len);
+			printf(" - l2_len=%d", hdr_lens.l2_len);
 		if (sw_packet_type & RTE_PTYPE_L3_MASK)
-			MKDUMPSTR(print_buf, buf_size, cur_len, " - l3_len=%d",
-				  hdr_lens.l3_len);
+			printf(" - l3_len=%d", hdr_lens.l3_len);
 		if (sw_packet_type & RTE_PTYPE_L4_MASK)
-			MKDUMPSTR(print_buf, buf_size, cur_len, " - l4_len=%d",
-				  hdr_lens.l4_len);
+			printf(" - l4_len=%d", hdr_lens.l4_len);
 		if (sw_packet_type & RTE_PTYPE_TUNNEL_MASK)
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - tunnel_len=%d", hdr_lens.tunnel_len);
+			printf(" - tunnel_len=%d", hdr_lens.tunnel_len);
 		if (sw_packet_type & RTE_PTYPE_INNER_L2_MASK)
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - inner_l2_len=%d", hdr_lens.inner_l2_len);
+			printf(" - inner_l2_len=%d", hdr_lens.inner_l2_len);
 		if (sw_packet_type & RTE_PTYPE_INNER_L3_MASK)
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - inner_l3_len=%d", hdr_lens.inner_l3_len);
+			printf(" - inner_l3_len=%d", hdr_lens.inner_l3_len);
 		if (sw_packet_type & RTE_PTYPE_INNER_L4_MASK)
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  " - inner_l4_len=%d", hdr_lens.inner_l4_len);
+			printf(" - inner_l4_len=%d", hdr_lens.inner_l4_len);
 		if (is_encapsulation) {
 			struct rte_ipv4_hdr *ipv4_hdr;
 			struct rte_ipv6_hdr *ipv6_hdr;
@@ -267,32 +146,18 @@
 				l2_len + l3_len + l4_len);
 				udp_port = RTE_BE_TO_CPU_16(udp_hdr->dst_port);
 				vx_vni = rte_be_to_cpu_32(vxlan_hdr->vx_vni);
-				MKDUMPSTR(print_buf, buf_size, cur_len,
-					  " - VXLAN packet: packet type =%d, "
-					  "Destination UDP port =%d, VNI = %d, "
-					  "last_rsvd = %d", packet_type,
-					  udp_port, vx_vni >> 8, vx_vni & 0xff);
+				printf(" - VXLAN packet: packet type =%d, "
+				       "Destination UDP port =%d, VNI = %d",
+				       packet_type, udp_port, vx_vni >> 8);
 			}
 		}
-		MKDUMPSTR(print_buf, buf_size, cur_len,
-			  " - %s queue=0x%x", is_rx ? "Receive" : "Send",
-			  (unsigned int) queue);
-		MKDUMPSTR(print_buf, buf_size, cur_len, "\n");
-		if (is_rx)
-			rte_get_rx_ol_flag_list(mb->ol_flags, buf, sizeof(buf));
-		else
-			rte_get_tx_ol_flag_list(mb->ol_flags, buf, sizeof(buf));
-
-		MKDUMPSTR(print_buf, buf_size, cur_len,
-			  "  ol_flags: %s\n", buf);
+		printf(" - %s queue=0x%x", is_rx ? "Receive" : "Send",
+			(unsigned int) queue);
+		printf("\n");
+		rte_get_rx_ol_flag_list(mb->ol_flags, buf, sizeof(buf));
+		printf("  ol_flags: %s\n", buf);
 		if (rte_mbuf_check(mb, 1, &reason) < 0)
-			MKDUMPSTR(print_buf, buf_size, cur_len,
-				  "INVALID mbuf: %s\n", reason);
-		if (cur_len >= buf_size)
-			printf("%s ...\n", print_buf);
-		else
-			printf("%s", print_buf);
-		cur_len = 0;
+			printf("INVALID mbuf: %s\n", reason);
 	}
 }
 
@@ -328,7 +193,7 @@
 		for (i = 0; i < nb_pkts; i++) {
 			*RTE_FLOW_DYNF_METADATA(pkts[i]) =
 						ports[port_id].tx_metadata;
-			pkts[i]->ol_flags |= RTE_MBUF_DYNFLAG_TX_METADATA;
+			pkts[i]->ol_flags |= PKT_TX_DYNF_METADATA;
 		}
 	return nb_pkts;
 }
@@ -376,62 +241,6 @@
 		}
 }
 
-uint16_t
-tx_pkt_set_dynf(uint16_t port_id, __rte_unused uint16_t queue,
-		struct rte_mbuf *pkts[], uint16_t nb_pkts,
-		__rte_unused void *user_param)
-{
-	uint16_t i = 0;
-
-	if (ports[port_id].mbuf_dynf)
-		for (i = 0; i < nb_pkts; i++)
-			pkts[i]->ol_flags |= ports[port_id].mbuf_dynf;
-	return nb_pkts;
-}
-
-void
-add_tx_dynf_callback(portid_t portid)
-{
-	struct rte_eth_dev_info dev_info;
-	uint16_t queue;
-	int ret;
-
-	if (port_id_is_invalid(portid, ENABLED_WARN))
-		return;
-
-	ret = eth_dev_info_get_print_err(portid, &dev_info);
-	if (ret != 0)
-		return;
-
-	for (queue = 0; queue < dev_info.nb_tx_queues; queue++)
-		if (!ports[portid].tx_set_dynf_cb[queue])
-			ports[portid].tx_set_dynf_cb[queue] =
-				rte_eth_add_tx_callback(portid, queue,
-							tx_pkt_set_dynf, NULL);
-}
-
-void
-remove_tx_dynf_callback(portid_t portid)
-{
-	struct rte_eth_dev_info dev_info;
-	uint16_t queue;
-	int ret;
-
-	if (port_id_is_invalid(portid, ENABLED_WARN))
-		return;
-
-	ret = eth_dev_info_get_print_err(portid, &dev_info);
-	if (ret != 0)
-		return;
-
-	for (queue = 0; queue < dev_info.nb_tx_queues; queue++)
-		if (ports[portid].tx_set_dynf_cb[queue]) {
-			rte_eth_remove_tx_callback(portid, queue,
-				ports[portid].tx_set_dynf_cb[queue]);
-			ports[portid].tx_set_dynf_cb[queue] = NULL;
-		}
-}
-
 int
 eth_dev_info_get_print_err(uint16_t port_id,
 					struct rte_eth_dev_info *dev_info)
@@ -440,23 +249,8 @@
 
 	ret = rte_eth_dev_info_get(port_id, dev_info);
 	if (ret != 0)
-		fprintf(stderr,
-			"Error during getting device (port %u) info: %s\n",
-			port_id, strerror(-ret));
-
-	return ret;
-}
-
-int
-eth_dev_conf_get_print_err(uint16_t port_id, struct rte_eth_conf *dev_conf)
-{
-	int ret;
-
-	ret = rte_eth_dev_conf_get(port_id, dev_conf);
-	if (ret != 0)
-		fprintf(stderr,
-			"Error during getting device configuration (port %u): %s\n",
-			port_id, strerror(-ret));
+		printf("Error during getting device (port %u) info: %s\n",
+				port_id, strerror(-ret));
 
 	return ret;
 }
@@ -472,8 +266,7 @@
 		ret = rte_eth_promiscuous_disable(port);
 
 	if (ret != 0)
-		fprintf(stderr,
-			"Error during %s promiscuous mode for port %u: %s\n",
+		printf("Error during %s promiscuous mode for port %u: %s\n",
 			enable ? "enabling" : "disabling",
 			port, rte_strerror(-ret));
 }
@@ -489,8 +282,7 @@
 		ret = rte_eth_allmulticast_disable(port);
 
 	if (ret != 0)
-		fprintf(stderr,
-			"Error during %s all-multicast mode for port %u: %s\n",
+		printf("Error during %s all-multicast mode for port %u: %s\n",
 			enable ? "enabling" : "disabling",
 			port, rte_strerror(-ret));
 }
@@ -502,8 +294,7 @@
 
 	ret = rte_eth_link_get_nowait(port_id, link);
 	if (ret < 0)
-		fprintf(stderr,
-			"Device (port %u) link get (without wait) failed: %s\n",
+		printf("Device (port %u) link get (without wait) failed: %s\n",
 			port_id, rte_strerror(-ret));
 
 	return ret;
@@ -516,9 +307,8 @@
 
 	ret = rte_eth_macaddr_get(port_id, mac_addr);
 	if (ret != 0)
-		fprintf(stderr,
-			"Error getting device (port %u) mac address: %s\n",
-			port_id, rte_strerror(-ret));
+		printf("Error getting device (port %u) mac address: %s\n",
+				port_id, rte_strerror(-ret));
 
 	return ret;
 }
